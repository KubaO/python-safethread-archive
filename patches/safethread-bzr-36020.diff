=== added file '.bzrignore'
--- .bzrignore	1970-01-01 00:00:00 +0000
+++ .bzrignore	2008-03-24 18:53:11 +0000
@@ -0,0 +1,1 @@
+RE:build-[a-z-]+

=== modified file 'Doc/includes/noddy2.c'
--- Doc/includes/noddy2.c	2007-10-27 04:00:45 +0000
+++ Doc/includes/noddy2.c	2008-03-24 04:28:04 +0000
@@ -13,7 +13,7 @@
 {
     Py_XDECREF(self->first);
     Py_XDECREF(self->last);
-    self->ob_type->tp_free((PyObject*)self);
+    PyObject_Del(self);
 }
 
 static PyObject *
@@ -21,7 +21,7 @@
 {
     Noddy *self;
 
-    self = (Noddy *)type->tp_alloc(type, 0);
+    self = PyObject_New(type);
     if (self != NULL) {
         self->first = PyUnicode_FromString("");
         if (self->first == NULL)
@@ -160,7 +160,6 @@
     0,                         /* tp_descr_set */
     0,                         /* tp_dictoffset */
     (initproc)Noddy_init,      /* tp_init */
-    0,                         /* tp_alloc */
     Noddy_new,                 /* tp_new */
 };
 

=== modified file 'Doc/includes/noddy3.c'
--- Doc/includes/noddy3.c	2007-10-27 04:00:45 +0000
+++ Doc/includes/noddy3.c	2008-03-24 04:28:04 +0000
@@ -13,7 +13,7 @@
 {
     Py_XDECREF(self->first);
     Py_XDECREF(self->last);
-    self->ob_type->tp_free((PyObject*)self);
+    PyObject_Del(self);
 }
 
 static PyObject *
@@ -21,7 +21,7 @@
 {
     Noddy *self;
 
-    self = (Noddy *)type->tp_alloc(type, 0);
+    self = PyObject_New(type);
     if (self != NULL) {
         self->first = PyUnicode_FromString("");
         if (self->first == NULL)
@@ -213,7 +213,6 @@
     0,                         /* tp_descr_set */
     0,                         /* tp_dictoffset */
     (initproc)Noddy_init,      /* tp_init */
-    0,                         /* tp_alloc */
     Noddy_new,                 /* tp_new */
 };
 

=== modified file 'Doc/includes/noddy4.c'
--- Doc/includes/noddy4.c	2007-10-27 04:00:45 +0000
+++ Doc/includes/noddy4.c	2008-03-24 04:28:04 +0000
@@ -47,7 +47,7 @@
 Noddy_dealloc(Noddy* self)
 {
     Noddy_clear(self);
-    self->ob_type->tp_free((PyObject*)self);
+    PyObject_Del(self);
 }
 
 static PyObject *
@@ -55,7 +55,7 @@
 {
     Noddy *self;
 
-    self = (Noddy *)type->tp_alloc(type, 0);
+    self = PyObject_New(type);
     if (self != NULL) {
         self->first = PyUnicode_FromString("");
         if (self->first == NULL)
@@ -194,7 +194,6 @@
     0,                         /* tp_descr_set */
     0,                         /* tp_dictoffset */
     (initproc)Noddy_init,      /* tp_init */
-    0,                         /* tp_alloc */
     Noddy_new,                 /* tp_new */
 };
 

=== modified file 'Doc/includes/shoddy.c'
--- Doc/includes/shoddy.c	2007-12-02 14:31:20 +0000
+++ Doc/includes/shoddy.c	2008-03-24 04:28:04 +0000
@@ -69,7 +69,6 @@
     0,                       /* tp_descr_set */
     0,                       /* tp_dictoffset */
     (initproc)Shoddy_init,   /* tp_init */
-    0,                       /* tp_alloc */
     0,                       /* tp_new */
 };
 

=== modified file 'Doc/includes/typestruct.h'
--- Doc/includes/typestruct.h	2007-08-15 14:28:22 +0000
+++ Doc/includes/typestruct.h	2008-04-11 03:06:23 +0000
@@ -63,9 +63,7 @@
     descrsetfunc tp_descr_set;
     long tp_dictoffset;
     initproc tp_init;
-    allocfunc tp_alloc;
     newfunc tp_new;
-    freefunc tp_free; /* Low-level free-memory routine */
     inquiry tp_is_gc; /* For PyObject_IS_GC */
     PyObject *tp_bases;
     PyObject *tp_mro; /* method resolution order */

=== modified file 'Include/Python.h'
--- Include/Python.h	2008-03-28 10:53:29 +0000
+++ Include/Python.h	2008-04-11 02:07:04 +0000
@@ -105,7 +105,7 @@
 #include "pythonrun.h"
 #include "ceval.h"
 #include "sysmodule.h"
-#include "intrcheck.h"
+#include "pysignal.h"
 #include "import.h"
 
 #include "abstract.h"

=== modified file 'Include/abstract.h'
--- Include/abstract.h	2008-02-17 19:48:00 +0000
+++ Include/abstract.h	2008-03-24 04:28:03 +0000
@@ -1286,6 +1286,9 @@
 PyAPI_FUNC(int) PyObject_IsSubclass(PyObject *object, PyObject *typeorclass);
       /* issubclass(object, typeorclass) */
 
+/* Used when it's not safe to call arbitrary code */
+PyAPI_FUNC(int) _PyObject_IsSubclassSimple(PyObject *object, PyObject *typeorclass);
+
 
 #ifdef __cplusplus
 }

=== added file 'Include/branchobject.h'
--- Include/branchobject.h	1970-01-01 00:00:00 +0000
+++ Include/branchobject.h	2008-04-08 18:35:21 +0000
@@ -0,0 +1,66 @@
+/* Branch object */
+
+#ifndef Py_BRANCHOBJECT_H
+#define Py_BRANCHOBJECT_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "pythread.h"
+#include "pystate.h"
+
+
+struct _PyCancelObject; /* Avoid including cancelobject.h */
+
+struct _PyBranchObject;
+
+typedef struct _PyBranchChild {
+    PyState *pystate;
+    struct _PyCancelObject *cancel_scope;
+    struct _PyBranchObject *branch;
+    PyObject *func;
+    PyObject *args;
+    PyObject *kwds;
+    int save_result;
+    PyObject *result;
+    PyObject *exception;
+    PyThread_type_flag *dead;
+    PyLinkedListNode children_links;
+    PyLinkedListNode alive_links; /* Also used by deletable */
+    PyWaitFor waitfor;
+} PyBranchChild;
+
+typedef struct _PyBranchObject {
+    PyObject_HEAD
+    PyCritical *crit;
+    int col_state;
+
+    PyObject *col_ownerthread;
+    PyObject *col_threads;
+    PyBranchChild *col_mainthread;
+    PyLinkedList children;
+    PyLinkedList alive;
+    PyLinkedList deletable;
+
+    struct _PyCancelObject *col_basecancel;
+
+    int col_cancelling;
+    Py_ssize_t col_resultcount;
+    Py_ssize_t col_exceptioncount;
+} PyBranchObject;
+
+PyAPI_DATA(PyTypeObject) PyBranch_Type;
+
+#define PyBranch_Check(op) PyObject_TypeCheck(op, &PyBranch_Type)
+#define PyBranch_CheckExact(op) (Py_TYPE(op) == &PyBranch_Type)
+
+#define BRANCH_NEW      1
+#define BRANCH_ALIVE    2
+#define BRANCH_DYING    3
+#define BRANCH_DEAD     4
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_BRANCHOBJECT_H */

=== added file 'Include/cancelobject.h'
--- Include/cancelobject.h	1970-01-01 00:00:00 +0000
+++ Include/cancelobject.h	2008-04-09 16:12:04 +0000
@@ -0,0 +1,52 @@
+/* Cancel Object */
+
+#ifndef Py_CANCELOBJECT_H
+#define Py_CANCELOBJECT_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "pythread.h"
+
+
+struct _PyCancelQueue;
+
+typedef struct _PyCancelObject {
+    PyObject_HEAD
+    int cancelled;
+    PyState *pystate;
+    PyLinkedListNode stack_links;
+
+    void (*callback)(struct _PyCancelQueue *, void *arg);
+    void *arg;
+    int callback_activated;
+    PyThread_type_flag *callback_finished;
+
+    PyLinkedListNode queue_links;
+} PyCancelObject;
+
+typedef struct _PyCancelQueue {
+    PyLinkedList list;
+} PyCancelQueue;
+
+
+PyAPI_DATA(PyTypeObject) PyCancel_Type;
+#define PyCancel_Check(op) (Py_TYPE(op) == &PyCancel_Type)
+
+PyAPI_FUNC(PyCancelObject *) PyCancel_New(
+    void (*)(PyCancelQueue *, void *),
+    void *, PyState *);
+PyAPI_FUNC(void) PyCancel_Push(PyCancelObject *);
+PyAPI_FUNC(void) PyCancel_Pop(PyCancelObject *);
+
+/* Cancel marks a given PyCancelObject as cancelled, notifying children 
+ * of this.  This childrens' callbacks are not called until Finish. */
+PyAPI_FUNC(void) PyCancelQueue_Init(PyCancelQueue *);
+PyAPI_FUNC(void) PyCancelQueue_Cancel(PyCancelQueue *, PyCancelObject *);
+PyAPI_FUNC(void) PyCancelQueue_Finish(PyCancelQueue *);
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_CANCELOBJECT_H */

=== modified file 'Include/ceval.h'
--- Include/ceval.h	2008-02-12 19:30:35 +0000
+++ Include/ceval.h	2008-03-24 04:28:03 +0000
@@ -39,20 +39,17 @@
    flag was set, else return 0. */
 PyAPI_FUNC(int) PyEval_MergeCompilerFlags(PyCompilerFlags *cf);
 
-PyAPI_FUNC(int) Py_AddPendingCall(int (*func)(void *), void *arg);
-PyAPI_FUNC(int) Py_MakePendingCalls(void);
-
 /* Protection against deeply nested recursive calls */
 PyAPI_FUNC(void) Py_SetRecursionLimit(int);
 PyAPI_FUNC(int) Py_GetRecursionLimit(void);
 
 #define Py_EnterRecursiveCall(where)                                    \
-	    (_Py_MakeRecCheck(PyThreadState_GET()->recursion_depth) &&  \
+	    (_Py_MakeRecCheck(PyState_Get()->recursion_depth) &&  \
 	     _Py_CheckRecursiveCall(where))
 #define Py_LeaveRecursiveCall()				\
-    do{ if((--PyThreadState_GET()->recursion_depth) <   \
+    do{ if((--PyState_Get()->recursion_depth) <   \
 	   _Py_CheckRecursionLimit - 50)                \
-	  PyThreadState_GET()->overflowed = 0;          \
+	  PyState_Get()->overflowed = 0;          \
     } while(0)
 PyAPI_FUNC(int) _Py_CheckRecursiveCall(char *where);
 PyAPI_DATA(int) _Py_CheckRecursionLimit;
@@ -63,11 +60,11 @@
 #endif
 
 #define Py_ALLOW_RECURSION \
-  do { unsigned char _old = PyThreadState_GET()->recursion_critical;\
-    PyThreadState_GET()->recursion_critical = 1;
+  do { unsigned char _old = PyState_Get()->recursion_critical;\
+    PyState_Get()->recursion_critical = 1;
 
 #define Py_END_ALLOW_RECURSION \
-    PyThreadState_GET()->recursion_critical = _old; \
+    PyState_Get()->recursion_critical = _old; \
   } while(0);
 
 PyAPI_FUNC(const char *) PyEval_GetFuncName(PyObject *);
@@ -81,83 +78,6 @@
 PyAPI_DATA(volatile int) _Py_Ticker;
 PyAPI_DATA(int) _Py_CheckInterval;
 
-/* Interface for threads.
-
-   A module that plans to do a blocking system call (or something else
-   that lasts a long time and doesn't touch Python data) can allow other
-   threads to run as follows:
-
-	...preparations here...
-	Py_BEGIN_ALLOW_THREADS
-	...blocking system call here...
-	Py_END_ALLOW_THREADS
-	...interpret result here...
-
-   The Py_BEGIN_ALLOW_THREADS/Py_END_ALLOW_THREADS pair expands to a
-   {}-surrounded block.
-   To leave the block in the middle (e.g., with return), you must insert
-   a line containing Py_BLOCK_THREADS before the return, e.g.
-
-	if (...premature_exit...) {
-		Py_BLOCK_THREADS
-		PyErr_SetFromErrno(PyExc_IOError);
-		return NULL;
-	}
-
-   An alternative is:
-
-	Py_BLOCK_THREADS
-	if (...premature_exit...) {
-		PyErr_SetFromErrno(PyExc_IOError);
-		return NULL;
-	}
-	Py_UNBLOCK_THREADS
-
-   For convenience, that the value of 'errno' is restored across
-   Py_END_ALLOW_THREADS and Py_BLOCK_THREADS.
-
-   WARNING: NEVER NEST CALLS TO Py_BEGIN_ALLOW_THREADS AND
-   Py_END_ALLOW_THREADS!!!
-
-   The function PyEval_InitThreads() should be called only from
-   initthread() in "threadmodule.c".
-
-   Note that not yet all candidates have been converted to use this
-   mechanism!
-*/
-
-PyAPI_FUNC(PyThreadState *) PyEval_SaveThread(void);
-PyAPI_FUNC(void) PyEval_RestoreThread(PyThreadState *);
-
-#ifdef WITH_THREAD
-
-PyAPI_FUNC(int)  PyEval_ThreadsInitialized(void);
-PyAPI_FUNC(void) PyEval_InitThreads(void);
-PyAPI_FUNC(void) PyEval_AcquireLock(void);
-PyAPI_FUNC(void) PyEval_ReleaseLock(void);
-PyAPI_FUNC(void) PyEval_AcquireThread(PyThreadState *tstate);
-PyAPI_FUNC(void) PyEval_ReleaseThread(PyThreadState *tstate);
-PyAPI_FUNC(void) PyEval_ReInitThreads(void);
-
-#define Py_BEGIN_ALLOW_THREADS { \
-			PyThreadState *_save; \
-			_save = PyEval_SaveThread();
-#define Py_BLOCK_THREADS	PyEval_RestoreThread(_save);
-#define Py_UNBLOCK_THREADS	_save = PyEval_SaveThread();
-#define Py_END_ALLOW_THREADS	PyEval_RestoreThread(_save); \
-		 }
-
-#else /* !WITH_THREAD */
-
-#define Py_BEGIN_ALLOW_THREADS {
-#define Py_BLOCK_THREADS
-#define Py_UNBLOCK_THREADS
-#define Py_END_ALLOW_THREADS }
-
-#endif /* !WITH_THREAD */
-
-PyAPI_FUNC(int) _PyEval_SliceIndex(PyObject *, Py_ssize_t *);
-
 
 #ifdef __cplusplus
 }

=== modified file 'Include/code.h'
--- Include/code.h	2008-03-26 22:34:47 +0000
+++ Include/code.h	2008-04-11 02:11:55 +0000
@@ -51,6 +51,7 @@
 #define CO_FUTURE_PRINT_FUNCTION  0x10000
 #define CO_FUTURE_UNICODE_LITERALS 0x20000
 #endif
+#define CO_FUTURE_SHARED_MODULE 0x40000
 
 /* This should be defined if a future statement modifies the syntax.
    For example, when a keyword is added.

=== modified file 'Include/compile.h'
--- Include/compile.h	2008-03-26 22:34:47 +0000
+++ Include/compile.h	2008-04-11 02:10:20 +0000
@@ -26,6 +26,7 @@
 #define FUTURE_WITH_STATEMENT "with_statement"
 #define FUTURE_PRINT_FUNCTION "print_function"
 #define FUTURE_UNICODE_LITERALS "unicode_literals"
+#define FUTURE_SHARED_MODULE "shared_module"
 
 struct _mod; /* Declare the existence of this type */
 PyAPI_FUNC(PyCodeObject *) PyAST_Compile(struct _mod *, const char *,

=== modified file 'Include/datetime.h'
--- Include/datetime.h	2007-12-19 02:45:37 +0000
+++ Include/datetime.h	2008-03-24 04:28:03 +0000
@@ -76,13 +76,8 @@
 typedef struct
 {
 	_PyDateTime_TIMEHEAD
-} _PyDateTime_BaseTime;		/* hastzinfo false */
-
-typedef struct
-{
-	_PyDateTime_TIMEHEAD
 	PyObject *tzinfo;
-} PyDateTime_Time;		/* hastzinfo true */
+} PyDateTime_Time;
 
 
 /* All datetime objects are of PyDateTime_DateTimeType, but that can be
@@ -103,13 +98,8 @@
 typedef struct
 {
 	_PyDateTime_DATETIMEHEAD
-} _PyDateTime_BaseDateTime;	/* hastzinfo false */
-
-typedef struct
-{
-	_PyDateTime_DATETIMEHEAD
 	PyObject *tzinfo;
-} PyDateTime_DateTime;		/* hastzinfo true */
+} PyDateTime_DateTime;
 
 
 /* Apply for date and datetime instances. */

=== modified file 'Include/descrobject.h'
--- Include/descrobject.h	2007-12-19 02:45:37 +0000
+++ Include/descrobject.h	2008-03-24 04:28:03 +0000
@@ -67,6 +67,10 @@
 	void *d_wrapped; /* This can be any function pointer */
 } PyWrapperDescrObject;
 
+typedef struct {
+    PyDescr_COMMON;
+} PyFinalizeAttrDescrObject;
+
 PyAPI_DATA(PyTypeObject) PyClassMethodDescr_Type;
 PyAPI_DATA(PyTypeObject) PyGetSetDescr_Type;
 PyAPI_DATA(PyTypeObject) PyMemberDescr_Type;
@@ -82,6 +86,7 @@
 					       struct PyGetSetDef *);
 PyAPI_FUNC(PyObject *) PyDescr_NewWrapper(PyTypeObject *,
 						struct wrapperbase *, void *);
+PyAPI_FUNC(PyObject *) PyDescr_NewFinalizeAttr(PyTypeObject *, PyObject *);
 #define PyDescr_IsData(d) (Py_TYPE(d)->tp_descr_set != NULL)
 
 PyAPI_FUNC(PyObject *) PyDictProxy_New(PyObject *);

=== modified file 'Include/dictobject.h'
--- Include/dictobject.h	2007-12-19 02:45:37 +0000
+++ Include/dictobject.h	2008-03-24 04:28:03 +0000
@@ -67,6 +67,7 @@
 it's two-thirds full.
 */
 typedef struct _dictobject PyDictObject;
+typedef struct _pydict_lockstate PyDict_LockState;
 struct _dictobject {
 	PyObject_HEAD
 	Py_ssize_t ma_fill;  /* # Active + # Dummy */
@@ -78,17 +79,41 @@
 	 */
 	Py_ssize_t ma_mask;
 
+	/* Counter for number of times ma_table has been reallocated and
+	 * rebuilt.  Used to detect changes during a lookup.
+	 *
+	 * It's theoretically possible for this to wrap around completely
+	 * during one lookup, causing it to not restart.  Using a 64bit
+	 * counter would be the safest defense against this, but for now
+	 * we'll just be lazy.
+	 */
+	unsigned long long ma_rebuilds;
+
 	/* ma_table points to ma_smalltable for small tables, else to
 	 * additional malloc'ed memory.  ma_table is never NULL!  This rule
 	 * saves repeated runtime null-tests in the workhorse getitem and
 	 * setitem calls.
 	 */
 	PyDictEntry *ma_table;
-	PyDictEntry *(*ma_lookup)(PyDictObject *mp, PyObject *key, long hash);
+	PyDictEntry *(*ma_lookup)(PyDictObject *mp, PyObject *key,
+		long hash, PyDict_LockState *lockstate);
 	PyDictEntry ma_smalltable[PyDict_MINSIZE];
 };
 
+typedef struct {
+    PyDictObject base;
+    AO_t readonly_mode;
+    PyCritical *crit;
+    int read_count;
+} PySharedDictObject;
+
+struct _pydict_lockstate {
+    int doing_write;  /* These two flags are mutually incompatible */
+    int skipped_lock;
+};
+
 PyAPI_DATA(PyTypeObject) PyDict_Type;
+PyAPI_DATA(PyTypeObject) PySharedDict_Type;
 PyAPI_DATA(PyTypeObject) PyDictIterKey_Type;
 PyAPI_DATA(PyTypeObject) PyDictIterValue_Type;
 PyAPI_DATA(PyTypeObject) PyDictIterItem_Type;
@@ -105,10 +130,12 @@
 /* This excludes Values, since they are not sets. */
 # define PyDictViewSet_Check(op) \
 	(PyDictKeys_Check(op) || PyDictItems_Check(op))
+#define PySharedDict_Check(op) (Py_TYPE(op) == &PySharedDict_Type)
 
 
 PyAPI_FUNC(PyObject *) PyDict_New(void);
 PyAPI_FUNC(PyObject *) PyDict_GetItem(PyObject *mp, PyObject *key);
+PyAPI_FUNC(int) PyDict_GetItemEx(PyObject *op, PyObject *key, PyObject **value);
 PyAPI_FUNC(int) PyDict_SetItem(PyObject *mp, PyObject *key, PyObject *item);
 PyAPI_FUNC(int) PyDict_DelItem(PyObject *mp, PyObject *key);
 PyAPI_FUNC(void) PyDict_Clear(PyObject *mp);
@@ -116,6 +143,8 @@
 	PyObject *mp, Py_ssize_t *pos, PyObject **key, PyObject **value);
 PyAPI_FUNC(int) _PyDict_Next(
 	PyObject *mp, Py_ssize_t *pos, PyObject **key, PyObject **value, long *hash);
+PyAPI_FUNC(int) PyDict_NextEx(PyObject *mp, Py_ssize_t *pos,
+    PyObject **key, PyObject **value);
 PyAPI_FUNC(PyObject *) PyDict_Keys(PyObject *mp);
 PyAPI_FUNC(PyObject *) PyDict_Values(PyObject *mp);
 PyAPI_FUNC(PyObject *) PyDict_Items(PyObject *mp);
@@ -147,8 +176,16 @@
 					   int override);
 
 PyAPI_FUNC(PyObject *) PyDict_GetItemString(PyObject *dp, const char *key);
+PyAPI_FUNC(int) PyDict_GetItemStringEx(PyObject *v, const char *key, PyObject **value);
 PyAPI_FUNC(int) PyDict_SetItemString(PyObject *dp, const char *key, PyObject *item);
 PyAPI_FUNC(int) PyDict_DelItemString(PyObject *dp, const char *key);
+PyAPI_FUNC(int) PyDict_ContainsString(PyObject *d, const char *key);
+
+PyAPI_FUNC(void) _pydictlock_initstate_read(PyDict_LockState *);
+PyAPI_FUNC(void) _pydictlock_initstate_write(PyDict_LockState *);
+PyAPI_FUNC(void) _pydictlock_initstate_notshared(PyDict_LockState *);
+PyAPI_FUNC(void) _pydictlock_acquire(PyDictObject *, PyDict_LockState *);
+PyAPI_FUNC(void) _pydictlock_release(PyDictObject *, PyDict_LockState *);
 
 #ifdef __cplusplus
 }

=== modified file 'Include/frameobject.h'
--- Include/frameobject.h	2008-02-16 07:38:31 +0000
+++ Include/frameobject.h	2008-03-24 04:28:03 +0000
@@ -36,7 +36,7 @@
      */
     PyObject *f_exc_type, *f_exc_value, *f_exc_traceback;
 
-    PyThreadState *f_tstate;
+    PyState *f_pystate;
     int f_lasti;		/* Last instruction if called */
     /* As of 2.3 f_lineno is only valid when tracing is active (i.e. when
        f_trace is set) -- at other times use PyCode_Addr2Line instead. */
@@ -53,7 +53,7 @@
 
 #define PyFrame_Check(op) (Py_TYPE(op) == &PyFrame_Type)
 
-PyAPI_FUNC(PyFrameObject *) PyFrame_New(PyThreadState *, PyCodeObject *,
+PyAPI_FUNC(PyFrameObject *) PyFrame_New(PyState *, PyCodeObject *,
                                        PyObject *, PyObject *);
 
 

=== modified file 'Include/import.h'
--- Include/import.h	2008-01-03 23:01:04 +0000
+++ Include/import.h	2008-03-24 04:28:03 +0000
@@ -13,6 +13,7 @@
 	char *name, PyObject *co, char *pathname);
 PyAPI_FUNC(PyObject *) PyImport_GetModuleDict(void);
 PyAPI_FUNC(PyObject *) PyImport_AddModule(const char *name);
+PyAPI_FUNC(PyObject *) PyImport_AddModuleEx(const char *name, int shared);
 PyAPI_FUNC(PyObject *) PyImport_ImportModule(const char *name);
 PyAPI_FUNC(PyObject *) PyImport_ImportModuleNoBlock(const char *);
 PyAPI_FUNC(PyObject *) PyImport_ImportModuleLevel(char *name,
@@ -30,7 +31,6 @@
 PyAPI_FUNC(struct filedescr *) _PyImport_FindModule(
 	const char *, PyObject *, char *, size_t, FILE **, PyObject **);
 PyAPI_FUNC(int) _PyImport_IsScript(struct filedescr *);
-PyAPI_FUNC(void) _PyImport_ReInitLock(void);
 
 PyAPI_FUNC(PyObject *)_PyImport_FindExtension(char *, char *);
 PyAPI_FUNC(PyObject *)_PyImport_FixupExtension(char *, char *);

=== modified file 'Include/intrcheck.h'
--- Include/intrcheck.h	2002-08-12 07:21:58 +0000
+++ Include/intrcheck.h	2008-03-24 04:28:03 +0000
@@ -1,15 +0,0 @@
-
-#ifndef Py_INTRCHECK_H
-#define Py_INTRCHECK_H
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-PyAPI_FUNC(int) PyOS_InterruptOccurred(void);
-PyAPI_FUNC(void) PyOS_InitInterrupts(void);
-PyAPI_FUNC(void) PyOS_AfterFork(void);
-
-#ifdef __cplusplus
-}
-#endif
-#endif /* !Py_INTRCHECK_H */

=== modified file 'Include/methodobject.h'
--- Include/methodobject.h	2008-02-16 07:38:31 +0000
+++ Include/methodobject.h	2008-03-24 04:28:03 +0000
@@ -70,6 +70,9 @@
 
 #define METH_COEXIST   0x0040
 
+/* METH_SHARED allows a method to be shared between threads */
+#define METH_SHARED   0x0080
+
 typedef struct PyMethodChain {
     PyMethodDef *methods;		/* Methods of this type */
     struct PyMethodChain *link;	/* NULL or base type */

=== modified file 'Include/modsupport.h'
--- Include/modsupport.h	2008-01-23 08:24:23 +0000
+++ Include/modsupport.h	2008-03-24 04:28:03 +0000
@@ -43,6 +43,10 @@
 #define PyModule_AddIntMacro(m, c) PyModule_AddIntConstant(m, #c, c)
 #define PyModule_AddStringMacro(m, c) PyModule_AddStringConstant(m, #c, c)
 
+PyAPI_FUNC(int) PyArg_RequireShareable(const char *, PyObject *, PyObject *);
+PyAPI_FUNC(int) PyArg_RequireShareableReturn(const char *funcname, PyObject *innerfunc, PyObject *result);
+
+
 #define PYTHON_API_VERSION 1013
 #define PYTHON_API_STRING "1013"
 /* The API version is maintained (independently from the Python version)
@@ -117,6 +121,9 @@
 PyAPI_FUNC(PyObject *) Py_InitModule4(const char *name, PyMethodDef *methods,
                                       const char *doc, PyObject *self,
                                       int apiver);
+PyAPI_FUNC(PyObject *) Py_InitModule5(const char *name, PyMethodDef *methods,
+                                      const char *doc, PyObject *self,
+                                      int apiver, int shared);
 
 #define Py_InitModule(name, methods) \
 	Py_InitModule4(name, methods, (char *)NULL, (PyObject *)NULL, \

=== modified file 'Include/moduleobject.h'
--- Include/moduleobject.h	2007-12-19 02:45:37 +0000
+++ Include/moduleobject.h	2008-03-24 04:28:03 +0000
@@ -13,6 +13,7 @@
 #define PyModule_CheckExact(op) (Py_TYPE(op) == &PyModule_Type)
 
 PyAPI_FUNC(PyObject *) PyModule_New(const char *);
+PyAPI_FUNC(PyObject *) PyModule_NewEx(const char *, int);
 PyAPI_FUNC(PyObject *) PyModule_GetDict(PyObject *);
 PyAPI_FUNC(const char *) PyModule_GetName(PyObject *);
 PyAPI_FUNC(const char *) PyModule_GetFilename(PyObject *);

=== added file 'Include/monitorobject.h'
--- Include/monitorobject.h	1970-01-01 00:00:00 +0000
+++ Include/monitorobject.h	2008-04-07 20:19:32 +0000
@@ -0,0 +1,74 @@
+/* Monitor object and Monitor Space interface */
+
+#ifndef Py_MONITOROBJECT_H
+#define Py_MONITOROBJECT_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "pythread.h"
+#include "pystate.h"
+
+
+struct _PyBranchChild; /* Avoid including branchobject.h */
+
+typedef struct {
+    PyObject_HEAD
+    PyObject *mon_monitorspace;  /* The monitorspace that contains us */
+    PyObject *mon_conditions;  /* All conditions that have been used on us */
+    int mon_waking;  /* One condition is true and is being woken */
+} PyMonitorObject;
+
+typedef struct _PyMonitorSpaceObject {
+    PyObject_HEAD
+    PyWaitFor waitfor;
+    //PyState *lock_holder;
+    //PyState *first_waiter;
+    //PyState *last_waiter;
+    /* XXX flag (or counter?) used by PyState_StopTheWorld */
+    PyLinkedList waiters;
+    PyThread_type_cond *idle;
+} PyMonitorSpaceObject;
+
+PyAPI_DATA(PyTypeObject) PyMonitorMeta_Type;
+PyAPI_DATA(PyTypeObject) PyMonitor_Type;
+PyAPI_DATA(PyTypeObject) PyMonitorMethod_Type;
+PyAPI_DATA(PyTypeObject) PyBoundMonitorMethod_Type;
+PyAPI_DATA(PyTypeObject) PyMonitorCondition_Type;
+PyAPI_DATA(PyTypeObject) PyBoundMonitorCondition_Type;
+PyAPI_DATA(PyTypeObject) PyMonitorSpace_Type;
+
+#define PyMonitorMeta_Check(op) PyObject_TypeCheck(op, &PyMonitorMeta_Type)
+#define PyMonitorMeta_CheckExact(op) (Py_TYPE(op) == &PyMonitorMeta_Type)
+
+#define PyMonitor_Check(op) \
+    PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_MONITOR_SUBCLASS)
+#define PyMonitor_CheckExact(op) (Py_TYPE(op) == &PyMonitor_Type)
+
+#define PyCondition_Check(op) PyObject_TypeCheck(op, &PyMonitorCondition_Type)
+#define PyCondition_CheckExact(op) (Py_TYPE(op) == &PyMonitorCondition_Type)
+
+#define PyMonitorSpace_Check(op) PyObject_TypeCheck(op, &PyMonitorSpace_Type)
+#define PyMonitorSpace_CheckExact(op) (Py_TYPE(op) == &PyMonitorSpace_Type)
+
+#define PyMonitor_GetMonitorSpace(op) \
+    ((PyMonitorSpaceObject *)(((PyMonitorObject *)op)->mon_monitorspace))
+
+PyAPI_FUNC(int) PyMonitorSpace_IsCurrent(struct _PyMonitorSpaceObject *);
+PyAPI_FUNC(PyObject *) PyMonitorSpace_GetCurrent(void);
+PyAPI_FUNC(void) PyMonitorSpace_SetDeadlockDelay(double);
+PyAPI_FUNC(double) PyMonitorSpace_GetDeadlockDelay(void);
+PyAPI_FUNC(void) _PyMonitorSpace_WaitForBranchChild(struct _PyBranchChild *);
+PyAPI_FUNC(void) _PyMonitorSpace_BlockOnSelf(PyWaitFor *);
+PyAPI_FUNC(void) _PyMonitorSpace_UnblockOnSelf(PyWaitFor *);
+
+PyAPI_FUNC(PyObject *) PyMonitorMethod_New(PyObject *);
+PyAPI_FUNC(PyObject *) PyBoundMonitorMethod_New(PyObject *, PyObject *);
+PyAPI_FUNC(PyObject *) PyMonitorCondition_New(PyObject *);
+PyAPI_FUNC(PyObject *) PyBoundMonitorCondition_New(PyObject *, PyObject *);
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_MONITOROBJECT_H */

=== modified file 'Include/object.h'
--- Include/object.h	2008-03-31 01:51:45 +0000
+++ Include/object.h	2008-04-11 02:07:04 +0000
@@ -4,6 +4,8 @@
 extern "C" {
 #endif
 
+#include <atomic_ops.h>
+
 
 /* Object and type object interface */
 
@@ -51,6 +53,12 @@
 whose size is determined when the object is allocated.
 */
 
+#define Py_REFOWNER_ASYNC ((AO_t)0)
+#define Py_REFOWNER_STATICINIT ((AO_t)-1)
+#define Py_REFOWNER_DELETED ((AO_t)-2)
+
+#define Py_REFCNT_DELETED ((AO_t)-42)
+
 /* Py_DEBUG implies Py_TRACE_REFS. */
 #if defined(Py_DEBUG) && !defined(Py_TRACE_REFS)
 #define Py_TRACE_REFS
@@ -77,12 +85,16 @@
 /* PyObject_HEAD defines the initial segment of every PyObject. */
 #define PyObject_HEAD		        PyObject ob_base;
 
-#define PyObject_HEAD_INIT(type)	\
+/* XXX FIXME the default for ob_sizeclass is a cludge */
+#define PyObject_HEAD_INIT_NOCOMMA(type)	\
 	{ _PyObject_EXTRA_INIT		\
-	1, type },
+	NULL, NULL, 1, Py_REFOWNER_STATICINIT, 1, _PyGC_REFS_UNTRACKED, type }
+#define PyObject_HEAD_INIT(type) PyObject_HEAD_INIT_NOCOMMA(type),
 
-#define PyVarObject_HEAD_INIT(type, size)	\
-	{ PyObject_HEAD_INIT(type) size },
+#define PyVarObject_HEAD_INIT_NOCOMMA(type, size) \
+	{ PyObject_HEAD_INIT(type) size }
+#define PyVarObject_HEAD_INIT(type, size) \
+	PyVarObject_HEAD_INIT_NOCOMMA(type, size),
 
 /* PyObject_VAR_HEAD defines the initial segment of all variable-size
  * container objects.  These end with a declaration of an array with 1
@@ -100,7 +112,12 @@
  */
 typedef struct _object {
 	_PyObject_HEAD_EXTRA
-	Py_ssize_t ob_refcnt;
+	struct _object *ob_prev;
+	struct _object *ob_next;
+	Py_ssize_t ob_sizeclass;
+	AO_t ob_refowner;
+	AO_t ob_refcnt;
+	AO_t ob_refcnt_trace;
 	struct _typeobject *ob_type;
 } PyObject;
 
@@ -109,10 +126,29 @@
 	Py_ssize_t ob_size; /* Number of items in variable part */
 } PyVarObject;
 
-#define Py_REFCNT(ob)		(((PyObject*)(ob))->ob_refcnt)
 #define Py_TYPE(ob)		(((PyObject*)(ob))->ob_type)
 #define Py_SIZE(ob)		(((PyVarObject*)(ob))->ob_size)
 
+#include "pystate.h"
+
+#define Py_RefcntMatches(ob, count) (Py_RefcntSnoop(ob) == (count))
+
+#if 0
+static inline Py_ssize_t
+_Py_RefcntSnoop(PyObject *op)
+{
+	PyState *pystate = PyState_Get();
+	void *owner = (void *)AO_load_full(&op->ob_refowner);
+	Py_ssize_t count = (Py_ssize_t)AO_load_full(&op->ob_refcnt);
+
+	if (owner == pystate)
+		return count;
+	else
+		return 1000000;  /* Arbitrary large value */
+}
+#endif
+#define Py_RefcntSnoop(ob) _Py_RefcntSnoop((PyObject*)(ob))
+
 /*
 Type objects contain a string containing the type name (to help somewhat
 in debugging), the allocation parameters (see PyObject_New() and
@@ -279,7 +315,6 @@
      releasebufferproc bf_releasebuffer;
 } PyBufferProcs;
 
-typedef void (*freefunc)(void *);
 typedef void (*destructor)(PyObject *);
 typedef int (*printfunc)(PyObject *, FILE *, int);
 typedef PyObject *(*getattrfunc)(PyObject *, char *);
@@ -296,7 +331,7 @@
 typedef int (*descrsetfunc) (PyObject *, PyObject *, PyObject *);
 typedef int (*initproc)(PyObject *, PyObject *, PyObject *);
 typedef PyObject *(*newfunc)(struct _typeobject *, PyObject *, PyObject *);
-typedef PyObject *(*allocfunc)(struct _typeobject *, Py_ssize_t);
+typedef int (*isshareablefunc)(PyObject *);
 
 typedef struct _typeobject {
 	PyObject_VAR_HEAD
@@ -330,7 +365,7 @@
 	PyBufferProcs *tp_as_buffer;
 
 	/* Flags to define presence of optional/expanded features */
-	long tp_flags;
+	unsigned long tp_flags;
 
 	const char *tp_doc; /* Documentation string */
 
@@ -362,16 +397,16 @@
 	descrsetfunc tp_descr_set;
 	Py_ssize_t tp_dictoffset;
 	initproc tp_init;
-	allocfunc tp_alloc;
 	newfunc tp_new;
-	freefunc tp_free; /* Low-level free-memory routine */
 	inquiry tp_is_gc; /* For PyObject_IS_GC */
 	PyObject *tp_bases;
 	PyObject *tp_mro; /* method resolution order */
 	PyObject *tp_cache;
 	PyObject *tp_subclasses;
 	PyObject *tp_weaklist;
-	destructor tp_del;
+
+	/* Freezing to allow sharing between threads */
+	isshareablefunc tp_isshareable;
 
 	/* Type attribute cache version tag. Added in version 2.6 */
 	unsigned int tp_version_tag;
@@ -423,10 +458,9 @@
 #define PyType_CheckExact(op) (Py_TYPE(op) == &PyType_Type)
 
 PyAPI_FUNC(int) PyType_Ready(PyTypeObject *);
-PyAPI_FUNC(PyObject *) PyType_GenericAlloc(PyTypeObject *, Py_ssize_t);
 PyAPI_FUNC(PyObject *) PyType_GenericNew(PyTypeObject *,
 					       PyObject *, PyObject *);
-PyAPI_FUNC(PyObject *) _PyType_Lookup(PyTypeObject *, PyObject *);
+PyAPI_FUNC(int) _PyType_LookupEx(PyTypeObject *, PyObject *, PyObject **);
 PyAPI_FUNC(unsigned int) PyType_ClearCache(void);
 
 /* Generic operations on objects */
@@ -446,6 +480,7 @@
 PyAPI_FUNC(int) PyObject_SetAttr(PyObject *, PyObject *, PyObject *);
 PyAPI_FUNC(int) PyObject_HasAttr(PyObject *, PyObject *);
 PyAPI_FUNC(PyObject **) _PyObject_GetDictPtr(PyObject *);
+PyAPI_FUNC(PyObject **) _PyObject_GetDictPtr_NoCheck(PyObject *);
 PyAPI_FUNC(PyObject *) PyObject_SelfIter(PyObject *);
 PyAPI_FUNC(PyObject *) PyObject_GenericGetAttr(PyObject *, PyObject *);
 PyAPI_FUNC(int) PyObject_GenericSetAttr(PyObject *,
@@ -454,12 +489,16 @@
 PyAPI_FUNC(int) PyObject_IsTrue(PyObject *);
 PyAPI_FUNC(int) PyObject_Not(PyObject *);
 PyAPI_FUNC(int) PyCallable_Check(PyObject *);
+PyAPI_FUNC(int) PyObject_IsShareable(PyObject *);
 
-PyAPI_FUNC(void) PyObject_ClearWeakRefs(PyObject *);
+PyAPI_FUNC(int) _PyObject_TryClearWeakref(PyObject *);
+PyAPI_FUNC(void) _PyObject_ForceClearWeakref(PyObject *);
 
 /* A slot function whose address we need to compare */
 extern int _PyObject_SlotCompare(PyObject *, PyObject *);
 
+PyAPI_FUNC(void) _PyGC_AsyncRefcount_Flush(PyState *);
+PyAPI_FUNC(void) _PyGC_RefMode_Promote(PyObject *);
 
 /* PyObject_Dir(obj) acts like Python builtins.dir(obj), returning a
    list of strings.  PyObject_Dir(NULL) is like builtins.dir(),
@@ -507,44 +546,55 @@
 */
 
 /* Set if the type object is dynamically allocated */
-#define Py_TPFLAGS_HEAPTYPE (1L<<9)
+#define Py_TPFLAGS_HEAPTYPE (1UL<<9)
 
 /* Set if the type allows subclassing */
-#define Py_TPFLAGS_BASETYPE (1L<<10)
+#define Py_TPFLAGS_BASETYPE (1UL<<10)
 
 /* Set if the type is 'ready' -- fully initialized */
-#define Py_TPFLAGS_READY (1L<<12)
+#define Py_TPFLAGS_READY (1UL<<12)
 
 /* Set while the type is being 'readied', to prevent recursive ready calls */
-#define Py_TPFLAGS_READYING (1L<<13)
+#define Py_TPFLAGS_READYING (1UL<<13)
 
 /* Objects support garbage collection (see objimp.h) */
-#define Py_TPFLAGS_HAVE_GC (1L<<14)
+#define Py_TPFLAGS_HAVE_GC (1UL<<14)
 
 /* These two bits are preserved for Stackless Python, next after this is 17 */
 #ifdef STACKLESS
-#define Py_TPFLAGS_HAVE_STACKLESS_EXTENSION (3L<<15)
+#define Py_TPFLAGS_HAVE_STACKLESS_EXTENSION (3UL<<15)
 #else
 #define Py_TPFLAGS_HAVE_STACKLESS_EXTENSION 0
 #endif
 
+/* Type object is shareable */
+#define Py_TPFLAGS_SHAREABLE (1UL<<17)
+
+/* Type's tp_new will call PyObject_Complete itself.  Memory may not be
+ * wiped. */
+#define Py_TPFLAGS_SKIPWIPE (1UL<<18)
+
+/* Objects provide __finalize__ method */
+#define Py_TPFLAGS_HAVE_FINALIZE (1UL<<19)
+
 /* Objects support type attribute cache */
-#define Py_TPFLAGS_HAVE_VERSION_TAG   (1L<<18)
-#define Py_TPFLAGS_VALID_VERSION_TAG  (1L<<19)
+#define Py_TPFLAGS_HAVE_VERSION_TAG   (1L<<20)
+#define Py_TPFLAGS_VALID_VERSION_TAG  (1L<<21)
 
 /* Type is abstract and cannot be instantiated */
-#define Py_TPFLAGS_IS_ABSTRACT (1L<<20)
+#define Py_TPFLAGS_IS_ABSTRACT (1L<<22)
 
 /* These flags are used to determine if a type is a subclass. */
-#define Py_TPFLAGS_INT_SUBCLASS		(1L<<23)
-#define Py_TPFLAGS_LONG_SUBCLASS	(1L<<24)
-#define Py_TPFLAGS_LIST_SUBCLASS	(1L<<25)
-#define Py_TPFLAGS_TUPLE_SUBCLASS	(1L<<26)
-#define Py_TPFLAGS_STRING_SUBCLASS	(1L<<27)
-#define Py_TPFLAGS_UNICODE_SUBCLASS	(1L<<28)
-#define Py_TPFLAGS_DICT_SUBCLASS	(1L<<29)
-#define Py_TPFLAGS_BASE_EXC_SUBCLASS	(1L<<30)
-#define Py_TPFLAGS_TYPE_SUBCLASS	(1L<<31)
+#define Py_TPFLAGS_MONITOR_SUBCLASS	(1UL<<22)
+#define Py_TPFLAGS_INT_SUBCLASS		(1UL<<23)
+#define Py_TPFLAGS_LONG_SUBCLASS	(1UL<<24)
+#define Py_TPFLAGS_LIST_SUBCLASS	(1UL<<25)
+#define Py_TPFLAGS_TUPLE_SUBCLASS	(1UL<<26)
+#define Py_TPFLAGS_STRING_SUBCLASS	(1UL<<27)
+#define Py_TPFLAGS_UNICODE_SUBCLASS	(1UL<<28)
+#define Py_TPFLAGS_DICT_SUBCLASS	(1UL<<29)
+#define Py_TPFLAGS_BASE_EXC_SUBCLASS	(1UL<<30)
+#define Py_TPFLAGS_TYPE_SUBCLASS	(1UL<<31)
 
 #define Py_TPFLAGS_DEFAULT  ( \
                              Py_TPFLAGS_HAVE_STACKLESS_EXTENSION | \
@@ -584,7 +634,7 @@
 
 *** WARNING*** The Py_DECREF macro must have a side-effect-free argument
 since it may evaluate its argument multiple times.  (The alternative
-would be to mace it a proper function or assign it to a global temporary
+would be to make it a proper function or assign it to a global temporary
 variable first, both of which are slower; and in a multi-threaded
 environment the global variable trick is not safe.)
 */
@@ -599,28 +649,48 @@
  * #ifdefs (we used to do that -- it was impenetrable).
  */
 #ifdef Py_REF_DEBUG
-PyAPI_DATA(Py_ssize_t) _Py_RefTotal;
-PyAPI_FUNC(void) _Py_NegativeRefcount(const char *fname,
-					    int lineno, PyObject *op);
+PyAPI_DATA(AO_t) _Py_RefTotal;
+PyAPI_FUNC(void) _Py_NegativeRefcount(const char *fname, int lineno,
+	PyObject *op, Py_ssize_t count);
 PyAPI_FUNC(PyObject *) _PyDict_Dummy(void);
 PyAPI_FUNC(PyObject *) _PySet_Dummy(void);
 PyAPI_FUNC(Py_ssize_t) _Py_GetRefTotal(void);
-#define _Py_INC_REFTOTAL	_Py_RefTotal++
-#define _Py_DEC_REFTOTAL	_Py_RefTotal--
-#define _Py_REF_DEBUG_COMMA	,
-#define _Py_CHECK_REFCNT(OP)					\
+//#define _Py_INC_REFTOTAL	_Py_RefTotal++
+static inline void
+_Py_INC_REFTOTAL(void)
+{
+#ifdef Py_REF_DEBUG
+	AO_fetch_and_add1_full(&_Py_RefTotal);
+#endif
+}
+//#define _Py_DEC_REFTOTAL	_Py_RefTotal--
+static inline void
+_Py_DEC_REFTOTAL(void)
+{
+#ifdef Py_REF_DEBUG
+	AO_fetch_and_sub1_full(&_Py_RefTotal);
+#endif
+}
+//#define _Py_REF_DEBUG_COMMA	,
+/*#define _Py_CHECK_REFCNT(OP)					\
 {	if (((PyObject*)OP)->ob_refcnt < 0)				\
 		_Py_NegativeRefcount(__FILE__, __LINE__,	\
 				     (PyObject *)(OP));		\
 }
+*/
 #else
-#define _Py_INC_REFTOTAL
-#define _Py_DEC_REFTOTAL
-#define _Py_REF_DEBUG_COMMA
-#define _Py_CHECK_REFCNT(OP)	/* a semicolon */;
+//#define _Py_INC_REFTOTAL
+#define _Py_INC_REFTOTAL()
+//#define _Py_DEC_REFTOTAL
+#define _Py_DEC_REFTOTAL()
+//#define _Py_REF_DEBUG_COMMA
+//#define _Py_CHECK_REFCNT(OP)	/* a semicolon */;
 #endif /* Py_REF_DEBUG */
 
 #ifdef COUNT_ALLOCS
+#ifndef WITH_GIL
+#error FIXME
+#endif
 PyAPI_FUNC(void) inc_count(PyTypeObject *);
 PyAPI_FUNC(void) dec_count(PyTypeObject *);
 #define _Py_INC_TPALLOCS(OP)	inc_count(Py_TYPE(OP))
@@ -636,9 +706,6 @@
 
 #ifdef Py_TRACE_REFS
 /* Py_TRACE_REFS is such major surgery that we call external routines. */
-PyAPI_FUNC(void) _Py_NewReference(PyObject *);
-PyAPI_FUNC(void) _Py_ForgetReference(PyObject *);
-PyAPI_FUNC(void) _Py_Dealloc(PyObject *);
 PyAPI_FUNC(void) _Py_PrintReferences(FILE *);
 PyAPI_FUNC(void) _Py_PrintReferenceAddresses(FILE *);
 PyAPI_FUNC(void) _Py_AddToAllObjects(PyObject *, int force);
@@ -647,28 +714,45 @@
 /* Without Py_TRACE_REFS, there's little enough to do that we expand code
  * inline.
  */
-#define _Py_NewReference(op) (				\
-	_Py_INC_TPALLOCS(op) _Py_COUNT_ALLOCS_COMMA	\
-	_Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA		\
-	Py_REFCNT(op) = 1)
-
-#define _Py_ForgetReference(op) _Py_INC_TPFREES(op)
-
-#define _Py_Dealloc(op) (				\
-	_Py_INC_TPFREES(op) _Py_COUNT_ALLOCS_COMMA	\
-	(*Py_TYPE(op)->tp_dealloc)((PyObject *)(op)))
 #endif /* !Py_TRACE_REFS */
 
-#define Py_INCREF(op) (				\
-	_Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA	\
-	((PyObject*)(op))->ob_refcnt++)
-
-#define Py_DECREF(op)					\
-	if (_Py_DEC_REFTOTAL  _Py_REF_DEBUG_COMMA	\
-	    --((PyObject*)(op))->ob_refcnt != 0)		\
-		_Py_CHECK_REFCNT(op)			\
-	else						\
-		_Py_Dealloc((PyObject *)(op))
+PyAPI_FUNC(Py_ssize_t) _Py_RefcntSnoop(PyObject *);
+
+#ifndef WITH_GIL
+PyAPI_FUNC(void) _Py_INCREF(PyObject *, PyState *);
+PyAPI_FUNC(void) _Py_DECREF(PyObject *, PyState *);
+PyAPI_FUNC(void) _Py_DECREF_ASYNC(PyObject *, PyState *);
+#define Py_INCREF(op) _Py_INCREF((PyObject *)(op), PyState_Get())
+#define Py_DECREF(op) _Py_DECREF((PyObject *)(op), PyState_Get())
+#define Py_DECREF_ASYNC(op) _Py_DECREF_ASYNC((PyObject *)(op), PyState_Get())
+
+#define Py_INCREF_PS(op) _Py_INCREF((PyObject *)(op), pystate)
+#define Py_DECREF_PS(op) _Py_DECREF((PyObject *)(op), pystate)
+#else
+static inline void
+_Py_INCREF(PyObject *op)
+{
+        _Py_INC_REFTOTAL();
+        op->ob_refcnt++;
+}
+
+static inline void
+_Py_DECREF(PyObject *op)
+{
+        _Py_DEC_REFTOTAL();
+        op->ob_refcnt--;
+        if (op->ob_refcnt == 0)
+                _Py_Dealloc(op);
+#ifdef Py_REF_DEBUG
+        else if (((Py_ssize_t)op->ob_refcnt) < 0)
+                _Py_NegativeRefcount(__FILE__, __LINE__, op, op->ob_refcnt);
+#endif
+}
+#define Py_INCREF(op) _Py_INCREF((PyObject *)(op))
+#define Py_DECREF(op) _Py_DECREF((PyObject *)(op))
+#define Py_INCREF_PS Py_INCREF
+#define Py_DECREF_PS Py_DECREF
+#endif /* WITH_GIL */
 
 /* Safely decref `op` and set `op` to NULL, especially useful in tp_clear
  * and tp_dealloc implementatons.
@@ -713,10 +797,22 @@
                 }				\
         } while (0)
 
+#define Py_CLEAR_PS(op)				\
+        do {                            	\
+                if (op) {			\
+                        PyObject *tmp = (PyObject *)(op);	\
+                        (op) = NULL;		\
+                        Py_DECREF_PS(tmp);		\
+                }				\
+        } while (0)
+
 /* Macros to use in case the object pointer may be NULL: */
 #define Py_XINCREF(op) if ((op) == NULL) ; else Py_INCREF(op)
 #define Py_XDECREF(op) if ((op) == NULL) ; else Py_DECREF(op)
 
+#define Py_XINCREF_PS(op) if ((op) == NULL) ; else Py_INCREF_PS(op)
+#define Py_XDECREF_PS(op) if ((op) == NULL) ; else Py_DECREF_PS(op)
+
 /*
 These are provided as conveniences to Python runtime embedders, so that
 they can have object code that is not dependent on Python compilation flags.
@@ -809,67 +905,6 @@
 times.
 */
 
-
-/* Trashcan mechanism, thanks to Christian Tismer.
-
-When deallocating a container object, it's possible to trigger an unbounded
-chain of deallocations, as each Py_DECREF in turn drops the refcount on "the
-next" object in the chain to 0.  This can easily lead to stack faults, and
-especially in threads (which typically have less stack space to work with).
-
-A container object that participates in cyclic gc can avoid this by
-bracketing the body of its tp_dealloc function with a pair of macros:
-
-static void
-mytype_dealloc(mytype *p)
-{
-        ... declarations go here ...
-
- 	PyObject_GC_UnTrack(p);	   // must untrack first
-	Py_TRASHCAN_SAFE_BEGIN(p)
-	... The body of the deallocator goes here, including all calls ...
-	... to Py_DECREF on contained objects.                         ...
-	Py_TRASHCAN_SAFE_END(p)
-}
-
-CAUTION:  Never return from the middle of the body!  If the body needs to
-"get out early", put a label immediately before the Py_TRASHCAN_SAFE_END
-call, and goto it.  Else the call-depth counter (see below) will stay
-above 0 forever, and the trashcan will never get emptied.
-
-How it works:  The BEGIN macro increments a call-depth counter.  So long
-as this counter is small, the body of the deallocator is run directly without
-further ado.  But if the counter gets large, it instead adds p to a list of
-objects to be deallocated later, skips the body of the deallocator, and
-resumes execution after the END macro.  The tp_dealloc routine then returns
-without deallocating anything (and so unbounded call-stack depth is avoided).
-
-When the call stack finishes unwinding again, code generated by the END macro
-notices this, and calls another routine to deallocate all the objects that
-may have been added to the list of deferred deallocations.  In effect, a
-chain of N deallocations is broken into N / PyTrash_UNWIND_LEVEL pieces,
-with the call stack never exceeding a depth of PyTrash_UNWIND_LEVEL.
-*/
-
-PyAPI_FUNC(void) _PyTrash_deposit_object(PyObject*);
-PyAPI_FUNC(void) _PyTrash_destroy_chain(void);
-PyAPI_DATA(int) _PyTrash_delete_nesting;
-PyAPI_DATA(PyObject *) _PyTrash_delete_later;
-
-#define PyTrash_UNWIND_LEVEL 50
-
-#define Py_TRASHCAN_SAFE_BEGIN(op) \
-	if (_PyTrash_delete_nesting < PyTrash_UNWIND_LEVEL) { \
-		++_PyTrash_delete_nesting;
-		/* The body of the deallocator is here. */
-#define Py_TRASHCAN_SAFE_END(op) \
-		--_PyTrash_delete_nesting; \
-		if (_PyTrash_delete_later && _PyTrash_delete_nesting <= 0) \
-			_PyTrash_destroy_chain(); \
-	} \
-	else \
-		_PyTrash_deposit_object((PyObject*)op);
-
 #ifdef __cplusplus
 }
 #endif

=== modified file 'Include/objimpl.h'
--- Include/objimpl.h	2007-12-19 02:45:37 +0000
+++ Include/objimpl.h	2008-03-24 04:28:03 +0000
@@ -6,6 +6,7 @@
 #define Py_OBJIMPL_H
 
 #include "pymem.h"
+#include "pythread.h"
 
 #ifdef __cplusplus
 extern "C" {
@@ -94,6 +95,7 @@
    the object gets initialized via PyObject_{Init, InitVar} after obtaining
    the raw memory.
 */
+#if 0
 PyAPI_FUNC(void *) PyObject_Malloc(size_t);
 PyAPI_FUNC(void *) PyObject_Realloc(void *, size_t);
 PyAPI_FUNC(void) PyObject_Free(void *);
@@ -130,6 +132,7 @@
 
 #define PyObject_Del		PyObject_Free
 #define PyObject_DEL		PyObject_FREE
+#endif
 
 /*
  * Generic object allocator interface
@@ -137,23 +140,12 @@
  */
 
 /* Functions */
-PyAPI_FUNC(PyObject *) PyObject_Init(PyObject *, PyTypeObject *);
-PyAPI_FUNC(PyVarObject *) PyObject_InitVar(PyVarObject *,
-                                                 PyTypeObject *, Py_ssize_t);
-PyAPI_FUNC(PyObject *) _PyObject_New(PyTypeObject *);
-PyAPI_FUNC(PyVarObject *) _PyObject_NewVar(PyTypeObject *, Py_ssize_t);
-
-#define PyObject_New(type, typeobj) \
-		( (type *) _PyObject_New(typeobj) )
-#define PyObject_NewVar(type, typeobj, n) \
-		( (type *) _PyObject_NewVar((typeobj), (n)) )
-
-/* Macros trading binary compatibility for speed. See also pymem.h.
-   Note that these macros expect non-NULL object pointers.*/
-#define PyObject_INIT(op, typeobj) \
-	( Py_TYPE(op) = (typeobj), _Py_NewReference((PyObject *)(op)), (op) )
-#define PyObject_INIT_VAR(op, typeobj, size) \
-	( Py_SIZE(op) = (size), PyObject_INIT((op), (typeobj)) )
+PyAPI_FUNC(void *) PyObject_New(PyTypeObject *);
+PyAPI_FUNC(void *) PyObject_NewVar(PyTypeObject *, Py_ssize_t);
+PyAPI_FUNC(void) PyObject_Del(void *pyobject);
+PyAPI_FUNC(void) PyObject_Revive(void *pyobject);
+PyAPI_FUNC(void) PyObject_Complete(void *pyobject);
+PyAPI_FUNC(void *) PyObject_Resize(void *pyobject, Py_ssize_t);
 
 #define _PyObject_SIZE(typeobj) ( (typeobj)->tp_basicsize )
 
@@ -179,15 +171,6 @@
 	  ) & ~(SIZEOF_VOID_P - 1)		\
 	)
 
-#define PyObject_NEW(type, typeobj) \
-( (type *) PyObject_Init( \
-	(PyObject *) PyObject_MALLOC( _PyObject_SIZE(typeobj) ), (typeobj)) )
-
-#define PyObject_NEW_VAR(type, typeobj, n) \
-( (type *) PyObject_InitVar( \
-      (PyVarObject *) PyObject_MALLOC(_PyObject_VAR_SIZE((typeobj),(n)) ),\
-      (typeobj), (n)) )
-
 /* This example code implements an object constructor with a custom
    allocator, where PyObject_New is inlined, and shows the important
    distinction between two steps (at least):
@@ -231,68 +214,33 @@
 #define PyObject_IS_GC(o) (PyType_IS_GC(Py_TYPE(o)) && \
 	(Py_TYPE(o)->tp_is_gc == NULL || Py_TYPE(o)->tp_is_gc(o)))
 
-PyAPI_FUNC(PyVarObject *) _PyObject_GC_Resize(PyVarObject *, Py_ssize_t);
-#define PyObject_GC_Resize(type, op, n) \
-		( (type *) _PyObject_GC_Resize((PyVarObject *)(op), (n)) )
-
-/* for source compatibility with 2.2 */
-#define _PyObject_GC_Del PyObject_GC_Del
-
+#if 0
 /* GC information is stored BEFORE the object structure. */
 typedef union _gc_head {
 	struct {
+		Py_ssize_t gc_sizeclass;
 		union _gc_head *gc_next;
 		union _gc_head *gc_prev;
 		Py_ssize_t gc_refs;
 	} gc;
 	long double dummy;  /* force worst-case alignment */
 } PyGC_Head;
+#else
+#define PyGC_Head PyObject
+#endif
 
 extern PyGC_Head *_PyGC_generation0;
 
+#if 0
 #define _Py_AS_GC(o) ((PyGC_Head *)(o)-1)
-
-#define _PyGC_REFS_UNTRACKED			(-2)
-#define _PyGC_REFS_REACHABLE			(-3)
-#define _PyGC_REFS_TENTATIVELY_UNREACHABLE	(-4)
-
-/* Tell the GC to track this object.  NB: While the object is tracked the
- * collector it must be safe to call the ob_traverse method. */
-#define _PyObject_GC_TRACK(o) do { \
-	PyGC_Head *g = _Py_AS_GC(o); \
-	if (g->gc.gc_refs != _PyGC_REFS_UNTRACKED) \
-		Py_FatalError("GC object already tracked"); \
-	g->gc.gc_refs = _PyGC_REFS_REACHABLE; \
-	g->gc.gc_next = _PyGC_generation0; \
-	g->gc.gc_prev = _PyGC_generation0->gc.gc_prev; \
-	g->gc.gc_prev->gc.gc_next = g; \
-	_PyGC_generation0->gc.gc_prev = g; \
-    } while (0);
-
-/* Tell the GC to stop tracking this object.
- * gc_next doesn't need to be set to NULL, but doing so is a good
- * way to provoke memory errors if calling code is confused.
- */
-#define _PyObject_GC_UNTRACK(o) do { \
-	PyGC_Head *g = _Py_AS_GC(o); \
-	assert(g->gc.gc_refs != _PyGC_REFS_UNTRACKED); \
-	g->gc.gc_refs = _PyGC_REFS_UNTRACKED; \
-	g->gc.gc_prev->gc.gc_next = g->gc.gc_next; \
-	g->gc.gc_next->gc.gc_prev = g->gc.gc_prev; \
-	g->gc.gc_next = NULL; \
-    } while (0);
-
-PyAPI_FUNC(PyObject *) _PyObject_GC_Malloc(size_t);
-PyAPI_FUNC(PyObject *) _PyObject_GC_New(PyTypeObject *);
-PyAPI_FUNC(PyVarObject *) _PyObject_GC_NewVar(PyTypeObject *, Py_ssize_t);
-PyAPI_FUNC(void) PyObject_GC_Track(void *);
-PyAPI_FUNC(void) PyObject_GC_UnTrack(void *);
-PyAPI_FUNC(void) PyObject_GC_Del(void *);
-
-#define PyObject_GC_New(type, typeobj) \
-		( (type *) _PyObject_GC_New(typeobj) )
-#define PyObject_GC_NewVar(type, typeobj, n) \
-		( (type *) _PyObject_GC_NewVar((typeobj), (n)) )
+#endif
+
+#define _PyGC_REFS_TRACKED          (-2)
+#define _PyGC_REFS_TRACKED_YOUNG    (-3)
+#define _PyGC_REFS_UNTRACKED        (-4)
+#define _PyGC_REFS_UNTRACKED_YOUNG  (-5)
+
+PyAPI_FUNC(void) _PyGC_Object_Cache_Flush(void);
 
 
 /* Utility macro to help write tp_traverse functions.
@@ -322,9 +270,6 @@
 /* Test if a type supports weak references */
 #define PyType_SUPPORTS_WEAKREFS(t) ((t)->tp_weaklistoffset > 0)
 
-#define PyObject_GET_WEAKREFS_LISTPTR(o) \
-	((PyObject **) (((char *) (o)) + Py_TYPE(o)->tp_weaklistoffset))
-
 #ifdef __cplusplus
 }
 #endif

=== modified file 'Include/pyerrors.h'
--- Include/pyerrors.h	2008-03-18 15:15:01 +0000
+++ Include/pyerrors.h	2008-04-11 02:07:04 +0000
@@ -69,13 +69,14 @@
 #ifdef Py_DEBUG
 #define _PyErr_OCCURRED() PyErr_Occurred()
 #else
-#define _PyErr_OCCURRED() (_PyThreadState_Current->curexc_type)
+#define _PyErr_OCCURRED() (PyState_Get()->curexc_type)
 #endif
 
 /* Error testing and normalization */
 PyAPI_FUNC(int) PyErr_GivenExceptionMatches(PyObject *, PyObject *);
 PyAPI_FUNC(int) PyErr_ExceptionMatches(PyObject *);
 PyAPI_FUNC(void) PyErr_NormalizeException(PyObject**, PyObject**, PyObject**);
+PyAPI_FUNC(PyObject *) PyErr_SimplifyException(PyObject *, PyObject *, PyObject *);
 
 /* Traceback manipulation (PEP 3134) */
 PyAPI_FUNC(int) PyException_SetTraceback(PyObject *, PyObject *);
@@ -116,6 +117,7 @@
 
 PyAPI_DATA(PyObject *) PyExc_AssertionError;
 PyAPI_DATA(PyObject *) PyExc_AttributeError;
+PyAPI_DATA(PyObject *) PyExc_Cancelled;
 PyAPI_DATA(PyObject *) PyExc_EOFError;
 PyAPI_DATA(PyObject *) PyExc_FloatingPointError;
 PyAPI_DATA(PyObject *) PyExc_EnvironmentError;
@@ -126,9 +128,13 @@
 PyAPI_DATA(PyObject *) PyExc_KeyError;
 PyAPI_DATA(PyObject *) PyExc_KeyboardInterrupt;
 PyAPI_DATA(PyObject *) PyExc_MemoryError;
+PyAPI_DATA(PyObject *) PyExc_MultipleError;
 PyAPI_DATA(PyObject *) PyExc_NameError;
 PyAPI_DATA(PyObject *) PyExc_OverflowError;
 PyAPI_DATA(PyObject *) PyExc_RuntimeError;
+PyAPI_DATA(PyObject *) PyExc_DeadlockError;
+PyAPI_DATA(PyObject *) PyExc_HardDeadlockError;
+PyAPI_DATA(PyObject *) PyExc_SoftDeadlockError;
 PyAPI_DATA(PyObject *) PyExc_NotImplementedError;
 PyAPI_DATA(PyObject *) PyExc_SyntaxError;
 PyAPI_DATA(PyObject *) PyExc_IndentationError;
@@ -225,10 +231,6 @@
 				   const char *, int,
 				   const char *, PyObject *);
 
-/* In sigcheck.c or signalmodule.c */
-PyAPI_FUNC(int) PyErr_CheckSignals(void);
-PyAPI_FUNC(void) PyErr_SetInterrupt(void);
-
 /* In signalmodule.c */
 int PySignal_SetWakeupFd(int fd);
 

=== modified file 'Include/pyfpe.h'
--- Include/pyfpe.h	1997-10-20 23:50:01 +0000
+++ Include/pyfpe.h	2008-03-24 04:28:03 +0000
@@ -126,6 +126,7 @@
  */
 
 #ifdef WANT_SIGFPE_HANDLER
+#error FPE currently broken.  Needs to be made thread-safe
 #include <signal.h>
 #include <setjmp.h>
 #include <math.h>

=== added file 'Include/pylinkedlist.h'
--- Include/pylinkedlist.h	1970-01-01 00:00:00 +0000
+++ Include/pylinkedlist.h	2008-04-08 21:15:33 +0000
@@ -0,0 +1,201 @@
+/* Weak references objects for Python. */
+
+#ifndef Py_LINKEDLIST_H
+#define Py_LINKEDLIST_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* Needed for offsetof */
+#include "structmember.h"
+
+
+/* Internally, each PyLinkedListNode stores pointers directly other
+ * PyLinkedListNodes, not to the overall object, which makes them inner
+ * pointers.  The primary advantage is it allows using a sentinel, which
+ * in turn allows removing a node from a linked list without knowing
+ * exactly which linked list contains it. */
+typedef struct _PyLinkedListNode PyLinkedListNode;
+struct _PyLinkedListNode {
+    PyLinkedListNode *_prev;
+    PyLinkedListNode *_next;
+};
+
+typedef struct _PyLinkedList {
+    PyLinkedListNode _sentinel;
+    size_t _offset;
+} PyLinkedList;
+
+
+static inline int PyLinkedList_Empty(PyLinkedList *base);
+static inline int PyLinkedList_Detached(PyLinkedListNode *node);
+
+
+#define _PyLinkedList_ToNode(op, offset) \
+    ((PyLinkedListNode *)(((char *)op) + (offset)))
+#define _PyLinkedList_FromNode(node, offset) \
+    ((void *)(((char *)node) - (offset)))
+
+
+static inline void
+PyLinkedList_InitBase(PyLinkedList *base, size_t offset)
+{
+    base->_sentinel._prev = &base->_sentinel;
+    base->_sentinel._next = &base->_sentinel;
+    base->_offset = offset;
+}
+
+static inline void
+PyLinkedList_InitNode(PyLinkedListNode *node)
+{
+    node->_prev = NULL;
+    node->_next = NULL;
+}
+
+static inline void *
+PyLinkedList_First(PyLinkedList *base)
+{
+    if (PyLinkedList_Empty(base))
+        return NULL;
+    else
+        return _PyLinkedList_FromNode(base->_sentinel._next, base->_offset);
+}
+
+static inline void *
+PyLinkedList_Last(PyLinkedList *base)
+{
+    if (PyLinkedList_Empty(base))
+        return NULL;
+    else
+        return _PyLinkedList_FromNode(base->_sentinel._prev, base->_offset);
+}
+
+static inline void *
+PyLinkedList_Before(PyLinkedList *base, void *op)
+{
+    PyLinkedListNode *node;
+
+    assert(op != NULL);
+
+    node = _PyLinkedList_ToNode(op, base->_offset);
+    assert(!PyLinkedList_Detached(node));
+    if (node->_prev == &base->_sentinel)
+        return NULL;
+    return _PyLinkedList_FromNode(node->_prev, base->_offset);
+}
+
+static inline void *
+PyLinkedList_After(PyLinkedList *base, void *op)
+{
+    PyLinkedListNode *node;
+
+    assert(op != NULL);
+
+    node = _PyLinkedList_ToNode(op, base->_offset);
+    assert(!PyLinkedList_Detached(node));
+    if (node->_next == &base->_sentinel)
+        return NULL;
+    return _PyLinkedList_FromNode(node->_next, base->_offset);
+}
+
+static inline void
+_PyLinkedList_InsertBefore(PyLinkedListNode *a, PyLinkedListNode *b)
+{
+    assert(a->_prev != NULL && a->_next != NULL);
+    assert(b->_prev == NULL && b->_next == NULL);
+
+    b->_prev = a->_prev;
+    a->_prev->_next = b;
+
+    b->_next = a;
+    a->_prev = b;
+}
+
+static inline void
+PyLinkedList_Append(PyLinkedList *base, void *op)
+{
+    PyLinkedListNode *node = _PyLinkedList_ToNode(op, base->_offset);
+    _PyLinkedList_InsertBefore(&base->_sentinel, node);
+}
+
+static inline void
+PyLinkedList_Remove(PyLinkedListNode *node)
+{
+    assert(node->_prev != NULL && node->_next != NULL);
+    assert(node->_prev != node && node->_next != node);
+
+    node->_prev->_next = node->_next;
+    node->_next->_prev = node->_prev;
+
+    node->_prev = NULL;
+    node->_next = NULL;
+}
+
+/*
+ * Iterate over a LinkedList.  Use like so:
+ *
+ *     PyBranchObject *child = NULL;
+ *
+ *     while (PyLinkedList_Next(&self->children, &child))
+ *         Py_VISIT(child);
+ *
+ * CAUTION:  It is not safe to remove the current node while iterating.
+ *           Removing other nodes is okay.
+ */
+static inline void *
+_PyLinkedList_Next(PyLinkedList *base, void *op)
+{
+    PyLinkedListNode *node;
+
+    if (op == NULL)
+        node = &base->_sentinel;
+    else
+        node = _PyLinkedList_ToNode(op, base->_offset);
+
+    assert(node->_next != NULL);
+
+    if (node->_next == &base->_sentinel)
+        return NULL;
+    else
+        return _PyLinkedList_FromNode(node->_next, base->_offset);
+}
+/* Passing in a void ** doesn't do the right thing, so this fancy macro
+ * lets us get the right result with the desired API */
+#define PyLinkedList_Next(base, op) \
+    ((*(op) = (_PyLinkedList_Next((base), *(op)))) != NULL)
+
+static inline int
+PyLinkedList_Empty(PyLinkedList *base)
+{
+    PyLinkedListNode *sentinel = &base->_sentinel;
+    assert(sentinel->_prev != NULL && sentinel->_next != NULL);
+
+    if (sentinel->_next == sentinel) {
+        assert(sentinel->_prev == sentinel);
+        return 1;
+    } else {
+        assert(sentinel->_prev != sentinel);
+        return 0;
+    }
+}
+
+static inline int
+PyLinkedList_Detached(PyLinkedListNode *node)
+{
+    assert(node->_prev != node && node->_next != node);
+
+    if (node->_next == NULL) {
+        assert(node->_prev == NULL);
+        return 1;
+    } else {
+        assert(node->_prev != NULL);
+        return 0;
+    }
+}
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_LINKEDLIST_H */

=== modified file 'Include/pymem.h'
--- Include/pymem.h	2007-05-14 22:51:27 +0000
+++ Include/pymem.h	2008-03-24 04:28:03 +0000
@@ -49,6 +49,73 @@
    performed on failure (no exception is set, no warning is printed, etc).
 */
 
+#if 1
+PyAPI_FUNC(void) Py_FatalError(const char *message)
+    Py_GCC_ATTRIBUTE((noreturn));
+
+/* XXX Must match up with obmalloc.c's size_classes */
+#define PYMALLOC_CACHE_SIZECLASSES 13
+
+#define PYMALLOC_CACHE_COUNT 32
+
+
+PyAPI_FUNC(void *) pymemcache_malloc(size_t);
+PyAPI_FUNC(void *) pymemcache_realloc(void *, size_t);
+PyAPI_FUNC(void) pymemcache_free(void *);
+
+
+/* pymemwrap is just a temporary bodge until the different names are
+ * properly unified. */
+PyAPI_FUNC(void *) _pymemwrap_malloc(const char *, const char *, size_t);
+PyAPI_FUNC(void *) _pymemwrap_realloc(const char *, const char *, void *, size_t);
+PyAPI_FUNC(void) _pymemwrap_free(const char *, const char *, void *);
+
+#define PyMEMWRAP_MALLOC(name, group) \
+static inline void * \
+name(size_t size) \
+{ \
+	return _pymemwrap_malloc(#name, #group, size); \
+}
+
+#define PyMEMWRAP_REALLOC(name, group) \
+static inline void * \
+name(void *oldmem, size_t size) \
+{ \
+	return _pymemwrap_realloc(#name, #group, oldmem, size); \
+}
+
+#define PyMEMWRAP_FREE(name, group) \
+static inline void \
+name(void *mem) \
+{ \
+	_pymemwrap_free(#name, #group, mem); \
+}
+
+PyMEMWRAP_MALLOC(PyMem_Malloc, PyMem_Camel)
+PyMEMWRAP_REALLOC(PyMem_Realloc, PyMem_Camel)
+PyMEMWRAP_FREE(PyMem_Free, PyMem_Camel)
+
+PyMEMWRAP_MALLOC(PyMem_MALLOC, PyMem_UPPER)
+PyMEMWRAP_REALLOC(PyMem_REALLOC, PyMem_UPPER)
+PyMEMWRAP_FREE(PyMem_FREE, PyMem_UPPER)
+
+PyMEMWRAP_MALLOC(PyObject_Malloc, PyObject_Camel)
+PyMEMWRAP_REALLOC(PyObject_Realloc, PyObject_Camel)
+PyMEMWRAP_FREE(PyObject_Free, PyObject_Camel)
+
+PyMEMWRAP_MALLOC(PyObject_MALLOC, PyObject_UPPER)
+PyMEMWRAP_REALLOC(PyObject_REALLOC, PyObject_UPPER)
+PyMEMWRAP_FREE(PyObject_FREE, PyObject_UPPER)
+
+/* PyMem_Del is only used by multibytecodec.c */
+PyMEMWRAP_FREE(PyMem_Del, PyMem_CamelDel)
+PyMEMWRAP_FREE(PyMem_DEL, PyMem_UPPERDEL)
+
+//PyMEMWRAP_FREE(hidden_PyObject_Del, PyObject_CamelDel)
+//PyAPI_FUNC(void) PyObject_Del(void *);
+//PyMEMWRAP_FREE(PyObject_DEL, PyObject_UPPERDEL)
+
+#else
 PyAPI_FUNC(void *) PyMem_Malloc(size_t);
 PyAPI_FUNC(void *) PyMem_Realloc(void *, size_t);
 PyAPI_FUNC(void) PyMem_Free(void *);
@@ -74,6 +141,7 @@
 #define PyMem_FREE		free
 
 #endif	/* PYMALLOC_DEBUG */
+#endif
 
 /*
  * Type-oriented memory interface
@@ -97,8 +165,8 @@
 /* PyMem{Del,DEL} are left over from ancient days, and shouldn't be used
  * anymore.  They're just confusing aliases for PyMem_{Free,FREE} now.
  */
-#define PyMem_Del		PyMem_Free
-#define PyMem_DEL		PyMem_FREE
+//#define PyMem_Del		PyMem_Free
+//#define PyMem_DEL		PyMem_FREE
 
 #ifdef __cplusplus
 }

=== added file 'Include/pysignal.h'
--- Include/pysignal.h	1970-01-01 00:00:00 +0000
+++ Include/pysignal.h	2008-03-24 04:28:03 +0000
@@ -0,0 +1,16 @@
+#ifndef Py_PYSIGNAL_H
+#define Py_PYSIGNAL_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef void (*PyOS_sighandler_t)(int);
+PyAPI_FUNC(PyOS_sighandler_t) PyOS_getsig(int);
+PyAPI_FUNC(PyOS_sighandler_t) PyOS_setsig(int, PyOS_sighandler_t);
+
+PyAPI_FUNC(void) PyOS_AfterFork(void);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_PYSIGNAL_H */

=== modified file 'Include/pystate.h'
--- Include/pystate.h	2007-06-10 09:51:05 +0000
+++ Include/pystate.h	2008-04-08 22:45:55 +0000
@@ -8,38 +8,31 @@
 extern "C" {
 #endif
 
+#include <atomic_ops.h>
+
+#include "pythread.h"
+#include "pylinkedlist.h"
+
+
+/* XXX Must match up with gcmodule.c's gc_cache_size_classes */
+#define PYGC_CACHE_SIZECLASSES 13
+
+#define PYGC_CACHE_COUNT 32
+
+/* XXX Must be a power of 2 */
+//#define Py_ASYNCREFCOUNT_TABLE 1024
+#define Py_ASYNCREFCOUNT_TABLE 2048
+
+
 /* State shared between threads */
 
-struct _ts; /* Forward */
-struct _is; /* Forward */
-
-typedef struct _is {
-
-    struct _is *next;
-    struct _ts *tstate_head;
-
-    PyObject *modules;
-    PyObject *sysdict;
-    PyObject *builtins;
-    PyObject *modules_reloading;
-
-    PyObject *codec_search_path;
-    PyObject *codec_search_cache;
-    PyObject *codec_error_registry;
-
-#ifdef HAVE_DLOPEN
-    int dlopenflags;
-#endif
-#ifdef WITH_TSC
-    int tscdump;
-#endif
-
-} PyInterpreterState;
-
-
-/* State unique per thread */
+struct _PyState; /* Forward */
+struct _PyMonitorSpaceFrame; /* Forward */
+struct _PyState_EnterFrame; /* Forward */
 
 struct _frame; /* Avoid including frameobject.h */
+struct _PyMonitorSpaceObject; /* Avoid including monitorobject.h */
+struct _PyCancelObject; /* Avoid including cancelobject.h */
 
 /* Py_tracefunc return -1 when raising an exception, or 0 for success. */
 typedef int (*Py_tracefunc)(PyObject *, struct _frame *, int, PyObject *);
@@ -53,18 +46,63 @@
 #define PyTrace_C_EXCEPTION 5
 #define PyTrace_C_RETURN 6
 
-typedef struct _ts {
+struct _PyWaitFor;
+struct _PyWaitFor_Inspection;
+typedef void (*py_abortfunc)(struct _PyWaitFor_Inspection *,
+    struct _PyWaitFor *node);
+
+typedef struct _PyWaitFor {
+    void *self;
+    PyThread_type_lock *lock;
+    struct _PyWaitFor *blocker;
+    int checking_deadlock;
+    PyLinkedListNode inspection_links;
+    py_abortfunc abortfunc;
+} PyWaitFor;
+
+typedef struct _PyWaitFor_Inspection {
+    PyLinkedList inspecting;
+    int global;
+} PyWaitFor_Inspection;
+
+typedef struct _PyMonitorSpaceFrame {
+    struct _PyMonitorSpaceObject *monitorspace;
+    PyLinkedListNode links;
+} PyMonitorSpaceFrame;
+
+typedef struct _PyState_EnterFrame {
+    struct _PyState_EnterFrame *prevframe;
+    PyMonitorSpaceFrame monitorspaceframe;
+    int locked;
+} PyState_EnterFrame;
+
+typedef struct _PyCritical {
+    PyThread_type_lock *lock;
+    Py_ssize_t depth;
+    struct _PyCritical *prev;
+} PyCritical;
+
+struct _object;  /* From object.h, which includes us.  Doh! */
+
+typedef struct {
+    struct _object *obj;
+    AO_t diff;
+} PyAsyncRefEntry;
+
+typedef struct _PyState {
     /* See Python/ceval.c for comments explaining most fields */
 
-    struct _ts *next;
-    PyInterpreterState *interp;
+    struct _PyState *next;
+    int used;
+    int deleted;
 
     struct _frame *frame;
     int recursion_depth;
     char overflowed; /* The stack has overflowed. Allow 50 more calls
-		        to handle the runtime error. */
-    char recursion_critical; /* The current calls must not cause 
-				a stack overflow. */
+                        to handle the runtime error. */
+    char recursion_critical; /* The current calls must not cause
+                                a stack overflow. */
+    int dealloc_depth;
     /* 'tracing' keeps track of the execution depth when tracing/profiling.
        This is to prevent the actual trace/profile code from being recorded in
        the trace/profile. */
@@ -86,54 +124,82 @@
 
     PyObject *dict;  /* Stores per-thread state */
 
-    /* tick_counter is incremented whenever the check_interval ticker
+    /* large_ticks is incremented whenever the check_interval ticker
      * reaches zero. The purpose is to give a useful measure of the number
      * of interpreted bytecode instructions in a given thread.  This
      * extremely lightweight statistic collector may be of interest to
      * profilers (like psyco.jit()), although nothing in the core uses it.
      */
-    int tick_counter;
-
-    int gilstate_counter;
-
-    PyObject *async_exc; /* Asynchronous exception to raise */
-    long thread_id; /* Thread id where this tstate was created */
+    int large_ticks;
+    int small_ticks;
+
+    PyThread_type_lock *thread_lock;
+    PyThread_type_sem *world_wakeup;
+    PyLinkedListNode world_wakeup_links;
+
+    PyThread_type_lock *refowner_lock;
+    PyThread_type_lock *refowner_waiting_lock;
+    AO_t refowner_waiting_flag;
+
+    int suspended;
+
+    PyState_EnterFrame *enterframe;
+
+    Py_ssize_t import_depth;
+    PyLinkedList monitorspaces;
+
+    PyLinkedList cancel_stack;
+    PyCritical *cancel_crit;
+
+    /* Simple lock that doesn't employ deadlock detection */
+    PyCritical *critical_section;
+
+    /* The Monitor Space lock that this thread may be blocked on */
+    //struct _PyMonitorSpaceObject *active_lock;
+    //struct _PyState *lockwait_prev;
+    //struct _PyState *lockwait_next;
+    //PyThread_type_cond *lockwait_cond;
+    PyWaitFor waitfor;
+    PyThread_type_timeout *monitorspace_timeout;
+    //PyMonitorSpaceObject *monitorspace_wanted;
+    PyLinkedListNode monitorspace_waitinglinks;
+    PyThread_type_flag *monitorspace_waitingflag;
+
+    /* The Monitor condition that this thread may be waiting on */
+    PyLinkedListNode condition_links;
+    PyThread_type_flag *condition_flag;
 
     /* XXX signal handlers should also be here */
 
-} PyThreadState;
-
-
-PyAPI_FUNC(PyInterpreterState *) PyInterpreterState_New(void);
-PyAPI_FUNC(void) PyInterpreterState_Clear(PyInterpreterState *);
-PyAPI_FUNC(void) PyInterpreterState_Delete(PyInterpreterState *);
-
-PyAPI_FUNC(PyThreadState *) PyThreadState_New(PyInterpreterState *);
-PyAPI_FUNC(void) PyThreadState_Clear(PyThreadState *);
-PyAPI_FUNC(void) PyThreadState_Delete(PyThreadState *);
-#ifdef WITH_THREAD
-PyAPI_FUNC(void) PyThreadState_DeleteCurrent(void);
-#endif
-
-PyAPI_FUNC(PyThreadState *) PyThreadState_Get(void);
-PyAPI_FUNC(PyThreadState *) PyThreadState_Swap(PyThreadState *);
-PyAPI_FUNC(PyObject *) PyThreadState_GetDict(void);
-PyAPI_FUNC(int) PyThreadState_SetAsyncExc(long, PyObject *);
-
-
-/* Variable and macro for in-line access to current thread state */
-
-PyAPI_DATA(PyThreadState *) _PyThreadState_Current;
-
-#ifdef Py_DEBUG
-#define PyThreadState_GET() PyThreadState_Get()
+    void *malloc_cache[PYMALLOC_CACHE_SIZECLASSES][PYMALLOC_CACHE_COUNT];
+    void *gc_object_cache[PYGC_CACHE_SIZECLASSES][PYGC_CACHE_COUNT];
+
+    PyAsyncRefEntry async_refcounts[Py_ASYNCREFCOUNT_TABLE];
+} PyState;
+
+
+PyAPI_FUNC(int) _PyState_SingleThreaded(void);
+
+PyAPI_FUNC(PyState *) _PyState_New(void);
+PyAPI_FUNC(void) _PyState_Delete(PyState *);
+
+PyAPI_FUNC(PyState *) _PyState_Get(void);
+#if defined(Py_BUILD_CORE) && defined(HAVE_THREAD_LOCAL_VARIABLE)
+PyAPI_DATA(__thread PyState *) _py_local_pystate;
+static inline PyState *
+PyState_Get(void)
+{
+    PyState *pystate = _py_local_pystate;
+    if (pystate == NULL)
+        Py_FatalError("PyState_Get: no current thread");
+    return pystate;
+}
 #else
-#define PyThreadState_GET() (_PyThreadState_Current)
+#define PyState_Get _PyState_Get
 #endif
 
-typedef
-    enum {PyGILState_LOCKED, PyGILState_UNLOCKED}
-        PyGILState_STATE;
+PyAPI_FUNC(PyObject *) PyState_GetDict(void);
+
 
 /* Ensure that the current thread is ready to call the Python
    C API, regardless of the current state of Python, or of its
@@ -154,9 +220,10 @@
 
    When the function returns, the current thread will hold the GIL.
 
-   Failure is a fatal error.
+   0 is returned if memory is unavailable.
 */
-PyAPI_FUNC(PyGILState_STATE) PyGILState_Ensure(void);
+PyAPI_FUNC(PyState_EnterFrame *) PyState_Enter(void);
+PyAPI_FUNC(int) _PyState_EnterPreallocated(PyState_EnterFrame *, PyState *);
 
 /* Release any resources previously acquired.  After this call, Python's
    state will be the same as it was prior to the corresponding
@@ -166,32 +233,137 @@
    Every call to PyGILState_Ensure must be matched by a call to
    PyGILState_Release on the same thread.
 */
-PyAPI_FUNC(void) PyGILState_Release(PyGILState_STATE);
-
-/* Helper/diagnostic function - get the current thread state for
-   this thread.  May return NULL if no GILState API has been used
-   on the current thread.  Note the main thread always has such a
-   thread-state, even if no auto-thread-state call has been made
-   on the main thread.
-*/
-PyAPI_FUNC(PyThreadState *) PyGILState_GetThisThreadState(void);
-
-/* The implementation of sys._current_frames()  Returns a dict mapping
-   thread id to that thread's current frame.
-*/
-PyAPI_FUNC(PyObject *) _PyThread_CurrentFrames(void);
-
-/* Routines for advanced debuggers, requested by David Beazley.
-   Don't use unless you know what you are doing! */
-PyAPI_FUNC(PyInterpreterState *) PyInterpreterState_Head(void);
-PyAPI_FUNC(PyInterpreterState *) PyInterpreterState_Next(PyInterpreterState *);
-PyAPI_FUNC(PyThreadState *) PyInterpreterState_ThreadHead(PyInterpreterState *);
-PyAPI_FUNC(PyThreadState *) PyThreadState_Next(PyThreadState *);
-
-typedef struct _frame *(*PyThreadFrameGetter)(PyThreadState *self_);
+PyAPI_FUNC(void) PyState_Exit(PyState_EnterFrame *);
+PyAPI_FUNC(void) _PyState_ExitPreallocated(PyState_EnterFrame *);
+
+typedef struct _frame *(*PyThreadFrameGetter)(PyState *self_);
 
 /* hook for PyEval_GetFrame(), requested for Psyco */
-PyAPI_DATA(PyThreadFrameGetter) _PyThreadState_GetFrame;
+PyAPI_DATA(PyThreadFrameGetter) _PyState_GetFrame;
+
+PyAPI_FUNC(int) PyState_Tick(void);
+
+
+PyAPI_FUNC(void) PyState_EnterImport(void);
+PyAPI_FUNC(void) PyState_ExitImport(void);
+
+PyAPI_FUNC(void) PyState_StopTheWorld(void);
+PyAPI_FUNC(void) PyState_StartTheWorld(void);
+
+
+/* Prefered API for locking if PyState is involved.  Required if
+ * Py_INCREF/Py_DECREF are used.  The code is assumed to be a critical
+ * section (involving a known, fixed amount of code; entering other
+ * critical sections is an error.)  PyState_Suspend might be called
+ * while entering. */
+PyAPI_FUNC(PyCritical *) PyCritical_Allocate(Py_ssize_t);
+PyAPI_FUNC(void) PyCritical_Free(PyCritical *);
+PyAPI_FUNC(void) PyCritical_Enter(PyCritical *);
+PyAPI_FUNC(void) PyCritical_Exit(PyCritical *);
+
+/* This is just a bodge for deathqueue_wait.  It shouldn't be used in general */
+PyAPI_FUNC(void) _PyCritical_CondWait(PyCritical *, PyThread_type_cond *);
+
+/* Dummy critical sections, allocated on a stack and only used by one
+ * thread, used only to limit the effects of PyState_Suspend (and
+ * thereby preventing PyState_StopTheWorld from functioning). */
+PyAPI_FUNC(void) PyCritical_EnterDummy(PyCritical *, Py_ssize_t);
+PyAPI_FUNC(void) PyCritical_ExitDummy(PyCritical *);
+
+/* Most code only needs one critical section at a time.  They should use
+ * PyCRITICAL_NORMAL and be done with it.  Occasionally you'll need two
+ * specific critical sections at once, in which case you should add your
+ * defines and document them with your own little graph here.
+ *
+ * If there's enough independent graphs I may also add a "section" field,
+ * so you can't accidentally mix graphs.  Will I ever have a need for
+ * "universal" critical sections though, that can be entered while in
+ * any other critical section (except other universal critical sections)?
+ * XXX Using a stack-allocated critical section for INCREF/DECREF and the
+ * like would need a "universal" section field.
+ *
+ *    WEAKREF
+ *       |
+ *    HANDLE
+ *       |
+ *     QUEUE
+ */
+#define PyCRITICAL_DEALLOC 100
+
+#define PyCRITICAL_WEAKREF_REF 2
+#define PyCRITICAL_WEAKREF_HANDLE 1
+#define PyCRITICAL_WEAKREF_QUEUE 0
+
+#define PyCRITICAL_NORMAL 0
+
+#define PyCRITICAL_CANCEL -1
+
+#define PyCRITICAL_REFMODE_PROMOTE -100
+
+
+/* Interface for threads.
+
+   A module that plans to do a blocking system call (or something else
+   that lasts a long time and doesn't touch Python data) can allow other
+   threads to run as follows:
+
+        ...preparations here...
+        Py_BEGIN_ALLOW_THREADS
+        ...blocking system call here...
+        Py_END_ALLOW_THREADS
+        ...interpret result here...
+
+   The Py_BEGIN_ALLOW_THREADS/Py_END_ALLOW_THREADS pair expands to a
+   {}-surrounded block.
+   To leave the block in the middle (e.g., with return), you must insert
+   a line containing Py_BLOCK_THREADS before the return, e.g.
+
+        if (...premature_exit...) {
+            Py_BLOCK_THREADS
+            PyErr_SetFromErrno(PyExc_IOError);
+            return NULL;
+        }
+
+   An alternative is:
+
+        Py_BLOCK_THREADS
+        if (...premature_exit...) {
+            PyErr_SetFromErrno(PyExc_IOError);
+            return NULL;
+        }
+        Py_UNBLOCK_THREADS
+
+   For convenience, that the value of 'errno' is restored across
+   Py_END_ALLOW_THREADS and Py_BLOCK_THREADS.
+
+   WARNING: NEVER NEST CALLS TO Py_BEGIN_ALLOW_THREADS AND
+   Py_END_ALLOW_THREADS!!!
+
+   The function PyEval_InitThreads() should be called only from
+   initthread() in "threadmodule.c".
+
+   Note that not yet all candidates have been converted to use this
+   mechanism!
+*/
+
+#ifndef WITH_THREAD
+#error Threading support is now unconditional
+#endif
+
+PyAPI_FUNC(void) PyState_Suspend(void);
+PyAPI_FUNC(void) PyState_Resume(void);
+PyAPI_FUNC(void) PyState_MaybeSuspend(void);
+PyAPI_FUNC(void) PyState_MaybeResume(void);
+
+#define Py_BEGIN_ALLOW_THREADS PyState_Suspend();
+#define Py_BLOCK_THREADS PyState_Resume();
+#define Py_UNBLOCK_THREADS PyState_Suspend();
+#define Py_END_ALLOW_THREADS PyState_Resume();
+
+PyAPI_FUNC(int) _PyEval_SliceIndex(PyObject *, Py_ssize_t *);
+
+PyAPI_FUNC(void) _PyState_FlushAsyncRefcounts(void);
+
 
 #ifdef __cplusplus
 }

=== modified file 'Include/pythonrun.h'
--- Include/pythonrun.h	2008-04-05 20:41:37 +0000
+++ Include/pythonrun.h	2008-04-11 02:07:04 +0000
@@ -7,7 +7,7 @@
 extern "C" {
 #endif
 
-#define PyCF_MASK 0
+#define PyCF_MASK CO_FUTURE_SHARED_MODULE
 #define PyCF_MASK_OBSOLETE 0
 #define PyCF_SOURCE_IS_UTF8  0x0100
 #define PyCF_DONT_IMPLY_DEDENT 0x0200
@@ -27,8 +27,6 @@
 PyAPI_FUNC(void) Py_InitializeEx(int);
 PyAPI_FUNC(void) Py_Finalize(void);
 PyAPI_FUNC(int) Py_IsInitialized(void);
-PyAPI_FUNC(PyThreadState *) Py_NewInterpreter(void);
-PyAPI_FUNC(void) Py_EndInterpreter(PyThreadState *);
 
 PyAPI_FUNC(int) PyRun_AnyFileFlags(FILE *, const char *, PyCompilerFlags *);
 PyAPI_FUNC(int) PyRun_AnyFileExFlags(FILE *, const char *, int, PyCompilerFlags *);
@@ -76,7 +74,8 @@
 PyAPI_FUNC(void) _Py_PyAtExit(void (*func)(void));
 PyAPI_FUNC(int) Py_AtExit(void (*func)(void));
 
-PyAPI_FUNC(void) Py_Exit(int);
+PyAPI_FUNC(void) Py_Exit(int)
+    Py_GCC_ATTRIBUTE((noreturn));
 
 PyAPI_FUNC(int) Py_FdIsInteractive(FILE *, const char *);
 
@@ -119,14 +118,21 @@
 PyAPI_FUNC(const char *) Py_SubversionShortBranch(void);
 
 /* Internal -- various one-time initializations */
-PyAPI_FUNC(PyObject *) _PyBuiltin_Init(void);
-PyAPI_FUNC(PyObject *) _PySys_Init(void);
+PyAPI_FUNC(int) _PyBuiltin_Init(void);
+PyAPI_FUNC(void) _Py_ThreadTools_Init(void);
+PyAPI_FUNC(int) _PySys_Init(void);
 PyAPI_FUNC(void) _PyImport_Init(void);
 PyAPI_FUNC(void) _PyExc_Init(void);
 PyAPI_FUNC(void) _PyImportHooks_Init(void);
 PyAPI_FUNC(int) _PyFrame_Init(void);
 PyAPI_FUNC(void) _PyFloat_Init(void);
 PyAPI_FUNC(int) PyBytes_Init(void);
+PyAPI_FUNC(void) _PyMethod_Init(void);
+PyAPI_FUNC(void) _PyList_Init(void);
+PyAPI_FUNC(void) _PySet_Init(void);
+PyAPI_FUNC(void) _PyCFunction_Init(void);
+PyAPI_FUNC(void) _PySignal_Init(void);
+PyAPI_FUNC(void) _PySignal_InitSigInt(int);
 
 /* Various internal finalizers */
 PyAPI_FUNC(void) _PyExc_Fini(void);
@@ -141,13 +147,15 @@
 PyAPI_FUNC(void) PyString_Fini(void);
 PyAPI_FUNC(void) PyBytes_Fini(void);
 PyAPI_FUNC(void) PyFloat_Fini(void);
-PyAPI_FUNC(void) PyOS_FiniInterrupts(void);
+PyAPI_FUNC(void) PyDict_Fini(void);
+PyAPI_FUNC(void) _PySignal_Fini(void);
+PyAPI_FUNC(void) _PySignal_FiniSigInt(void);
 
 /* Stuff with no proper home (yet) */
 PyAPI_FUNC(char *) PyOS_Readline(FILE *, FILE *, char *);
 PyAPI_DATA(int) (*PyOS_InputHook)(void);
 PyAPI_DATA(char) *(*PyOS_ReadlineFunctionPointer)(FILE *, FILE *, char *);
-PyAPI_DATA(PyThreadState*) _PyOS_ReadlineTState;
+PyAPI_DATA(PyState *) _PyOS_ReadlineTState;
 
 /* Stack size, in "pointers" (so we get extra safety margins
    on 64-bit platforms).  On a 32-bit platform, this translates
@@ -164,11 +172,6 @@
 PyAPI_FUNC(int) PyOS_CheckStack(void);
 #endif
 
-/* Signals */
-typedef void (*PyOS_sighandler_t)(int);
-PyAPI_FUNC(PyOS_sighandler_t) PyOS_getsig(int);
-PyAPI_FUNC(PyOS_sighandler_t) PyOS_setsig(int, PyOS_sighandler_t);
-
 
 #ifdef __cplusplus
 }

=== modified file 'Include/pythread.h'
--- Include/pythread.h	2006-08-11 14:57:12 +0000
+++ Include/pythread.h	2008-04-07 20:05:55 +0000
@@ -2,43 +2,78 @@
 #ifndef Py_PYTHREAD_H
 #define Py_PYTHREAD_H
 
-#define NO_EXIT_PROG		/* don't define PyThread_exit_prog() */
-				/* (the result is no use of signals on SGI) */
-
-typedef void *PyThread_type_lock;
-typedef void *PyThread_type_sema;
+/* Incomplete types are intentionally used here.  Only thread_*.h has
+ * the full definitions. */
+typedef struct _PyThread_type_lock PyThread_type_lock;
+typedef struct _PyThread_type_sem PyThread_type_sem;
+typedef struct _PyThread_type_cond PyThread_type_cond;
+typedef struct _PyThread_type_key PyThread_type_key;
+typedef struct _PyThread_type_handle PyThread_type_handle;
+typedef struct _PyThread_type_timeout PyThread_type_timeout;
+typedef struct _PyThread_type_flag PyThread_type_flag;
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
 PyAPI_FUNC(void) PyThread_init_thread(void);
-PyAPI_FUNC(long) PyThread_start_new_thread(void (*)(void *), void *);
-PyAPI_FUNC(void) PyThread_exit_thread(void);
-PyAPI_FUNC(void) PyThread__PyThread_exit_thread(void);
-PyAPI_FUNC(long) PyThread_get_thread_ident(void);
+PyAPI_FUNC(int) PyThread_start_new_thread(PyThread_type_handle **,
+    void (*)(void *), void *);
 
-PyAPI_FUNC(PyThread_type_lock) PyThread_allocate_lock(void);
-PyAPI_FUNC(void) PyThread_free_lock(PyThread_type_lock);
-PyAPI_FUNC(int) PyThread_acquire_lock(PyThread_type_lock, int);
-#define WAIT_LOCK	1
-#define NOWAIT_LOCK	0
-PyAPI_FUNC(void) PyThread_release_lock(PyThread_type_lock);
+PyAPI_FUNC(PyThread_type_handle *) PyThread_get_handle(void);
+PyAPI_FUNC(void) PyThread_free_handle(PyThread_type_handle *);
+PyAPI_FUNC(void) PyThread_send_signal(PyThread_type_handle *, int signum);
 
 PyAPI_FUNC(size_t) PyThread_get_stacksize(void);
 PyAPI_FUNC(int) PyThread_set_stacksize(size_t);
 
-#ifndef NO_EXIT_PROG
-PyAPI_FUNC(void) PyThread_exit_prog(int);
-PyAPI_FUNC(void) PyThread__PyThread_exit_prog(int);
-#endif
+PyAPI_FUNC(PyThread_type_lock* ) PyThread_lock_allocate(void);
+PyAPI_FUNC(void) PyThread_lock_free(PyThread_type_lock *);
+PyAPI_FUNC(void) PyThread_lock_acquire(PyThread_type_lock *);
+PyAPI_FUNC(int) PyThread_lock_tryacquire(PyThread_type_lock *);
+PyAPI_FUNC(void) PyThread_lock_release(PyThread_type_lock *);
+
+PyAPI_FUNC(PyThread_type_sem *) PyThread_sem_allocate(int);
+PyAPI_FUNC(void) PyThread_sem_free(PyThread_type_sem *);
+PyAPI_FUNC(void) PyThread_sem_acquire(PyThread_type_sem *);
+PyAPI_FUNC(void) PyThread_sem_release(PyThread_type_sem *);
+
+PyAPI_FUNC(PyThread_type_cond *) PyThread_cond_allocate(void);
+PyAPI_FUNC(void) PyThread_cond_free(PyThread_type_cond *);
+PyAPI_FUNC(void) PyThread_cond_wait(PyThread_type_cond *,
+    PyThread_type_lock *);
+PyAPI_FUNC(void) PyThread_cond_timedwait(PyThread_type_cond *,
+    PyThread_type_lock *, PyThread_type_timeout *);
+PyAPI_FUNC(void) PyThread_cond_wakeone(PyThread_type_cond *);
+PyAPI_FUNC(void) PyThread_cond_wakeall(PyThread_type_cond *);
 
 /* Thread Local Storage (TLS) API */
-PyAPI_FUNC(int) PyThread_create_key(void);
-PyAPI_FUNC(void) PyThread_delete_key(int);
-PyAPI_FUNC(int) PyThread_set_key_value(int, void *);
-PyAPI_FUNC(void *) PyThread_get_key_value(int);
-PyAPI_FUNC(void) PyThread_delete_key_value(int key);
+PyAPI_FUNC(PyThread_type_key *) PyThread_create_key(void);
+PyAPI_FUNC(void) PyThread_delete_key(PyThread_type_key *);
+PyAPI_FUNC(void) PyThread_set_key_value(PyThread_type_key *, void *);
+PyAPI_FUNC(void *) PyThread_get_key_value(PyThread_type_key *);
+PyAPI_FUNC(void) PyThread_delete_key_value(PyThread_type_key *);
+
+PyAPI_FUNC(PyThread_type_timeout *) PyThread_timeout_allocate(void);
+PyAPI_FUNC(void) PyThread_timeout_free(PyThread_type_timeout *);
+PyAPI_FUNC(void) PyThread_timeout_set(PyThread_type_timeout *, double delay);
+/* A timeout might only be marked as expired after being used.  Sleeping
+ * and calling PyThread_timeout_expired may not be sufficient. */
+PyAPI_FUNC(int) PyThread_timeout_expired(PyThread_type_timeout *);
+
+/* It is assumed that PyThread_flag_set and PyThread_flag_clear are only
+ * called while holding some common lock.  Only PyThread_flag_wait
+ * should be called without holding said common lock.
+ *
+ * It is also assumed that there is only one thread calling
+ * PyThread_flag_wait and it is that thread which later calls
+ * PyThread_flag_clear */
+PyAPI_FUNC(PyThread_type_flag *) PyThread_flag_allocate(void);
+PyAPI_FUNC(void) PyThread_flag_free(PyThread_type_flag *);
+PyAPI_FUNC(void) PyThread_flag_set(PyThread_type_flag *);
+PyAPI_FUNC(void) PyThread_flag_clear(PyThread_type_flag *);
+PyAPI_FUNC(void) PyThread_flag_wait(PyThread_type_flag *);
+PyAPI_FUNC(int) PyThread_flag_timedwait(PyThread_type_flag *, double delay);
 
 #ifdef __cplusplus
 }

=== modified file 'Include/tupleobject.h'
--- Include/tupleobject.h	2008-02-16 07:38:31 +0000
+++ Include/tupleobject.h	2008-03-24 04:28:03 +0000
@@ -23,6 +23,7 @@
 
 typedef struct {
     PyObject_VAR_HEAD
+    AO_t shareable;
     PyObject *ob_item[1];
 
     /* ob_item contains space for 'ob_size' elements.

=== modified file 'Include/unicodeobject.h'
--- Include/unicodeobject.h	2008-02-16 07:38:31 +0000
+++ Include/unicodeobject.h	2008-03-24 04:28:03 +0000
@@ -424,7 +424,7 @@
     Py_ssize_t length;		/* Length of raw Unicode data in buffer */
     Py_UNICODE *str;		/* Raw Unicode buffer */
     long hash;			/* Hash value; -1 if not set */
-    int state;			/* != 0 if interned. In this case the two
+    AO_t state;			/* != 0 if interned. In this case the two
     				 * references from the dictionary to this object
     				 * are *not* counted in ob_refcnt. */
     PyObject *defenc;		/* (Default) Encoded version as Python
@@ -436,8 +436,9 @@
 PyAPI_DATA(PyTypeObject) PyUnicodeIter_Type;
 
 #define SSTATE_NOT_INTERNED 0
-#define SSTATE_INTERNED_MORTAL 1
-#define SSTATE_INTERNED_IMMORTAL 2
+#define SSTATE_INTERNED 1
+
+PyAPI_FUNC(int) _PyUnicode_SnoopState(PyUnicodeObject *);
 
 #define PyUnicode_Check(op) \
                  PyType_FastSubclass(Py_TYPE(op), Py_TPFLAGS_UNICODE_SUBCLASS)
@@ -572,13 +573,9 @@
 PyAPI_FUNC(PyObject *) PyUnicode_FromFormat(const char*, ...);
 
 PyAPI_FUNC(void) PyUnicode_InternInPlace(PyObject **);
-PyAPI_FUNC(void) PyUnicode_InternImmortal(PyObject **);
 PyAPI_FUNC(PyObject *) PyUnicode_InternFromString(const char *);
 PyAPI_FUNC(void) _Py_ReleaseInternedUnicodeStrings(void);
 
-/* Use only if you know it's a string */
-#define PyUnicode_CHECK_INTERNED(op) (((PyUnicodeObject *)(op))->state)
-
 /* --- wchar_t support for platforms which support it --------------------- */
 
 #ifdef HAVE_WCHAR_H

=== modified file 'Include/weakrefobject.h'
--- Include/weakrefobject.h	2007-12-19 02:45:37 +0000
+++ Include/weakrefobject.h	2008-04-03 17:59:36 +0000
@@ -7,66 +7,114 @@
 #endif
 
 
+#include "pythread.h"
+#include "pylinkedlist.h"
+
+
 typedef struct _PyWeakReference PyWeakReference;
+typedef struct _PyDeathQueueHandle PyDeathQueueHandle;
+typedef struct _PyDeathQueue PyDeathQueue;
+typedef struct _PyWeakBinding PyWeakBinding;
 
-/* PyWeakReference is the base struct for the Python ReferenceType, ProxyType,
- * and CallableProxyType.
- */
 struct _PyWeakReference {
     PyObject_HEAD
 
+    /* Critical section protecting access to wr_object and our (not yet
+     * implemented) death notice list.  hash is NOT protected */
+    PyCritical *crit;
+
     /* The object to which this is a weak reference, or Py_None if none.
      * Note that this is a stealth reference:  wr_object's refcount is
      * not incremented to reflect this pointer.
      */
+    /* XXX it gets set to NULL now, not Py_None */
     PyObject *wr_object;
 
-    /* A callable to invoke when wr_object dies, or NULL if none. */
-    PyObject *wr_callback;
-
     /* A cache for wr_object's hash code.  As usual for hashes, this is -1
      * if the hash code isn't known yet.
      */
-    long hash;
+    /* XXX I'd much rather remove this, but to detect existing usage
+     * I'd have to make it an error. */
+    AO_t hash;
 
     /* If wr_object is weakly referenced, wr_object has a doubly-linked NULL-
      * terminated list of weak references to it.  These are the list pointers.
      * If wr_object goes away, wr_object is set to Py_None, and these pointers
      * have no meaning then.
      */
-    PyWeakReference *wr_prev;
-    PyWeakReference *wr_next;
-};
-
-PyAPI_DATA(PyTypeObject) _PyWeakref_RefType;
-PyAPI_DATA(PyTypeObject) _PyWeakref_ProxyType;
-PyAPI_DATA(PyTypeObject) _PyWeakref_CallableProxyType;
-
-#define PyWeakref_CheckRef(op) PyObject_TypeCheck(op, &_PyWeakref_RefType)
-#define PyWeakref_CheckRefExact(op) \
-        (Py_TYPE(op) == &_PyWeakref_RefType)
-#define PyWeakref_CheckProxy(op) \
-        ((Py_TYPE(op) == &_PyWeakref_ProxyType) || \
-         (Py_TYPE(op) == &_PyWeakref_CallableProxyType))
-
-/* This macro calls PyWeakref_CheckRef() last since that can involve a
-   function call; this makes it more likely that the function call
-   will be avoided. */
-#define PyWeakref_Check(op) \
-        (PyWeakref_CheckRef(op) || PyWeakref_CheckProxy(op))
-
-
-PyAPI_FUNC(PyObject *) PyWeakref_NewRef(PyObject *ob,
-                                              PyObject *callback);
-PyAPI_FUNC(PyObject *) PyWeakref_NewProxy(PyObject *ob,
-                                                PyObject *callback);
-PyAPI_FUNC(PyObject *) PyWeakref_GetObject(PyObject *ref);
-
-PyAPI_FUNC(Py_ssize_t) _PyWeakref_GetWeakrefCount(PyWeakReference *head);
-
-PyAPI_FUNC(void) _PyWeakref_ClearRef(PyWeakReference *self);
-
-#define PyWeakref_GET_OBJECT(ref) (((PyWeakReference *)(ref))->wr_object)
+    //PyWeakReference *wr_prev;
+    //PyWeakReference *wr_next;
+    PyLinkedList handle_links;
+
+    PyLinkedList binding_links;
+};
+
+PyAPI_DATA(PyTypeObject) _PyWeakref_Type;
+
+#define PyWeakref_Check(op) (Py_TYPE(op) == &_PyWeakref_Type)
+#define PyWeakref_CheckRefExact PyWeakref_Check
+#define PyWeakref_CheckRef PyWeakref_Check
+
+
+PyAPI_FUNC(PyObject *) PyWeakref_NewRef(PyObject *ob, PyObject *callback);
+/* Note that this DOES incref the returned object, if not NULL! */
+PyAPI_FUNC(PyObject *) PyWeakref_GetObjectEx(PyObject *ref);
+PyAPI_FUNC(PyObject *) PyWeakref_NewBinding(PyObject *ob, PyObject *value);
+PyAPI_FUNC(PyObject *) PyWeakref_GetBindingObject(PyObject *bind, PyObject **value);
+
+PyAPI_FUNC(void) _PyWeakref_ClearBindings(PyObject *ob, PyWeakReference *ref);
+
+#define _PY_GETWEAKREFPTR(o) \
+        ((PyWeakReference **) (((char *) (o)) + Py_TYPE(o)->tp_weaklistoffset))
+
+
+struct _PyDeathQueueHandle {
+    PyObject_HEAD
+
+    PyCritical *crit;
+
+    PyObject *payload;
+
+    PyWeakReference *weakref;
+    PyLinkedListNode weakref_links;
+
+    PyDeathQueue *queue;
+    PyLinkedListNode queue_links;
+};
+
+PyAPI_DATA(PyTypeObject) _PyDeathQueueHandle_Type;
+
+#define PyDeathQueueHandle_Check(op) \
+    (Py_TYPE(op) == &_PyDeathQueueHandle_Type)
+
+
+struct _PyDeathQueue {
+    PyObject_HEAD
+
+    PyCritical *crit;
+    PyThread_type_cond *cond;
+
+    PyLinkedList live_links;
+    PyLinkedList dead_links;
+};
+
+PyAPI_DATA(PyTypeObject) _PyDeathQueue_Type;
+
+#define PyDeathQueue_Check(op) (Py_TYPE(op) == &_PyDeathQueue_Type)
+
+
+struct _PyWeakBinding {
+    PyObject_HEAD
+
+    PyWeakReference *weakref;
+    PyObject *value; /* This is actually owned by weakref->wr_object */
+
+    PyLinkedListNode weakref_links;
+};
+
+PyAPI_DATA(PyTypeObject) _PyWeakBinding_Type;
+
+#define PyWeakBinding_Check(op) (Py_TYPE(op) == &_PyWeakBinding_Type)
 
 
 #ifdef __cplusplus

=== modified file 'LICENSE'
--- LICENSE	2008-03-01 17:45:23 +0000
+++ LICENSE	2008-03-24 04:28:03 +0000
@@ -1,3 +1,7 @@
+The python-safethread patch is licensed under the Apache License, version 2.0.  Obviously the rest of Python is under its own license (or licenses.)
+
+~~~~~~~~~~
+
 A. HISTORY OF THE SOFTWARE
 ==========================
 

=== modified file 'Lib/__future__.py'
--- Lib/__future__.py	2008-03-26 22:34:47 +0000
+++ Lib/__future__.py	2008-04-11 02:14:57 +0000
@@ -55,6 +55,7 @@
     "with_statement",
     "print_function",
     "unicode_literals",
+    "shared_module",
 ]
 
 __all__ = ["all_feature_names"] + all_feature_names
@@ -70,6 +71,7 @@
 CO_FUTURE_WITH_STATEMENT  = 0x8000   # with statement
 CO_FUTURE_PRINT_FUNCTION  = 0x10000   # print function
 CO_FUTURE_UNICODE_LITERALS = 0x20000 # unicode string literals
+CO_FUTURE_SHARED_MODULE   = 0x40000 # module shared between threads
 
 class _Feature:
     def __init__(self, optionalRelease, mandatoryRelease, compiler_flag):
@@ -126,3 +128,11 @@
 unicode_literals = _Feature((2, 6, 0, "alpha", 2),
                             (3, 0, 0, "alpha", 0),
                             CO_FUTURE_UNICODE_LITERALS)
+
+shared_module = _Feature((3, 1, 0, "alpha", 1),
+                          (4, 0, 0, "alpha", 0),
+                          CO_FUTURE_SHARED_MODULE)
+# To make _Feature shareable we'd need a __future__ import at the top of
+# this file.  However, we can't do that as we haven't defined the
+# features yet.  Doh!
+shared_module = '__future__.shared_module XXX FIXME'

=== modified file 'Lib/_weakrefset.py'
--- Lib/_weakrefset.py	2008-02-05 00:20:01 +0000
+++ Lib/_weakrefset.py	2008-03-24 04:28:04 +0000
@@ -1,12 +1,203 @@
+from __future__ import shared_module
+
 # Access WeakSet through the weakref module.
 # This code is separated-out because it is needed
 # by abc.py to load everything else at startup.
 
-from _weakref import ref
-
-__all__ = ['WeakSet']
+from _weakref import ref, DeathQueueType
+from threadtools import Monitor, MonitorMeta
+
+__all__ = ('WeakSet',)
+
+
+class BypassCallMeta(MonitorMeta):
+    __shared__ = True
+
+    def __call__(self, *args, **kwargs):
+        # We bypass MonitorMeta.__call__, so that no MonitorSpace is
+        # created.  This is perverse, but it works.
+        return type.__call__(self, *args, **kwargs)
+
 
 class WeakSet:
+    __shared__ = True
+
+    def __init__(self, data=None):
+        self._deathqueue = DeathQueueType()
+        self._data = {}
+        if data is not None:
+            self.update(data)
+
+    def _checkdeathqueue(self):
+        while self._deathqueue:
+            entry = self._deathqueue.pop()
+            tmp = self._data.pop(entry)
+            assert entry is tmp
+
+    def __iter__(self):
+        self._checkdeathqueue()
+        for entry in self._data:
+            item = entry.ref()
+            if item is not None:
+                yield item
+
+    def __contains__(self, item):
+        self._checkdeathqueue()
+        return _Entry(item) in self._data
+
+    def __reduce__(self):
+        d = getattr(self, '__dict__', {})
+        d.pop('_data', None)
+        d.pop('_deathqueue', None)
+        return (self.__class__, (list(self),), d)
+
+    def add(self, item):
+        olditem = self.intern(item)
+        if olditem is not item:
+            raise ValueError("WeakSet.add requires equal items to have the same identity")
+
+    def intern(self, item):
+        self._checkdeathqueue()
+        entry = _Entry(item)
+
+        try:
+            oldentry = self._data[entry]
+        except KeyError:
+            pass
+        else:
+            olditem = oldentry.ref()
+            if olditem is None:
+                del self._data[oldentry]
+                self._deathqueue.cancel(oldentry.handle)
+            else:
+                return olditem
+
+        entry.handle = self._deathqueue.watch(item, entry)
+        self._data[entry] = entry
+        return item
+
+    def clear(self):
+        try:
+            while True:
+                self.pop()
+        except KeyError:
+            pass
+
+    def copy(self):
+        return self.__class__(self)
+
+    def pop(self):
+        self._checkdeathqueue()
+        while True:
+            entry = self._data.pop()
+            item = entry.ref()
+            if item is None:
+                self._deathqueue.cancel(entry.handle)
+            else:
+                return item
+
+    def remove(self, item):
+        self._checkdeathqueue()
+        entry = self._data[_Entry(item)]
+        del self._data[entry]
+        self._deathqueue.cancel(entry.handle)
+
+    def discard(self, item):
+        try:
+            self.remove(item)
+        except KeyError:
+            pass
+
+    def update(self, other):
+        for item in other:
+            self.add(item)
+
+    def __ior__(self, other):
+        self.update(other)
+        return self
+
+    def _proxy_set(methname):
+        method = getattr(set, methname)
+        def func(self, other):
+            return self.__class__(method(set(self), other))
+        func.func_name = methname
+        return func
+
+    def _proxy_set_mutate(methname):
+        method = getattr(set, methname)
+        def func(self, other):
+            s = set(self)
+            method(s, other)
+            self.clear()
+            self.update(s)
+        func.func_name = methname
+        return func
+
+    def _proxy_set_mutateoper(methname):
+        method = getattr(set, methname)
+        def func(self, other):
+            s = set(self)
+            method(s, other)
+            self.clear()
+            self.update(s)
+            return self
+        func.func_name = methname
+        return func
+
+    difference = _proxy_set('difference')
+    intersection = _proxy_set('intersection')
+    issubset = _proxy_set('issubset')
+    issuperset = _proxy_set('issuperset')
+    symmetric_difference = _proxy_set('symmetric_difference')
+    union = _proxy_set('union')
+    difference_update = _proxy_set_mutate('difference_update')
+    intersection_update = _proxy_set_mutate('intersection_update')
+    symmetric_difference_update = _proxy_set_mutate('symmetric_difference_update')
+    __sub__ = _proxy_set('__sub__')
+    __and__ = _proxy_set('__and__')
+    __lt__ = _proxy_set('__lt__')
+    __gt__ = _proxy_set('__gt__')
+    __xor__ = _proxy_set('__xor__')
+    __or__ = _proxy_set('__or__')
+    __isub__ = _proxy_set_mutateoper('__isub__')
+    __iand__ = _proxy_set_mutateoper('__iand__')
+    __ixor__ = _proxy_set_mutateoper('__ixor__')
+
+    del _proxy_set, _proxy_set_mutate, _proxy_set_mutateoper
+
+
+class _Entry(Monitor, metaclass=BypassCallMeta):
+    __slots__ = 'ref', 'handle', 'hash'
+    __shared__ = True
+
+    def __init__(self, item):
+        self.ref = ref(item)
+        self.hash = hash(item)
+
+    def __hash__(self):
+        return self.hash
+
+    def __eq__(self, other):
+        if not isinstance(other, _Entry):
+            return NotImplemented
+
+        # We guarantee a _Entry always compares equal to itself, even if
+        # the weakref has been cleared.
+        if self is other:
+            return True
+
+        # If it's a different _Entry then we compare objects, defaulting
+        # to False if either of them have been cleared.
+        self_item = self.ref()
+        other_item = other.ref()
+        if self_item is None or other_item is None:
+            return False
+        return self_item == other_item
+
+
+class WeakSetOld:
+    __shared__ = True
+
     def __init__(self, data=None):
         self.data = set()
         def _remove(item, selfref=ref(self)):

=== modified file 'Lib/abc.py'
--- Lib/abc.py	2008-02-28 12:27:11 +0000
+++ Lib/abc.py	2008-03-24 04:28:04 +0000
@@ -67,7 +67,8 @@
     even via super()).
 
     """
-
+    # XXX GIANT FREAKIN' BODGE!
+    '''
     # A global counter that is incremented each time a class is
     # registered as a virtual subclass of anything.  It forces the
     # negative cache to be cleared before its next use.
@@ -169,3 +170,6 @@
         # No dice; update negative cache
         cls._abc_negative_cache.add(subclass)
         return False
+    '''
+    def register(self, subclass):
+        pass

=== modified file 'Lib/ctypes/__init__.py'
--- Lib/ctypes/__init__.py	2008-03-16 00:07:10 +0000
+++ Lib/ctypes/__init__.py	2008-04-11 02:07:06 +0000
@@ -483,7 +483,7 @@
 def cast(obj, typ):
     return _cast(obj, obj, typ)
 
-_string_at = CFUNCTYPE(py_object, c_void_p, c_int)(_string_at_addr)
+_string_at = PYFUNCTYPE(py_object, c_void_p, c_int)(_string_at_addr)
 def string_at(ptr, size=-1):
     """string_at(addr[, size]) -> string
 
@@ -495,7 +495,7 @@
 except ImportError:
     pass
 else:
-    _wstring_at = CFUNCTYPE(py_object, c_void_p, c_int)(_wstring_at_addr)
+    _wstring_at = PYFUNCTYPE(py_object, c_void_p, c_int)(_wstring_at_addr)
     def wstring_at(ptr, size=-1):
         """wstring_at(addr[, size]) -> string
 
@@ -538,4 +538,6 @@
 # function is needed for the unittests on Win64 to succeed.  This MAY
 # be a compiler bug, since the problem occurs only when _ctypes is
 # compiled with the MS SDK compiler.  Or an uninitialized variable?
+# XXX This is itself broken.  If it were ever called it'd have to be
+# a PYFUNCTYPE, not a CFUNCTYPE
 CFUNCTYPE(c_int)(lambda: None)

=== modified file 'Lib/distutils/spawn.py'
--- Lib/distutils/spawn.py	2008-01-06 21:13:42 +0000
+++ Lib/distutils/spawn.py	2008-03-24 04:28:04 +0000
@@ -28,7 +28,9 @@
     return on success.
     """
     if os.name == 'posix':
-        _spawn_posix(cmd, search_path, dry_run=dry_run)
+        #_spawn_posix(cmd, search_path, dry_run=dry_run)
+        # XXX FIXME bodge
+        _spawn_nt(cmd, search_path, dry_run=dry_run)
     elif os.name == 'nt':
         _spawn_nt(cmd, search_path, dry_run=dry_run)
     elif os.name == 'os2':

=== modified file 'Lib/site.py'
--- Lib/site.py	2008-01-23 08:24:23 +0000
+++ Lib/site.py	2008-03-24 04:28:04 +0000
@@ -51,10 +51,12 @@
 ImportError exception, it is silently ignored.
 
 """
+from __future__ import shared_module
 
 import sys
 import os
 import builtins
+from threadtools import Monitor, monitormethod
 
 
 def makepath(*paths):
@@ -234,11 +236,14 @@
     else:
         eof = 'Ctrl-D (i.e. EOF)'
 
-    class Quitter(object):
-        def __init__(self, name):
+    class Quitter(Monitor):
+        __shared__ = True
+        def __init__(self, name, eof):
             self.name = name
+            self.eof = eof
+        @monitormethod
         def __repr__(self):
-            return 'Use %s() or %s to exit' % (self.name, eof)
+            return 'Use %s() or %s to exit' % (self.name, self.eof)
         def __call__(self, code=None):
             # Shells like IDLE catch the SystemExit, but listen when their
             # stdin wrapper is closed.
@@ -252,13 +257,14 @@
             except:
                 pass
             raise SystemExit(code)
-    builtins.quit = Quitter('quit')
-    builtins.exit = Quitter('exit')
-
-
-class _Printer(object):
+    builtins.quit = Quitter('quit', eof)
+    builtins.exit = Quitter('exit', eof)
+
+
+class _Printer(Monitor):
     """interactive prompt objects for printing the license text, a list of
     contributors and the copyright notice."""
+    __shared__ = True
 
     MAXLINES = 23
 
@@ -290,6 +296,7 @@
         self.__lines = data.split('\n')
         self.__linecnt = len(self.__lines)
 
+    @monitormethod
     def __repr__(self):
         self.__setup()
         if len(self.__lines) <= self.MAXLINES:
@@ -297,6 +304,7 @@
         else:
             return "Type %s() to see the full %s text" % ((self.__name,)*2)
 
+    @monitormethod
     def __call__(self):
         self.__setup()
         prompt = 'Hit Return for more, or q (and Return) to quit: '
@@ -331,15 +339,16 @@
     here = os.path.dirname(os.__file__)
     builtins.license = _Printer(
         "license", "See http://www.python.org/%.3s/license.html" % sys.version,
-        ["LICENSE.txt", "LICENSE"],
-        [os.path.join(here, os.pardir), here, os.curdir])
-
-
-class _Helper(object):
+        ("LICENSE.txt", "LICENSE"),
+        (os.path.join(here, os.pardir), here, os.curdir))
+
+
+class _Helper(Monitor):
     """Define the built-in 'help'.
     This is a wrapper around pydoc.help (with a twist).
 
     """
+    __shared__ = True
 
     def __repr__(self):
         return "Type help() for interactive help, " \

=== modified file 'Lib/test/pystone.py'
--- Lib/test/pystone.py	2007-08-12 07:02:50 +0000
+++ Lib/test/pystone.py	2008-03-24 04:28:04 +0000
@@ -128,6 +128,8 @@
         IntLoc1 = Proc2(IntLoc1)
 
     benchtime = clock() - starttime - nulltime
+    if benchtime < 0.0001:
+        benchtime = 0.0001
     return benchtime, (loops / benchtime)
 
 def Proc1(PtrParIn):

=== added file 'Lib/test/sharedmodule.py'
--- Lib/test/sharedmodule.py	1970-01-01 00:00:00 +0000
+++ Lib/test/sharedmodule.py	2008-04-08 22:27:21 +0000
@@ -0,0 +1,136 @@
+# WTF.  If my __future__ import is on the first line it gets ignored?!
+from __future__ import shared_module
+
+from threadtools import monitormethod, Monitor, branch, condition, wait
+from operator import isShareable
+from time import sleep
+a = 42
+
+def safesharedfunc():
+    return a
+
+def sharedfunc():
+    raise ValueError('moo')
+
+def readloop():
+    with open('/dev/zero', 'rb') as f:
+        while f.read(1024):
+            pass
+
+
+class SharedClass:
+    __shared__=True
+
+    @staticmethod
+    def sharedstaticmethod():
+        return a
+
+    @classmethod
+    def sharedclassmethod(cls):
+        return cls
+
+    def normalmethod(self):
+        pass
+
+
+class MyMonitor(Monitor):
+    __shared__ = True
+    __slots__ = 'hello', '__dict__'
+
+    def __init__(self):
+        self.hello = 'world'
+
+    @monitormethod
+    def foo(self):
+        return 'pink'
+
+    def bar(self):
+        return 'purple'
+
+    @monitormethod
+    def wait_test_child(self, cp_A, cp_B):
+        def outside(cp_A, cp_B):
+            cp_A.set()
+            cp_B.wait()
+        wait(self, outside, cp_A, cp_B)
+
+    baz = monitormethod(bar)
+
+
+class Counter(Monitor):
+    __shared__ = True
+
+    def __init__(self, highwatermark=1000):
+        self.count = 0
+        self.highwatermark = highwatermark
+
+    @monitormethod
+    def tick(self):
+        self.count += 1
+
+    @monitormethod
+    def value(self):
+        return self.count
+
+    @condition
+    def high(self):
+        return self.count >= self.highwatermark
+
+    @monitormethod
+    def wait_for_high(self):
+        wait(self.high)
+
+
+class Checkpoint(Monitor):
+    __shared__ = True
+
+    def __init__(self):
+        self.value = 0;
+
+    @monitormethod
+    def set(self):
+        self.value = 1
+
+    @condition
+    def finished(self):
+        return self.value
+
+    @monitormethod
+    def wait(self):
+        wait(self.finished)
+
+
+class Finalizable(Monitor):
+    __shared__ = True
+    __finalizeattrs__ = 'counter'
+
+    def __init__(self, counter):
+        self.counter = counter
+
+    @monitormethod
+    def __finalize__(self):
+        super().__finalize__()
+        self.counter.tick()
+
+
+class Deadlocker(Monitor):
+    __shared__ = True
+
+    @monitormethod
+    def chain(self, func, *args, **kwargs):
+        func(*args, **kwargs)
+
+    @monitormethod
+    def pair_outer(self, m, cp_A, cp_B):
+        cp_A.set()
+        cp_B.wait()
+        m.pair_inner()
+
+    @monitormethod
+    def pair_inner(self):
+        readloop()
+
+    @monitormethod
+    def through_branch(self):
+        with branch() as children:
+            children.add(self.chain, sleep, 0)

=== modified file 'Lib/test/test_dict.py'
--- Lib/test/test_dict.py	2008-03-18 15:15:01 +0000
+++ Lib/test/test_dict.py	2008-04-11 02:07:08 +0000
@@ -10,6 +10,7 @@
         # calling built-in types without argument must return empty
         self.assertEqual(dict(), {})
         self.assert_(dict() is not {})
+        self.assertRaises(TypeError, dict, {'a': 7}, {'a': 42})
 
     def test_literal_constructor(self):
         # check literal constructor for different sized dicts (to exercise the BUILD_MAP oparg

=== modified file 'Lib/test/test_gc.py'
--- Lib/test/test_gc.py	2008-02-16 07:38:31 +0000
+++ Lib/test/test_gc.py	2008-03-24 04:28:04 +0000
@@ -299,6 +299,16 @@
                 v = {1: v, 2: Ouch()}
         gc.disable()
 
+    def test_trashcan_clear(self):
+        # Make sure that, if the trashcan is utilized during the
+        # clearing phase, it performs well
+        t = l = []
+        for i in range(100000):
+            t = (t,)
+        l.append(t)
+        del t, l
+        gc.collect()
+
     def test_boom(self):
         class Boom:
             def __getattr__(self, someattribute):

=== added file 'Lib/test/test_sharedmodule.py'
--- Lib/test/test_sharedmodule.py	1970-01-01 00:00:00 +0000
+++ Lib/test/test_sharedmodule.py	2008-04-11 03:26:25 +0000
@@ -0,0 +1,346 @@
+import sys
+import unittest
+from contextlib import contextmanager
+from time import sleep, time
+from test import test_support
+
+from test import sharedmodule
+import threadtools
+
+sharedmoduletest = """
+>>> from test import sharedmodule
+>>> import operator, threadtools
+>>> from time import sleep
+
+>>> operator.isShareable(sharedmodule)
+True
+>>> type(sharedmodule.__dict__)
+<class 'shareddict'>
+>>> sharedmodule.a
+42
+
+>>> sharedmodule.SharedClass.sharedstaticmethod()
+42
+>>> sharedmodule.SharedClass.sharedclassmethod()
+<class 'test.sharedmodule.SharedClass'>
+
+>>> sharedmodule.purple = []
+Traceback (most recent call last):
+  ...
+TypeError: shareddict value must be shareable, 'list' object is not
+
+
+>>> m = sharedmodule.MyMonitor()
+>>> m.foo()
+'pink'
+>>> m.bar()
+'purple'
+>>> m.baz()
+'purple'
+
+>>> operator.isShareable(threadtools.Monitor)
+True
+>>> operator.isShareable(sharedmodule.MyMonitor)
+True
+>>> operator.isShareable(threadtools.Monitor())
+True
+>>> operator.isShareable(m)
+True
+>>> operator.isShareable(m.foo)
+True
+>>> operator.isShareable(m.bar)
+True
+>>> operator.isShareable(sharedmodule.MyMonitor.bar)
+True
+>>> operator.isShareable(sharedmodule.MyMonitor.__dict__['bar'])
+True
+
+>>> m.hello
+Traceback (most recent call last):
+  ...
+AttributeError: hello
+>>> m.__monitorspace__.enter(getattr, m, 'hello')
+'world'
+>>> m.plumage = 'green'
+Traceback (most recent call last):
+  ...
+AttributeError: 'MyMonitor' object has no attribute 'plumage'
+>>> m.__monitorspace__.enter(setattr, m, 'plumage', 'orange')
+>>> m.plumage
+Traceback (most recent call last):
+  ...
+AttributeError: 'MyMonitor' object has no attribute 'plumage'
+>>> m.__monitorspace__.enter(getattr, m, 'plumage')
+'orange'
+
+
+>>> with threadtools.branch() as children:
+...     children.add(sharedmodule.safesharedfunc)
+>>> children.getresults()
+[]
+
+>>> with threadtools.branch() as children:
+...     children.addresult(sharedmodule.safesharedfunc)
+>>> children.getresults()
+[42]
+>>> children.getresults()
+[]
+
+>>> with threadtools.branch() as children:
+...     children.add(sharedmodule.sharedfunc)
+Traceback (most recent call last):
+  ...
+ValueError: moo
+>>> children.getresults()
+[]
+
+>>> with threadtools.branch() as children:
+...     children.addresult(sharedmodule.sharedfunc)
+Traceback (most recent call last):
+  ...
+ValueError: moo
+>>> children.getresults()
+[]
+
+>>> with threadtools.branch() as children:
+...     1/0
+Traceback (most recent call last):
+  ...
+ZeroDivisionError: int division or modulo by zero
+>>> children.getresults()
+[]
+
+
+>>> with threadtools.branch() as children:
+...     children.addresult(m.foo)
+...     children.addresult(m.bar)
+...     children.addresult(m.baz)
+>>> children.getresults()
+['pink', 'purple', 'purple']
+
+>>> counter = sharedmodule.Counter()
+>>> for i in range(10):
+...     counter.tick()
+>>> counter.value()
+10
+>>> with threadtools.branch() as children:
+...     for i in range(15):
+...         children.add(counter.tick)
+>>> counter.value()
+25
+
+#>>> with threadtools.branch() as children:
+#...     for i in range(10000):  # XXX arbitrary value.  Probably should be much higher
+#...         children.add(sleep, 1)
+#Traceback (most recent call last):
+#  ...
+#RuntimeError: branch.add can't spawn new thread
+
+"""
+
+
+@contextmanager
+def no_deadlock_delay():
+    old_delay = sys.getdeadlockdelay()
+    sys.setdeadlockdelay(0)
+    try:
+        yield
+    finally:
+        sys.setdeadlockdelay(old_delay)
+
+
+class BranchTests(unittest.TestCase):
+    def assertRaisesCause(self, excClass, excCause, func, *args, **kwargs):
+        try:
+            func(*args, **kwargs)
+        except excClass as e:
+            if not isinstance(excCause, tuple):
+                excCause = (excCause,)
+            cause = e.__cause__
+            if not isinstance(cause, tuple):
+                cause = (cause,)
+
+            if len(excCause) != len(cause):
+                raise
+            for c, t in zip(cause, excCause):
+                if not isinstance(c, t):
+                    raise
+
+            return
+
+        excName = str(getattr(excClass, '__name__', excClass))
+        objName = str(getattr(callableObj, '__name__', callableObj))
+        raise self.failureException("%s(%s) not raised by %s" % (excName,
+            excCause, objName))
+
+    def test_main_and_child(self):
+        def x():
+            with threadtools.branch() as children:
+                children.addresult(sharedmodule.sharedfunc)
+                1/0
+        self.assertRaisesCause(MultipleError, (ZeroDivisionError, ValueError), x)
+
+    def test_multiple_child(self):
+        def x():
+            with threadtools.branch() as children:
+                children.addresult(sharedmodule.sharedfunc)
+                children.addresult(sharedmodule.sharedfunc)
+                children.addresult(sharedmodule.sharedfunc)
+        self.assertRaisesCause(MultipleError, (ValueError, ValueError, ValueError), x)
+
+    def test_main_and_cancelled_child(self):
+        def x():
+            with threadtools.branch() as children:
+                children.add(sharedmodule.readloop)
+                1/0
+        self.assertRaisesCause(ZeroDivisionError, (ZeroDivisionError, Cancelled), x)
+
+    def test_nested_branch_failing_outer(self):
+        def x():
+            with threadtools.branch() as outer:
+                with threadtools.branch() as inner:
+                    inner.add(sharedmodule.readloop)
+                    outer.add(sharedmodule.sharedfunc)
+        self.assertRaisesCause(ValueError, (Cancelled, ValueError), x)
+
+    def test_nested_branch_failing_outer_direct(self):
+        def x():
+            with threadtools.branch() as outer:
+                with threadtools.branch() as inner:
+                    outer.add(sharedmodule.sharedfunc)
+                    sharedmodule.readloop()
+        self.assertRaisesCause(ValueError, (Cancelled, ValueError), x)
+
+    def test_cancelled_sleep(self):
+        def x():
+            with threadtools.branch() as children:
+                children.add(sleep, 60)
+                1/0
+        starttime = time()
+        self.assertRaisesCause(ZeroDivisionError, (ZeroDivisionError, Cancelled), x)
+        endtime = time()
+        self.assert_(endtime - starttime < 5.0)
+
+
+class MonitorTests(unittest.TestCase):
+    def test_condition_wait(self):
+        c = sharedmodule.Counter(10)
+
+        with threadtools.branch() as children:
+            for i in range(10):
+                children.add(c.tick)
+            c.wait_for_high()
+            self.assert_(c.value() == 10)
+
+    def test_monitor_wait(self):
+        m = sharedmodule.MyMonitor()
+        cp_A = sharedmodule.Checkpoint()
+        cp_B = sharedmodule.Checkpoint()
+
+        with threadtools.branch() as children:
+            children.add(m.wait_test_child, cp_A, cp_B)
+            cp_A.wait()
+            m.foo()
+            cp_B.set()
+
+    def test_condition_cancellation(self):
+        def x():
+            cp = sharedmodule.Checkpoint()
+
+            with threadtools.branch() as children:
+                children.add(cp.wait)
+                1/0
+        self.assertRaises(ZeroDivisionError, x)
+
+
+class FinalizeTests(unittest.TestCase):
+    def test_activates(self):
+        counter = sharedmodule.Counter()
+        obj = sharedmodule.Finalizable(counter)
+        del obj
+
+        # We want to wait long enough for this test to complete, but we
+        # also don't want to expand every test run by 5 seconds.  A
+        # polling sleep loop suffices.
+        for i in range(50):
+            if counter.value():
+                break
+            sleep(0.1)
+        else:
+            self.fail("__finalize__ never ran")
+
+    def test_manual(self):
+        # If __finalize__ gets called again by the finalizer thread it
+        # will abort everything with an AttributeError
+        def x():
+            obj = sharedmodule.Finalizable(None)
+            obj.__finalize__()
+        self.assertRaises(AttributeError, x)
+
+
+class DeadlockTests(unittest.TestCase):
+    def assertRaisesCause(self, excClass, excCause, func, *args, **kwargs):
+        try:
+            func(*args, **kwargs)
+        except excClass as e:
+            if not isinstance(excCause, tuple):
+                excCause = (excCause,)
+            cause = e.__cause__
+            if not isinstance(cause, tuple):
+                cause = (cause,)
+
+            if len(excCause) != len(cause):
+                raise
+            for c, t in zip(cause, excCause):
+                if not isinstance(c, t):
+                    raise
+
+            return
+
+        excName = str(getattr(excClass, '__name__', excClass))
+        objName = str(getattr(callableObj, '__name__', callableObj))
+        raise self.failureException("%s(%s) not raised by %s" % (excName,
+            excCause, objName))
+
+    def test_direct_self_nondeadlock(self):
+        # Calling directly into ourself shouldn't deadlock
+        d = sharedmodule.Deadlocker()
+        d.chain(d.chain, sleep, 0)
+
+    def test_indirect_self_deadlock(self):
+        # Calling into another monitor, then having them call back into
+        # us, should deadlock
+        d1 = sharedmodule.Deadlocker()
+        d2 = sharedmodule.Deadlocker()
+        with no_deadlock_delay():
+            self.assertRaises(SoftDeadlockError, d1.chain, d2.chain, d1.chain, sleep, 0)
+
+    def test_paired_deadlock(self):
+        # Two threads, each with their own monitor, calling into each other
+        def x():
+            a = sharedmodule.Deadlocker()
+            b = sharedmodule.Deadlocker()
+            cp_A = sharedmodule.Checkpoint()
+            cp_B = sharedmodule.Checkpoint()
+            with threadtools.branch() as children:
+                children.add(a.pair_outer, b, cp_A, cp_B)
+                children.add(b.pair_outer, a, cp_B, cp_A)
+        with no_deadlock_delay():
+            self.assertRaises(SoftDeadlockError, x)
+
+    def test_branched_deadlock(self):
+        d = sharedmodule.Deadlocker()
+        with no_deadlock_delay():
+            self.assertRaises(SoftDeadlockError, d.through_branch)
+
+
+__test__ = {'sharedmoduletest' : sharedmoduletest}
+
+def test_main(verbose=None):
+    from test import test_sharedmodule
+    test_support.run_doctest(test_sharedmodule, verbose)
+    test_support.run_unittest(BranchTests, MonitorTests, FinalizeTests, DeadlockTests)
+
+
+if __name__ == "__main__":
+    test_main(verbose=True)

=== modified file 'Lib/test/test_weakref.py'
--- Lib/test/test_weakref.py	2008-02-12 20:03:09 +0000
+++ Lib/test/test_weakref.py	2008-04-10 21:12:22 +0000
@@ -189,7 +189,7 @@
     # they are active.  In Python 2.3.3 and earlier, this guarantee
     # was not honored, and was broken in different ways for
     # PyWeakref_NewRef() and PyWeakref_NewProxy().  (Two tests.)
-
+    """
     def test_shared_ref_without_callback(self):
         self.check_shared_without_callback(weakref.ref)
 
@@ -213,7 +213,7 @@
         p1 = makeref(o, None)
         p2 = makeref(o)
         self.assert_(p1 is p2, "callbacks were None, NULL in the C API")
-
+"""
     def test_callable_proxy(self):
         o = Callable()
         ref1 = weakref.proxy(o)
@@ -728,7 +728,7 @@
         #
         dict, objects = self.make_weak_valued_dict()
         for o in objects:
-            self.assertEqual(weakref.getweakrefcount(o), 1)
+            #self.assertEqual(weakref.getweakrefcount(o), 1)
             self.assert_(o is dict[o.arg],
                          "wrong object returned by weak dict!")
         items1 = dict.items()
@@ -758,8 +758,8 @@
         #
         dict, objects = self.make_weak_keyed_dict()
         for o in objects:
-            self.assert_(weakref.getweakrefcount(o) == 1,
-                         "wrong number of weak references to %r!" % o)
+            #self.assert_(weakref.getweakrefcount(o) == 1,
+            #             "wrong number of weak references to %r!" % o)
             self.assert_(o.arg is dict[o],
                          "wrong object returned by weak dict!")
         items1 = dict.items()
@@ -777,7 +777,8 @@
         o = Object(42)
         dict[o] = "What is the meaning of the universe?"
         self.assert_(o in dict)
-        self.assert_(34 not in dict)
+        #self.assert_(34 not in dict)
+        self.assert_(Object(34) not in dict)
 
     def test_weak_keyed_iters(self):
         dict, objects = self.make_weak_keyed_dict()
@@ -842,6 +843,10 @@
         keys = list(dict.keys())
         for k in dict:
             keys.remove(k)
+        print(dict)
+        print(keys)
+        print(dict.keys())
+        print(list(dict))
         self.assert_(len(keys) == 0, "__iter__() did not touch all keys")
 
         # key iterator, via iterkeys():
@@ -971,7 +976,8 @@
         self.assertEqual(len(d), 2)
         del d[o1]
         self.assertEqual(len(d), 1)
-        self.assertEqual(d.keys(), [o2])
+        #self.assertEqual(d.keys(), [o2])
+        self.assertEqual(d.keys(), {o2})
 
     def test_weak_valued_delitem(self):
         d = weakref.WeakValueDictionary()
@@ -1043,6 +1049,16 @@
         self.assertEqual(len(d), 0)
         self.assertEqual(count, 2)
 
+    def test_weak_keyed_cycle(self):
+        # Test if a cycle from the value back to the key is collected
+        pass
+        o = Object(42)
+        o.loop = o
+        dict = weakref.WeakKeyDictionary({o:o})
+        del o
+        gc.collect()
+        self.assertEqual(len(dict), 0)
+
 from test import mapping_tests
 
 class WeakValueDictionaryTestCase(mapping_tests.BasicTestMappingProtocol):

=== added file 'Lib/test/thread_pystone.py'
--- Lib/test/thread_pystone.py	1970-01-01 00:00:00 +0000
+++ Lib/test/thread_pystone.py	2008-03-24 04:28:04 +0000
@@ -0,0 +1,151 @@
+#!/usr/bin/env python
+
+"""
+Threaded wrapper for pystone
+"""
+
+from __future__ import shared_module
+
+import sys
+from threadtools import Monitor, monitormethod, branch
+from test.pystone import LOOPS
+from test.pystone import __file__ as pystone_filename
+
+if pystone_filename.endswith('.pyc'):
+    pystone_filename = pystone_filename[:-1]
+
+__version__ = "0.1"
+
+
+TRUE = 1
+
+class Foo:
+    __shared__ = True
+
+class WrappedPystone(Monitor):
+    __shared__ = True
+
+    def __init__(self):
+        #self.globals = {}
+        #with open(pystone_filename, 'r') as f:
+        #    exec(f.read(), self.globals)
+        if 'test.pystone' in sys.modules:
+            del sys.modules['test.pystone']
+        import test.pystone
+        self.globals = test.pystone.__dict__
+        self.mod = test.pystone  # Needed to keep globals alive
+        del sys.modules['test.pystone']
+        pass
+
+    @monitormethod
+    def printfunc(self):
+        print(self.globals['Proc0'])
+
+    def x(self):
+        pass
+
+    @monitormethod
+    def run(self, loops):
+        self.globals['Proc0'](loops)
+        #for i in range(loops):
+            #Foo()
+            #self.globals['Func3'](self.globals['Ident1'])
+            #self.globals['Proc5']()
+            #self.x()
+            #x = []*5000
+            #IntLoc1 = 2
+            #IntLoc2 = 3
+            #while IntLoc1 < IntLoc2:
+            #    IntLoc3 = 5 * IntLoc1 - IntLoc2
+            #    IntLoc3 = self.globals['Proc7'](IntLoc1, IntLoc2)
+            #    IntLoc1 = IntLoc1 + 1
+            #self.globals['Proc8'](self.globals['Array1Glob'], self.globals['Array2Glob'], IntLoc1, IntLoc3)
+
+    def run_external(self, loops):
+        #self.globals['Proc0'](loops)
+        for i in range(loops):
+            #self.globals['Func3'](self.globals['Ident1'])
+            #self.globals['Proc5']()
+            self.x()
+
+def x(loops):
+    n = 1.0
+    for i in fakerange(loops):
+        y()
+        1.0+n
+        pass
+
+def y():
+    pass
+
+
+def main(threads, loops):
+    # WEEEEE!  clock behaves differently for threads!
+    from time import clock  # XXX workaround for clock not being shareable
+    from time import time
+
+    mods = [WrappedPystone() for i in range(threads)]
+    #mods = list(range(threads))
+
+    #starttime = clock()
+    #for i in range(loops):
+    #    pass
+    #nulltime = clock() - starttime
+
+    starttime = clock()
+    starttime2 = time()
+
+    with branch() as jobs:
+        for mod in mods:
+            jobs.add(mod.run, loops)
+            #jobs.add(x, loops)
+
+    #benchtime = clock() - starttime - nulltime
+    benchtime = clock() - starttime
+    benchtime2 = time() - starttime2
+    if benchtime < 0.0001:
+        benchtime = 0.0001
+    stones = (threads * loops) / benchtime2
+
+    #results = jobs.getresults()
+    ## Crude hack!
+    #results = [eval(result) for result in results]
+    #results = [benchtime for benchtime, stones in results]
+    #print(results)
+    #print(benchtime)
+    #print(stones)
+
+    print("Thread-Pystone(%s) time for %d*%d passes = %g" % \
+          (__version__, threads, loops, benchtime2))
+    print("This machine benchmarks at %g pystones/second" % stones)
+    #print(starttime, benchtime)
+    #print(starttime2, benchtime2)
+
+
+if __name__ == '__main__':
+    import sys
+    def error(msg):
+        print(msg, end=' ', file=sys.stderr)
+        print("usage: %s number_of_threads [number_of_loops]" % sys.argv[0], file=sys.stderr)
+        sys.exit(100)
+    nargs = len(sys.argv) - 1
+    if nargs > 2:
+        error("%d arguments are too many;" % nargs)
+    elif nargs < 1:
+        error("not enough arguments")
+
+    try:
+        threads = int(sys.argv[1])
+    except ValueError:
+        error("Invalid thread argument %r;" % sys.argv[1])
+
+    if nargs >= 2:
+        try:
+            loops = int(sys.argv[1])
+        except ValueError:
+            error("Invalid argument %r;" % sys.argv[1])
+    else:
+        loops = LOOPS
+
+    main(threads, loops)
+

=== added file 'Lib/test/trivialthreadbench.py'
--- Lib/test/trivialthreadbench.py	1970-01-01 00:00:00 +0000
+++ Lib/test/trivialthreadbench.py	2008-03-24 04:28:04 +0000
@@ -0,0 +1,23 @@
+#!/usr/bin/env python
+from __future__ import shared_module
+from threadtools import branch
+
+def runthread(start, count):
+    for i in range(start, start + count):
+        pass
+    return i
+
+def main(split, total=10**7):
+    if split:
+        chunk = total // split
+        print("Chunk of", chunk, "for", split, "threads.")
+        with branch() as workers:
+            for i in range(split):
+                workers.addresult(runthread, i * chunk, chunk)
+        print(workers.getresults())
+    else:
+        print("Running", total, "threadless.")
+        runthread(0, total)
+
+if __name__ == '__main__':
+    raise RuntimeError("trivialthreadbench must not be the __main__ module")

=== added file 'Lib/threadtools.py'
--- Lib/threadtools.py	1970-01-01 00:00:00 +0000
+++ Lib/threadtools.py	2008-03-31 18:00:03 +0000
@@ -0,0 +1,7 @@
+"""Tools for working with frozen objects and threads"""
+from __future__ import shared_module
+# To prevent users from doing "from threadtools import isShareable", we
+# use the full operator.isShareable() name
+#import operator
+from _threadtools import (Monitor, MonitorSpace, MonitorMeta, branch,
+    monitormethod, condition, wait)

=== modified file 'Lib/trace.py'
--- Lib/trace.py	2008-04-10 19:02:25 +0000
+++ Lib/trace.py	2008-04-11 02:07:06 +0000
@@ -52,7 +52,7 @@
 import os
 import re
 import sys
-import threading
+#import threading
 import time
 import token
 import tokenize
@@ -483,26 +483,26 @@
         dict = __main__.__dict__
         if not self.donothing:
             sys.settrace(self.globaltrace)
-            threading.settrace(self.globaltrace)
+            #threading.settrace(self.globaltrace)
         try:
             exec(cmd, dict, dict)
         finally:
             if not self.donothing:
                 sys.settrace(None)
-                threading.settrace(None)
+                #threading.settrace(None)
 
     def runctx(self, cmd, globals=None, locals=None):
         if globals is None: globals = {}
         if locals is None: locals = {}
         if not self.donothing:
             sys.settrace(self.globaltrace)
-            threading.settrace(self.globaltrace)
+            #threading.settrace(self.globaltrace)
         try:
             exec(cmd, globals, locals)
         finally:
             if not self.donothing:
                 sys.settrace(None)
-                threading.settrace(None)
+                #threading.settrace(None)
 
     def runfunc(self, func, *args, **kw):
         result = None

=== modified file 'Lib/unittest.py'
--- Lib/unittest.py	2008-01-30 02:55:10 +0000
+++ Lib/unittest.py	2008-04-10 20:58:20 +0000
@@ -679,6 +679,7 @@
         if self.showAll:
             self.stream.write(self.getDescription(test))
             self.stream.write(" ... ")
+            self.stream.flush()
 
     def addSuccess(self, test):
         TestResult.addSuccess(self, test)

=== modified file 'Lib/uu.py'
--- Lib/uu.py	2007-10-16 18:12:55 +0000
+++ Lib/uu.py	2008-03-24 04:28:04 +0000
@@ -58,10 +58,12 @@
     #
     # Open out_file if it is a pathname
     #
+    opened = False
     if out_file == '-':
         out_file = sys.stdout.buffer
     elif isinstance(out_file, str):
         out_file = open(out_file, 'wb')
+        opened = True
     #
     # Set defaults for name and mode
     #
@@ -78,6 +80,8 @@
         out_file.write(binascii.b2a_uu(data))
         data = in_file.read(45)
     out_file.write(b' \nend\n')
+    if opened:
+        out_file.close()
 
 
 def decode(in_file, out_file=None, mode=None, quiet=0):

=== modified file 'Lib/weakref.py'
--- Lib/weakref.py	2008-02-11 19:00:13 +0000
+++ Lib/weakref.py	2008-04-11 03:31:39 +0000
@@ -4,219 +4,149 @@
 
 http://python.sourceforge.net/peps/pep-0205.html
 """
+from __future__ import shared_module
+
+# XXX FIXME big freakin bug!  MutableMapping.update() does
+# "for key in other: self[key] = other[key]".  In the case of a
+# WeakValueDictionary, the key may be deleted before you have a chance
+# to use it.  Either MutableMapping.update() is wrong, or
+# WeakValueDictionary isn't a MutableMapping.  Why doesn't it try
+# .items() first?
 
 # Naming convention: Variables named "wr" are weak reference objects;
 # they are called this instead of "ref" to avoid name collisions with
 # the module-global ref() function imported from _weakref.
 
-import collections
-
-from _weakref import (
-     getweakrefcount,
-     getweakrefs,
-     ref,
-     proxy,
-     CallableProxyType,
-     ProxyType,
-     ReferenceType)
-
-from _weakrefset import WeakSet
-
-ProxyTypes = (ProxyType, CallableProxyType)
-
-__all__ = ["ref", "proxy", "getweakrefcount", "getweakrefs",
-           "WeakKeyDictionary", "ReferenceType", "ProxyType",
-           "CallableProxyType", "ProxyTypes", "WeakValueDictionary",
-           "WeakSet"]
-
-
-class WeakValueDictionary(collections.MutableMapping):
+import operator
+from collections import MutableMapping
+from threadtools import Monitor, MonitorMeta
+
+from _weakref import ref, bind, ReferenceType, DeathQueueType, WeakBindingType
+
+from _weakrefset import WeakSet, BypassCallMeta
+
+__all__ = ("ref", "bind", "proxy",
+           "ReferenceType", "WeakBindingType", "ProxyType",
+           "WeakKeyDictionary", "WeakValueDictionary", "WeakSet")
+
+
+class WeakValueDictionary(MutableMapping):
     """Mapping class that references values weakly.
 
     Entries in the dictionary will be discarded when no strong
-    reference to the value exists anymore
+    reference to the value exists anymore.
+
+    Discarding keys may be delayed until the dictionary is next used.
     """
+    __shared__ = True
     # We inherit the constructor without worrying about the input
-    # dictionary; since it uses our .update() method, we get the right
-    # checks (if the other dictionary is a WeakValueDictionary,
-    # objects are unwrapped on the way out, and we always wrap on the
-    # way in).
+    # dictionary; since it uses our __setitem__, we get the right checks
+    # (if the other dictionary is a WeakValueDictionary, objects are
+    # unwrapped on the way out, and we always wrap on the way in).
 
     def __init__(self, *args, **kw):
-        def remove(wr, selfref=ref(self)):
-            self = selfref()
-            if self is not None:
-                del self.data[wr.key]
-        self._remove = remove
-        self.data = d = {}
-        d.update(*args, **kw)
+        self._deathqueue = DeathQueueType()
+        self._data = {}
+        self.update(*args, **kw)
+
+    def _checkdeathqueue(self):
+        while self._deathqueue:
+            hrk = self._deathqueue.pop()
+            tmp = self._data.pop(hrk.key)
+            assert hrk is tmp
 
     def __getitem__(self, key):
-        o = self.data[key]()
+        self._checkdeathqueue()
+        o = self._data[key].ref()
         if o is None:
             raise KeyError(key)
         else:
             return o
 
+    def __setitem__(self, key, value):
+        self._checkdeathqueue()
+        if key in self._data:
+            self._deathqueue.cancel(self._data[key].handle)
+        hrk = _HandleRefKey(ref(value), key)
+        hrk.handle = self._deathqueue.watch(value, hrk)
+        self._data[key] = hrk
+
     def __delitem__(self, key):
-        del self.data[key]
+        self._checkdeathqueue()
+        hrk = self._data[key]
+        del self._data[key]
+        self._deathqueue.cancel(hrk.handle)
+
+    def __iter__(self):
+        for k in self.keys():
+            yield k
 
     def __len__(self):
-        return sum(wr() is not None for wr in self.data.values())
-
-    def __contains__(self, key):
-        try:
-            o = self.data[key]()
-        except KeyError:
-            return False
-        return o is not None
+        self._checkdeathqueue()
+        return len(self._data)
 
     def __repr__(self):
         return "<WeakValueDictionary at %s>" % id(self)
 
-    def __setitem__(self, key, value):
-        self.data[key] = KeyedRef(value, self._remove, key)
-
     def copy(self):
-        new = WeakValueDictionary()
-        for key, wr in self.data.items():
-            o = wr()
-            if o is not None:
-                new[key] = o
-        return new
+        # XXX Is this really important enough to provide?
+        return WeakValueDictionary(self.items())
 
-    def get(self, key, default=None):
-        try:
-            wr = self.data[key]
-        except KeyError:
-            return default
-        else:
-            o = wr()
-            if o is None:
-                # This should only happen
-                return default
-            else:
-                return o
+    def keys(self):
+        self._checkdeathqueue()
+        # Nearly any operation on us could potentially delete values and
+        # invalidate our iteration.  To be safe we always return a set,
+        # even though a real dict returns an iterator since 3.0.
+        return set(self._data.keys())
+    iterkeys = keys
 
     def items(self):
+        self._checkdeathqueue()
+        # Nearly any operation on us could potentially delete values and
+        # invalidate our iteration.  To be safe we always return a list,
+        # even though a real dict returns an iterator since 3.0.
         L = []
-        for key, wr in self.data.items():
-            o = wr()
+        for key, hrk in self._data.items():
+            o = hrk.ref()
             if o is not None:
                 L.append((key, o))
         return L
-
-    def iteritems(self):
-        for wr in self.data.values():
-            value = wr()
-            if value is not None:
-                yield wr.key, value
-
-    def iterkeys(self):
-        return iter(self.data.keys())
-
-    def __iter__(self):
-        return iter(self.data.keys())
-
-    def itervaluerefs(self):
-        """Return an iterator that yields the weak references to the values.
-
-        The references are not guaranteed to be 'live' at the time
-        they are used, so the result of calling the references needs
-        to be checked before being used.  This can be used to avoid
-        creating references that will cause the garbage collector to
-        keep the values around longer than needed.
-
-        """
-        return self.data.values()
-
-    def itervalues(self):
-        for wr in self.data.values():
-            obj = wr()
-            if obj is not None:
-                yield obj
+    iteritems = items
+
+    def values(self):
+        self._checkdeathqueue()
+        # Nearly any operation on us could potentially delete values and
+        # invalidate our iteration.  To be safe we always return a list,
+        # even though a real dict returns an iterator since 3.0.
+        L = []
+        for hrk in self._data.values():
+            o = hrk.ref()
+            if o is not None:
+                L.append(o)
+        return L
+    itervalues = values
 
     def popitem(self):
+        self._checkdeathqueue()
         while 1:
-            key, wr = self.data.popitem()
-            o = wr()
+            key, hrk = self._data.popitem()
+            o = hrk.ref()
+            self._deathqueue.cancel(hrk.handle)
             if o is not None:
                 return key, o
 
-    def pop(self, key, *args):
-        try:
-            o = self.data.pop(key)()
-        except KeyError:
-            if args:
-                return args[0]
-            raise
-        if o is None:
-            raise KeyError(key)
-        else:
-            return o
-
-    def setdefault(self, key, default=None):
-        try:
-            wr = self.data[key]
-        except KeyError:
-            self.data[key] = KeyedRef(default, self._remove, key)
-            return default
-        else:
-            return wr()
-
-    def update(self, dict=None, **kwargs):
-        d = self.data
-        if dict is not None:
-            if not hasattr(dict, "items"):
-                dict = type({})(dict)
-            for key, o in dict.items():
-                d[key] = KeyedRef(o, self._remove, key)
-        if len(kwargs):
-            self.update(kwargs)
-
-    def valuerefs(self):
-        """Return a list of weak references to the values.
-
-        The references are not guaranteed to be 'live' at the time
-        they are used, so the result of calling the references needs
-        to be checked before being used.  This can be used to avoid
-        creating references that will cause the garbage collector to
-        keep the values around longer than needed.
-
-        """
-        return self.data.values()
-
-    def values(self):
-        L = []
-        for wr in self.data.values():
-            o = wr()
-            if o is not None:
-                L.append(o)
-        return L
-
-
-class KeyedRef(ref):
-    """Specialized reference that includes a key corresponding to the value.
-
-    This is used in the WeakValueDictionary to avoid having to create
-    a function object for each key stored in the mapping.  A shared
-    callback object can use the 'key' attribute of a KeyedRef instead
-    of getting a reference to the key from an enclosing scope.
-
-    """
-
-    __slots__ = "key",
-
-    def __new__(type, ob, callback, key):
-        self = ref.__new__(type, ob, callback)
+
+class _HandleRefKey(Monitor, metaclass=BypassCallMeta):
+    __slots__ = "handle", "ref", "key"
+    __shared__ = True
+
+    def __init__(self, ref, key):
+        self.ref = ref
         self.key = key
-        return self
-
-    def __init__(self, ob, callback, key):
-        super().__init__(ob, callback)
-
-
-class WeakKeyDictionary(collections.MutableMapping):
+        # self.handle has to be filled in after
+
+
+class WeakKeyDictionary(MutableMapping):
     """ Mapping class that references keys weakly.
 
     Entries in the dictionary will be discarded when there is no
@@ -225,127 +155,225 @@
     an application without adding attributes to those objects. This
     can be especially useful with objects that override attribute
     accesses.
+
+    Keys are compared using identity (not value!)
+
+    Discarding values may be delayed until the dictionary is next used.
     """
-
-    def __init__(self, dict=None):
-        self.data = {}
-        def remove(k, selfref=ref(self)):
-            self = selfref()
-            if self is not None:
-                del self.data[k]
-        self._remove = remove
-        if dict is not None: self.update(dict)
+    __shared__ = True
+
+    def __init__(self, dict=None, **kwargs):
+        self._deathqueue = DeathQueueType()
+        self._data = {}
+        if dict is not None:
+            self.update(dict)
+        if kwargs:
+            self.update(kwargs)
+
+    def _checkdeathqueue(self):
+        while self._deathqueue:
+            wkhv = self._deathqueue.pop()
+            tmp = self._data.pop(wkhv)
+            assert wkhv is tmp
+
+    def __getitem__(self, key):
+        self._checkdeathqueue()
+        key, value = self._data[_WeakKeyHandleValue(key)].binding()
+        if key is None:
+            raise KeyError(key)
+        return value
+
+    def __setitem__(self, key, value):
+        self._checkdeathqueue()
+        wkhv = _WeakKeyHandleValue(key, value)
+        old_wkhv = self._data.get(wkhv, None)
+        if old_wkhv is not None:
+            del self._data[old_wkhv]
+            self._deathqueue.cancel(old_wkhv.handle)
+
+        wkhv.handle = self._deathqueue.watch(key, wkhv)
+        self._data[wkhv] = wkhv
 
     def __delitem__(self, key):
-        del self.data[ref(key)]
+        self._checkdeathqueue()
+        wkhv = self._data[_WeakKeyHandleValue(key)]
+        del self._data[wkhv]
+        self._deathqueue.cancel(wkhv.handle)
 
-    def __getitem__(self, key):
-        return self.data[ref(key)]
+    def __iter__(self):
+        for k in self.keys():
+            yield k
 
     def __len__(self):
-        return len(self.data)
+        self._checkdeathqueue()
+        return len(self._data)
 
     def __repr__(self):
         return "<WeakKeyDictionary at %s>" % id(self)
 
-    def __setitem__(self, key, value):
-        self.data[ref(key, self._remove)] = value
-
     def copy(self):
-        new = WeakKeyDictionary()
-        for key, value in self.data.items():
-            o = key()
-            if o is not None:
-                new[o] = value
-        return new
-
-    def get(self, key, default=None):
-        return self.data.get(ref(key),default)
-
-    def __contains__(self, key):
-        try:
-            wr = ref(key)
-        except TypeError:
-            return 0
-        return wr in self.data
+        # XXX Is this really important enough to provide?
+        return WeakKeyDictionary(self.items())
+
+    def keys(self):
+        self._checkdeathqueue()
+        # Nearly any operation on us could potentially delete keys and
+        # invalidate our iteration.  To be safe we always return a set,
+        # even though a real dict returns an iterator since 3.0.
+        s = set()
+        for wkhv in self._data:
+            key, value = wkhv.binding()
+            if key is not None:
+                s.add(key)
+        return s
+    iterkeys = keys
 
     def items(self):
-        L = []
-        for key, value in self.data.items():
-            o = key()
-            if o is not None:
-                L.append((o, value))
-        return L
-
-    def iteritems(self):
-        for wr, value in self.data.items():
-            key = wr()
-            if key is not None:
-                yield key, value
-
-    def iterkeyrefs(self):
-        """Return an iterator that yields the weak references to the keys.
-
-        The references are not guaranteed to be 'live' at the time
-        they are used, so the result of calling the references needs
-        to be checked before being used.  This can be used to avoid
-        creating references that will cause the garbage collector to
-        keep the keys around longer than needed.
-
-        """
-        return self.data.keys()
-
-    def iterkeys(self):
-        for wr in self.data.keys():
-            obj = wr()
-            if obj is not None:
-                yield obj
-
-    def __iter__(self):
-        return iter(self.keys())
-
-    def itervalues(self):
-        return iter(self.data.values())
-
-    def keyrefs(self):
-        """Return a list of weak references to the keys.
-
-        The references are not guaranteed to be 'live' at the time
-        they are used, so the result of calling the references needs
-        to be checked before being used.  This can be used to avoid
-        creating references that will cause the garbage collector to
-        keep the keys around longer than needed.
-
-        """
-        return self.data.keys()
-
-    def keys(self):
-        L = []
-        for wr in self.data.keys():
-            o = wr()
-            if o is not None:
-                L.append(o)
-        return L
+        self._checkdeathqueue()
+        # Nearly any operation on us could potentially delete keys and
+        # invalidate our iteration.  To be safe we always return a list,
+        # even though a real dict returns an iterator since 3.0.
+        L = []
+        for wkhv in self._data:
+            key, value = wkhv.binding()
+            if key is not None:
+                L.append((key, value))
+        return L
+    iteritems = items
+
+    def values(self):
+        self._checkdeathqueue()
+        # Nearly any operation on us could potentially delete keys and
+        # invalidate our iteration.  To be safe we always return a list,
+        # even though a real dict returns an iterator since 3.0.
+        L = []
+        for wkhv in self._data:
+            key, value = wkhv.binding()
+            if key is not None:
+                L.append(value)
+        return L
+    itervalues = values
 
     def popitem(self):
+        self._checkdeathqueue()
         while 1:
-            key, value = self.data.popitem()
-            o = key()
-            if o is not None:
-                return o, value
-
-    def pop(self, key, *args):
-        return self.data.pop(ref(key), *args)
-
-    def setdefault(self, key, default=None):
-        return self.data.setdefault(ref(key, self._remove),default)
-
-    def update(self, dict=None, **kwargs):
-        d = self.data
-        if dict is not None:
-            if not hasattr(dict, "items"):
-                dict = type({})(dict)
-            for key, value in dict.items():
-                d[ref(key, self._remove)] = value
-        if len(kwargs):
-            self.update(kwargs)
+            wkhv, wkhv = self._data.popitem()
+            key, value = wkhv.binding()
+            self._deathqueue.cancel(wkhv.handle)
+            if key is not None:
+                return key, value
+
+
+class _WeakKeyHandleValue(Monitor, metaclass=BypassCallMeta):
+    __slots__ = 'binding', 'handle', 'hash'
+    __shared__ = True
+
+    def __init__(self, key, value=None):
+        self.binding = bind(key, value)
+        self.hash = hash(id(key))
+        # self.handle has to be filled in after
+
+    def __hash__(self):
+        return self.hash
+
+    def __eq__(self, other):
+        if not isinstance(other, _WeakKeyHandleValue):
+            return NotImplemented
+
+        # We guarantee a _WeakKeyHandleValue always compares equal to
+        # itself, even if the weakref has been cleared.
+        if self is other:
+            return True
+
+        # If it's a different _WeakKeyHandleValue then we compare
+        # objects, defaulting to False if either of them have been
+        # cleared.
+        self_o, self_value = self.binding()
+        other_o, other_value = other.binding()
+        if self_o is None or other_o is None:
+            return False
+        return self_o is other_o
+
+
+def proxy(obj):
+    return ProxyType(obj)
+
+
+class ProxyType:
+    __shared__ = True
+
+    def __init__(self, obj):
+        super().__setattr__('ref', ref(obj))
+
+    def __getattribute__(self, name):
+        o = super().__getattribute__('ref')()
+        if o is None:
+            raise ReferenceError
+        return getattr(o, name)
+
+    def __repr__(self):
+        o = super().__getattribute__('ref')()
+        if o is None:
+            return '<weakproxy at {0}, dead>'.format(hex(id(self)))
+        return '<weakproxy at {0} to {1} at {2}>'.format(hex(id(self)),
+            type(o).__name__, hex(id(o)))
+
+    def __bool__(self):
+        # We can't use our generic operator proxying because the names
+        # are different.  __bool__ -> operator.truth
+        o = super().__getattribute__('ref')()
+        if o is None:
+            raise ReferenceError
+        return bool(o)
+
+CallableProxyType = ProxyType
+
+_directmethods = tuple("""
+setattr delattr call iter len str
+""".split())
+def _directproxy_(name):
+    name = '__{0}__'.format(name)
+    def _directproxy(self, *args, **kwargs):
+        o = super(ProxyType, self).__getattribute__('ref')()
+        if o is None:
+            raise ReferenceError
+        return getattr(o, name)(*args, **kwargs)
+    return _directproxy
+for _directname in _directmethods:
+    _name = '__' + _directname + '__'
+    setattr(ProxyType, _name, _directproxy_(_directname))
+
+_opermethods = tuple("""
+abs add and concat contains delitem eq floordiv ge getitem
+gt iadd iand iconcat ifloordiv ilshift imod imul index inv
+invert ior ipow irepeat irshift isub itruediv ixor le lshift lt mod mul
+ne neg not or pos pow repeat rshift setitem sub truediv xor
+""".split())
+def _operproxy_(name):
+    oper = getattr(operator, '__{0}__'.format(name))
+    def _operproxy(self, *args):
+        o = super(ProxyType, self).__getattribute__('ref')()
+        if o is None:
+            raise ReferenceError
+        return oper(o, *args)
+    return _operproxy
+for _opername in _opermethods:
+    _name = '__' + _opername + '__'
+    setattr(ProxyType, _name, _operproxy_(_opername))
+
+_reverseopermethods = tuple("""
+add sub mul
+truediv floordiv mod pow
+lshift rshift and xor or
+""".split())
+def _reverseoperproxy_(name):
+    oper = getattr(operator, '__{0}__'.format(name))
+    def _operproxy(self, other):
+        o = super(ProxyType, self).__getattribute__('ref')()
+        if o is None:
+            raise ReferenceError
+        return oper(other, o)
+    return _operproxy
+for _opername in _reverseopermethods:
+    _name = '__r' + _opername + '__'
+    setattr(ProxyType, _name, _reverseoperproxy_(_opername))

=== modified file 'Mac/Modules/MacOS.c'
--- Mac/Modules/MacOS.c	2008-01-03 23:01:04 +0000
+++ Mac/Modules/MacOS.c	2008-03-24 04:28:03 +0000
@@ -231,7 +231,7 @@
 {
 	rfobject *self;
 	
-	self = PyObject_NEW(rfobject, &Rftype);
+	self = PyObject_New(&Rftype);
 	if (self == NULL)
 		return NULL;
 	self->isclosed = 1;
@@ -243,7 +243,7 @@
 rf_dealloc(rfobject *self)
 {
 	do_close(self);
-	PyObject_DEL(self);
+	PyObject_Del(self);
 }
 
 static PyObject *

=== modified file 'Mac/Modules/Nav.c'
--- Mac/Modules/Nav.c	2007-07-25 16:47:51 +0000
+++ Mac/Modules/Nav.c	2008-03-24 04:28:03 +0000
@@ -283,7 +283,7 @@
 {
 	navrrobject *self;
 	
-	self = PyObject_NEW(navrrobject, &Navrrtype);
+	self = PyObject_New(&Navrrtype);
 	if (self == NULL)
 		return NULL;
 	self->itself = *itself;
@@ -295,7 +295,7 @@
 navrr_dealloc(navrrobject *self)
 {
 	NavDisposeReply(&self->itself);
-	PyObject_DEL(self);
+	PyObject_Del(self);
 }
 
 static PyObject *

=== modified file 'Mac/Modules/icgluemodule.c'
--- Mac/Modules/icgluemodule.c	2007-07-25 16:47:51 +0000
+++ Mac/Modules/icgluemodule.c	2008-03-24 04:28:03 +0000
@@ -362,12 +362,12 @@
 	iciobject *self;
 	OSStatus err;
 	
-	self = PyObject_NEW(iciobject, &Icitype);
+	self = PyObject_New(&Icitype);
 	if (self == NULL)
 		return NULL;
 	if ((err=ICStart(&self->inst, creator)) != 0 ) {
 		(void)PyMac_Error(err);
-		PyObject_DEL(self);
+		PyObject_Del(self);
 		return NULL;
 	}
 	return self;
@@ -378,7 +378,7 @@
 ici_dealloc(iciobject *self)
 {
 	(void)ICStop(self->inst);
-	PyObject_DEL(self);
+	PyObject_Del(self);
 }
 
 static PyObject *

=== modified file 'Makefile.pre.in'
--- Makefile.pre.in	2008-04-09 08:37:03 +0000
+++ Makefile.pre.in	2008-04-11 02:07:01 +0000
@@ -184,10 +184,8 @@
 		Modules/config.o \
 		Modules/getpath.o \
 		Modules/main.o \
-		Modules/gcmodule.o
-
-# Used of signalmodule.o is not available
-SIGNAL_OBJS=	@SIGNAL_OBJS@
+		Modules/gcmodule.o \
+		Modules/signalmodule.o
 
 
 ##########################################################################
@@ -294,10 +292,12 @@
 		Objects/boolobject.o \
 		Objects/bytes_methods.o \
 		Objects/bytesobject.o \
+		Objects/cancelobject.o \
 		Objects/cellobject.o \
 		Objects/classobject.o \
 		Objects/cobject.o \
 		Objects/codeobject.o \
+		Objects/branchobject.o \
 		Objects/complexobject.o \
 		Objects/descrobject.o \
 		Objects/enumobject.o \
@@ -314,6 +314,7 @@
 		Objects/memoryobject.o \
 		Objects/methodobject.o \
 		Objects/moduleobject.o \
+		Objects/monitorobject.o \
 		Objects/object.o \
 		Objects/obmalloc.o \
 		Objects/rangeobject.o \
@@ -336,7 +337,6 @@
 		$(OBJECT_OBJS) \
 		$(PYTHON_OBJS) \
 		$(MODULE_OBJS) \
-		$(SIGNAL_OBJS) \
 		$(MODOBJS)
 
 #########################################################################
@@ -371,7 +371,7 @@
 	$(AR) cr $@ $(PARSER_OBJS)
 	$(AR) cr $@ $(OBJECT_OBJS)
 	$(AR) cr $@ $(PYTHON_OBJS)
-	$(AR) cr $@ $(MODULE_OBJS) $(SIGNAL_OBJS)
+	$(AR) cr $@ $(MODULE_OBJS)
 	$(AR) cr $@ $(MODOBJS)
 	$(RANLIB) $@
 
@@ -465,7 +465,6 @@
 		$(OBJECT_OBJS) \
 		$(PYTHON_OBJS) \
 		$(MODULE_OBJS) \
-		$(SIGNAL_OBJS) \
 		$(MODOBJS) \
 		$(srcdir)/Modules/getbuildinfo.c
 	$(CC) -c $(PY_CFLAGS) -DSVNVERSION=\"`LC_ALL=C $(SVNVERSION)`\" -o $@ $(srcdir)/Modules/getbuildinfo.c
@@ -552,12 +551,14 @@
 		Include/boolobject.h \
 		Include/bytes_methods.h \
 		Include/bytesobject.h \
+		Include/cancelobject.h \
 		Include/cellobject.h \
 		Include/ceval.h \
 		Include/classobject.h \
 		Include/cobject.h \
 		Include/code.h \
 		Include/codecs.h \
+		Include/branchobject.h \
 		Include/compile.h \
 		Include/complexobject.h \
 		Include/descrobject.h \
@@ -572,7 +573,6 @@
 		Include/funcobject.h \
 		Include/genobject.h \
 		Include/import.h \
-		Include/intrcheck.h \
 		Include/iterobject.h \
 		Include/listobject.h \
 		Include/longintrepr.h \
@@ -583,6 +583,7 @@
 		Include/methodobject.h \
 		Include/modsupport.h \
 		Include/moduleobject.h \
+		Include/monitorobject.h \
 		Include/node.h \
 		Include/object.h \
 		Include/objimpl.h \
@@ -599,6 +600,7 @@
 		Include/pygetopt.h \
 		Include/pymem.h \
 		Include/pyport.h \
+		Include/pysignal.h \
 		Include/pystate.h \
 		Include/pystrcmp.h \
 		Include/pystrtod.h \

=== modified file 'Modules/Setup.config.in'
--- Modules/Setup.config.in	2002-12-12 17:37:50 +0000
+++ Modules/Setup.config.in	2008-03-24 04:28:04 +0000
@@ -4,10 +4,10 @@
 # based on configure-time options.
 
 # Threading
-@USE_THREAD_MODULE@thread threadmodule.c
+#@USE_THREAD_MODULE@thread threadmodule.c
 
 # The signal module
-@USE_SIGNAL_MODULE@signal signalmodule.c
+#@USE_SIGNAL_MODULE@signal signalmodule.c
 
 # The rest of the modules previously listed in this file are built
 # by the setup.py script in Python 2.1 and later.

=== modified file 'Modules/_bsddb.c'
--- Modules/_bsddb.c	2008-03-17 20:16:47 +0000
+++ Modules/_bsddb.c	2008-04-11 02:07:10 +0000
@@ -115,9 +115,10 @@
 /* and these are for calling C --> Python */
 #if defined(MYDB_USE_GILSTATE)
 #define MYDB_BEGIN_BLOCK_THREADS \
-		PyGILState_STATE __savestate = PyGILState_Ensure();
+		PyState_EnterFrame *__enterframe = PyState_Enter(); \
+		if (__enterframe == NULL) Py_FatalError("PyState_Enter failed");
 #define MYDB_END_BLOCK_THREADS \
-		PyGILState_Release(__savestate);
+		PyState_Exit(__enterframe);
 #else /* MYDB_USE_GILSTATE */
 /* Pre GILState API - do it the long old way */
 static PyInterpreterState* _db_interpreterState = NULL;
@@ -785,7 +786,7 @@
     DB_ENV* db_env = NULL;
     int err;
 
-    self = PyObject_New(DBObject, &DB_Type);
+    self = PyObject_New(&DB_Type);
     if (self == NULL)
         return NULL;
 
@@ -846,9 +847,13 @@
         if (!self->myenvobj ||
             (self->myenvobj && self->myenvobj->db_env))
         {
-            MYDB_BEGIN_ALLOW_THREADS;
+#warning XXX FIXME DB_dealloc cannot call PyState_Suspend while in *_dealloc function
+            /* XXX FIXME shouldn't block here */
+            //MYDB_BEGIN_ALLOW_THREADS;
+            PyState_MaybeSuspend();
             self->db->close(self->db, 0);
-            MYDB_END_ALLOW_THREADS;
+            PyState_MaybeResume();
+            //MYDB_END_ALLOW_THREADS;
         } else {
             PyErr_WarnEx(PyExc_RuntimeWarning,
 			 "DB could not be closed in destructor:"
@@ -857,9 +862,6 @@
         }
         self->db = NULL;
     }
-    if (self->in_weakreflist != NULL) {
-        PyObject_ClearWeakRefs((PyObject *) self);
-    }
     if (self->myenvobj) {
         Py_DECREF(self->myenvobj);
         self->myenvobj = NULL;
@@ -881,7 +883,7 @@
 static DBCursorObject*
 newDBCursorObject(DBC* dbc, DBObject* db)
 {
-    DBCursorObject* self = PyObject_New(DBCursorObject, &DBCursor_Type);
+    DBCursorObject* self = PyObject_New(&DBCursor_Type);
     if (self == NULL)
         return NULL;
 
@@ -898,10 +900,6 @@
 {
     int err;
 
-    if (self->in_weakreflist != NULL) {
-        PyObject_ClearWeakRefs((PyObject *) self);
-    }
-
     if (self->dbc != NULL) {
 	/* If the underlying database has been closed, we don't
 	   need to do anything. If the environment has been closed
@@ -914,9 +912,12 @@
         /* test for: open db + no environment or non-closed environment */
 	if (self->mydb->db && (!self->mydb->myenvobj || (self->mydb->myenvobj &&
 	    !self->mydb->myenvobj->closed))) {
-            MYDB_BEGIN_ALLOW_THREADS;
+            /* XXX FIXME shouldn't block here */
+            //MYDB_BEGIN_ALLOW_THREADS;
+            PyState_MaybeSuspend();
             err = self->dbc->c_close(self->dbc);
-            MYDB_END_ALLOW_THREADS;
+            PyState_MaybeResume();
+            //MYDB_END_ALLOW_THREADS;
         }
         self->dbc = NULL;
     }
@@ -929,7 +930,7 @@
 newDBEnvObject(int flags)
 {
     int err;
-    DBEnvObject* self = PyObject_New(DBEnvObject, &DBEnv_Type);
+    DBEnvObject* self = PyObject_New(&DBEnv_Type);
     if (self == NULL)
         return NULL;
 
@@ -956,14 +957,13 @@
 static void
 DBEnv_dealloc(DBEnvObject* self)
 {
-    if (self->in_weakreflist != NULL) {
-        PyObject_ClearWeakRefs((PyObject *) self);
-    }
-
     if (self->db_env && !self->closed) {
-        MYDB_BEGIN_ALLOW_THREADS;
+        /* XXX FIXME shouldn't block here */
+        //MYDB_BEGIN_ALLOW_THREADS;
+        PyState_MaybeSuspend();
         self->db_env->close(self->db_env, 0);
-        MYDB_END_ALLOW_THREADS;
+        PyState_MaybeResume();
+        //MYDB_END_ALLOW_THREADS;
     }
     PyObject_Del(self);
 }
@@ -973,7 +973,7 @@
 newDBTxnObject(DBEnvObject* myenv, DB_TXN *parent, int flags)
 {
     int err;
-    DBTxnObject* self = PyObject_New(DBTxnObject, &DBTxn_Type);
+    DBTxnObject* self = PyObject_New(&DBTxn_Type);
     if (self == NULL)
         return NULL;
     Py_INCREF(myenv);
@@ -999,19 +999,18 @@
 static void
 DBTxn_dealloc(DBTxnObject* self)
 {
-    if (self->in_weakreflist != NULL) {
-        PyObject_ClearWeakRefs((PyObject *) self);
-    }
-
     if (self->txn) {
         /* it hasn't been finalized, abort it! */
-        MYDB_BEGIN_ALLOW_THREADS;
+        /* XXX FIXME shouldn't block here */
+        //MYDB_BEGIN_ALLOW_THREADS;
+        PyState_MaybeSuspend();
 #if (DBVER >= 40)
         self->txn->abort(self->txn);
 #else
         txn_abort(self->txn);
 #endif
-        MYDB_END_ALLOW_THREADS;
+        PyState_MaybeResume();
+        //MYDB_END_ALLOW_THREADS;
         PyErr_WarnEx(PyExc_RuntimeWarning,
 		     "DBTxn aborted in destructor. "
 		     " No prior commit() or abort().",
@@ -1028,7 +1027,7 @@
                 db_lockmode_t lock_mode, int flags)
 {
     int err;
-    DBLockObject* self = PyObject_New(DBLockObject, &DBLock_Type);
+    DBLockObject* self = PyObject_New(&DBLock_Type);
     if (self == NULL)
         return NULL;
     self->in_weakreflist = NULL;
@@ -1053,9 +1052,6 @@
 static void
 DBLock_dealloc(DBLockObject* self)
 {
-    if (self->in_weakreflist != NULL) {
-        PyObject_ClearWeakRefs((PyObject *) self);
-    }
     /* TODO: is this lock held? should we release it? */
 
     PyObject_Del(self);
@@ -1091,10 +1087,6 @@
 static void
 DBSequence_dealloc(DBSequenceObject* self)
 {
-    if (self->in_weakreflist != NULL) {
-        PyObject_ClearWeakRefs((PyObject *) self);
-    }
-
     Py_DECREF(self->mydb);
     PyObject_Del(self);
 }
@@ -1274,7 +1266,7 @@
      *  (see pybsddb-users mailing list post on 2002-08-07)
      */
 #ifdef WITH_THREAD
-    PyEval_InitThreads();
+    //PyState_InitThreads();
 #endif
     MYDB_BEGIN_ALLOW_THREADS;
 #if (DBVER >= 41)
@@ -2203,7 +2195,7 @@
     /* This is to workaround a problem with un-initialized threads (see
        comment in DB_associate) */
 #ifdef WITH_THREAD
-    PyEval_InitThreads();
+    //PyState_InitThreads();
 #endif
 
     err = self->db->set_bt_compare(self->db, _db_compareCallback);

=== modified file 'Modules/_collectionsmodule.c'
--- Modules/_collectionsmodule.c	2008-02-12 22:59:25 +0000
+++ Modules/_collectionsmodule.c	2008-03-24 04:28:04 +0000
@@ -133,7 +133,7 @@
 	block *b;
 
 	/* create dequeobject structure */
-	deque = (dequeobject *)type->tp_alloc(type, 0);
+	deque = PyObject_New(type);
 	if (deque == NULL)
 		return NULL;
 
@@ -573,9 +573,6 @@
 static void
 deque_dealloc(dequeobject *deque)
 {
-	PyObject_GC_UnTrack(deque);
-	if (deque->weakreflist != NULL)
-		PyObject_ClearWeakRefs((PyObject *) deque);
 	if (deque->leftblock != NULL) {
 		deque_clear(deque);
 		assert(deque->leftblock != NULL);
@@ -583,7 +580,7 @@
 	}
 	deque->leftblock = NULL;
 	deque->rightblock = NULL;
-	Py_TYPE(deque)->tp_free(deque);
+	PyObject_Del(deque);
 }
 
 static int
@@ -882,9 +879,7 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	(initproc)deque_init,		/* tp_init */
-	PyType_GenericAlloc,		/* tp_alloc */
 	deque_new,			/* tp_new */
-	PyObject_GC_Del,		/* tp_free */
 };
 
 /*********************** Deque Iterator **************************/
@@ -905,7 +900,7 @@
 {
 	dequeiterobject *it;
 
-	it = PyObject_New(dequeiterobject, &dequeiter_type);
+	it = PyObject_New(&dequeiter_type);
 	if (it == NULL)
 		return NULL;
 	it->b = deque->leftblock;
@@ -921,7 +916,7 @@
 dequeiter_dealloc(dequeiterobject *dio)
 {
 	Py_XDECREF(dio->deque);
-	Py_TYPE(dio)->tp_free(dio);
+	PyObject_Del(dio);
 }
 
 static PyObject *
@@ -1007,7 +1002,7 @@
 {
 	dequeiterobject *it;
 
-	it = PyObject_New(dequeiterobject, &dequereviter_type);
+	it = PyObject_New(&dequereviter_type);
 	if (it == NULL)
 		return NULL;
 	it->b = deque->rightblock;
@@ -1335,9 +1330,7 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	defdict_init,			/* tp_init */
-	PyType_GenericAlloc,		/* tp_alloc */
 	0,				/* tp_new */
-	PyObject_GC_Del,		/* tp_free */
 };
 
 /* module level code ********************************************************/

=== modified file 'Modules/_csv.c'
--- Modules/_csv.c	2007-12-19 02:45:37 +0000
+++ Modules/_csv.c	2008-03-24 04:28:04 +0000
@@ -284,7 +284,7 @@
 Dialect_dealloc(DialectObj *self)
 {
         Py_XDECREF(self->lineterminator);
-        Py_TYPE(self)->tp_free((PyObject *)self);
+        PyObject_Del(self);
 }
 
 static char *dialect_kws[] = {
@@ -349,7 +349,7 @@
 			return dialect;
 	}
 
-	self = (DialectObj *)type->tp_alloc(type, 0);
+	self = PyObject_New(type);
 	if (self == NULL) {
 		Py_XDECREF(dialect);
 		return NULL;
@@ -471,9 +471,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	dialect_new,			        /* tp_new */
-	0,                           		/* tp_free */
 };
 
 /*
@@ -804,13 +802,12 @@
 static void
 Reader_dealloc(ReaderObj *self)
 {
-	PyObject_GC_UnTrack(self);
         Py_XDECREF(self->dialect);
         Py_XDECREF(self->input_iter);
         Py_XDECREF(self->fields);
         if (self->field != NULL)
         	PyMem_Free(self->field);
-	PyObject_GC_Del(self);
+	PyObject_Del(self);
 }
 
 static int
@@ -890,7 +887,7 @@
 csv_reader(PyObject *module, PyObject *args, PyObject *keyword_args)
 {
 	PyObject * iterator, * dialect = NULL;
-        ReaderObj * self = PyObject_GC_New(ReaderObj, &Reader_Type);
+        ReaderObj * self = PyObject_New(&Reader_Type);
 
         if (!self)
                 return NULL;
@@ -924,7 +921,6 @@
                 return NULL;
         }
 
-	PyObject_GC_Track(self);
         return (PyObject *)self;
 }
 
@@ -1235,12 +1231,11 @@
 static void
 Writer_dealloc(WriterObj *self)
 {
-	PyObject_GC_UnTrack(self);
         Py_XDECREF(self->dialect);
         Py_XDECREF(self->writeline);
 	if (self->rec != NULL)
 		PyMem_Free(self->rec);
-	PyObject_GC_Del(self);
+	PyObject_Del(self);
 }
 
 static int
@@ -1305,7 +1300,7 @@
 csv_writer(PyObject *module, PyObject *args, PyObject *keyword_args)
 {
 	PyObject * output_file, * dialect = NULL;
-        WriterObj * self = PyObject_GC_New(WriterObj, &Writer_Type);
+        WriterObj * self = PyObject_New(&Writer_Type);
 
         if (!self)
                 return NULL;
@@ -1334,7 +1329,6 @@
                 Py_DECREF(self);
                 return NULL;
         }
-	PyObject_GC_Track(self);
         return (PyObject *)self;
 }
 

=== modified file 'Modules/_ctypes/_ctypes.c'
--- Modules/_ctypes/_ctypes.c	2008-03-26 13:45:42 +0000
+++ Modules/_ctypes/_ctypes.c	2008-04-11 02:20:15 +0000
@@ -134,6 +134,7 @@
 
 /****************************************************************/
 
+#if 0
 typedef struct {
 	PyObject_HEAD
 	PyObject *key;
@@ -146,7 +147,7 @@
 	DictRemoverObject *self = (DictRemoverObject *)_self;
 	Py_XDECREF(self->key);
 	Py_XDECREF(self->dict);
-	Py_TYPE(self)->tp_free(_self);
+	PyObject_Del(_self);
 }
 
 static PyObject *
@@ -204,9 +205,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	0,					/* tp_new */
-	0,					/* tp_free */
 };
 
 int
@@ -254,6 +253,7 @@
 		return NULL;
 	return result;
 }
+#endif
 
 /******************************************************************/
 /*
@@ -591,9 +591,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	StructType_new,				/* tp_new */
-	0,					/* tp_free */
 };
 
 static PyTypeObject UnionType_Type = {
@@ -633,9 +631,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	UnionType_new,				/* tp_new */
-	0,					/* tp_free */
 };
 
 
@@ -848,9 +844,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	PointerType_new,			/* tp_new */
-	0,					/* tp_free */
 };
 
 
@@ -1227,9 +1221,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	ArrayType_new,				/* tp_new */
-	0,					/* tp_free */
 };
 
 
@@ -1874,9 +1866,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	SimpleType_new,				/* tp_new */
-	0,					/* tp_free */
 };
 
 /******************************************************************/
@@ -2085,9 +2075,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	CFuncPtrType_new,			/* tp_new */
-	0,					/* tp_free */
 };
 
 
@@ -2217,7 +2205,7 @@
 CData_dealloc(PyObject *self)
 {
 	CData_clear((CDataObject *)self);
-	Py_TYPE(self)->tp_free(self);
+	PyObject_Del(self);
 }
 
 static PyMemberDef CData_members[] = {
@@ -2347,9 +2335,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	0,					/* tp_new */
-	0,					/* tp_free */
 };
 
 static int CData_MallocBuffer(CDataObject *obj, StgDictObject *dict)
@@ -2394,7 +2380,7 @@
 		return NULL;
 	}
 	dict->flags |= DICTFLAG_FINAL;
-	cmem = (CDataObject *)((PyTypeObject *)type)->tp_alloc((PyTypeObject *)type, 0);
+	cmem = PyObject_New((PyTypeObject *)type);
 	if (cmem == NULL)
 		return NULL;
 	assert(CDataObject_Check(cmem));
@@ -2437,7 +2423,7 @@
 	}
 	dict->flags |= DICTFLAG_FINAL;
 
-	pd = (CDataObject *)((PyTypeObject *)type)->tp_alloc((PyTypeObject *)type, 0);
+	pd = PyObject_New((PyTypeObject *)type);
 	if (!pd)
 		return NULL;
 	assert(CDataObject_Check(pd));
@@ -2616,7 +2602,7 @@
 	}
 	dict->flags |= DICTFLAG_FINAL;
 
-	obj = (CDataObject *)type->tp_alloc(type, 0);
+	obj = PyObject_New(type);
 	if (!obj)
 		return NULL;
 
@@ -3613,7 +3599,7 @@
 CFuncPtr_dealloc(CFuncPtrObject *self)
 {
 	CFuncPtr_clear(self);
-	Py_TYPE(self)->tp_free((PyObject *)self);
+	PyObject_Del(self);
 }
 
 static PyObject *
@@ -3668,9 +3654,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
         CFuncPtr_new,				/* tp_new */
-	0,					/* tp_free */
 };
 
 /*****************************************************************/
@@ -3811,9 +3795,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	Struct_init,				/* tp_init */
-	0,					/* tp_alloc */
 	GenericCData_new,			/* tp_new */
-	0,					/* tp_free */
 };
 
 static PyTypeObject Union_Type = {
@@ -3853,9 +3835,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	Struct_init,				/* tp_init */
-	0,					/* tp_alloc */
 	GenericCData_new,			/* tp_new */
-	0,					/* tp_free */
 };
 
 
@@ -4162,14 +4142,13 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	(initproc)Array_init,			/* tp_init */
-	0,					/* tp_alloc */
         GenericCData_new,			/* tp_new */
-	0,					/* tp_free */
 };
 
 PyObject *
 CreateArrayType(PyObject *itemtype, Py_ssize_t length)
 {
+#if 0
 	static PyObject *cache;
 	PyObject *key;
 	PyObject *result;
@@ -4228,6 +4207,10 @@
 	}
 	Py_DECREF(key);
 	return result;
+#else
+	PyErr_SetString(PyExc_NotImplementedError, "CreateArrayType");
+        return NULL;
+#endif
 }
 
 
@@ -4394,9 +4377,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	(initproc)Simple_init,			/* tp_init */
-	0,					/* tp_alloc */
         GenericCData_new,			/* tp_new */
-	0,					/* tp_free */
 };
 
 /******************************************************************/
@@ -4771,9 +4752,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	(initproc)Pointer_init,			/* tp_init */
-	0,					/* tp_alloc */
 	Pointer_new,				/* tp_new */
-	0,					/* tp_free */
 };
 
 
@@ -4866,7 +4845,6 @@
     0,                          /* tp_descr_set */
     0,                          /* tp_dictoffset */
     (initproc)comerror_init,    /* tp_init */
-    0,                          /* tp_alloc */
     0,                          /* tp_new */
 };
 
@@ -4987,9 +4965,6 @@
    ob_type is the metatype (the 'type'), defaults to PyType_Type,
    tp_base is the base type, defaults to 'object' aka PyBaseObject_Type.
 */
-#ifdef WITH_THREAD
-	PyEval_InitThreads();
-#endif
 	m = Py_InitModule3("_ctypes", module_methods, module_docs);
 	if (!m)
 		return;
@@ -5093,9 +5068,11 @@
 	 * Other stuff
 	 */
 
+#if 0
 	DictRemover_Type.tp_new = PyType_GenericNew;
 	if (PyType_Ready(&DictRemover_Type) < 0)
 		return;
+#endif
 
 #ifdef MS_WIN32
 	if (create_comerror() < 0)

=== modified file 'Modules/_ctypes/callbacks.c'
--- Modules/_ctypes/callbacks.c	2008-01-28 02:38:20 +0000
+++ Modules/_ctypes/callbacks.c	2008-03-24 04:28:04 +0000
@@ -63,7 +63,7 @@
 		);
 	if (!py_code) goto bad;
 	py_frame = PyFrame_New(
-		PyThreadState_Get(), /*PyThreadState *tstate,*/
+		PyState_Get(),       /*PyState *pystate,*/
 		py_code,             /*PyCodeObject *code,*/
 		py_globals,          /*PyObject *globals,*/
 		0                    /*PyObject *locals*/
@@ -124,7 +124,9 @@
 	PyObject *arglist = NULL;
 	Py_ssize_t nArgs;
 #ifdef WITH_THREAD
-	PyGILState_STATE state = PyGILState_Ensure();
+	PyState_EnterFrame *enterframe = PyState_Enter();
+	if (enterframe == NULL)
+		Py_FatalError("PyState_Enter failed");
 #endif
 
 	nArgs = PySequence_Length(converters);
@@ -235,7 +237,7 @@
   Done:
 	Py_XDECREF(arglist);
 #ifdef WITH_THREAD
-	PyGILState_Release(state);
+	PyState_Exit(enterframe);
 #endif
 }
 
@@ -349,9 +351,6 @@
 static void LoadPython(void)
 {
 	if (!Py_IsInitialized()) {
-#ifdef WITH_THREAD
-		PyEval_InitThreads();
-#endif
 		Py_Initialize();
 	}
 }
@@ -423,16 +422,18 @@
 {
 	long result;
 #ifdef WITH_THREAD
-	PyGILState_STATE state;
+	PyState_EnterFrame *enterframe;
 #endif
 
 	LoadPython();
 #ifdef WITH_THREAD
-	state = PyGILState_Ensure();
+	enterframe = PyState_Enter();
+	if (enterframe == NULL)
+		Py_FatalError("PyState_Enter failed");
 #endif
 	result = Call_GetClassObject(rclsid, riid, ppv);
 #ifdef WITH_THREAD
-	PyGILState_Release(state);
+	PyState_Exit(enterframe);
 #endif
 	return result;
 }
@@ -486,11 +487,13 @@
 {
 	long result;
 #ifdef WITH_THREAD
-	PyGILState_STATE state = PyGILState_Ensure();
+	PyState_EnterFrame *enterframe = PyState_Enter();
+	if (enterframe == NULL)
+		Py_FatalError("PyState_Enter failed");
 #endif
 	result = Call_CanUnloadNow();
 #ifdef WITH_THREAD
-	PyGILState_Release(state);
+	PyState_Exit(enterframe);
 #endif
 	return result;
 }

=== modified file 'Modules/_ctypes/callproc.c'
--- Modules/_ctypes/callproc.c	2008-02-13 20:40:44 +0000
+++ Modules/_ctypes/callproc.c	2008-03-24 04:28:04 +0000
@@ -280,7 +280,7 @@
 new_CArgObject(void)
 {
 	PyCArgObject *p;
-	p = PyObject_New(PyCArgObject, &PyCArg_Type);
+	p = PyObject_New(&PyCArg_Type);
 	if (p == NULL)
 		return NULL;
 	p->pffi_type = NULL;
@@ -611,9 +611,6 @@
 				  void *resmem,
 				  int argcount)
 {
-#ifdef WITH_THREAD
-	PyThreadState *_save = NULL; /* For Py_BLOCK_THREADS and Py_UNBLOCK_THREADS */
-#endif
 	ffi_cif cif;
 	int cc;
 #ifdef MS_WIN32

=== modified file 'Modules/_ctypes/cfield.c'
--- Modules/_ctypes/cfield.c	2008-03-16 00:07:10 +0000
+++ Modules/_ctypes/cfield.c	2008-04-11 02:07:12 +0000
@@ -13,9 +13,7 @@
 static PyObject *
 CField_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
 {
-	CFieldObject *obj;
-	obj = (CFieldObject *)type->tp_alloc(type, 0);
-	return (PyObject *)obj;
+	return PyObject_New(type);
 }
 
 /*
@@ -254,7 +252,7 @@
 CField_dealloc(PyObject *self)
 {
 	CField_clear((CFieldObject *)self);
-	self->ob_type->tp_free((PyObject *)self);
+	PyObject_Del(self);
 }
 
 static PyObject *
@@ -315,9 +313,7 @@
 	(descrsetfunc)CField_set,		/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	CField_new,				/* tp_new */
-	0,					/* tp_free */
 };
 
 

=== modified file 'Modules/_ctypes/stgdict.c'
--- Modules/_ctypes/stgdict.c	2008-02-13 20:40:44 +0000
+++ Modules/_ctypes/stgdict.c	2008-03-24 04:28:04 +0000
@@ -115,9 +115,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	(initproc)StgDict_init,			/* tp_init */
-	0,					/* tp_alloc */
 	0,					/* tp_new */
-	0,					/* tp_free */
 };
 
 /* May return NULL, but does not set an exception! */

=== modified file 'Modules/_curses_panel.c'
--- Modules/_curses_panel.c	2007-12-19 02:45:37 +0000
+++ Modules/_curses_panel.c	2008-03-24 04:28:04 +0000
@@ -175,13 +175,13 @@
 {
     PyCursesPanelObject *po;
 
-    po = PyObject_NEW(PyCursesPanelObject, &PyCursesPanel_Type);
+    po = PyObject_New(&PyCursesPanel_Type);
     if (po == NULL) return NULL;
     po->pan = pan;
     po->wo = wo;
     Py_INCREF(wo);
     if (insert_lop(po) < 0) {
-	PyObject_DEL(po);
+	PyObject_Del(po);
 	return NULL;
     }
     return (PyObject *)po;
@@ -193,7 +193,7 @@
     (void)del_panel(po->pan);
     Py_DECREF(po->wo);
     remove_lop(po);
-    PyObject_DEL(po);
+    PyObject_Del(po);
 }
 
 /* panel_above(NULL) returns the bottom panel in the stack. To get

=== modified file 'Modules/_cursesmodule.c'
--- Modules/_cursesmodule.c	2008-01-27 15:18:18 +0000
+++ Modules/_cursesmodule.c	2008-03-24 04:28:04 +0000
@@ -354,7 +354,7 @@
 {
 	PyCursesWindowObject *wo;
 
-	wo = PyObject_NEW(PyCursesWindowObject, &PyCursesWindow_Type);
+	wo = PyObject_New(&PyCursesWindow_Type);
 	if (wo == NULL) return NULL;
 	wo->win = win;
 	return (PyObject *)wo;
@@ -364,7 +364,7 @@
 PyCursesWindow_Dealloc(PyCursesWindowObject *wo)
 {
   if (wo->win != stdscr) delwin(wo->win);
-  PyObject_DEL(wo);
+  PyObject_Del(wo);
 }
 
 /* Addch, Addstr, Addnstr */

=== modified file 'Modules/_elementtree.c'
--- Modules/_elementtree.c	2008-01-18 09:56:22 +0000
+++ Modules/_elementtree.c	2008-03-24 04:28:04 +0000
@@ -294,7 +294,7 @@
 {
     ElementObject* self;
 
-    self = PyObject_New(ElementObject, &Element_Type);
+    self = PyObject_New(&Element_Type);
     if (self == NULL)
         return NULL;
 
@@ -1427,7 +1427,7 @@
 {
     TreeBuilderObject* self;
 
-    self = PyObject_New(TreeBuilderObject, &TreeBuilder_Type);
+    self = PyObject_New(&TreeBuilder_Type);
     if (self == NULL)
         return NULL;
 
@@ -1584,7 +1584,7 @@
         Py_INCREF(data); self->data = data;
     } else {
         /* more than one item; use a list to collect items */
-        if (PyString_CheckExact(self->data) && Py_REFCNT(self->data) == 1 &&
+        if (PyString_CheckExact(self->data) && Py_RefcntMatches(self->data, 1) &&
             PyString_CheckExact(data) && PyString_GET_SIZE(data) == 1) {
             /* expat often generates single character data sections; handle
                the most common case by resizing the existing string... */
@@ -2167,7 +2167,7 @@
     }
 #endif
 
-    self = PyObject_New(XMLParserObject, &XMLParser_Type);
+    self = PyObject_New(&XMLParser_Type);
     if (self == NULL)
         return NULL;
 

=== modified file 'Modules/_fileio.c'
--- Modules/_fileio.c	2008-03-18 18:26:33 +0000
+++ Modules/_fileio.c	2008-04-11 02:07:11 +0000
@@ -2,10 +2,13 @@
 
 #define PY_SSIZE_T_CLEAN
 #include "Python.h"
+#include "cancelobject.h"
+
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <fcntl.h>
 #include <stddef.h> /* For offsetof */
+#include <poll.h> /* For poll stuff */
 
 /*
  * Known likely problems:
@@ -41,6 +44,96 @@
 
 #define PyFileIO_Check(op) (PyObject_TypeCheck((op), &PyFileIO_Type))
 
+/* Conveniently chosen so that POLL_READ|POLL_WRITE == POLL_ANY. */
+#define POLL_READ 1
+#define POLL_WRITE 2
+#define POLL_ANY 3
+
+/* XXX FIXME clean up the Cancel API and delete this. */
+typedef struct {
+	int fd;
+	int cancelled;
+} blewed_up;
+
+static void
+poll_wakeup(PyCancelQueue *queue, void *arg)
+{
+	blewed_up *bu = arg;
+	bu->cancelled = 1;
+	if (write(bu->fd, "x", 1) != 1)
+		Py_FatalError("Writing to I/O wakeup pipe failed");
+}
+
+static int
+poll_single_fd(int fd, int mode)
+{
+	int fds[2];
+	PyCancelObject *cancel_scope;
+	struct pollfd events[2];
+	int status;
+	blewed_up bu;
+
+	assert(!(mode & ~POLL_ANY));
+
+	if (pipe(fds)) {
+		PyErr_SetFromErrno(PyExc_IOError);
+		return 1;
+	}
+
+	bu.fd = fds[1];
+	bu.cancelled = 0;
+
+	cancel_scope = PyCancel_New(poll_wakeup, &bu, PyState_Get());
+	if (cancel_scope == NULL) {
+		close(fds[0]); /* XXX FIXME error handling */
+		close(fds[1]);
+		return 1;
+	}
+
+	events[0].fd = fd;
+	events[0].events = 0;
+	if (mode & POLL_READ)
+		events[0].events |= POLLIN;
+	if (mode & POLL_WRITE)
+		events[0].events |= POLLOUT;
+
+	events[1].fd = fds[0];
+	events[1].events = POLLIN;
+
+	PyCancel_Push(cancel_scope);
+	Py_BEGIN_ALLOW_THREADS
+
+	status = poll(events, 2, -1);
+
+	Py_END_ALLOW_THREADS
+	PyCancel_Pop(cancel_scope);
+
+	if (status == 0)
+		Py_FatalError("I/O wakeup poll somehow returned 0");
+
+	//if (status == -1 || events[1].revents & (POLLIN|POLLHUP)) {
+	if (bu.cancelled) {
+		char buf[1];
+		/* Reset pipe for next usage */
+		/* XXX doesn't matter yet */
+		if (read(fds[0], buf, 1) != 1)
+			Py_FatalError("Resetting I/O wakeup pipe failed");
+	}
+
+	close(fds[0]); /* XXX FIXME error handling */
+	close(fds[1]);
+
+	if (bu.cancelled) {
+		PyErr_SetString(PyExc_Cancelled,
+			"I/O operation cancelled by parent");
+		Py_DECREF(cancel_scope);
+		return 1;
+	}
+
+	Py_DECREF(cancel_scope);
+	return 0;
+}
+
 /* Returns 0 on success, errno (which is < 0) on failure. */
 static int
 internal_close(PyFileIOObject *self)
@@ -49,10 +142,13 @@
 	if (self->fd >= 0) {
 		int fd = self->fd;
 		self->fd = -1;
-		Py_BEGIN_ALLOW_THREADS
+		/* We may be called from tp_dealloc, which does not
+		 * allow suspending.  Hopefully the OS won't make
+		 * close() block significantly. */
+		PyState_MaybeSuspend();
 		if (close(fd) < 0)
 			save_errno = errno;
-		Py_END_ALLOW_THREADS
+		PyState_MaybeResume();
 	}
 	return save_errno;
 }
@@ -81,9 +177,9 @@
 {
 	PyFileIOObject *self;
 
-	assert(type != NULL && type->tp_alloc != NULL);
+	assert(type != NULL);
 
-	self = (PyFileIOObject *) type->tp_alloc(type, 0);
+	self = PyObject_New(type);
 	if (self != NULL) {
 		self->fd = -1;
 		self->weakreflist = NULL;
@@ -241,6 +337,8 @@
 		flags |= O_APPEND;
 #endif
 
+	flags |= O_NONBLOCK;
+
 	if (fd >= 0) {
 		self->fd = fd;
 		self->closefd = closefd;
@@ -285,9 +383,6 @@
 static void
 fileio_dealloc(PyFileIOObject *self)
 {
-	if (self->weakreflist != NULL)
-		PyObject_ClearWeakRefs((PyObject *) self);
-
 	if (self->fd >= 0 && self->closefd) {
 		errno = internal_close(self);
 		if (errno < 0) {
@@ -296,7 +391,7 @@
 		}
 	}
 
-	Py_TYPE(self)->tp_free((PyObject *)self);
+	PyObject_Del(self);
 }
 
 static PyObject *
@@ -369,10 +464,11 @@
 	if (!PyArg_ParseTuple(args, "w#", &ptr, &n))
 		return NULL;
 
-	Py_BEGIN_ALLOW_THREADS
+	if (poll_single_fd(self->fd, POLL_READ))
+		return NULL;
+
 	errno = 0;
 	n = read(self->fd, ptr, n);
-	Py_END_ALLOW_THREADS
 	if (n < 0) {
 		if (errno == EAGAIN)
 			Py_RETURN_NONE;
@@ -408,12 +504,14 @@
 				break;
 			}
 		}
-		Py_BEGIN_ALLOW_THREADS
+
+		if (poll_single_fd(self->fd, POLL_READ))
+			return NULL;
+
 		errno = 0;
 		n = read(self->fd,
 			 PyString_AS_STRING(result) + total,
 			 newsize - total);
-		Py_END_ALLOW_THREADS
 		if (n == 0)
 			break;
 		if (n < 0) {
@@ -465,10 +563,11 @@
 		return NULL;
 	ptr = PyString_AS_STRING(bytes);
 
-	Py_BEGIN_ALLOW_THREADS
+	if (poll_single_fd(self->fd, POLL_READ))
+		return NULL;
+
 	errno = 0;
 	n = read(self->fd, ptr, size);
-	Py_END_ALLOW_THREADS
 
 	if (n < 0) {
 		if (errno == EAGAIN)
@@ -501,10 +600,11 @@
 	if (!PyArg_ParseTuple(args, "s#", &ptr, &n))
 		return NULL;
 
-	Py_BEGIN_ALLOW_THREADS
+	if (poll_single_fd(self->fd, POLL_WRITE))
+		return NULL;
+
 	errno = 0;
 	n = write(self->fd, ptr, n);
-	Py_END_ALLOW_THREADS
 
 	if (n < 0) {
 		if (errno == EAGAIN)
@@ -894,9 +994,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	fileio_init,				/* tp_init */
-	PyType_GenericAlloc,			/* tp_alloc */
 	fileio_new,				/* tp_new */
-	PyObject_Del,				/* tp_free */
 };
 
 static PyMethodDef module_methods[] = {

=== modified file 'Modules/_functoolsmodule.c'
--- Modules/_functoolsmodule.c	2007-12-19 02:45:37 +0000
+++ Modules/_functoolsmodule.c	2008-03-24 04:28:04 +0000
@@ -42,7 +42,7 @@
 	}
 
 	/* create partialobject structure */
-	pto = (partialobject *)type->tp_alloc(type, 0);
+	pto = PyObject_New(type);
 	if (pto == NULL)
 		return NULL;
 
@@ -74,14 +74,11 @@
 static void
 partial_dealloc(partialobject *pto)
 {
-	PyObject_GC_UnTrack(pto);
-	if (pto->weakreflist != NULL)
-		PyObject_ClearWeakRefs((PyObject *) pto);
 	Py_XDECREF(pto->fn);
 	Py_XDECREF(pto->args);
 	Py_XDECREF(pto->kw);
 	Py_XDECREF(pto->dict);
-	Py_TYPE(pto)->tp_free(pto);
+	PyObject_Del(pto);
 }
 
 static PyObject *
@@ -235,9 +232,7 @@
 	0,				/* tp_descr_set */
 	offsetof(partialobject, dict),	/* tp_dictoffset */
 	0,				/* tp_init */
-	0,				/* tp_alloc */
 	partial_new,			/* tp_new */
-	PyObject_GC_Del,		/* tp_free */
 };
 
 
@@ -267,7 +262,7 @@
 	for (;;) {
 		PyObject *op2;
 
-		if (args->ob_refcnt > 1) {
+		if (Py_RefcntSnoop(args) > 1) {
 			Py_DECREF(args);
 			if ((args = PyTuple_New(2)) == NULL)
 				goto Fail;

=== modified file 'Modules/_hashopenssl.c'
--- Modules/_hashopenssl.c	2007-12-19 02:45:37 +0000
+++ Modules/_hashopenssl.c	2008-03-24 04:28:04 +0000
@@ -55,7 +55,7 @@
 static EVPobject *
 newEVPobject(PyObject *name)
 {
-    EVPobject *retval = (EVPobject *)PyObject_New(EVPobject, &EVPtype);
+    EVPobject *retval = PyObject_New(&EVPtype);
 
     /* save the name for .name to return */
     if (retval != NULL) {

=== modified file 'Modules/_lsprof.c'
--- Modules/_lsprof.c	2007-12-19 02:45:37 +0000
+++ Modules/_lsprof.c	2008-03-24 04:28:04 +0000
@@ -207,8 +207,11 @@
 		PyObject *self = fn->m_self;
 		PyObject *name = PyUnicode_FromString(fn->m_ml->ml_name);
 		if (name != NULL) {
-			PyObject *mo = _PyType_Lookup(Py_TYPE(self), name);
-			Py_XINCREF(mo);
+			PyObject *mo;
+			if (_PyType_LookupEx(Py_TYPE(self), name, &mo) < 0) {
+				Py_DECREF(name);
+				return NULL;
+			}
 			Py_DECREF(name);
 			if (mo != NULL) {
 				PyObject *res = PyObject_Repr(mo);
@@ -217,7 +220,8 @@
 					return res;
 			}
 		}
-		PyErr_Clear();
+		/* XXX FIXME why is this calling PyErr_Clear()? */
+		//PyErr_Clear();
 		return PyUnicode_FromFormat("<built-in method %s>",
 					    fn->m_ml->ml_name);
 	}
@@ -756,7 +760,7 @@
 	flush_unmatched(op);
 	clearEntries(op);
 	Py_XDECREF(op->externalTimer);
-	Py_TYPE(op)->tp_free(op);
+	PyObject_Del(op);
 }
 
 static int
@@ -848,9 +852,7 @@
 	0,                                      /* tp_descr_set */
 	0,                                      /* tp_dictoffset */
 	(initproc)profiler_init,                /* tp_init */
-	PyType_GenericAlloc,                    /* tp_alloc */
 	PyType_GenericNew,                      /* tp_new */
-	PyObject_Del,                           /* tp_free */
 };
 
 static PyMethodDef moduleMethods[] = {

=== modified file 'Modules/_randommodule.c'
--- Modules/_randommodule.c	2008-01-13 23:40:30 +0000
+++ Modules/_randommodule.c	2008-03-24 04:28:04 +0000
@@ -419,7 +419,7 @@
 	if (type == &Random_Type && !_PyArg_NoKeywords("Random()", kwds))
 		return NULL;
 
-	self = (RandomObject *)type->tp_alloc(type, 0);
+	self = PyObject_New(type);
 	if (self == NULL)
 		return NULL;
 	tmp = random_seed(self, args);
@@ -487,9 +487,7 @@
 	0,				/*tp_descr_set*/
 	0,				/*tp_dictoffset*/
 	0,				/*tp_init*/
-	0,				/*tp_alloc*/
 	random_new,			/*tp_new*/
-	PyObject_Free,			/*tp_free*/
 	0,				/*tp_is_gc*/
 };
 

=== modified file 'Modules/_sqlite/cache.c'
--- Modules/_sqlite/cache.c	2008-03-29 00:45:29 +0000
+++ Modules/_sqlite/cache.c	2008-04-11 02:07:13 +0000
@@ -29,7 +29,7 @@
 {
     pysqlite_Node* node;
 
-    node = (pysqlite_Node*) (pysqlite_NodeType.tp_alloc(&pysqlite_NodeType, 0));
+    node = PyObject_New(&pysqlite_NodeType);
     if (!node) {
         return NULL;
     }
@@ -51,7 +51,7 @@
     Py_DECREF(self->key);
     Py_DECREF(self->data);
 
-    Py_TYPE(self)->tp_free((PyObject*)self);
+    PyObject_Del(self);
 }
 
 int pysqlite_cache_init(pysqlite_Cache* self, PyObject* args, PyObject* kwargs)
@@ -109,7 +109,7 @@
     }
     Py_DECREF(self->mapping);
 
-    Py_TYPE(self)->tp_free((PyObject*)self);
+    PyObject_Del(self);
 }
 
 PyObject* pysqlite_cache_get(pysqlite_Cache* self, PyObject* args)
@@ -310,9 +310,7 @@
         0,                                              /* tp_descr_set */
         0,                                              /* tp_dictoffset */
         (initproc)0,                                    /* tp_init */
-        0,                                              /* tp_alloc */
         0,                                              /* tp_new */
-        0                                               /* tp_free */
 };
 
 PyTypeObject pysqlite_CacheType = {
@@ -352,9 +350,7 @@
         0,                                              /* tp_descr_set */
         0,                                              /* tp_dictoffset */
         (initproc)pysqlite_cache_init,                  /* tp_init */
-        0,                                              /* tp_alloc */
         0,                                              /* tp_new */
-        0                                               /* tp_free */
 };
 
 extern int pysqlite_cache_setup_types(void)

=== modified file 'Modules/_sqlite/connection.c'
--- Modules/_sqlite/connection.c	2008-03-29 00:45:29 +0000
+++ Modules/_sqlite/connection.c	2008-04-11 02:07:13 +0000
@@ -213,7 +213,7 @@
     Py_XDECREF(self->collations);
     Py_XDECREF(self->statements);
 
-    Py_TYPE(self)->tp_free((PyObject*)self);
+    PyObject_Del(self);
 }
 
 PyObject* pysqlite_connection_cursor(pysqlite_Connection* self, PyObject* args, PyObject* kwargs)
@@ -510,9 +510,11 @@
     PyObject* py_func;
     PyObject* py_retval = NULL;
 
-    PyGILState_STATE threadstate;
+    PyState_EnterFrame *enterframe;
 
-    threadstate = PyGILState_Ensure();
+    enterframe = PyState_Enter();
+    if (enterframe == NULL)
+        Py_FatalError("PyState_Enter failed");
 
     py_func = (PyObject*)sqlite3_user_data(context);
 
@@ -534,7 +536,7 @@
         _sqlite3_result_error(context, "user-defined function raised exception", -1);
     }
 
-    PyGILState_Release(threadstate);
+    PyState_Exit(threadstate);
 }
 
 static void _pysqlite_step_callback(sqlite3_context *context, int argc, sqlite3_value** params)
@@ -545,9 +547,11 @@
     PyObject** aggregate_instance;
     PyObject* stepmethod = NULL;
 
-    PyGILState_STATE threadstate;
+    PyState_EnterFrame *enterframe;
 
-    threadstate = PyGILState_Ensure();
+    enterframe = PyState_Enter();
+    if (enterframe == NULL)
+        Py_FatalError("PyState_Enter failed");
 
     aggregate_class = (PyObject*)sqlite3_user_data(context);
 
@@ -594,7 +598,7 @@
     Py_XDECREF(stepmethod);
     Py_XDECREF(function_result);
 
-    PyGILState_Release(threadstate);
+    PyState_Exit(enterframe);
 }
 
 void _pysqlite_final_callback(sqlite3_context* context)
@@ -603,9 +607,11 @@
     PyObject** aggregate_instance;
     PyObject* aggregate_class;
 
-    PyGILState_STATE threadstate;
+    PyState_EnterFrame *enterframe;
 
-    threadstate = PyGILState_Ensure();
+    enterframe = PyState_Enter();
+    if (enterframe == NULL)
+        Py_FatalError("PyState_Enter failed");
 
     aggregate_class = (PyObject*)sqlite3_user_data(context);
 
@@ -633,7 +639,7 @@
     Py_XDECREF(*aggregate_instance);
     Py_XDECREF(function_result);
 
-    PyGILState_Release(threadstate);
+    PyState_Exit(enterframe);
 }
 
 void _pysqlite_drop_unused_statement_references(pysqlite_Connection* self)
@@ -728,9 +734,12 @@
 {
     PyObject *ret;
     int rc;
-    PyGILState_STATE gilstate;
-
-    gilstate = PyGILState_Ensure();
+    PyState_EnterFrame *enterframe;
+
+    enterframe = PyState_Enter();
+    if (enterframe == NULL)
+        Py_FatalError("PyState_Enter failed");
+
     ret = PyObject_CallFunction((PyObject*)user_arg, "issss", action, arg1, arg2, dbname, access_attempt_source);
 
     if (!ret) {
@@ -750,7 +759,7 @@
         Py_DECREF(ret);
     }
 
-    PyGILState_Release(gilstate);
+    PyState_Exit(enterframe);
     return rc;
 }
 
@@ -1071,12 +1080,14 @@
     PyObject* callback = (PyObject*)context;
     PyObject* string1 = 0;
     PyObject* string2 = 0;
-    PyGILState_STATE gilstate;
+    PyState_EnterFrame *enterframe;
 
     PyObject* retval = NULL;
     int result = 0;
 
-    gilstate = PyGILState_Ensure();
+    enterframe = PyState_Enter();
+    if (enterframe == NULL)
+        Py_FatalError("PyState_Enter failed");
 
     if (PyErr_Occurred()) {
         goto finally;
@@ -1106,7 +1117,7 @@
     Py_XDECREF(string2);
     Py_XDECREF(retval);
 
-    PyGILState_Release(gilstate);
+    PyState_Exit(enterframe);
 
     return result;
 }
@@ -1383,9 +1394,7 @@
         0,                                              /* tp_descr_set */
         0,                                              /* tp_dictoffset */
         (initproc)pysqlite_connection_init,             /* tp_init */
-        0,                                              /* tp_alloc */
         0,                                              /* tp_new */
-        0                                               /* tp_free */
 };
 
 extern int pysqlite_connection_setup_types(void)

=== modified file 'Modules/_sqlite/cursor.c'
--- Modules/_sqlite/cursor.c	2008-03-29 14:11:55 +0000
+++ Modules/_sqlite/cursor.c	2008-04-11 02:07:13 +0000
@@ -134,7 +134,7 @@
     Py_XDECREF(self->row_factory);
     Py_XDECREF(self->next_row);
 
-    Py_TYPE(self)->tp_free((PyObject*)self);
+    PyObject_Del(self);
 }
 
 PyObject* _pysqlite_get_converter(PyObject* key)
@@ -1094,9 +1094,7 @@
         0,                                              /* tp_descr_set */
         0,                                              /* tp_dictoffset */
         (initproc)pysqlite_cursor_init,                 /* tp_init */
-        0,                                              /* tp_alloc */
         0,                                              /* tp_new */
-        0                                               /* tp_free */
 };
 
 extern int pysqlite_cursor_setup_types(void)

=== modified file 'Modules/_sqlite/module.c'
--- Modules/_sqlite/module.c	2008-03-29 00:45:29 +0000
+++ Modules/_sqlite/module.c	2008-04-11 02:07:13 +0000
@@ -402,7 +402,7 @@
      * threads have already been initialized.
      *  (see pybsddb-users mailing list post on 2002-08-07)
      */
-    PyEval_InitThreads();
+    //PyEval_InitThreads();
 
 error:
     if (PyErr_Occurred())

=== modified file 'Modules/_sqlite/prepare_protocol.c'
--- Modules/_sqlite/prepare_protocol.c	2007-12-19 02:45:37 +0000
+++ Modules/_sqlite/prepare_protocol.c	2008-03-24 04:28:04 +0000
@@ -30,7 +30,7 @@
 
 void pysqlite_prepare_protocol_dealloc(pysqlite_PrepareProtocol* self)
 {
-    Py_TYPE(self)->tp_free((PyObject*)self);
+    PyObject_Del(self);
 }
 
 PyTypeObject pysqlite_PrepareProtocolType= {
@@ -70,9 +70,7 @@
         0,                                              /* tp_descr_set */
         0,                                              /* tp_dictoffset */
         (initproc)pysqlite_prepare_protocol_init,       /* tp_init */
-        0,                                              /* tp_alloc */
         0,                                              /* tp_new */
-        0                                               /* tp_free */
 };
 
 extern int pysqlite_prepare_protocol_setup_types(void)

=== modified file 'Modules/_sqlite/row.c'
--- Modules/_sqlite/row.c	2008-03-29 00:45:29 +0000
+++ Modules/_sqlite/row.c	2008-04-11 02:07:13 +0000
@@ -30,7 +30,7 @@
     Py_XDECREF(self->data);
     Py_XDECREF(self->description);
 
-    Py_TYPE(self)->tp_free((PyObject*)self);
+    PyObject_Del(self);
 }
 
 int pysqlite_row_init(pysqlite_Row* self, PyObject* args, PyObject* kwargs)
@@ -214,9 +214,7 @@
         0,                                              /* tp_descr_set */
         0,                                              /* tp_dictoffset */
         (initproc)pysqlite_row_init,                    /* tp_init */
-        0,                                              /* tp_alloc */
         0,                                              /* tp_new */
-        0                                               /* tp_free */
 };
 
 extern int pysqlite_row_setup_types(void)

=== modified file 'Modules/_sqlite/statement.c'
--- Modules/_sqlite/statement.c	2008-03-29 00:45:29 +0000
+++ Modules/_sqlite/statement.c	2008-04-11 02:07:13 +0000
@@ -398,7 +398,7 @@
         PyObject_ClearWeakRefs((PyObject*)self);
     }
 
-    Py_TYPE(self)->tp_free((PyObject*)self);
+    PyObject_Del(self);
 }
 
 /*
@@ -508,9 +508,7 @@
         0,                                              /* tp_descr_set */
         0,                                              /* tp_dictoffset */
         (initproc)0,                                    /* tp_init */
-        0,                                              /* tp_alloc */
         0,                                              /* tp_new */
-        0                                               /* tp_free */
 };
 
 extern int pysqlite_statement_setup_types(void)

=== modified file 'Modules/_sre.c'
--- Modules/_sre.c	2008-01-19 16:21:02 +0000
+++ Modules/_sre.c	2008-03-24 04:28:04 +0000
@@ -74,7 +74,7 @@
 #undef USE_BUILTIN_COPY
 
 #if PY_VERSION_HEX < 0x01060000
-#define PyObject_DEL(op) PyMem_DEL((op))
+#define PyObject_Del(op) PyMem_DEL((op))
 #endif
 
 /* -------------------------------------------------------------------- */
@@ -806,7 +806,6 @@
     Py_ssize_t alloc_pos, ctx_pos = -1;
     Py_ssize_t i, ret = 0;
     Py_ssize_t jump;
-    unsigned int sigcount=0;
 
     SRE_MATCH_CONTEXT* ctx;
     SRE_MATCH_CONTEXT* nextctx;
@@ -835,10 +834,6 @@
     }
 
     for (;;) {
-        ++sigcount;
-        if ((0 == (sigcount & 0xfff)) && PyErr_CheckSignals())
-            RETURN_ERROR(SRE_ERROR_INTERRUPTED);
-
         switch (*ctx->pattern++) {
 
         case SRE_OP_MARK:
@@ -1853,12 +1848,10 @@
 static void
 pattern_dealloc(PatternObject* self)
 {
-    if (self->weakreflist != NULL)
-        PyObject_ClearWeakRefs((PyObject *) self);
     Py_XDECREF(self->pattern);
     Py_XDECREF(self->groupindex);
     Py_XDECREF(self->indexgroup);
-    PyObject_DEL(self);
+    PyObject_Del(self);
 }
 
 static PyObject*
@@ -2494,7 +2487,7 @@
     PatternObject* copy;
     int offset;
 
-    copy = PyObject_NEW_VAR(PatternObject, &Pattern_Type, self->codesize);
+    copy = PyObject_NewVar(&Pattern_Type, self->codesize);
     if (!copy)
         return NULL;
 
@@ -2678,7 +2671,7 @@
 
     n = PyList_GET_SIZE(code);
     /* coverity[ampersand_in_size] */
-    self = PyObject_NEW_VAR(PatternObject, &Pattern_Type, n);
+    self = PyObject_NewVar(&Pattern_Type, n);
     if (!self)
         return NULL;
 
@@ -2696,7 +2689,7 @@
     }
 
     if (PyErr_Occurred()) {
-        PyObject_DEL(self);
+        PyObject_Del(self);
         return NULL;
     }
 
@@ -2727,7 +2720,7 @@
     Py_XDECREF(self->regs);
     Py_XDECREF(self->string);
     Py_DECREF(self->pattern);
-    PyObject_DEL(self);
+    PyObject_Del(self);
 }
 
 static PyObject*
@@ -3040,7 +3033,7 @@
 
     slots = 2 * (self->pattern->groups+1);
 
-    copy = PyObject_NEW_VAR(MatchObject, &Match_Type, slots);
+    copy = PyObject_NewVar(&Match_Type, slots);
     if (!copy)
         return NULL;
 
@@ -3188,8 +3181,7 @@
 
         /* create match object (with room for extra group marks) */
         /* coverity[ampersand_in_size] */
-        match = PyObject_NEW_VAR(MatchObject, &Match_Type,
-                                 2*(pattern->groups+1));
+        match = PyObject_NewVar(&Match_Type, 2*(pattern->groups+1));
         if (!match)
             return NULL;
 
@@ -3246,7 +3238,7 @@
 {
     state_fini(&self->state);
     Py_DECREF(self->pattern);
-    PyObject_DEL(self);
+    PyObject_Del(self);
 }
 
 static PyObject*
@@ -3364,13 +3356,13 @@
         return NULL;
 
     /* create scanner object */
-    self = PyObject_NEW(ScannerObject, &Scanner_Type);
+    self = PyObject_New(&Scanner_Type);
     if (!self)
         return NULL;
 
     string = state_init(&self->state, pattern, string, start, end);
     if (!string) {
-        PyObject_DEL(self);
+        PyObject_Del(self);
         return NULL;
     }
 

=== modified file 'Modules/_ssl.c'
--- Modules/_ssl.c	2008-03-28 00:55:15 +0000
+++ Modules/_ssl.c	2008-04-11 02:07:11 +0000
@@ -18,11 +18,10 @@
 #ifdef WITH_THREAD
 #include "pythread.h"
 #define PySSL_BEGIN_ALLOW_THREADS { \
-			PyThreadState *_save = NULL;  \
-			if (_ssl_locks_count>0) {_save = PyEval_SaveThread();}
-#define PySSL_BLOCK_THREADS	if (_ssl_locks_count>0){PyEval_RestoreThread(_save)};
-#define PySSL_UNBLOCK_THREADS	if (_ssl_locks_count>0){_save = PyEval_SaveThread()};
-#define PySSL_END_ALLOW_THREADS	if (_ssl_locks_count>0){PyEval_RestoreThread(_save);} \
+			if (_ssl_locks_count>0) {PyState_Suspend();}
+#define PySSL_BLOCK_THREADS	if (_ssl_locks_count>0){PyState_Resume();};
+#define PySSL_UNBLOCK_THREADS	if (_ssl_locks_count>0){PyState_Suspend();};
+#define PySSL_END_ALLOW_THREADS	if (_ssl_locks_count>0){PyState_Resume();} \
 		 }
 
 #else	/* no WITH_THREAD */
@@ -190,18 +189,22 @@
 			unsigned long e = ERR_get_error();
 			if (e == 0) {
                                 PySocketSockObject *s
-                                  = (PySocketSockObject *) PyWeakref_GetObject(obj->Socket);
-				if (ret == 0 || (((PyObject *)s) == Py_None)) {
+                                  = (PySocketSockObject *) PyWeakref_GetObjectEx(obj->Socket);
+				if (ret == 0 || s == NULL) {
 				  p = PY_SSL_ERROR_EOF;
 				  errstr =
                                       "EOF occurred in violation of protocol";
+				  Py_XDECREF(s);
 				} else if (ret == -1) {
 				  /* underlying BIO reported an I/O error */
-                                  return s->errorhandler();
+                                  PyObject *retval = s->errorhandler();
+				  Py_DECREF(s);
+				  return retval;
 				} else { /* possible? */
                                   p = PY_SSL_ERROR_SYSCALL;
                                   errstr = "Some I/O error occurred";
 				}
+				Py_DECREF(s);
 			} else {
 				p = PY_SSL_ERROR_SYSCALL;
 				/* XXX Protected by global interpreter lock */
@@ -269,7 +272,7 @@
 	int ret;
 	int verification_mode;
 
-	self = PyObject_New(PySSLObject, &PySSL_Type); /* Create new object */
+	self = PyObject_New(&PySSL_Type); /* Create new object */
 	if (self == NULL)
 		return NULL;
 	self->peer_cert = NULL;
@@ -439,26 +442,23 @@
 	int ret;
 	int err;
 	int sockstate;
+        PySocketSockObject *sock
+          = (PySocketSockObject *) PyWeakref_GetObjectEx(self->Socket);
+
+        if (sock == NULL) {
+                _setSSLError("Underlying socket connection gone",
+                             PY_SSL_ERROR_NO_SOCKET, __FILE__, __LINE__);
+                return NULL;
+        }
 
 	/* Actually negotiate SSL connection */
 	/* XXX If SSL_do_handshake() returns 0, it's also a failure. */
 	sockstate = 0;
 	do {
-                PySocketSockObject *sock
-                  = (PySocketSockObject *) PyWeakref_GetObject(self->Socket);
-                if (((PyObject*)sock) == Py_None) {
-                        _setSSLError("Underlying socket connection gone",
-                                     PY_SSL_ERROR_NO_SOCKET, __FILE__, __LINE__);
-                        return NULL;
-                }
-
 		PySSL_BEGIN_ALLOW_THREADS
 		ret = SSL_do_handshake(self->ssl);
 		err = SSL_get_error(self->ssl, ret);
 		PySSL_END_ALLOW_THREADS
-		if(PyErr_CheckSignals()) {
-			return NULL;
-		}
 		if (err == SSL_ERROR_WANT_READ) {
 			sockstate = check_socket_and_wait_for_timeout(sock, 0);
 		} else if (err == SSL_ERROR_WANT_WRITE) {
@@ -469,19 +469,25 @@
 		if (sockstate == SOCKET_HAS_TIMED_OUT) {
 			PyErr_SetString(PySSLErrorObject,
 				ERRSTR("The handshake operation timed out"));
+			Py_DECREF(sock);
 			return NULL;
 		} else if (sockstate == SOCKET_HAS_BEEN_CLOSED) {
 			PyErr_SetString(PySSLErrorObject,
 				ERRSTR("Underlying socket has been closed."));
+			Py_DECREF(sock);
 			return NULL;
 		} else if (sockstate == SOCKET_TOO_LARGE_FOR_SELECT) {
 			PyErr_SetString(PySSLErrorObject,
 			  ERRSTR("Underlying socket too large for select()."));
+			Py_DECREF(sock);
 			return NULL;
 		} else if (sockstate == SOCKET_IS_NONBLOCKING) {
 			break;
 		}
 	} while (err == SSL_ERROR_WANT_READ || err == SSL_ERROR_WANT_WRITE);
+
+	Py_DECREF(sock);
+
 	if (ret < 1)
 		return PySSL_SetError(self, ret, __FILE__, __LINE__);
 	self->ssl->debug = 1;
@@ -1151,16 +1157,18 @@
 	int err;
         int nonblocking;
         PySocketSockObject *sock
-          = (PySocketSockObject *) PyWeakref_GetObject(self->Socket);
+          = (PySocketSockObject *) PyWeakref_GetObjectEx(self->Socket);
 
-        if (((PyObject*)sock) == Py_None) {
+        if (sock == NULL) {
                 _setSSLError("Underlying socket connection gone",
                              PY_SSL_ERROR_NO_SOCKET, __FILE__, __LINE__);
                 return NULL;
         }
 
-	if (!PyArg_ParseTuple(args, "y#:write", &data, &count))
+	if (!PyArg_ParseTuple(args, "y#:write", &data, &count)) {
+		Py_DECREF(sock);
 		return NULL;
+	}
 
         /* just in case the blocking state of the socket has been changed */
 	nonblocking = (sock->sock_timeout >= 0.0);
@@ -1171,25 +1179,26 @@
 	if (sockstate == SOCKET_HAS_TIMED_OUT) {
 		PyErr_SetString(PySSLErrorObject,
                                 "The write operation timed out");
+		Py_DECREF(sock);
 		return NULL;
 	} else if (sockstate == SOCKET_HAS_BEEN_CLOSED) {
 		PyErr_SetString(PySSLErrorObject,
                                 "Underlying socket has been closed.");
+		Py_DECREF(sock);
 		return NULL;
 	} else if (sockstate == SOCKET_TOO_LARGE_FOR_SELECT) {
 		PyErr_SetString(PySSLErrorObject,
                                 "Underlying socket too large for select().");
+		Py_DECREF(sock);
 		return NULL;
 	}
+
 	do {
 		err = 0;
 		PySSL_BEGIN_ALLOW_THREADS
 		len = SSL_write(self->ssl, data, count);
 		err = SSL_get_error(self->ssl, len);
 		PySSL_END_ALLOW_THREADS
-		if(PyErr_CheckSignals()) {
-			return NULL;
-		}
 		if (err == SSL_ERROR_WANT_READ) {
 			sockstate =
                             check_socket_and_wait_for_timeout(sock, 0);
@@ -1202,15 +1211,19 @@
 		if (sockstate == SOCKET_HAS_TIMED_OUT) {
 			PyErr_SetString(PySSLErrorObject,
                                         "The write operation timed out");
+			Py_DECREF(sock);
 			return NULL;
 		} else if (sockstate == SOCKET_HAS_BEEN_CLOSED) {
 			PyErr_SetString(PySSLErrorObject,
                                         "Underlying socket has been closed.");
+			Py_DECREF(sock);
 			return NULL;
 		} else if (sockstate == SOCKET_IS_NONBLOCKING) {
 			break;
 		}
 	} while (err == SSL_ERROR_WANT_READ || err == SSL_ERROR_WANT_WRITE);
+
+	Py_DECREF(sock);
 	if (len > 0)
 		return PyLong_FromLong(len);
 	else
@@ -1252,26 +1265,35 @@
 	int err;
         int nonblocking;
         PySocketSockObject *sock
-          = (PySocketSockObject *) PyWeakref_GetObject(self->Socket);
+          = (PySocketSockObject *) PyWeakref_GetObjectEx(self->Socket);
 
-        if (((PyObject*)sock) == Py_None) {
+        if (sock == NULL) {
                 _setSSLError("Underlying socket connection gone",
                              PY_SSL_ERROR_NO_SOCKET, __FILE__, __LINE__);
                 return NULL;
         }
 
-	if (!PyArg_ParseTuple(args, "|Oi:read", &buf, &count))
+	if (!PyArg_ParseTuple(args, "|Oi:read", &buf, &count)) {
+		Py_DECREF(sock);
 		return NULL;
+	}
+
         if ((buf == NULL) || (buf == Py_None)) {
-		if (!(buf = PyBytes_FromStringAndSize((char *) 0, len)))
+		if (!(buf = PyBytes_FromStringAndSize((char *) 0, len))) {
+			Py_DECREF(sock);
 			return NULL;
+		}
         } else if (PyLong_Check(buf)) {
 		len = PyLong_AS_LONG(buf);
-		if (!(buf = PyBytes_FromStringAndSize((char *) 0, len)))
+		if (!(buf = PyBytes_FromStringAndSize((char *) 0, len))) {
+			Py_DECREF(sock);
 			return NULL;
+		}
 	} else {
-		if (!PyBytes_Check(buf))
+		if (!PyBytes_Check(buf)) {
+			Py_DECREF(sock);
 			return NULL;
+		}
 		len = PyBytes_Size(buf);
 		if ((count > 0) && (count <= len))
 			len = count;
@@ -1296,6 +1318,7 @@
 			if (!buf_passed) {
 				Py_DECREF(buf);
 			}
+			Py_DECREF(sock);
 			return NULL;
 		} else if (sockstate == SOCKET_TOO_LARGE_FOR_SELECT) {
 			PyErr_SetString(PySSLErrorObject,
@@ -1304,24 +1327,20 @@
 				Py_DECREF(buf);
 			}
 			Py_DECREF(buf);
+			Py_DECREF(sock);
 			return NULL;
 		} else if (sockstate == SOCKET_HAS_BEEN_CLOSED) {
 			count = 0;
 			goto done;
 		}
 	}
+
 	do {
 		err = 0;
 		PySSL_BEGIN_ALLOW_THREADS
 		count = SSL_read(self->ssl, PyBytes_AsString(buf), len);
 		err = SSL_get_error(self->ssl, count);
 		PySSL_END_ALLOW_THREADS
-		if(PyErr_CheckSignals()) {
-			if (!buf_passed) {
-				Py_DECREF(buf);
-			}
-			return NULL;
-		}
 		if (err == SSL_ERROR_WANT_READ) {
 			sockstate =
 			  check_socket_and_wait_for_timeout(sock, 0);
@@ -1343,18 +1362,24 @@
 			if (!buf_passed) {
 				Py_DECREF(buf);
 			}
+			Py_DECREF(sock);
 			return NULL;
 		} else if (sockstate == SOCKET_IS_NONBLOCKING) {
 			break;
 		}
 	} while (err == SSL_ERROR_WANT_READ || err == SSL_ERROR_WANT_WRITE);
+
 	if (count <= 0) {
 		if (!buf_passed) {
 			Py_DECREF(buf);
 		}
+		Py_DECREF(sock);
 		return PySSL_SetError(self, count, __FILE__, __LINE__);
 	}
+
   done:
+	Py_DECREF(sock);
+
 	if (!buf_passed) {
 		PyObject *res = PyString_FromStringAndSize(
 			PyBytes_AS_STRING(buf), count);
@@ -1495,11 +1520,17 @@
 /* an implementation of OpenSSL threading operations in terms
    of the Python C thread library */
 
-static PyThread_type_lock *_ssl_locks = NULL;
+static PyThread_type_lock **_ssl_locks = NULL;
 
+#if OPENSSL_VERSION_NUMBER < 0x0090900fL
 static unsigned long _ssl_thread_id_function (void) {
-	return PyThread_get_thread_ident();
+#if SIZEOF_LONG == SIZEOF_VOID_P
+	return (unsigned long)&errno;
+#else
+#error OpenSSL 0.9.9s API is broken on platforms where sizeof(long) < sizeof(void *)
+#endif
 }
+#endif
 
 static void _ssl_thread_locking_function
         (int mode, int n, const char *file, int line) {
@@ -1522,9 +1553,9 @@
 		return;
 
 	if (mode & CRYPTO_LOCK) {
-		PyThread_acquire_lock(_ssl_locks[n], 1);
+		PyThread_lock_acquire(_ssl_locks[n]);
 	} else {
-		PyThread_release_lock(_ssl_locks[n]);
+		PyThread_lock_release(_ssl_locks[n]);
 	}
 }
 
@@ -1534,25 +1565,34 @@
 
 	if (_ssl_locks == NULL) {
 		_ssl_locks_count = CRYPTO_num_locks();
-		_ssl_locks = (PyThread_type_lock *)
-			malloc(sizeof(PyThread_type_lock) * _ssl_locks_count);
+		_ssl_locks = (PyThread_type_lock **)
+			malloc(sizeof(PyThread_type_lock *) * _ssl_locks_count);
 		if (_ssl_locks == NULL)
 			return 0;
 		memset(_ssl_locks, 0,
-                       sizeof(PyThread_type_lock) * _ssl_locks_count);
+                       sizeof(PyThread_type_lock *) * _ssl_locks_count);
 		for (i = 0;  i < _ssl_locks_count;  i++) {
-			_ssl_locks[i] = PyThread_allocate_lock();
+			_ssl_locks[i] = PyThread_lock_allocate();
 			if (_ssl_locks[i] == NULL) {
 				int j;
 				for (j = 0;  j < i;  j++) {
-					PyThread_free_lock(_ssl_locks[j]);
+					PyThread_lock_free(_ssl_locks[j]);
 				}
 				free(_ssl_locks);
 				return 0;
 			}
 		}
 		CRYPTO_set_locking_callback(_ssl_thread_locking_function);
+		/* OpenSSL's API is broken.  It wants a per-thread
+		 * identifier that fits in a long, but all the normal
+		 * ways of getting one are at least size_t.  OpenSSL
+		 * 0.9.9 claims to add an alternate API that uses a
+		 * void * instead, but the default of &errno should work
+		 * on any platform with functional threading, so we just
+		 * skip it entirely there. */
+#if OPENSSL_VERSION_NUMBER < 0x0090900fL
 		CRYPTO_set_id_callback(_ssl_thread_id_function);
+#endif
 	}
 	return 1;
 }

=== modified file 'Modules/_struct.c'
--- Modules/_struct.c	2008-03-16 00:07:10 +0000
+++ Modules/_struct.c	2008-04-11 02:07:11 +0000
@@ -1440,9 +1440,9 @@
 {
 	PyObject *self;
 
-	assert(type != NULL && type->tp_alloc != NULL);
+	assert(type != NULL);
 
-	self = type->tp_alloc(type, 0);
+	self = PyObject_New(type);
 	if (self != NULL) {
 		PyStructObject *s = (PyStructObject*)self;
 		Py_INCREF(Py_None);
@@ -1496,13 +1496,11 @@
 static void
 s_dealloc(PyStructObject *s)
 {
-	if (s->weakreflist != NULL)
-		PyObject_ClearWeakRefs((PyObject *)s);
 	if (s->s_codes != NULL) {
 		PyMem_FREE(s->s_codes);
 	}
 	Py_XDECREF(s->s_format);
-	Py_TYPE(s)->tp_free((PyObject *)s);
+	PyObject_Del(s);
 }
 
 static PyObject *
@@ -1873,9 +1871,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	s_init,				/* tp_init */
-	PyType_GenericAlloc,/* tp_alloc */
 	s_new,				/* tp_new */
-	PyObject_Del,		/* tp_free */
 };
 
 

=== modified file 'Modules/_testcapimodule.c'
--- Modules/_testcapimodule.c	2008-02-28 11:19:05 +0000
+++ Modules/_testcapimodule.c	2008-03-24 04:28:04 +0000
@@ -670,7 +670,8 @@
 	return NULL;
 }
 
-#ifdef WITH_THREAD
+//#ifdef WITH_THREAD
+#if 0
 
 /* test_thread_state spawns a thread of its own, and that thread releases
  * `thread_done` when it's finished.  The driver code has to know when the
@@ -679,16 +680,18 @@
  * synchronization caused rare segfaults, so rare that they were seen only
  * on a Mac buildbot (although they were possible on any box).
  */
-static PyThread_type_lock thread_done = NULL;
+static PyThread_type_sem *thread_done = NULL;
 
 static void
 _make_call(void *callable)
 {
 	PyObject *rc;
-	PyGILState_STATE s = PyGILState_Ensure();
+	PyState_EnterTag entertag = PyState_Enter();
+	if (!entertag)
+		Py_FatalError("PyState_Enter failed");
 	rc = PyObject_CallFunction((PyObject *)callable, "");
 	Py_XDECREF(rc);
-	PyGILState_Release(s);
+	PyState_Exit(entertag);
 }
 
 /* Same thing, but releases `thread_done` when it returns.  This variant
@@ -698,7 +701,7 @@
 _make_call_from_thread(void *callable)
 {
 	_make_call(callable);
-	PyThread_release_lock(thread_done);
+	PyThread_sem_post(thread_done);
 }
 
 static PyObject *
@@ -706,15 +709,14 @@
 {
 	PyObject *fn;
 
+	if (!PyArg_RequireShareable("test_thread_state", args, NULL))
+		return NULL;
 	if (!PyArg_ParseTuple(args, "O:test_thread_state", &fn))
 		return NULL;
 
-	/* Ensure Python is set up for threading */
-	PyEval_InitThreads();
-	thread_done = PyThread_allocate_lock();
+	thread_done = PyThread_sem_allocate(0);
 	if (thread_done == NULL)
 		return PyErr_NoMemory();
-	PyThread_acquire_lock(thread_done, 1);
 
 	/* Start a new thread with our callback. */
 	PyThread_start_new_thread(_make_call_from_thread, fn);
@@ -723,7 +725,7 @@
 	/* Do it all again, but this time with the thread-lock released */
 	Py_BEGIN_ALLOW_THREADS
 	_make_call(fn);
-	PyThread_acquire_lock(thread_done, 1);  /* wait for thread to finish */
+	PyThread_sem_wait(thread_done);  /* wait for thread to finish */
 	Py_END_ALLOW_THREADS
 
 	/* And once more with and without a thread
@@ -733,13 +735,10 @@
 	Py_BEGIN_ALLOW_THREADS
 	PyThread_start_new_thread(_make_call_from_thread, fn);
 	_make_call(fn);
-	PyThread_acquire_lock(thread_done, 1);  /* wait for thread to finish */
+	PyThread_sem_wait(thread_done);  /* wait for thread to finish */
 	Py_END_ALLOW_THREADS
 
-	/* Release lock we acquired above.  This is required on HP-UX. */
-	PyThread_release_lock(thread_done);
-
-	PyThread_free_lock(thread_done);
+	PyThread_sem_free(thread_done);
 	Py_RETURN_NONE;
 }
 #endif
@@ -936,9 +935,9 @@
 #endif
 	{"test_u_code",		(PyCFunction)test_u_code,	 METH_NOARGS},
 	{"test_Z_code",		(PyCFunction)test_Z_code,	 METH_NOARGS},
-#ifdef WITH_THREAD
-	{"_test_thread_state",  test_thread_state, 		 METH_VARARGS},
-#endif
+//#ifdef WITH_THREAD
+//	{"_test_thread_state",  test_thread_state, 		 METH_VARARGS},
+#//endif
 #ifdef HAVE_GETTIMEOFDAY
 	{"profile_int",		profile_int,			METH_NOARGS},
 #endif
@@ -1006,8 +1005,7 @@
 		"LK"
 #endif
 		;
-	test_structmembers *ob;
-	ob = PyObject_New(test_structmembers, type);
+	test_structmembers *ob = PyObject_New(type);
 	if (ob == NULL)
 		return NULL;
 	memset(&ob->structmembers, 0, sizeof(all_structmembers));
@@ -1037,7 +1035,7 @@
 static void
 test_structmembers_free(PyObject *ob)
 {
-	PyObject_FREE(ob);
+	PyObject_Del(ob);
 }
 
 static PyTypeObject test_structmembersType = {
@@ -1077,7 +1075,6 @@
 	0,
 	0,
 	0,
-	0,
 	test_structmembers_new,	       	/* tp_new */
 };
 

=== modified file 'Modules/_tkinter.c'
--- Modules/_tkinter.c	2008-04-05 20:41:37 +0000
+++ Modules/_tkinter.c	2008-04-11 02:07:11 +0000
@@ -180,42 +180,52 @@
    mainloop, and invoking commands causes an exception; if the main loop is running
    but not processing events, the command invocation will block.
 
-   In addition, for a threaded Tcl, a single global tcl_tstate won't be sufficient
+   In addition, for a threaded Tcl, a single global tcl_pystate won't be sufficient
    anymore, since multiple Tcl interpreters may simultaneously dispatch in different
    threads. So we use the Tcl TLS API.
 
 */
 
-static PyThread_type_lock tcl_lock = 0;
+static PyThread_type_lock *tcl_lock = 0;
 
 #ifdef TCL_THREADS
 static Tcl_ThreadDataKey state_key;
-typedef PyThreadState *ThreadSpecificData;
-#define tcl_tstate (*(PyThreadState**)Tcl_GetThreadData(&state_key, sizeof(PyThreadState*)))
-#else
-static PyThreadState *tcl_tstate = NULL;
-#endif
-
-#define ENTER_TCL \
-	{ PyThreadState *tstate = PyThreadState_Get(); Py_BEGIN_ALLOW_THREADS \
-	    if(tcl_lock)PyThread_acquire_lock(tcl_lock, 1); tcl_tstate = tstate;
-
-#define LEAVE_TCL \
-    tcl_tstate = NULL; if(tcl_lock)PyThread_release_lock(tcl_lock); Py_END_ALLOW_THREADS}
+typedef PyState *ThreadSpecificData;
+#define tcl_pystate (*(PyState**)Tcl_GetThreadData(&state_key, sizeof(PyState*)))
+#else
+static PyState *tcl_pystate = NULL;
+#endif
+
+#warning XXX FIXME TKapp_Dealloc should not suspend or block
+/* XXX FIXME as a bodge, we use PyState_MaybeSuspend instead.  This
+ * doesn't fix the blocking problem though. */
+#if 0
+#define ENTER_TCL \
+	{ PyState *pystate = PyState_Get(); Py_BEGIN_ALLOW_THREADS \
+	    if(tcl_lock)PyThread_lock_acquire(tcl_lock); tcl_pystate = pystate;
+
+#define LEAVE_TCL \
+    tcl_pystate = NULL; if(tcl_lock)PyThread_lock_release(tcl_lock); Py_END_ALLOW_THREADS}
+#else
+#define ENTER_TCL \
+	{ PyState *pystate = PyState_Get(); PyState_MaybeSuspend(); \
+	    if(tcl_lock)PyThread_lock_acquire(tcl_lock); tcl_pystate = pystate;
+
+#define LEAVE_TCL \
+    tcl_pystate = NULL; if(tcl_lock)PyThread_lock_release(tcl_lock); PyState_MaybeResume();}
+#endif
 
 #define ENTER_OVERLAP \
 	Py_END_ALLOW_THREADS
 
 #define LEAVE_OVERLAP_TCL \
-	tcl_tstate = NULL; if(tcl_lock)PyThread_release_lock(tcl_lock); }
+	tcl_pystate = NULL; if(tcl_lock)PyThread_lock_release(tcl_lock); }
 
 #define ENTER_PYTHON \
-	{ PyThreadState *tstate = tcl_tstate; tcl_tstate = NULL; \
-	    if(tcl_lock)PyThread_release_lock(tcl_lock); PyEval_RestoreThread((tstate)); }
+	{ if(tcl_lock)PyThread_lock_release(tcl_lock); PyState_Resume(); }
 
 #define LEAVE_PYTHON \
-	{ PyThreadState *tstate = PyEval_SaveThread(); \
-	    if(tcl_lock)PyThread_acquire_lock(tcl_lock, 1); tcl_tstate = tstate; }
+	{ PyState_Suspend(); if(tcl_lock)PyThread_lock_acquire(tcl_lock); }
 
 #define CHECK_TCL_APPARTMENT \
 	if (((TkappObject *)self)->threaded && \
@@ -267,7 +277,7 @@
 #define Tkapp_Result(v) Tcl_GetStringResult(Tkapp_Interp(v))
 
 #define DEBUG_REFCNT(v) (printf("DEBUG: id=%p, refcnt=%i\n", \
-(void *) v, Py_REFCNT(v)))
+(void *) v, Py_RefcntSnoop(v)))
 
 
 
@@ -589,7 +599,7 @@
 	TkappObject *v;
 	char *argv0;
 
-	v = PyObject_New(TkappObject, &Tkapp_Type);
+	v = PyObject_New(&Tkapp_Type);
 	if (v == NULL)
 		return NULL;
 
@@ -610,7 +620,7 @@
 #ifdef WITH_THREAD
 	if (v->threaded && tcl_lock) {
 	    /* If Tcl is threaded, we don't need the lock. */
-	    PyThread_free_lock(tcl_lock);
+	    PyThread_lock_free(tcl_lock);
 	    tcl_lock = NULL;
 	}
 #endif
@@ -725,7 +735,7 @@
 newPyTclObject(Tcl_Obj *arg)
 {
 	PyTclObject *self;
-	self = PyObject_New(PyTclObject, &PyTclObject_Type);
+	self = PyObject_New(&PyTclObject_Type);
 	if (self == NULL)
 		return NULL;
 	Tcl_IncrRefCount(arg);
@@ -853,9 +863,7 @@
         0,                      /*tp_descr_set*/
         0,                      /*tp_dictoffset*/
         0,                      /*tp_init*/
-        0,                      /*tp_alloc*/
         0,                      /*tp_new*/
-        0,                      /*tp_free*/
         0,                      /*tp_is_gc*/
 };
 
@@ -2292,7 +2300,7 @@
 {
 	TkttObject *v;
 
-	v = PyObject_New(TkttObject, &Tktt_Type);
+	v = PyObject_New(&Tktt_Type);
 	if (v == NULL)
 		return NULL;
 
@@ -2430,7 +2438,7 @@
 	int threshold = 0;
 	TkappObject *self = (TkappObject*)selfptr;
 #ifdef WITH_THREAD
-	PyThreadState *tstate = PyThreadState_Get();
+	PyState *pystate = PyState_Get();
 #endif
 
 	if (!PyArg_ParseTuple(args, "|i:mainloop", &threshold))
@@ -2467,11 +2475,11 @@
 		}
 		else {
 			Py_BEGIN_ALLOW_THREADS
-			if(tcl_lock)PyThread_acquire_lock(tcl_lock, 1);
-			tcl_tstate = tstate;
+			if(tcl_lock)PyThread_lock_acquire(tcl_lock);
+			tcl_pystate = pystate;
 			result = Tcl_DoOneEvent(TCL_DONT_WAIT);
-			tcl_tstate = NULL;
-			if(tcl_lock)PyThread_release_lock(tcl_lock);
+			tcl_pystate = NULL;
+			if(tcl_lock)PyThread_lock_release(tcl_lock);
 			if (result == 0)
 				Sleep(Tkinter_busywaitinterval);
 			Py_END_ALLOW_THREADS
@@ -2480,11 +2488,6 @@
 		result = Tcl_DoOneEvent(0);
 #endif
 
-		if (PyErr_CheckSignals() != 0) {
-			if (self)
-				self->dispatching = 0;
-			return NULL;
-		}
 		if (result < 0)
 			break;
 	}
@@ -2902,7 +2905,7 @@
 #endif
 
 #ifdef WITH_THREAD
-static PyThreadState *event_tstate = NULL;
+static PyState *event_pystate = NULL;
 #endif
 
 static int
@@ -2912,7 +2915,7 @@
 	int tfile;
 #endif
 #ifdef WITH_THREAD
-	PyEval_RestoreThread(event_tstate);
+	PyState_Resume();
 #endif
 	stdin_ready = 0;
 	errorInCmd = 0;
@@ -2930,13 +2933,13 @@
 #endif
 #if defined(WITH_THREAD) || defined(MS_WINDOWS)
 		Py_BEGIN_ALLOW_THREADS
-		if(tcl_lock)PyThread_acquire_lock(tcl_lock, 1);
-		tcl_tstate = event_tstate;
+		if(tcl_lock)PyThread_lock_acquire(tcl_lock);
+		tcl_pystate = event_pystate;
 
 		result = Tcl_DoOneEvent(TCL_DONT_WAIT);
 
-		tcl_tstate = NULL;
-		if(tcl_lock)PyThread_release_lock(tcl_lock);
+		tcl_pystate = NULL;
+		if(tcl_lock)PyThread_lock_release(tcl_lock);
 		if (result == 0)
 			Sleep(Tkinter_busywaitinterval);
 		Py_END_ALLOW_THREADS
@@ -2957,7 +2960,7 @@
 		PyErr_Print();
 	}
 #ifdef WITH_THREAD
-	PyEval_SaveThread();
+	PyState_Suspend();
 #endif
 	return 0;
 }
@@ -2970,7 +2973,7 @@
 #ifdef WAIT_FOR_STDIN
 	if (PyOS_InputHook == NULL) {
 #ifdef WITH_THREAD
-		event_tstate = PyThreadState_Get();
+		event_pystate = PyState_Get();
 #endif
 		PyOS_InputHook = EventHook;
 	}
@@ -3017,7 +3020,7 @@
 	Py_TYPE(&Tkapp_Type) = &PyType_Type;
 
 #ifdef WITH_THREAD
-	tcl_lock = PyThread_allocate_lock();
+	tcl_lock = PyThread_lock_allocate();
 #endif
 
 	m = Py_InitModule("_tkinter", moduleMethods);

=== modified file 'Modules/_weakref.c'
--- Modules/_weakref.c	2007-12-19 02:45:37 +0000
+++ Modules/_weakref.c	2008-03-24 04:28:04 +0000
@@ -1,89 +1,36 @@
 #include "Python.h"
 
 
-#define GET_WEAKREFS_LISTPTR(o) \
-        ((PyWeakReference **) PyObject_GET_WEAKREFS_LISTPTR(o))
-
-
-PyDoc_STRVAR(weakref_getweakrefcount__doc__,
-"getweakrefcount(object) -- return the number of weak references\n"
-"to 'object'.");
-
-static PyObject *
-weakref_getweakrefcount(PyObject *self, PyObject *object)
-{
-    PyObject *result = NULL;
-
-    if (PyType_SUPPORTS_WEAKREFS(Py_TYPE(object))) {
-        PyWeakReference **list = GET_WEAKREFS_LISTPTR(object);
-
-        result = PyLong_FromSsize_t(_PyWeakref_GetWeakrefCount(*list));
-    }
-    else
-        result = PyLong_FromLong(0);
-
-    return result;
-}
-
-
-PyDoc_STRVAR(weakref_getweakrefs__doc__,
-"getweakrefs(object) -- return a list of all weak reference objects\n"
-"that point to 'object'.");
-
-static PyObject *
-weakref_getweakrefs(PyObject *self, PyObject *object)
-{
-    PyObject *result = NULL;
-
-    if (PyType_SUPPORTS_WEAKREFS(Py_TYPE(object))) {
-        PyWeakReference **list = GET_WEAKREFS_LISTPTR(object);
-        Py_ssize_t count = _PyWeakref_GetWeakrefCount(*list);
-
-        result = PyList_New(count);
-        if (result != NULL) {
-            PyWeakReference *current = *list;
-            Py_ssize_t i;
-            for (i = 0; i < count; ++i) {
-                PyList_SET_ITEM(result, i, (PyObject *) current);
-                Py_INCREF(current);
-                current = current->wr_next;
-            }
-        }
-    }
-    else {
-        result = PyList_New(0);
-    }
-    return result;
-}
-
-
-PyDoc_STRVAR(weakref_proxy__doc__,
-"proxy(object[, callback]) -- create a proxy object that weakly\n"
-"references 'object'.  'callback', if given, is called with a\n"
-"reference to the proxy when 'object' is about to be finalized.");
-
-static PyObject *
-weakref_proxy(PyObject *self, PyObject *args)
-{
-    PyObject *object;
-    PyObject *callback = NULL;
-    PyObject *result = NULL;
-
-    if (PyArg_UnpackTuple(args, "proxy", 1, 2, &object, &callback)) {
-        result = PyWeakref_NewProxy(object, callback);
-    }
-    return result;
+PyDoc_STRVAR(weakref_ref__doc__,
+"ref(object) -- returns a weakref for 'object'.");
+
+static PyObject *
+weakref_ref(PyObject *self, PyObject *object)
+{
+    return PyWeakref_NewRef(object, NULL);
+}
+
+PyDoc_STRVAR(weakref_bind__doc__,
+"bind(object, value) -- returns a weakbinding for 'object' and 'value'.");
+
+static PyObject *
+weakref_bind(PyObject *self, PyObject *args)
+{
+    PyObject *object, *value;
+
+    if (!PyArg_ParseTuple(args, "OO:bind", &object, &value))
+        return NULL;
+
+    return PyWeakref_NewBinding(object, value);
 }
 
 
 static PyMethodDef
 weakref_functions[] =  {
-    {"getweakrefcount", weakref_getweakrefcount,        METH_O,
-     weakref_getweakrefcount__doc__},
-    {"getweakrefs",     weakref_getweakrefs,            METH_O,
-     weakref_getweakrefs__doc__},
-    {"proxy",           weakref_proxy,                  METH_VARARGS,
-     weakref_proxy__doc__},
+    {"ref",            weakref_ref,                    METH_O | METH_SHARED,
+     weakref_ref__doc__},
+    {"bind",           weakref_bind,                   METH_VARARGS | METH_SHARED,
+     weakref_bind__doc__},
     {NULL, NULL, 0, NULL}
 };
 
@@ -93,20 +40,19 @@
 {
     PyObject *m;
 
-    m = Py_InitModule3("_weakref", weakref_functions,
-                       "Weak-reference support module.");
+    m = Py_InitModule5("_weakref", weakref_functions,
+        "Weak-reference support module.", NULL, PYTHON_API_VERSION, 1);
     if (m != NULL) {
-        Py_INCREF(&_PyWeakref_RefType);
-        PyModule_AddObject(m, "ref",
-                           (PyObject *) &_PyWeakref_RefType);
-        Py_INCREF(&_PyWeakref_RefType);
+        Py_INCREF(&_PyWeakref_Type);
         PyModule_AddObject(m, "ReferenceType",
-                           (PyObject *) &_PyWeakref_RefType);
-        Py_INCREF(&_PyWeakref_ProxyType);
-        PyModule_AddObject(m, "ProxyType",
-                           (PyObject *) &_PyWeakref_ProxyType);
-        Py_INCREF(&_PyWeakref_CallableProxyType);
-        PyModule_AddObject(m, "CallableProxyType",
-                           (PyObject *) &_PyWeakref_CallableProxyType);
+            (PyObject *)&_PyWeakref_Type);
+
+        Py_INCREF(&_PyDeathQueue_Type);
+        PyModule_AddObject(m, "DeathQueueType",
+            (PyObject *)&_PyDeathQueue_Type);
+
+        Py_INCREF(&_PyWeakBinding_Type);
+        PyModule_AddObject(m, "WeakBindingType",
+            (PyObject *)&_PyWeakBinding_Type);
     }
 }

=== modified file 'Modules/arraymodule.c'
--- Modules/arraymodule.c	2008-02-01 11:30:18 +0000
+++ Modules/arraymodule.c	2008-03-24 04:28:04 +0000
@@ -417,7 +417,7 @@
 	if (nbytes / descr->itemsize != (size_t)size) {
 		return PyErr_NoMemory();
 	}
-	op = (arrayobject *) type->tp_alloc(type, 0);
+	op = PyObject_New(type);
 	if (op == NULL) {
 		return NULL;
 	}
@@ -484,11 +484,9 @@
 static void
 array_dealloc(arrayobject *op)
 {
-	if (op->weakreflist != NULL)
-		PyObject_ClearWeakRefs((PyObject *) op);
 	if (op->ob_item != NULL)
 		PyMem_DEL(op->ob_item);
-	Py_TYPE(op)->tp_free((PyObject *)op);
+	PyObject_Del(op);
 }
 
 static PyObject *
@@ -2056,9 +2054,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	PyType_GenericAlloc,			/* tp_alloc */
 	array_new,				/* tp_new */
-	PyObject_Del,				/* tp_free */
 };
 
 
@@ -2085,7 +2081,7 @@
 		return NULL;
 	}
 
-	it = PyObject_GC_New(arrayiterobject, &PyArrayIter_Type);
+	it = PyObject_New(&PyArrayIter_Type);
 	if (it == NULL)
 		return NULL;
 
@@ -2093,7 +2089,6 @@
 	it->ao = ao;
 	it->index = 0;
 	it->getitem = ao->ob_descr->getitem;
-	PyObject_GC_Track(it);
 	return (PyObject *)it;
 }
 
@@ -2109,9 +2104,8 @@
 static void
 arrayiter_dealloc(arrayiterobject *it)
 {
-	PyObject_GC_UnTrack(it);
 	Py_XDECREF(it->ao);
-	PyObject_GC_Del(it);
+	PyObject_Del(it);
 }
 
 static int

=== modified file 'Modules/atexitmodule.c'
--- Modules/atexitmodule.c	2007-08-06 20:59:28 +0000
+++ Modules/atexitmodule.c	2008-04-11 05:44:32 +0000
@@ -78,8 +78,10 @@
 void
 atexit_cleanup(void)
 {
-    PyObject *r = atexit_clear(NULL);
-    Py_DECREF(r);
+    // This is called after the interpreter is torn down, so it's too
+    // late to delete python objects
+    //PyObject *r = atexit_clear(NULL);
+    //Py_DECREF(r);
 }
 
 /* ===================================================================== */

=== modified file 'Modules/bz2module.c'
--- Modules/bz2module.c	2007-12-19 02:45:37 +0000
+++ Modules/bz2module.c	2008-03-24 04:28:04 +0000
@@ -78,8 +78,8 @@
 
 
 #ifdef WITH_THREAD
-#define ACQUIRE_LOCK(obj) PyThread_acquire_lock(obj->lock, 1)
-#define RELEASE_LOCK(obj) PyThread_release_lock(obj->lock)
+#define ACQUIRE_LOCK(obj) PyThread_lock_acquire(obj->lock)
+#define RELEASE_LOCK(obj) PyThread_lock_release(obj->lock)
 #else
 #define ACQUIRE_LOCK(obj)
 #define RELEASE_LOCK(obj)
@@ -107,7 +107,7 @@
 	Py_off_t pos;
 	Py_off_t size;
 #ifdef WITH_THREAD
-	PyThread_type_lock lock;
+	PyThread_type_lock *lock;
 #endif
 } BZ2FileObject;
 
@@ -116,7 +116,7 @@
 	bz_stream bzs;
 	int running;
 #ifdef WITH_THREAD
-	PyThread_type_lock lock;
+	PyThread_type_lock *lock;
 #endif
 } BZ2CompObject;
 
@@ -126,7 +126,7 @@
 	int running;
 	PyObject *unused_data;
 #ifdef WITH_THREAD
-	PyThread_type_lock lock;
+	PyThread_type_lock *lock;
 #endif
 } BZ2DecompObject;
 
@@ -1184,7 +1184,7 @@
 	 * instead of returning */
 
 #ifdef WITH_THREAD
-	self->lock = PyThread_allocate_lock();
+	self->lock = PyThread_lock_allocate();
 	if (!self->lock) {
 		PyErr_SetString(PyExc_MemoryError, "unable to allocate lock");
 		goto error;
@@ -1212,7 +1212,7 @@
 	self->rawfp = NULL;
 #ifdef WITH_THREAD
 	if (self->lock) {
-		PyThread_free_lock(self->lock);
+		PyThread_lock_free(self->lock);
 		self->lock = NULL;
 	}
 #endif
@@ -1225,7 +1225,7 @@
 	int bzerror;
 #ifdef WITH_THREAD
 	if (self->lock)
-		PyThread_free_lock(self->lock);
+		PyThread_lock_free(self->lock);
 #endif
 	switch (self->mode) {
 		case MODE_READ:
@@ -1240,7 +1240,7 @@
 	Util_DropReadAhead(self);
 	if (self->rawfp != NULL)
 		fclose(self->rawfp);
-	Py_TYPE(self)->tp_free((PyObject *)self);
+	PyObject_Del(self);
 }
 
 /* This is a hacked version of Python's fileobject.c:file_getiter(). */
@@ -1329,9 +1329,7 @@
         0,                      /*tp_descr_set*/
         0,                      /*tp_dictoffset*/
         (initproc)BZ2File_init, /*tp_init*/
-        PyType_GenericAlloc,    /*tp_alloc*/
         PyType_GenericNew,      /*tp_new*/
-      	PyObject_Free,          /*tp_free*/
         0,                      /*tp_is_gc*/
 };
 
@@ -1517,7 +1515,7 @@
 	}
 
 #ifdef WITH_THREAD
-	self->lock = PyThread_allocate_lock();
+	self->lock = PyThread_lock_allocate();
 	if (!self->lock) {
 		PyErr_SetString(PyExc_MemoryError, "unable to allocate lock");
 		goto error;
@@ -1537,7 +1535,7 @@
 error:
 #ifdef WITH_THREAD
 	if (self->lock) {
-		PyThread_free_lock(self->lock);
+		PyThread_lock_free(self->lock);
 		self->lock = NULL;
 	}
 #endif
@@ -1549,10 +1547,10 @@
 {
 #ifdef WITH_THREAD
 	if (self->lock)
-		PyThread_free_lock(self->lock);
+		PyThread_lock_free(self->lock);
 #endif
 	BZ2_bzCompressEnd(&self->bzs);
-	Py_TYPE(self)->tp_free((PyObject *)self);
+	PyObject_Del(self);
 }
 
 
@@ -1605,9 +1603,7 @@
         0,                      /*tp_descr_set*/
         0,                      /*tp_dictoffset*/
         (initproc)BZ2Comp_init, /*tp_init*/
-        PyType_GenericAlloc,    /*tp_alloc*/
         PyType_GenericNew,      /*tp_new*/
-      	PyObject_Free,          /*tp_free*/
         0,                      /*tp_is_gc*/
 };
 
@@ -1735,7 +1731,7 @@
 		return -1;
 
 #ifdef WITH_THREAD
-	self->lock = PyThread_allocate_lock();
+	self->lock = PyThread_lock_allocate();
 	if (!self->lock) {
 		PyErr_SetString(PyExc_MemoryError, "unable to allocate lock");
 		goto error;
@@ -1760,7 +1756,7 @@
 error:
 #ifdef WITH_THREAD
 	if (self->lock) {
-		PyThread_free_lock(self->lock);
+		PyThread_lock_free(self->lock);
 		self->lock = NULL;
 	}
 #endif
@@ -1773,11 +1769,11 @@
 {
 #ifdef WITH_THREAD
 	if (self->lock)
-		PyThread_free_lock(self->lock);
+		PyThread_lock_free(self->lock);
 #endif
 	Py_XDECREF(self->unused_data);
 	BZ2_bzDecompressEnd(&self->bzs);
-	Py_TYPE(self)->tp_free((PyObject *)self);
+	PyObject_Del(self);
 }
 
 
@@ -1829,9 +1825,7 @@
         0,                      /*tp_descr_set*/
         0,                      /*tp_dictoffset*/
         (initproc)BZ2Decomp_init, /*tp_init*/
-        PyType_GenericAlloc,    /*tp_alloc*/
         PyType_GenericNew,      /*tp_new*/
-      	PyObject_Free,          /*tp_free*/
         0,                      /*tp_is_gc*/
 };
 

=== modified file 'Modules/cjkcodecs/multibytecodec.c'
--- Modules/cjkcodecs/multibytecodec.c	2007-12-19 02:45:37 +0000
+++ Modules/cjkcodecs/multibytecodec.c	2008-03-24 04:28:04 +0000
@@ -903,7 +903,7 @@
 					 incnewkwarglist, &errors))
 		return NULL;
 
-	self = (MultibyteIncrementalEncoderObject *)type->tp_alloc(type, 0);
+	self = PyObject_New(type);
 	if (self == NULL)
 		return NULL;
 
@@ -951,9 +951,8 @@
 static void
 mbiencoder_dealloc(MultibyteIncrementalEncoderObject *self)
 {
-	PyObject_GC_UnTrack(self);
 	ERROR_DECREF(self->errors);
-	Py_TYPE(self)->tp_free(self);
+	PyObject_Del(self);
 }
 
 static PyTypeObject MultibyteIncrementalEncoder_Type = {
@@ -995,7 +994,6 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	mbiencoder_init,		/* tp_init */
-	0,				/* tp_alloc */
 	mbiencoder_new,			/* tp_new */
 };
 
@@ -1103,7 +1101,7 @@
 					 incnewkwarglist, &errors))
 		return NULL;
 
-	self = (MultibyteIncrementalDecoderObject *)type->tp_alloc(type, 0);
+	self = PyObject_New(type);
 	if (self == NULL)
 		return NULL;
 
@@ -1151,9 +1149,8 @@
 static void
 mbidecoder_dealloc(MultibyteIncrementalDecoderObject *self)
 {
-	PyObject_GC_UnTrack(self);
 	ERROR_DECREF(self->errors);
-	Py_TYPE(self)->tp_free(self);
+	PyObject_Del(self);
 }
 
 static PyTypeObject MultibyteIncrementalDecoder_Type = {
@@ -1195,7 +1192,6 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	mbidecoder_init,		/* tp_init */
-	0,				/* tp_alloc */
 	mbidecoder_new,			/* tp_new */
 };
 
@@ -1425,7 +1421,7 @@
 				streamkwarglist, &stream, &errors))
 		return NULL;
 
-	self = (MultibyteStreamReaderObject *)type->tp_alloc(type, 0);
+	self = PyObject_New(type);
 	if (self == NULL)
 		return NULL;
 
@@ -1476,10 +1472,9 @@
 static void
 mbstreamreader_dealloc(MultibyteStreamReaderObject *self)
 {
-	PyObject_GC_UnTrack(self);
 	ERROR_DECREF(self->errors);
 	Py_DECREF(self->stream);
-	Py_TYPE(self)->tp_free(self);
+	PyObject_Del(self);
 }
 
 static PyTypeObject MultibyteStreamReader_Type = {
@@ -1521,7 +1516,6 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	mbstreamreader_init,		/* tp_init */
-	0,				/* tp_alloc */
 	mbstreamreader_new,		/* tp_new */
 };
 
@@ -1628,7 +1622,7 @@
 				streamkwarglist, &stream, &errors))
 		return NULL;
 
-	self = (MultibyteStreamWriterObject *)type->tp_alloc(type, 0);
+	self = PyObject_New(type);
 	if (self == NULL)
 		return NULL;
 
@@ -1679,10 +1673,9 @@
 static void
 mbstreamwriter_dealloc(MultibyteStreamWriterObject *self)
 {
-	PyObject_GC_UnTrack(self);
 	ERROR_DECREF(self->errors);
 	Py_DECREF(self->stream);
-	Py_TYPE(self)->tp_free(self);
+	PyObject_Del(self);
 }
 
 static struct PyMethodDef mbstreamwriter_methods[] = {
@@ -1741,7 +1734,6 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	mbstreamwriter_init,		/* tp_init */
-	0,				/* tp_alloc */
 	mbstreamwriter_new,		/* tp_new */
 };
 
@@ -1765,7 +1757,7 @@
 	if (codec->codecinit != NULL && codec->codecinit(codec->config) != 0)
 		return NULL;
 
-	self = PyObject_New(MultibyteCodecObject, &MultibyteCodec_Type);
+	self = PyObject_New(&MultibyteCodec_Type);
 	if (self == NULL)
 		return NULL;
 	self->codec = codec;

=== modified file 'Modules/datetimemodule.c'
--- Modules/datetimemodule.c	2008-03-18 15:15:01 +0000
+++ Modules/datetimemodule.c	2008-04-11 02:07:11 +0000
@@ -576,56 +576,6 @@
 	return normalize_date(year, month, day);
 }
 
-/* ---------------------------------------------------------------------------
- * Basic object allocation:  tp_alloc implementations.  These allocate
- * Python objects of the right size and type, and do the Python object-
- * initialization bit.  If there's not enough memory, they return NULL after
- * setting MemoryError.  All data members remain uninitialized trash.
- *
- * We abuse the tp_alloc "nitems" argument to communicate whether a tzinfo
- * member is needed.  This is ugly, imprecise, and possibly insecure.
- * tp_basicsize for the time and datetime types is set to the size of the
- * struct that has room for the tzinfo member, so subclasses in Python will
- * allocate enough space for a tzinfo member whether or not one is actually
- * needed.  That's the "ugly and imprecise" parts.  The "possibly insecure"
- * part is that PyType_GenericAlloc() (which subclasses in Python end up
- * using) just happens today to effectively ignore the nitems argument
- * when tp_itemsize is 0, which it is for these type objects.  If that
- * changes, perhaps the callers of tp_alloc slots in this file should
- * be changed to force a 0 nitems argument unless the type being allocated
- * is a base type implemented in this file (so that tp_alloc is time_alloc
- * or datetime_alloc below, which know about the nitems abuse).
- */
-
-static PyObject *
-time_alloc(PyTypeObject *type, Py_ssize_t aware)
-{
-	PyObject *self;
-
-	self = (PyObject *)
-		PyObject_MALLOC(aware ?
-				sizeof(PyDateTime_Time) :
-				sizeof(_PyDateTime_BaseTime));
-	if (self == NULL)
-		return (PyObject *)PyErr_NoMemory();
-	PyObject_INIT(self, type);
-	return self;
-}
-
-static PyObject *
-datetime_alloc(PyTypeObject *type, Py_ssize_t aware)
-{
-	PyObject *self;
-
-	self = (PyObject *)
-		PyObject_MALLOC(aware ?
-				sizeof(PyDateTime_DateTime) :
-				sizeof(_PyDateTime_BaseDateTime));
-	if (self == NULL)
-		return (PyObject *)PyErr_NoMemory();
-	PyObject_INIT(self, type);
-	return self;
-}
 
 /* ---------------------------------------------------------------------------
  * Helpers for setting object fields.  These work on pointers to the
@@ -652,7 +602,7 @@
 {
 	PyDateTime_Date *self;
 
-	self = (PyDateTime_Date *) (type->tp_alloc(type, 0));
+	self = PyObject_New(type);
 	if (self != NULL)
 		set_date_fields(self, year, month, day);
 	return (PyObject *) self;
@@ -669,7 +619,7 @@
 	PyDateTime_DateTime *self;
 	char aware = tzinfo != Py_None;
 
-	self = (PyDateTime_DateTime *) (type->tp_alloc(type, aware));
+	self = PyObject_New(type);
 	if (self != NULL) {
 		self->hastzinfo = aware;
 		set_date_fields((PyDateTime_Date *)self, year, month, day);
@@ -697,7 +647,7 @@
 	PyDateTime_Time *self;
 	char aware = tzinfo != Py_None;
 
-	self = (PyDateTime_Time *) (type->tp_alloc(type, aware));
+	self = PyObject_New(type);
 	if (self != NULL) {
 		self->hastzinfo = aware;
 		self->hashcode = -1;
@@ -736,7 +686,7 @@
  	if (check_delta_day_range(days) < 0)
  		return NULL;
 
-	self = (PyDateTime_Delta *) (type->tp_alloc(type, 0));
+	self = PyObject_New(type);
 	if (self != NULL) {
 		self->hashcode = -1;
 		SET_TD_DAYS(self, days);
@@ -2163,9 +2113,7 @@
 	0,						/* tp_descr_set */
 	0,						/* tp_dictoffset */
 	0,						/* tp_init */
-	0,						/* tp_alloc */
 	delta_new,					/* tp_new */
-	0,						/* tp_free */
 };
 
 /*
@@ -2220,7 +2168,7 @@
 	{
 	    	PyDateTime_Date *me;
 
-		me = (PyDateTime_Date *) (type->tp_alloc(type, 0));
+		me = PyObject_New(type);
 		if (me != NULL) {
 			char *pdata = PyString_AS_STRING(state);
 			memcpy(me->data, pdata, _PyDateTime_DATE_DATASIZE);
@@ -2734,9 +2682,7 @@
 	0,						/* tp_descr_set */
 	0,						/* tp_dictoffset */
 	0,						/* tp_init */
-	0,						/* tp_alloc */
 	date_new,					/* tp_new */
-	0,						/* tp_free */
 };
 
 /*
@@ -2988,9 +2934,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	PyType_GenericNew,			/* tp_new */
-	0,					/* tp_free */
 };
 
 /*
@@ -3079,7 +3023,7 @@
 			}
 		}
 		aware = (char)(tzinfo != Py_None);
-		me = (PyDateTime_Time *) (type->tp_alloc(type, aware));
+		me = PyObject_New(type);
 		if (me != NULL) {
 			char *pdata = PyString_AS_STRING(state);
 
@@ -3117,7 +3061,7 @@
 	if (HASTZINFO(self)) {
 		Py_XDECREF(self->tzinfo);
 	}
-	Py_TYPE(self)->tp_free((PyObject *)self);
+	PyObject_Del(self);
 }
 
 /*
@@ -3502,9 +3446,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	time_alloc,				/* tp_alloc */
 	time_new,				/* tp_new */
-	0,					/* tp_free */
 };
 
 /*
@@ -3598,7 +3540,7 @@
 			}
 		}
 		aware = (char)(tzinfo != Py_None);
-		me = (PyDateTime_DateTime *) (type->tp_alloc(type , aware));
+		me = PyObject_New(type);
 		if (me != NULL) {
 			char *pdata = PyString_AS_STRING(state);
 
@@ -3941,7 +3883,7 @@
 	if (HASTZINFO(self)) {
 		Py_XDECREF(self->tzinfo);
 	}
-	Py_TYPE(self)->tp_free((PyObject *)self);
+	PyObject_Del(self);
 }
 
 /*
@@ -4630,9 +4572,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	datetime_alloc,				/* tp_alloc */
 	datetime_new,				/* tp_new */
-	0,					/* tp_free */
 };
 
 /* ---------------------------------------------------------------------------

=== modified file 'Modules/dbmmodule.c'
--- Modules/dbmmodule.c	2008-02-26 08:18:30 +0000
+++ Modules/dbmmodule.c	2008-03-24 04:28:04 +0000
@@ -48,7 +48,7 @@
 {
         dbmobject *dp;
 
-	dp = PyObject_New(dbmobject, &Dbmtype);
+	dp = PyObject_New(&Dbmtype);
 	if (dp == NULL)
 		return NULL;
 	dp->di_size = -1;

=== modified file 'Modules/gcmodule.c'
--- Modules/gcmodule.c	2008-02-16 07:38:31 +0000
+++ Modules/gcmodule.c	2008-04-03 19:01:32 +0000
@@ -19,50 +19,67 @@
 */
 
 #include "Python.h"
-#include "frameobject.h"	/* for PyFrame_ClearFreeList */
-
+#include "pythread.h"
+
+#define GC_MAX_DEALLOC_DEPTH 50
+
+#if 0
 /* Get an object's GC head */
 #define AS_GC(o) ((PyGC_Head *)(o)-1)
 
 /* Get the object given the GC head */
 #define FROM_GC(g) ((PyObject *)(((PyGC_Head *)g)+1))
+#else
+#define AS_GC
+#define FROM_GC
+#endif
 
 /*** Global GC state ***/
 
 struct gc_generation {
 	PyGC_Head head;
 	int threshold; /* collection threshold */
-	int count; /* count of allocations or collections of younger
-		      generations */
+	int count;  /* For generation[0] the count is the number of new
+		     * allocations.  For other generations count is the
+		     * number of collections done of lower generations. */
 };
 
 #define NUM_GENERATIONS 3
 #define GEN_HEAD(n) (&generations[n].head)
 
-/* linked lists of container objects */
-static struct gc_generation generations[NUM_GENERATIONS] = {
-	/* PyGC_Head,				threshold,	count */
-	{{{GEN_HEAD(0), GEN_HEAD(0), 0}},	700,		0},
-	{{{GEN_HEAD(1), GEN_HEAD(1), 0}},	10,		0},
-	{{{GEN_HEAD(2), GEN_HEAD(2), 0}},	10,		0},
-};
+#if 0
+/* linked lists of container objects */
+static struct gc_generation generations[NUM_GENERATIONS] = {
+	/* PyGC_Head,				threshold,	count */
+	{{{0, GEN_HEAD(0), GEN_HEAD(0), 0}},	700,		0},
+	{{{0, GEN_HEAD(1), GEN_HEAD(1), 0}},	10,		0},
+	{{{0, GEN_HEAD(2), GEN_HEAD(2), 0}},	10,		0},
+};
+#else
+/* linked lists of container objects */
+static struct gc_generation generations[NUM_GENERATIONS] = {
+	/* PyGC_Head,				threshold,	count */
+	{{GEN_HEAD(0), GEN_HEAD(0), 0, 0, 0, 0, NULL},	700,		0},
+	{{GEN_HEAD(1), GEN_HEAD(1), 0, 0, 0, 0, NULL},	10,		0},
+	{{GEN_HEAD(2), GEN_HEAD(2), 0, 0, 0, 0, NULL},	10,		0},
+};
+#endif
 
 PyGC_Head *_PyGC_generation0 = GEN_HEAD(0);
 
+PyGC_Head trashcan = {&trashcan, &trashcan, 0, 0, 0, 0, NULL};
+
 static int enabled = 1; /* automatic collection enabled? */
 
 /* true if we are currently running the collector */
 static int collecting = 0;
 
+/* True if asynchronous refcounting has been used */
+static AO_t gone_asynchronous = 0;
+
 /* list of uncollectable objects */
 static PyObject *garbage = NULL;
 
-/* Python string to use if unhandled exception occurs */
-static PyObject *gc_str = NULL;
-
-/* Python string used to look for __del__ attribute. */
-static PyObject *delstr = NULL;
-
 /* set for debugging information */
 #define DEBUG_STATS		(1<<0) /* print collection statistics */
 #define DEBUG_COLLECTABLE	(1<<1) /* print collectable objects */
@@ -74,6 +91,8 @@
 static int debug;
 static PyObject *tmod = NULL;
 
+static PyThread_type_lock *PyGC_lock;
+
 /*--------------------------------------------------------------------------
 gc_refs values.
 
@@ -81,12 +100,12 @@
 
 GC_UNTRACKED
     The initial state; objects returned by PyObject_GC_Malloc are in this
-    state.  The object doesn't live in any generation list, and its
-    tp_traverse slot must not be called.
+    state.  The object doesn't live in any generation list, and
+    gc_traverse must not be called.
 
 GC_REACHABLE
-    The object lives in some generation list, and its tp_traverse is safe to
-    call.  An object transitions to GC_REACHABLE when PyObject_GC_Track
+    The object lives in some generation list, and gc_traverse is safe to
+    call.  An object transitions to GC_REACHABLE when GC_Track
     is called.
 
 During a collection, gc_refs can temporarily take on other states:
@@ -113,50 +132,94 @@
     it has a __del__ method), its gc_refs is restored to GC_REACHABLE again.
 ----------------------------------------------------------------------------
 */
-#define GC_UNTRACKED			_PyGC_REFS_UNTRACKED
-#define GC_REACHABLE			_PyGC_REFS_REACHABLE
-#define GC_TENTATIVELY_UNREACHABLE	_PyGC_REFS_TENTATIVELY_UNREACHABLE
-
-#define IS_TRACKED(o) ((AS_GC(o))->gc.gc_refs != GC_UNTRACKED)
-#define IS_REACHABLE(o) ((AS_GC(o))->gc.gc_refs == GC_REACHABLE)
-#define IS_TENTATIVELY_UNREACHABLE(o) ( \
-	(AS_GC(o))->gc.gc_refs == GC_TENTATIVELY_UNREACHABLE)
+#define GC_TRACKED              _PyGC_REFS_TRACKED
+#define GC_TRACKED_YOUNG        _PyGC_REFS_TRACKED_YOUNG
+#define GC_UNTRACKED            _PyGC_REFS_UNTRACKED
+#define GC_UNTRACKED_YOUNG      _PyGC_REFS_UNTRACKED_YOUNG
+
+static int
+is_tracked(PyObject *o)
+{
+    if (o->ob_refcnt_trace == GC_TRACKED ||
+            o->ob_refcnt_trace == GC_TRACKED_YOUNG)
+        return 1;
+    else if (o->ob_refcnt_trace == GC_UNTRACKED ||
+            o->ob_refcnt_trace == GC_UNTRACKED_YOUNG)
+        return 0;
+    else
+        Py_FatalError("is_tracked called on object in bad state");
+}
+
+static int
+is_young(PyObject *o)
+{
+    if (o->ob_refcnt_trace == GC_TRACKED_YOUNG ||
+            o->ob_refcnt_trace == GC_UNTRACKED_YOUNG)
+        return 1;
+    else if (o->ob_refcnt_trace == GC_TRACKED ||
+            o->ob_refcnt_trace == GC_UNTRACKED)
+        return 0;
+    else
+        Py_FatalError("is_young called on object in bad state");
+}
+
+static void
+gc_track(PyObject *o)
+{
+    if (is_tracked(o))
+        Py_FatalError("object already tracked");
+
+    if (is_young(o))
+        o->ob_refcnt_trace = GC_TRACKED_YOUNG;
+    else
+        o->ob_refcnt_trace = GC_TRACKED;
+}
+
+static void
+gc_untrack(PyObject *o)
+{
+    if (!is_tracked(o))
+        Py_FatalError("object already not tracked");
+
+    if (is_young(o))
+        o->ob_refcnt_trace = GC_UNTRACKED_YOUNG;
+    else
+        o->ob_refcnt_trace = GC_UNTRACKED;
+}
+
 
 /*** list functions ***/
 
 static void
 gc_list_init(PyGC_Head *list)
 {
-	list->gc.gc_prev = list;
-	list->gc.gc_next = list;
+	list->ob_prev = list;
+	list->ob_next = list;
 }
 
 static int
 gc_list_is_empty(PyGC_Head *list)
 {
-	return (list->gc.gc_next == list);
+	return (list->ob_next == list);
 }
 
-#if 0
-/* This became unused after gc_list_move() was introduced. */
 /* Append `node` to `list`. */
 static void
 gc_list_append(PyGC_Head *node, PyGC_Head *list)
 {
-	node->gc.gc_next = list;
-	node->gc.gc_prev = list->gc.gc_prev;
-	node->gc.gc_prev->gc.gc_next = node;
-	list->gc.gc_prev = node;
+	node->ob_next = list;
+	node->ob_prev = list->ob_prev;
+	node->ob_prev->ob_next = node;
+	list->ob_prev = node;
 }
-#endif
 
 /* Remove `node` from the gc list it's currently in. */
 static void
 gc_list_remove(PyGC_Head *node)
 {
-	node->gc.gc_prev->gc.gc_next = node->gc.gc_next;
-	node->gc.gc_next->gc.gc_prev = node->gc.gc_prev;
-	node->gc.gc_next = NULL; /* object is not currently tracked */
+	node->ob_prev->ob_next = node->ob_next;
+	node->ob_next->ob_prev = node->ob_prev;
+	node->ob_next = NULL; /* object is not currently tracked */
 }
 
 /* Move `node` from the gc list it's currently in (which is not explicitly
@@ -167,15 +230,15 @@
 gc_list_move(PyGC_Head *node, PyGC_Head *list)
 {
 	PyGC_Head *new_prev;
-	PyGC_Head *current_prev = node->gc.gc_prev;
-	PyGC_Head *current_next = node->gc.gc_next;
+	PyGC_Head *current_prev = node->ob_prev;
+	PyGC_Head *current_next = node->ob_next;
 	/* Unlink from current list. */
-	current_prev->gc.gc_next = current_next;
-	current_next->gc.gc_prev = current_prev;
+	current_prev->ob_next = current_next;
+	current_next->ob_prev = current_prev;
 	/* Relink at end of new list. */
-	new_prev = node->gc.gc_prev = list->gc.gc_prev;
-	new_prev->gc.gc_next = list->gc.gc_prev = node;
-	node->gc.gc_next = list;
+	new_prev = node->ob_prev = list->ob_prev;
+	new_prev->ob_next = list->ob_prev = node;
+	node->ob_next = list;
 }
 
 /* append list `from` onto list `to`; `from` becomes an empty list */
@@ -185,11 +248,11 @@
 	PyGC_Head *tail;
 	assert(from != to);
 	if (!gc_list_is_empty(from)) {
-		tail = to->gc.gc_prev;
-		tail->gc.gc_next = from->gc.gc_next;
-		tail->gc.gc_next->gc.gc_prev = tail;
-		to->gc.gc_prev = from->gc.gc_prev;
-		to->gc.gc_prev->gc.gc_next = to;
+		tail = to->ob_prev;
+		tail->ob_next = from->ob_next;
+		tail->ob_next->ob_prev = tail;
+		to->ob_prev = from->ob_prev;
+		to->ob_prev->ob_next = to;
 	}
 	gc_list_init(from);
 }
@@ -199,7 +262,7 @@
 {
 	PyGC_Head *gc;
 	Py_ssize_t n = 0;
-	for (gc = list->gc.gc_next; gc != list; gc = gc->gc.gc_next) {
+	for (gc = list->ob_next; gc != list; gc = gc->ob_next) {
 		n++;
 	}
 	return n;
@@ -212,7 +275,7 @@
 append_objects(PyObject *py_list, PyGC_Head *gc_list)
 {
 	PyGC_Head *gc;
-	for (gc = gc_list->gc.gc_next; gc != gc_list; gc = gc->gc.gc_next) {
+	for (gc = gc_list->ob_next; gc != gc_list; gc = gc->ob_next) {
 		PyObject *op = FROM_GC(gc);
 		if (op != py_list) {
 			if (PyList_Append(py_list, op)) {
@@ -226,55 +289,116 @@
 /*** end of list stuff ***/
 
 
-/* Set all gc_refs = ob_refcnt.  After this, gc_refs is > 0 for all objects
- * in containers, and is GC_REACHABLE for all tracked gc objects not in
- * containers.
- */
-static void
-update_refs(PyGC_Head *containers)
-{
-	PyGC_Head *gc = containers->gc.gc_next;
-	for (; gc != containers; gc = gc->gc.gc_next) {
-		assert(gc->gc.gc_refs == GC_REACHABLE);
-		gc->gc.gc_refs = Py_REFCNT(FROM_GC(gc));
-		/* Python's cyclic gc should never see an incoming refcount
-		 * of 0:  if something decref'ed to 0, it should have been
-		 * deallocated immediately at that time.
-		 * Possible cause (if the assert triggers):  a tp_dealloc
-		 * routine left a gc-aware object tracked during its teardown
-		 * phase, and did something-- or allowed something to happen --
-		 * that called back into Python.  gc can trigger then, and may
-		 * see the still-tracked dying object.  Before this assert
-		 * was added, such mistakes went on to allow gc to try to
-		 * delete the object again.  In a debug build, that caused
-		 * a mysterious segfault, when _Py_ForgetReference tried
-		 * to remove the object from the doubly-linked list of all
-		 * objects a second time.  In a release build, an actual
-		 * double deallocation occurred, which leads to corruption
-		 * of the allocator's internal bookkeeping pointers.  That's
-		 * so serious that maybe this should be a release-build
-		 * check instead of an assert?
-		 */
-		assert(gc->gc.gc_refs != 0);
-	}
+static void
+gc_traverse(PyObject *ob, visitproc func, void *arg)
+{
+    traverseproc traverse;
+
+    if (PyType_SUPPORTS_WEAKREFS(Py_TYPE(ob))) {
+        PyWeakReference **ptr = _PY_GETWEAKREFPTR(ob);
+        PyWeakReference *ref = (PyWeakReference *)AO_load_full((AO_t *)ptr);
+        if (ref != NULL) {
+            PyWeakBinding *bind = NULL;
+
+            /* Traverse the weakref */
+            if (func((PyObject *)ref, arg) != 0)
+                Py_FatalError("non-zero retval in gc_traverse");
+
+            while (PyLinkedList_Next(&ref->binding_links, &bind)) {
+                if (bind->value == NULL)
+                    continue;
+
+                /* Traverse a binding's value (which is really owned by ob) */
+                if (func(bind->value, arg) != 0)
+                    Py_FatalError("non-zero retval in gc_traverse");
+            }
+
+        }
+    }
+
+    /* Traverse the rest of ob */
+    traverse = Py_TYPE(ob)->tp_traverse;
+    if (traverse && traverse(ob, func, arg) != 0)
+        Py_FatalError("non-zero retval in gc_traverse");
+}
+
+static void
+gc_clear(PyObject *ob)
+{
+    inquiry clear = Py_TYPE(ob)->tp_clear;
+
+    /* clear functions need a borrowed reference to ob.  Since they may
+     * remove the reference that's currently in a cycle, we make sure
+     * to create our own */
+    Py_INCREF(ob);
+
+    if (PyType_SUPPORTS_WEAKREFS(Py_TYPE(ob)))
+        _PyObject_ForceClearWeakref(ob);
+
+    if (clear != NULL)
+        clear(ob);
+
+    Py_DECREF(ob);
+}
+
+
+static void
+flush_asynchronous(PyGC_Head *list)
+{
+    PyGC_Head asyncdelete;
+    PyObject *ob, *next;
+
+    gc_list_init(&asyncdelete);
+    _PyState_FlushAsyncRefcounts();
+
+    /* Separate objects with a refcount of 0 */
+    for (ob = list->ob_next; ob != list; ob = next) {
+        next = ob->ob_next;
+
+        ob->ob_refowner = Py_REFOWNER_STATICINIT;
+
+        if (ob->ob_refcnt == 0) {
+            Py_INCREF(ob);
+            gc_list_move(ob, &asyncdelete);
+        }
+    }
+
+    /* Delete them */
+    while (asyncdelete.ob_next != &asyncdelete) {
+        ob = asyncdelete.ob_next;
+
+        gc_list_move(ob, list);
+        Py_DECREF(ob);
+    }
+}
+
+static void
+set_refcnt_trace(PyGC_Head *list, PyGC_Head *old)
+{
+    PyObject *ob, *next;
+
+    for (ob = list->ob_next; ob != list; ob = next) {
+        next = ob->ob_next;
+
+        if (is_tracked(ob))
+            ob->ob_refcnt_trace = ob->ob_refcnt;
+        else
+            gc_list_move(ob, old);
+    }
 }
 
 /* A traversal callback for subtract_refs. */
 static int
-visit_decref(PyObject *op, void *data)
+visit_decref(PyObject *ob, void *data)
 {
-        assert(op != NULL);
-	if (PyObject_IS_GC(op)) {
-		PyGC_Head *gc = AS_GC(op);
-		/* We're only interested in gc_refs for objects in the
-		 * generation being collected, which can be recognized
-		 * because only they have positive gc_refs.
-		 */
-		assert(gc->gc.gc_refs != 0); /* else refcount was too small */
-		if (gc->gc.gc_refs > 0)
-			gc->gc.gc_refs--;
-	}
-	return 0;
+    assert(ob != NULL);
+
+    if (((Py_ssize_t)ob->ob_refcnt_trace) >= 0) {
+        assert(ob->ob_refcnt_trace != 0);
+        ob->ob_refcnt_trace--;
+    }
+
+    return 0;
 }
 
 /* Subtract internal references from gc_refs.  After this, gc_refs is >= 0
@@ -283,591 +407,187 @@
  * reachable from outside containers, and so can't be collected.
  */
 static void
-subtract_refs(PyGC_Head *containers)
-{
-	traverseproc traverse;
-	PyGC_Head *gc = containers->gc.gc_next;
-	for (; gc != containers; gc=gc->gc.gc_next) {
-		traverse = Py_TYPE(FROM_GC(gc))->tp_traverse;
-		(void) traverse(FROM_GC(gc),
-			       (visitproc)visit_decref,
-			       NULL);
-	}
-}
-
-/* A traversal callback for move_unreachable. */
-static int
-visit_reachable(PyObject *op, PyGC_Head *reachable)
-{
-	if (PyObject_IS_GC(op)) {
-		PyGC_Head *gc = AS_GC(op);
-		const Py_ssize_t gc_refs = gc->gc.gc_refs;
-
-		if (gc_refs == 0) {
-			/* This is in move_unreachable's 'young' list, but
-			 * the traversal hasn't yet gotten to it.  All
-			 * we need to do is tell move_unreachable that it's
-			 * reachable.
-			 */
-			gc->gc.gc_refs = 1;
-		}
-		else if (gc_refs == GC_TENTATIVELY_UNREACHABLE) {
-			/* This had gc_refs = 0 when move_unreachable got
-			 * to it, but turns out it's reachable after all.
-			 * Move it back to move_unreachable's 'young' list,
-			 * and move_unreachable will eventually get to it
-			 * again.
-			 */
-			gc_list_move(gc, reachable);
-			gc->gc.gc_refs = 1;
-		}
-		/* Else there's nothing to do.
-		 * If gc_refs > 0, it must be in move_unreachable's 'young'
-		 * list, and move_unreachable will eventually get to it.
-		 * If gc_refs == GC_REACHABLE, it's either in some other
-		 * generation so we don't care about it, or move_unreachable
-		 * already dealt with it.
-		 * If gc_refs == GC_UNTRACKED, it must be ignored.
-		 */
-		 else {
-		 	assert(gc_refs > 0
-		 	       || gc_refs == GC_REACHABLE
-		 	       || gc_refs == GC_UNTRACKED);
-		 }
-	}
-	return 0;
-}
-
-/* Move the unreachable objects from young to unreachable.  After this,
- * all objects in young have gc_refs = GC_REACHABLE, and all objects in
- * unreachable have gc_refs = GC_TENTATIVELY_UNREACHABLE.  All tracked
- * gc objects not in young or unreachable still have gc_refs = GC_REACHABLE.
- * All objects in young after this are directly or indirectly reachable
- * from outside the original young; and all objects in unreachable are
- * not.
- */
-static void
-move_unreachable(PyGC_Head *young, PyGC_Head *unreachable)
-{
-	PyGC_Head *gc = young->gc.gc_next;
-
-	/* Invariants:  all objects "to the left" of us in young have gc_refs
-	 * = GC_REACHABLE, and are indeed reachable (directly or indirectly)
-	 * from outside the young list as it was at entry.  All other objects
-	 * from the original young "to the left" of us are in unreachable now,
-	 * and have gc_refs = GC_TENTATIVELY_UNREACHABLE.  All objects to the
-	 * left of us in 'young' now have been scanned, and no objects here
-	 * or to the right have been scanned yet.
-	 */
-
-	while (gc != young) {
-		PyGC_Head *next;
-
-		if (gc->gc.gc_refs) {
-                        /* gc is definitely reachable from outside the
-                         * original 'young'.  Mark it as such, and traverse
-                         * its pointers to find any other objects that may
-                         * be directly reachable from it.  Note that the
-                         * call to tp_traverse may append objects to young,
-                         * so we have to wait until it returns to determine
-                         * the next object to visit.
-                         */
-                        PyObject *op = FROM_GC(gc);
-                        traverseproc traverse = Py_TYPE(op)->tp_traverse;
-                        assert(gc->gc.gc_refs > 0);
-                        gc->gc.gc_refs = GC_REACHABLE;
-                        (void) traverse(op,
-                                        (visitproc)visit_reachable,
-                                        (void *)young);
-                        next = gc->gc.gc_next;
-		}
-		else {
-			/* This *may* be unreachable.  To make progress,
-			 * assume it is.  gc isn't directly reachable from
-			 * any object we've already traversed, but may be
-			 * reachable from an object we haven't gotten to yet.
-			 * visit_reachable will eventually move gc back into
-			 * young if that's so, and we'll see it again.
-			 */
-			next = gc->gc.gc_next;
-			gc_list_move(gc, unreachable);
-			gc->gc.gc_refs = GC_TENTATIVELY_UNREACHABLE;
-		}
-		gc = next;
-	}
-}
-
-/* Return true if object has a finalization method. */
-static int
-has_finalizer(PyObject *op)
-{
-	if (PyGen_CheckExact(op))
-		return PyGen_NeedsFinalizing((PyGenObject *)op);
-	else
-		return op->ob_type->tp_del != NULL;
-}
-
-/* Move the objects in unreachable with __del__ methods into `finalizers`.
- * Objects moved into `finalizers` have gc_refs set to GC_REACHABLE; the
- * objects remaining in unreachable are left at GC_TENTATIVELY_UNREACHABLE.
- */
-static void
-move_finalizers(PyGC_Head *unreachable, PyGC_Head *finalizers)
-{
-	PyGC_Head *gc;
-	PyGC_Head *next;
-
-	/* March over unreachable.  Move objects with finalizers into
-	 * `finalizers`.
-	 */
-	for (gc = unreachable->gc.gc_next; gc != unreachable; gc = next) {
-		PyObject *op = FROM_GC(gc);
-
-		assert(IS_TENTATIVELY_UNREACHABLE(op));
-		next = gc->gc.gc_next;
-
-		if (has_finalizer(op)) {
-			gc_list_move(gc, finalizers);
-			gc->gc.gc_refs = GC_REACHABLE;
-		}
-	}
-}
-
-/* A traversal callback for move_finalizer_reachable. */
-static int
-visit_move(PyObject *op, PyGC_Head *tolist)
-{
-	if (PyObject_IS_GC(op)) {
-		if (IS_TENTATIVELY_UNREACHABLE(op)) {
-			PyGC_Head *gc = AS_GC(op);
-			gc_list_move(gc, tolist);
-			gc->gc.gc_refs = GC_REACHABLE;
-		}
-	}
-	return 0;
-}
-
-/* Move objects that are reachable from finalizers, from the unreachable set
- * into finalizers set.
- */
-static void
-move_finalizer_reachable(PyGC_Head *finalizers)
-{
-	traverseproc traverse;
-	PyGC_Head *gc = finalizers->gc.gc_next;
-	for (; gc != finalizers; gc = gc->gc.gc_next) {
-		/* Note that the finalizers list may grow during this. */
-		traverse = Py_TYPE(FROM_GC(gc))->tp_traverse;
-		(void) traverse(FROM_GC(gc),
-				(visitproc)visit_move,
-				(void *)finalizers);
-	}
-}
-
-/* Clear all weakrefs to unreachable objects, and if such a weakref has a
- * callback, invoke it if necessary.  Note that it's possible for such
- * weakrefs to be outside the unreachable set -- indeed, those are precisely
- * the weakrefs whose callbacks must be invoked.  See gc_weakref.txt for
- * overview & some details.  Some weakrefs with callbacks may be reclaimed
- * directly by this routine; the number reclaimed is the return value.  Other
- * weakrefs with callbacks may be moved into the `old` generation.  Objects
- * moved into `old` have gc_refs set to GC_REACHABLE; the objects remaining in
- * unreachable are left at GC_TENTATIVELY_UNREACHABLE.  When this returns,
- * no object in `unreachable` is weakly referenced anymore.
- */
-static int
-handle_weakrefs(PyGC_Head *unreachable, PyGC_Head *old)
-{
-	PyGC_Head *gc;
-	PyObject *op;		/* generally FROM_GC(gc) */
-	PyWeakReference *wr;	/* generally a cast of op */
-	PyGC_Head wrcb_to_call;	/* weakrefs with callbacks to call */
-	PyGC_Head *next;
-	int num_freed = 0;
-
-	gc_list_init(&wrcb_to_call);
-
-	/* Clear all weakrefs to the objects in unreachable.  If such a weakref
-	 * also has a callback, move it into `wrcb_to_call` if the callback
-	 * needs to be invoked.  Note that we cannot invoke any callbacks until
-	 * all weakrefs to unreachable objects are cleared, lest the callback
-	 * resurrect an unreachable object via a still-active weakref.  We
-	 * make another pass over wrcb_to_call, invoking callbacks, after this
-	 * pass completes.
-	 */
-	for (gc = unreachable->gc.gc_next; gc != unreachable; gc = next) {
-		PyWeakReference **wrlist;
-
-		op = FROM_GC(gc);
-		assert(IS_TENTATIVELY_UNREACHABLE(op));
-		next = gc->gc.gc_next;
-
-		if (! PyType_SUPPORTS_WEAKREFS(Py_TYPE(op)))
-			continue;
-
-		/* It supports weakrefs.  Does it have any? */
-		wrlist = (PyWeakReference **)
-			     		PyObject_GET_WEAKREFS_LISTPTR(op);
-
-		/* `op` may have some weakrefs.  March over the list, clear
-		 * all the weakrefs, and move the weakrefs with callbacks
-		 * that must be called into wrcb_to_call.
-		 */
-		for (wr = *wrlist; wr != NULL; wr = *wrlist) {
-			PyGC_Head *wrasgc;	/* AS_GC(wr) */
-
-			/* _PyWeakref_ClearRef clears the weakref but leaves
-			 * the callback pointer intact.  Obscure:  it also
-			 * changes *wrlist.
-			 */
-			assert(wr->wr_object == op);
-			_PyWeakref_ClearRef(wr);
-			assert(wr->wr_object == Py_None);
-			if (wr->wr_callback == NULL)
-				continue;	/* no callback */
-
-	/* Headache time.  `op` is going away, and is weakly referenced by
-	 * `wr`, which has a callback.  Should the callback be invoked?  If wr
-	 * is also trash, no:
-	 *
-	 * 1. There's no need to call it.  The object and the weakref are
-	 *    both going away, so it's legitimate to pretend the weakref is
-	 *    going away first.  The user has to ensure a weakref outlives its
-	 *    referent if they want a guarantee that the wr callback will get
-	 *    invoked.
-	 *
-	 * 2. It may be catastrophic to call it.  If the callback is also in
-	 *    cyclic trash (CT), then although the CT is unreachable from
-	 *    outside the current generation, CT may be reachable from the
-	 *    callback.  Then the callback could resurrect insane objects.
-	 *
-	 * Since the callback is never needed and may be unsafe in this case,
-	 * wr is simply left in the unreachable set.  Note that because we
-	 * already called _PyWeakref_ClearRef(wr), its callback will never
-	 * trigger.
-	 *
-	 * OTOH, if wr isn't part of CT, we should invoke the callback:  the
-	 * weakref outlived the trash.  Note that since wr isn't CT in this
-	 * case, its callback can't be CT either -- wr acted as an external
-	 * root to this generation, and therefore its callback did too.  So
-	 * nothing in CT is reachable from the callback either, so it's hard
-	 * to imagine how calling it later could create a problem for us.  wr
-	 * is moved to wrcb_to_call in this case.
-	 */
-	 		if (IS_TENTATIVELY_UNREACHABLE(wr))
-	 			continue;
-			assert(IS_REACHABLE(wr));
-
-			/* Create a new reference so that wr can't go away
-			 * before we can process it again.
-			 */
-			Py_INCREF(wr);
-
-			/* Move wr to wrcb_to_call, for the next pass. */
-			wrasgc = AS_GC(wr);
-			assert(wrasgc != next); /* wrasgc is reachable, but
-			                           next isn't, so they can't
-			                           be the same */
-			gc_list_move(wrasgc, &wrcb_to_call);
-		}
-	}
-
-	/* Invoke the callbacks we decided to honor.  It's safe to invoke them
-	 * because they can't reference unreachable objects.
-	 */
-	while (! gc_list_is_empty(&wrcb_to_call)) {
-		PyObject *temp;
-		PyObject *callback;
-
-		gc = wrcb_to_call.gc.gc_next;
-		op = FROM_GC(gc);
-		assert(IS_REACHABLE(op));
-		assert(PyWeakref_Check(op));
-		wr = (PyWeakReference *)op;
-		callback = wr->wr_callback;
-		assert(callback != NULL);
-
-		/* copy-paste of weakrefobject.c's handle_callback() */
-		temp = PyObject_CallFunctionObjArgs(callback, wr, NULL);
-		if (temp == NULL)
-			PyErr_WriteUnraisable(callback);
-		else
-			Py_DECREF(temp);
-
-		/* Give up the reference we created in the first pass.  When
-		 * op's refcount hits 0 (which it may or may not do right now),
-		 * op's tp_dealloc will decref op->wr_callback too.  Note
-		 * that the refcount probably will hit 0 now, and because this
-		 * weakref was reachable to begin with, gc didn't already
-		 * add it to its count of freed objects.  Example:  a reachable
-		 * weak value dict maps some key to this reachable weakref.
-		 * The callback removes this key->weakref mapping from the
-		 * dict, leaving no other references to the weakref (excepting
-		 * ours).
-		 */
-		Py_DECREF(op);
-		if (wrcb_to_call.gc.gc_next == gc) {
-			/* object is still alive -- move it */
-			gc_list_move(gc, old);
-		}
-		else
-			++num_freed;
-	}
-
-	return num_freed;
-}
-
-static void
-debug_cycle(char *msg, PyObject *op)
-{
-	PySys_WriteStderr("gc: %.100s <%.100s %p>\n",
-			  msg, Py_TYPE(op)->tp_name, op);
-}
-
-/* Handle uncollectable garbage (cycles with finalizers, and stuff reachable
- * only from such cycles).
- * If DEBUG_SAVEALL, all objects in finalizers are appended to the module
- * garbage list (a Python list), else only the objects in finalizers with
- * __del__ methods are appended to garbage.  All objects in finalizers are
- * merged into the old list regardless.
- * Returns 0 if all OK, <0 on error (out of memory to grow the garbage list).
- * The finalizers list is made empty on a successful return.
- */
-static int
-handle_finalizers(PyGC_Head *finalizers, PyGC_Head *old)
-{
-	PyGC_Head *gc = finalizers->gc.gc_next;
-
-	if (garbage == NULL) {
-		garbage = PyList_New(0);
-		if (garbage == NULL)
-			Py_FatalError("gc couldn't create gc.garbage list");
-	}
-	for (; gc != finalizers; gc = gc->gc.gc_next) {
-		PyObject *op = FROM_GC(gc);
-
-		if ((debug & DEBUG_SAVEALL) || has_finalizer(op)) {
-			if (PyList_Append(garbage, op) < 0)
-				return -1;
-		}
-	}
-
-	gc_list_merge(finalizers, old);
-	return 0;
-}
-
-/* Break reference cycles by clearing the containers involved.	This is
- * tricky business as the lists can be changing and we don't know which
- * objects may be freed.  It is possible I screwed something up here.
- */
-static void
-delete_garbage(PyGC_Head *collectable, PyGC_Head *old)
-{
-	inquiry clear;
-
-	while (!gc_list_is_empty(collectable)) {
-		PyGC_Head *gc = collectable->gc.gc_next;
-		PyObject *op = FROM_GC(gc);
-
-		assert(IS_TENTATIVELY_UNREACHABLE(op));
-		if (debug & DEBUG_SAVEALL) {
-			PyList_Append(garbage, op);
-		}
-		else {
-			if ((clear = Py_TYPE(op)->tp_clear) != NULL) {
-				Py_INCREF(op);
-				clear(op);
-				Py_DECREF(op);
-			}
-		}
-		if (collectable->gc.gc_next == gc) {
-			/* object is still alive, move it, it may die later */
-			gc_list_move(gc, old);
-			gc->gc.gc_refs = GC_REACHABLE;
-		}
-	}
-}
-
-/* Clear all free lists
- * All free lists are cleared during the collection of the highest generation.
- * Allocated items in the free list may keep a pymalloc arena occupied.
- * Clearing the free lists may give back memory to the OS earlier.
- */
-static void
-clear_freelists(void)
-{
-	(void)PyMethod_ClearFreeList();
-	(void)PyFrame_ClearFreeList();
-	(void)PyCFunction_ClearFreeList();
-	(void)PyTuple_ClearFreeList();
-	(void)PyUnicode_ClearFreeList();
+subtract_refs(PyGC_Head *list)
+{
+    PyGC_Head *ob;
+
+    for (ob = list->ob_next; ob != list; ob = ob->ob_next)
+        gc_traverse(ob, (visitproc)visit_decref, NULL);
+}
+
+/* A traversal callback for subtract_refs. */
+static int
+visit_incref(PyObject *ob, PyObject *templist)
+{
+    assert(ob != NULL);
+
+    if (((Py_ssize_t)ob->ob_refcnt_trace) >= 0) {
+        assert(ob->ob_refcnt_trace == 0);
+        ob->ob_refcnt_trace = GC_TRACKED;
+        gc_list_move(ob, templist);
+    }
+
+    return 0;
+}
+
+static Py_ssize_t
+separate_unreachable(PyGC_Head *young, PyGC_Head *unreachable, PyGC_Head *old)
+{
+    Py_ssize_t m = 0;
+    PyGC_Head temp;
+    PyObject *ob, *next;
+
+    gc_list_init(&temp);
+
+    for (ob = young->ob_next; ob != young; ob = next) {
+        next = ob->ob_next;
+
+        if (((Py_ssize_t)ob->ob_refcnt_trace) < 0)
+            gc_list_move(ob, old);
+        else if (ob->ob_refcnt_trace > 0) {
+            ob->ob_refcnt_trace = GC_TRACKED;
+            gc_list_move(ob, &temp);
+        }
+    }
+
+    while (temp.ob_next != &temp) {
+        ob = temp.ob_next;
+        gc_list_move(ob, old);
+
+        gc_traverse(ob, (visitproc)visit_incref, &temp);
+    }
+
+    while (young->ob_next != young) {
+        ob = young->ob_next;
+        m += 1;
+        ob->ob_refcnt_trace = GC_TRACKED;
+        gc_list_move(ob, unreachable);
+    }
+
+    return m;
+}
+
+static void
+clear_cyclic_objects(PyGC_Head *input, PyGC_Head *output)
+{
+    while (input->ob_next != input) {
+        PyObject *ob = input->ob_next;
+
+        gc_list_move(ob, output);
+        gc_clear(ob);
+    }
 }
 
 /* This is the main function.  Read this to understand how the
  * collection process works. */
+/* Must be called with PyGC_lock held */
 static Py_ssize_t
 collect(int generation)
 {
-	int i;
-	Py_ssize_t m = 0; /* # objects collected */
-	Py_ssize_t n = 0; /* # unreachable objects that couldn't be collected */
-	PyGC_Head *young; /* the generation we are examining */
-	PyGC_Head *old; /* next older generation */
-	PyGC_Head unreachable; /* non-problematic unreachable trash */
-	PyGC_Head finalizers;  /* objects with, & reachable from, __del__ */
-	PyGC_Head *gc;
-	double t1 = 0.0;
-
-	if (delstr == NULL) {
-		delstr = PyUnicode_InternFromString("__del__");
-		if (delstr == NULL)
-			Py_FatalError("gc couldn't allocate \"__del__\"");
-	}
-
-	if (debug & DEBUG_STATS) {
-		if (tmod != NULL) {
-			PyObject *f = PyObject_CallMethod(tmod, "time", NULL);
-			if (f == NULL) {
-				PyErr_Clear();
-			}
-			else {
-				t1 = PyFloat_AsDouble(f);
-				Py_DECREF(f);
-			}
-		}
-		PySys_WriteStderr("gc: collecting generation %d...\n",
-				  generation);
-		PySys_WriteStderr("gc: objects in each generation:");
-		for (i = 0; i < NUM_GENERATIONS; i++)
-			PySys_WriteStderr(" %" PY_FORMAT_SIZE_T "d",
-					  gc_list_size(GEN_HEAD(i)));
-		PySys_WriteStderr("\n");
-	}
-
-	/* update collection and allocation counters */
-	if (generation+1 < NUM_GENERATIONS)
-		generations[generation+1].count += 1;
-	for (i = 0; i <= generation; i++)
-		generations[i].count = 0;
-
-	/* merge younger generations with one we are currently collecting */
-	for (i = 0; i < generation; i++) {
-		gc_list_merge(GEN_HEAD(i), GEN_HEAD(generation));
-	}
-
-	/* handy references */
-	young = GEN_HEAD(generation);
-	if (generation < NUM_GENERATIONS-1)
-		old = GEN_HEAD(generation+1);
-	else
-		old = young;
-
-	/* Using ob_refcnt and gc_refs, calculate which objects in the
-	 * container set are reachable from outside the set (i.e., have a
-	 * refcount greater than 0 when all the references within the
-	 * set are taken into account).
-	 */
-	update_refs(young);
-	subtract_refs(young);
-
-	/* Leave everything reachable from outside young in young, and move
-	 * everything else (in young) to unreachable.
-	 * NOTE:  This used to move the reachable objects into a reachable
-	 * set instead.  But most things usually turn out to be reachable,
-	 * so it's more efficient to move the unreachable things.
-	 */
-	gc_list_init(&unreachable);
-	move_unreachable(young, &unreachable);
-
-	/* Move reachable objects to next generation. */
-	if (young != old)
-		gc_list_merge(young, old);
-
-	/* All objects in unreachable are trash, but objects reachable from
-	 * finalizers can't safely be deleted.  Python programmers should take
-	 * care not to create such things.  For Python, finalizers means
-	 * instance objects with __del__ methods.  Weakrefs with callbacks
-	 * can also call arbitrary Python code but they will be dealt with by
-	 * handle_weakrefs().
- 	 */
-	gc_list_init(&finalizers);
-	move_finalizers(&unreachable, &finalizers);
-	/* finalizers contains the unreachable objects with a finalizer;
-	 * unreachable objects reachable *from* those are also uncollectable,
-	 * and we move those into the finalizers list too.
-	 */
-	move_finalizer_reachable(&finalizers);
-
-	/* Collect statistics on collectable objects found and print
-	 * debugging information.
-	 */
-	for (gc = unreachable.gc.gc_next; gc != &unreachable;
-			gc = gc->gc.gc_next) {
-		m++;
-		if (debug & DEBUG_COLLECTABLE) {
-			debug_cycle("collectable", FROM_GC(gc));
-		}
-		if (tmod != NULL && (debug & DEBUG_STATS)) {
-			PyObject *f = PyObject_CallMethod(tmod, "time", NULL);
-			if (f == NULL) {
-				PyErr_Clear();
-			}
-			else {
-				t1 = PyFloat_AsDouble(f)-t1;
-				Py_DECREF(f);
-				PySys_WriteStderr("gc: %.4fs elapsed.\n", t1);
-			}
-		}
-	}
-
-	/* Clear weakrefs and invoke callbacks as necessary. */
-	m += handle_weakrefs(&unreachable, old);
-
-	/* Call tp_clear on objects in the unreachable set.  This will cause
-	 * the reference cycles to be broken.  It may also cause some objects
-	 * in finalizers to be freed.
-	 */
-	delete_garbage(&unreachable, old);
-
-	/* Collect statistics on uncollectable objects found and print
-	 * debugging information. */
-	for (gc = finalizers.gc.gc_next;
-	     gc != &finalizers;
-	     gc = gc->gc.gc_next) {
-		n++;
-		if (debug & DEBUG_UNCOLLECTABLE)
-			debug_cycle("uncollectable", FROM_GC(gc));
-	}
-	if (debug & DEBUG_STATS) {
-		if (m == 0 && n == 0)
-			PySys_WriteStderr("gc: done.\n");
-		else
-			PySys_WriteStderr(
-			    "gc: done, "
-			    "%" PY_FORMAT_SIZE_T "d unreachable, "
-			    "%" PY_FORMAT_SIZE_T "d uncollectable.\n",
-			    n+m, n);
-	}
-
-	/* Append instances in the uncollectable set to a Python
-	 * reachable list of garbage.  The programmer has to deal with
-	 * this if they insist on creating this type of structure.
-	 */
-	(void)handle_finalizers(&finalizers, old);
-
-	/* Clear free list only during the collection of the higest
-	 * generation */
-	if (generation == NUM_GENERATIONS-1) {
-		clear_freelists();
-	}
-
-	if (PyErr_Occurred()) {
-		if (gc_str == NULL)
-			gc_str = PyUnicode_FromString("garbage collection");
-		PyErr_WriteUnraisable(gc_str);
-		Py_FatalError("unexpected exception during garbage collection");
-	}
-	return n+m;
+    int i;
+    Py_ssize_t m = 0;  /* unreachable objects */
+    PyGC_Head *young;
+    PyGC_Head unreachable;
+    PyGC_Head cleared;
+    PyGC_Head old;
+
+    PyThread_lock_release(PyGC_lock);
+    PyState_StopTheWorld();
+
+    //fprintf(stderr, "Collecting... ");
+
+    /* update collection and allocation counters */
+    if (generation+1 < NUM_GENERATIONS)
+        generations[generation+1].count += 1;
+    for (i = 0; i <= generation; i++)
+        generations[i].count = 0;
+
+    /* merge younger generations with one we are currently collecting */
+    for (i = 0; i < generation; i++)
+        gc_list_merge(GEN_HEAD(i), GEN_HEAD(generation));
+
+    /* handy references */
+    young = GEN_HEAD(generation);
+    gc_list_init(&unreachable);
+    gc_list_init(&cleared);
+    gc_list_init(&old);
+
+    /* Objects already on trashcan could have been revived through
+     * a weakref, so we don't treat them special.  Objects added to
+     * trashcan after this point are protected though, so we
+     * require them to be deleted. */
+    gc_list_merge(&trashcan, young);
+
+    gone_asynchronous = 1;  /* Always do at least one pass */
+    while (gone_asynchronous) {
+        gone_asynchronous = 0;
+
+        while (trashcan.ob_next != &trashcan)
+            flush_asynchronous(&trashcan);
+
+        flush_asynchronous(young);
+    }
+    assert(trashcan.ob_next == &trashcan);  /* Should be empty */
+
+    // 4. scan generation, setting ob_refcnt_trace from ob_refcnt
+    set_refcnt_trace(young, &old);
+    // 5. call tp_trace to decrement ob_refcnt_trace
+    subtract_refs(young);
+
+    // 6. scan generation, doing:
+    // 6a. moving unreachable objects to unreachable list
+    // 6b. moving reachable objects to older generation list
+    // 6c. resetting ob_refcnt_trace to GC_TRACKED
+    m = separate_unreachable(young, &unreachable, &old);
+
+    // 7. move unreachable list to cleared list, calling tp_clear while doing so
+    clear_cyclic_objects(&unreachable, &cleared);
+
+    // 8. assert cleared list becomes empty
+    while (gone_asynchronous) {
+        gone_asynchronous = 0;
+
+        while (trashcan.ob_next != &trashcan)
+            flush_asynchronous(&trashcan);
+
+        flush_asynchronous(&cleared);
+        flush_asynchronous(&old);
+    }
+    assert(trashcan.ob_next == &trashcan);  /* Should be empty */
+    if (cleared.ob_next != &cleared) {
+#if 1
+        long i = 0;
+        PyObject *obj = cleared.ob_next;
+        while (obj != &cleared) {
+            fprintf(stderr, "Uncollectable trash %ld:\n", i);
+            _PyObject_Dump(obj);
+            i++;
+            obj = obj->ob_next;
+        }
+#else
+        _PyObject_Dump(cleared.ob_next);
+#endif
+        Py_FatalError("Uncollectable trash");
+    }
+
+    // 9. merge old list with next-oldest generation
+    if (generation < NUM_GENERATIONS-1)
+        gc_list_merge(&old, GEN_HEAD(generation+1));
+    else
+        gc_list_merge(&old, GEN_HEAD(generation));
+
+    if (PyErr_Occurred()) {
+        PyObject *gc_str = PyUnicode_FromString("garbage collection");
+        PyErr_WriteUnraisable(gc_str);
+        Py_FatalError("unexpected exception during garbage collection");
+    }
+
+    PyState_StartTheWorld();
+    PyThread_lock_acquire(PyGC_lock);
+
+    //fprintf(stderr, "Done\n");
+
+    return m;
 }
 
 static Py_ssize_t
@@ -896,7 +616,9 @@
 static PyObject *
 gc_enable(PyObject *self, PyObject *noargs)
 {
+	PyThread_lock_acquire(PyGC_lock);
 	enabled = 1;
+	PyThread_lock_release(PyGC_lock);
 	Py_INCREF(Py_None);
 	return Py_None;
 }
@@ -909,7 +631,9 @@
 static PyObject *
 gc_disable(PyObject *self, PyObject *noargs)
 {
+	PyThread_lock_acquire(PyGC_lock);
 	enabled = 0;
+	PyThread_lock_release(PyGC_lock);
 	Py_INCREF(Py_None);
 	return Py_None;
 }
@@ -922,7 +646,11 @@
 static PyObject *
 gc_isenabled(PyObject *self, PyObject *noargs)
 {
-	return PyBool_FromLong((long)enabled);
+    int value;
+    PyThread_lock_acquire(PyGC_lock);
+    value = enabled;
+    PyThread_lock_release(PyGC_lock);
+    return PyBool_FromLong((long)value);
 }
 
 PyDoc_STRVAR(gc_collect__doc__,
@@ -948,6 +676,8 @@
 		return NULL;
 	}
 
+	PyThread_lock_acquire(PyGC_lock);
+
 	if (collecting)
 		n = 0; /* already collecting, don't do anything */
 	else {
@@ -956,6 +686,8 @@
 		collecting = 0;
 	}
 
+	PyThread_lock_release(PyGC_lock);
+
 	return PyLong_FromSsize_t(n);
 }
 
@@ -976,11 +708,16 @@
 static PyObject *
 gc_set_debug(PyObject *self, PyObject *args)
 {
-	if (!PyArg_ParseTuple(args, "i:set_debug", &debug))
-		return NULL;
-
-	Py_INCREF(Py_None);
-	return Py_None;
+    int value;
+    if (!PyArg_ParseTuple(args, "i:set_debug", &value))
+        return NULL;
+
+    PyThread_lock_acquire(PyGC_lock);
+    debug = value;
+    PyThread_lock_release(PyGC_lock);
+
+    Py_INCREF(Py_None);
+    return Py_None;
 }
 
 PyDoc_STRVAR(gc_get_debug__doc__,
@@ -991,7 +728,11 @@
 static PyObject *
 gc_get_debug(PyObject *self, PyObject *noargs)
 {
-	return Py_BuildValue("i", debug);
+    int value;
+    PyThread_lock_acquire(PyGC_lock);
+    value = debug;
+    PyThread_lock_release(PyGC_lock);
+    return Py_BuildValue("i", value);
 }
 
 PyDoc_STRVAR(gc_set_thresh__doc__,
@@ -1003,19 +744,27 @@
 static PyObject *
 gc_set_thresh(PyObject *self, PyObject *args)
 {
-	int i;
-	if (!PyArg_ParseTuple(args, "i|ii:set_threshold",
-			      &generations[0].threshold,
-			      &generations[1].threshold,
-			      &generations[2].threshold))
-		return NULL;
-	for (i = 2; i < NUM_GENERATIONS; i++) {
- 		/* generations higher than 2 get the same threshold */
-		generations[i].threshold = generations[2].threshold;
-	}
-
-	Py_INCREF(Py_None);
-	return Py_None;
+    int gens[3];
+    int i;
+
+    if (!PyArg_ParseTuple(args, "i|ii:set_threshold", &gens[0],
+            &gens[1], &gens[2]))
+        return NULL;
+
+    PyThread_lock_acquire(PyGC_lock);
+    generations[0].threshold = gens[0];
+    if (PyTuple_GET_SIZE(args) > 1)
+        generations[1].threshold = gens[1];
+    if (PyTuple_GET_SIZE(args) > 2)
+        generations[2].threshold = gens[2];
+    for (i = 2; i < NUM_GENERATIONS; i++) {
+        /* generations higher than 2 get the same threshold */
+        generations[i].threshold = generations[2].threshold;
+    }
+    PyThread_lock_release(PyGC_lock);
+
+    Py_INCREF(Py_None);
+    return Py_None;
 }
 
 PyDoc_STRVAR(gc_get_thresh__doc__,
@@ -1026,10 +775,15 @@
 static PyObject *
 gc_get_thresh(PyObject *self, PyObject *noargs)
 {
-	return Py_BuildValue("(iii)",
-			     generations[0].threshold,
-			     generations[1].threshold,
-			     generations[2].threshold);
+    int gens[3];
+
+    PyThread_lock_acquire(PyGC_lock);
+    gens[0] = generations[0].threshold;
+    gens[1] = generations[1].threshold;
+    gens[2] = generations[2].threshold;
+    PyThread_lock_release(PyGC_lock);
+
+    return Py_BuildValue("(iii)", gens[0], gens[1], gens[2]);
 }
 
 PyDoc_STRVAR(gc_get_count__doc__,
@@ -1040,19 +794,37 @@
 static PyObject *
 gc_get_count(PyObject *self, PyObject *noargs)
 {
-	return Py_BuildValue("(iii)",
-			     generations[0].count,
-			     generations[1].count,
-			     generations[2].count);
+    int gens[3];
+
+    PyThread_lock_acquire(PyGC_lock);
+    gens[0] = generations[0].count;
+    gens[1] = generations[1].count;
+    gens[2] = generations[2].count;
+    PyThread_lock_release(PyGC_lock);
+
+    return Py_BuildValue("(iii)", gens[0], gens[1], gens[2]);
 }
 
+struct referrers_state {
+    PyObject *objs;
+    int match;
+};
+
 static int
-referrersvisit(PyObject* obj, PyObject *objs)
+referrersvisit(PyObject* obj, struct referrers_state *state)
 {
 	Py_ssize_t i;
-	for (i = 0; i < PyTuple_GET_SIZE(objs); i++)
-		if (PyTuple_GET_ITEM(objs, i) == obj)
-			return 1;
+
+	if (state->match)
+		return 0;
+
+	for (i = 0; i < PyTuple_GET_SIZE(state->objs); i++) {
+		if (PyTuple_GET_ITEM(state->objs, i) == obj) {
+			state->match = 1;
+			return 0;
+		}
+	}
+
 	return 0;
 }
 
@@ -1061,13 +833,16 @@
 {
 	PyGC_Head *gc;
 	PyObject *obj;
-	traverseproc traverse;
-	for (gc = list->gc.gc_next; gc != list; gc = gc->gc.gc_next) {
+	struct referrers_state state;
+
+	state.objs = objs;
+
+	for (gc = list->ob_next; gc != list; gc = gc->ob_next) {
 		obj = FROM_GC(gc);
-		traverse = Py_TYPE(obj)->tp_traverse;
-		if (obj == objs || obj == resultlist)
-			continue;
-		if (traverse(obj, (visitproc)referrersvisit, objs)) {
+		state.match = 0;
+
+		gc_traverse(obj, (visitproc)referrersvisit, &state);
+		if (state.match) {
 			if (PyList_Append(resultlist, obj) < 0)
 				return 0; /* error */
 		}
@@ -1084,8 +859,10 @@
 {
 	int i;
 	PyObject *result = PyList_New(0);
-	if (!result) return NULL;
+	if (!result)
+		return NULL;
 
+#warning gc_get_referrers needs updating to StopTheWorld
 	for (i = 0; i < NUM_GENERATIONS; i++) {
 		if (!(gc_referrers_for(args, GEN_HEAD(i), result))) {
 			Py_DECREF(result);
@@ -1095,11 +872,23 @@
 	return result;
 }
 
-/* Append obj to list; return true if error (out of memory), false if OK. */
+struct referents_state {
+    PyObject *list;
+    int status;
+};
+
+/* Append obj to state->list; set state->status to 1 if an error (out
+ * of memory) occurs. */
 static int
-referentsvisit(PyObject *obj, PyObject *list)
+referentsvisit(PyObject *obj, struct referents_state *state)
 {
-	return PyList_Append(list, obj) < 0;
+	if (state->status)
+		return 0;
+
+	if (PyList_Append(state->list, obj) < 0)
+		state->status = 1;
+
+	return 0;
 }
 
 PyDoc_STRVAR(gc_get_referents__doc__,
@@ -1109,27 +898,27 @@
 static PyObject *
 gc_get_referents(PyObject *self, PyObject *args)
 {
+	struct referents_state state;
 	Py_ssize_t i;
-	PyObject *result = PyList_New(0);
 
-	if (result == NULL)
+	state.list = PyList_New(0);
+	if (state.list == NULL)
 		return NULL;
 
+#warning gc_get_referents needs updating to StopTheWorld
 	for (i = 0; i < PyTuple_GET_SIZE(args); i++) {
 		traverseproc traverse;
 		PyObject *obj = PyTuple_GET_ITEM(args, i);
 
-		if (! PyObject_IS_GC(obj))
-			continue;
-		traverse = Py_TYPE(obj)->tp_traverse;
-		if (! traverse)
-			continue;
-		if (traverse(obj, (visitproc)referentsvisit, result)) {
-			Py_DECREF(result);
+		if (!PyObject_IS_GC(obj))
+			continue;
+		gc_traverse(obj, (visitproc)referentsvisit, &state);
+		if (state.status) {
+			Py_DECREF(state.list);
 			return NULL;
 		}
 	}
-	return result;
+	return state.list;
 }
 
 PyDoc_STRVAR(gc_get_objects__doc__,
@@ -1147,6 +936,8 @@
 	result = PyList_New(0);
 	if (result == NULL)
 		return NULL;
+
+#warning gc_get_objects needs updating to StopTheWorld
 	for (i = 0; i < NUM_GENERATIONS; i++) {
 		if (append_objects(result, GEN_HEAD(i))) {
 			Py_DECREF(result);
@@ -1174,37 +965,47 @@
 "get_referents() -- Return the list of objects that an object refers to.\n");
 
 static PyMethodDef GcMethods[] = {
-	{"enable",	   gc_enable,	  METH_NOARGS,  gc_enable__doc__},
-	{"disable",	   gc_disable,	  METH_NOARGS,  gc_disable__doc__},
-	{"isenabled",	   gc_isenabled,  METH_NOARGS,  gc_isenabled__doc__},
-	{"set_debug",	   gc_set_debug,  METH_VARARGS, gc_set_debug__doc__},
-	{"get_debug",	   gc_get_debug,  METH_NOARGS,  gc_get_debug__doc__},
-	{"get_count",	   gc_get_count,  METH_NOARGS,  gc_get_count__doc__},
-	{"set_threshold",  gc_set_thresh, METH_VARARGS, gc_set_thresh__doc__},
-	{"get_threshold",  gc_get_thresh, METH_NOARGS,  gc_get_thresh__doc__},
+	{"enable",	   gc_enable,	  METH_SHARED | METH_NOARGS,  gc_enable__doc__},
+	{"disable",	   gc_disable,	  METH_SHARED | METH_NOARGS,  gc_disable__doc__},
+	{"isenabled",	   gc_isenabled,  METH_SHARED | METH_NOARGS,  gc_isenabled__doc__},
+	{"set_debug",	   gc_set_debug,  METH_SHARED | METH_VARARGS, gc_set_debug__doc__},
+	{"get_debug",	   gc_get_debug,  METH_SHARED | METH_NOARGS,  gc_get_debug__doc__},
+	{"get_count",	   gc_get_count,  METH_SHARED | METH_NOARGS,  gc_get_count__doc__},
+	{"set_threshold",  gc_set_thresh, METH_SHARED | METH_VARARGS, gc_set_thresh__doc__},
+	{"get_threshold",  gc_get_thresh, METH_SHARED | METH_NOARGS,  gc_get_thresh__doc__},
 	{"collect",	   (PyCFunction)gc_collect,
-         	METH_VARARGS | METH_KEYWORDS,           gc_collect__doc__},
-	{"get_objects",    gc_get_objects,METH_NOARGS,  gc_get_objects__doc__},
-	{"get_referrers",  gc_get_referrers, METH_VARARGS,
+         	METH_SHARED | METH_VARARGS | METH_KEYWORDS,           gc_collect__doc__},
+	{"get_objects",    gc_get_objects,METH_SHARED | METH_NOARGS,  gc_get_objects__doc__},
+	{"get_referrers",  gc_get_referrers, METH_SHARED | METH_VARARGS,
 		gc_get_referrers__doc__},
-	{"get_referents",  gc_get_referents, METH_VARARGS,
+	{"get_referents",  gc_get_referents, METH_SHARED | METH_VARARGS,
 		gc_get_referents__doc__},
 	{NULL,	NULL}		/* Sentinel */
 };
 
+void
+_PyGC_Init(void)
+{
+	/* XXX we leak this */
+	PyGC_lock = PyThread_lock_allocate();
+	if (!PyGC_lock)
+		Py_FatalError("unable to allocate lock");
+}
+
 PyMODINIT_FUNC
 initgc(void)
 {
 	PyObject *m;
 
-	m = Py_InitModule4("gc",
+	m = Py_InitModule5("gc",
 			      GcMethods,
 			      gc__doc__,
 			      NULL,
-			      PYTHON_API_VERSION);
+			      PYTHON_API_VERSION, 1);
 	if (m == NULL)
 		return;
 
+#if 0
 	if (garbage == NULL) {
 		garbage = PyList_New(0);
 		if (garbage == NULL)
@@ -1213,6 +1014,7 @@
 	Py_INCREF(garbage);
 	if (PyModule_AddObject(m, "garbage", garbage) < 0)
 		return;
+#endif
 
 	/* Importing can't be done in collect() because collect()
 	 * can be called via PyGC_Collect() in Py_Finalize().
@@ -1241,6 +1043,8 @@
 {
 	Py_ssize_t n;
 
+	PyThread_lock_acquire(PyGC_lock);
+
 	if (collecting)
 		n = 0; /* already collecting, don't do anything */
 	else {
@@ -1249,6 +1053,8 @@
 		collecting = 0;
 	}
 
+	PyThread_lock_release(PyGC_lock);
+
 	return n;
 }
 
@@ -1262,112 +1068,819 @@
 /* extension modules might be compiled with GC support so these
    functions must always be available */
 
-#undef PyObject_GC_Track
-#undef PyObject_GC_UnTrack
 #undef PyObject_GC_Del
 #undef _PyObject_GC_Malloc
 
 void
-PyObject_GC_Track(void *op)
-{
-	_PyObject_GC_TRACK(op);
-}
-
-/* for binary compatibility with 2.2 */
-void
-_PyObject_GC_Track(PyObject *op)
-{
-    PyObject_GC_Track(op);
-}
-
-void
-PyObject_GC_UnTrack(void *op)
-{
-	/* Obscure:  the Py_TRASHCAN mechanism requires that we be able to
-	 * call PyObject_GC_UnTrack twice on an object.
-	 */
-	if (IS_TRACKED(op))
-		_PyObject_GC_UNTRACK(op);
-}
-
-/* for binary compatibility with 2.2 */
-void
-_PyObject_GC_UnTrack(PyObject *op)
-{
-    PyObject_GC_UnTrack(op);
-}
-
+_Py_Refchain_Init(void)
+{
+#ifdef Py_TRACE_REFS
+	refchain_lock = PyThread_lock_allocate();
+	if (!refchain_lock)
+		Py_FatalError("Can't allocate refchain_lock");
+#endif
+}
+
+void
+_Py_Refchain_Fini(void)
+{
+#ifdef Py_TRACE_REFS
+	PyThread_lock_free(refchain_lock);
+	refchain_lock = 0;
+#endif
+}
+
+static void
+_Py_NewReference(PyObject *op)
+{
+	_Py_INC_REFTOTAL();
+	op->ob_refowner = (AO_t)PyState_Get();
+	op->ob_refcnt = 1;
+#ifdef Py_TRACE_REFS
+	_Py_AddToAllObjects(op, 1);
+#endif
+	_Py_INC_TPALLOCS(op);
+}
+
+static void
+_Py_ForgetReference(PyObject *op)
+{
+#ifdef Py_TRACE_REFS
+#ifdef SLOW_UNREF_CHECK
+        register PyObject *p;
+#endif
+	PyThread_lock_acquire(refchain_lock);
+	if (Py_RefcntSnoop(op) < 0)
+		Py_FatalError("UNREF negative refcnt");
+	if (op == &refchain ||
+	    op->_ob_prev->_ob_next != op || op->_ob_next->_ob_prev != op)
+		Py_FatalError("UNREF invalid object");
+#ifdef SLOW_UNREF_CHECK
+	for (p = refchain._ob_next; p != &refchain; p = p->_ob_next) {
+		if (p == op)
+			break;
+	}
+	if (p == &refchain) /* Not found */
+		Py_FatalError("UNREF unknown object");
+#endif
+	op->_ob_next->_ob_prev = op->_ob_prev;
+	op->_ob_prev->_ob_next = op->_ob_next;
+	op->_ob_next = op->_ob_prev = NULL;
+#endif
+	_Py_INC_TPFREES(op);
+#ifdef Py_TRACE_REFS
+	PyThread_lock_release(refchain_lock);
+#endif
+}
+
+static void
+_Py_Dealloc(register PyState *pystate, PyObject *op)
+{
+    destructor dealloc = Py_TYPE(op)->tp_dealloc;
+    assert(dealloc != NULL);
+
+    if (pystate->dealloc_depth > GC_MAX_DEALLOC_DEPTH) {
+        PyThread_lock_acquire(PyGC_lock);
+        if (is_young(op)) {
+            if (is_tracked(op))
+                op->ob_refcnt_trace = GC_TRACKED;
+            else
+                op->ob_refcnt_trace = GC_UNTRACKED;
+        }
+        gc_list_move(op, &trashcan);
+        PyThread_lock_release(PyGC_lock);
+        Py_DECREF_ASYNC(op);
+        return;
+    }
+
+    if (PyType_IS_GC(Py_TYPE(op)))
+        gc_untrack(op);
+
+    if (PyType_SUPPORTS_WEAKREFS(Py_TYPE(op)) &&
+            _PyObject_TryClearWeakref(op)) {
+        /* He's not dead, he's pining for the fjords! */
+        PyObject_Revive(op);
+        Py_DECREF_ASYNC(op);
+    } else {
+        PyCritical dummycrit;
+
+        _Py_INC_TPFREES(op) _Py_COUNT_ALLOCS_COMMA	\
+        pystate->dealloc_depth++;
+
+        if (pystate->critical_section == NULL ||
+                pystate->critical_section->depth > PyCRITICAL_DEALLOC) {
+            PyCritical_EnterDummy(&dummycrit, PyCRITICAL_DEALLOC);
+            (*dealloc)(op);
+            PyCritical_ExitDummy(&dummycrit);
+        } else
+            (*dealloc)(op);
+
+        pystate->dealloc_depth--;
+
+        if (pystate->dealloc_depth == 0) {
+            /* XXX do something if we've got some queued deallocs */
+        }
+    }
+}
+#ifdef Py_TRACE_REFS
+/* Print all live objects.  Because PyObject_Print is called, the
+ * interpreter must be in a healthy state.
+ */
+void
+_Py_PrintReferences(FILE *fp)
+{
+	PyObject *op;
+	PyThread_lock_acquire(refchain_lock);
+	fprintf(fp, "Remaining objects:\n");
+	for (op = refchain._ob_next; op != &refchain; op = op->_ob_next) {
+		fprintf(fp, "%p [%" PY_FORMAT_SIZE_T "d] ", op,
+			Py_RefcntSnoop(op));
+		/* XXX FIXME This is *wrong*.  It modifies the refchain
+		   again to do the print. */
+		if (PyObject_Print(op, fp, 0) != 0)
+			PyErr_Clear();
+		putc('\n', fp);
+	}
+	PyThread_lock_release(refchain_lock);
+}
+
+/* Print the addresses of all live objects.  Unlike _Py_PrintReferences, this
+ * doesn't make any calls to the Python C API, so is always safe to call.
+ */
+void
+_Py_PrintReferenceAddresses(FILE *fp)
+{
+	PyObject *op;
+	PyThread_lock_acquire(refchain_lock);
+	fprintf(fp, "Remaining object addresses:\n");
+	for (op = refchain._ob_next; op != &refchain; op = op->_ob_next)
+		fprintf(fp, "%p [%" PY_FORMAT_SIZE_T "d] %s\n", op,
+			Py_RefcntSnoop(op), Py_TYPE(op)->tp_name);
+	PyThread_lock_release(refchain_lock);
+}
+
+/* This is dangerous.  It relies on PyList_Append to not create or
+ * delete any objects. */
 PyObject *
+_Py_GetObjects(PyObject *self, PyObject *args)
+{
+	int i, n;
+	PyObject *t = NULL;
+	PyObject *res, *op;
+
+	if (!PyArg_ParseTuple(args, "i|O", &n, &t))
+		return NULL;
+	res = PyList_New(0);
+	if (res == NULL)
+		return NULL;
+	PyThread_lock_acquire(refchain_lock);
+	op = refchain._ob_next;
+	for (i = 0; (n == 0 || i < n) && op != &refchain; i++) {
+		while (op == self || op == args || op == res || op == t ||
+		       (t != NULL && Py_TYPE(op) != (PyTypeObject *) t)) {
+			op = op->_ob_next;
+			if (op == &refchain) {
+				PyThread_lock_release(refchain_lock);
+				return res;
+			}
+		}
+		if (PyList_Append(res, op) < 0) {
+			PyThread_lock_release(refchain_lock);
+			Py_DECREF(res);
+			return NULL;
+		}
+		op = op->_ob_next;
+	}
+	PyThread_lock_release(refchain_lock);
+	return res;
+}
+
+#endif
+static AO_t hit_count;
+static AO_t adj_count;
+static AO_T col_count;
+
+static void
+add_hit(void)
+{
+	AO_t count = AO_fetch_and_add1(&hit_count);
+	if ((count % 1000000) == 0)
+		printf("Hits: %lu\n", count);
+}
+
+static void
+add_adj(void)
+{
+	AO_t count = AO_fetch_and_add1(&adj_count);
+	if ((count % 1000) == 0)
+		printf("Adjacent: %lu\n", count);
+}
+
+static void
+add_col(void)
+{
+	AO_t count = AO_fetch_and_add1(&col_count);
+	if ((count % 1000000) == 0)
+		printf("Collisions: %lu\n", count);
+}
+
+static AO_T obj_count;
+
+static void
+add_obj(void)
+{
+	AO_t count = AO_fetch_and_add1(&obj_count);
+	if ((count % 1000) == 0)
+		printf("Objects: %lu\n", count);
+}
+
+static void
+del_obj(void)
+{
+	AO_fetch_and_sub1(&obj_count);
+}
+
+
+static inline void
+_PyGC_AsyncRefcount_FlushSingle(PyAsyncRefEntry *entry)
+{
+	assert(entry->obj);
+	AO_fetch_and_add_full(&entry->obj->ob_refcnt, entry->diff);
+	entry->obj = NULL;
+	entry->diff = 0;
+}
+
+void
+_PyGC_AsyncRefcount_Flush(PyState *pystate)
+{
+	int i;
+
+	for (i = 0; i < Py_ASYNCREFCOUNT_TABLE; i++) {
+		PyAsyncRefEntry *entry = &pystate->async_refcounts[i];
+		if (entry->obj != NULL)
+			_PyGC_AsyncRefcount_FlushSingle(entry);
+		assert(entry->obj == NULL);
+		assert(entry->diff == 0);
+	}
+}
+
+/* Attempts to promote the object's refowner one step.  May fail, even
+ * allowing the object's refowner to change to something else entirely. */
+void
+_PyGC_RefMode_Promote(PyObject *op)
+{
+	PyState *pystate = PyState_Get();
+	AO_t oldmode;
+
+	//assert(monitorspace != NULL);
+	//printf("Promoting %p\n", op);
+
+	oldmode = AO_load_acquire(&op->ob_refowner);
+	if (oldmode == Py_REFOWNER_STATICINIT)
+		AO_compare_and_swap_full(&op->ob_refowner,
+			Py_REFOWNER_STATICINIT, (AO_t)pystate);
+	else if (oldmode == Py_REFOWNER_ASYNC) {
+		/* Do nothing */
+	} else {
+		/* XXX FIXME this should only be a partial suspend.  We
+		 * musn't allow the tracing GC to collect the
+		 * PyState we're about to use.  Some sort of usage
+		 * count? */
+		PyState *owner = (PyState *)oldmode;
+		PyCritical dummycrit;
+		PyCritical_EnterDummy(&dummycrit, PyCRITICAL_REFMODE_PROMOTE);
+
+		PyState_MaybeSuspend();
+		PyThread_lock_acquire(owner->refowner_waiting_lock);
+		AO_store_full(&owner->refowner_waiting_flag, 1);
+		PyThread_lock_acquire(owner->refowner_lock);
+		AO_store_full(&owner->refowner_waiting_flag, 0);
+		PyThread_lock_release(owner->refowner_waiting_lock);
+
+		/* Another thread may already have altered the object's
+		 * refowner field, so we do another comparison. */
+		AO_compare_and_swap_full(&op->ob_refowner, oldmode,
+			Py_REFOWNER_ASYNC);
+
+		if (AO_load_acquire(&gone_asynchronous) == 0)
+			AO_store_full(&gone_asynchronous, 1);
+
+		PyThread_lock_release(owner->refowner_lock);
+		PyState_MaybeResume();
+
+		PyCritical_ExitDummy(&dummycrit);
+	}
+}
+
+static PyAsyncRefEntry *
+_Py_GetAsyncRefEntry(PyState *pystate, PyObject *op)
+{
+	/* XXX this probably needs to be heavily optimized */
+	PyAsyncRefEntry *entry;
+	AO_t index = (AO_t)op;
+
+	index ^= (index >> 3) ^ (index >> 7) ^ (index >> 17);
+	index &= Py_ASYNCREFCOUNT_TABLE - 1;
+
+	entry = &pystate->async_refcounts[index];
+
+	if (entry->obj == op || entry->obj == NULL) {
+		//add_hit();
+		return entry;
+	}
+	//add_col();
+	_PyGC_AsyncRefcount_FlushSingle(entry);
+	return entry;
+}
+
+
+void
+Py_IncRef(PyObject *o)
+{
+    Py_XINCREF(o);
+}
+
+void
+Py_DecRef(PyObject *o)
+{
+    Py_XDECREF(o);
+}
+
+/* These seem to help on my box, but on other boxes or different compiler
+ * versions may produce too strong of a preference.  YMMV. */
+#define _Py_EXPECT(expr) __builtin_expect((expr) != 0, 1)
+#define _Py_NOEXPECT(expr) __builtin_expect((expr) != 0, 0)
+
+#ifndef WITH_GIL
+void
+_Py_INCREF(PyObject *op, register PyState *pystate)
+{
+	assert(pystate != NULL);
+	assert(!pystate->suspended);
+
+//	if (PyType_Check(op) && ((PyTypeObject *)op)->tp_flags & Py_TPFLAGS_HEAPTYPE)
+//		printf("Heap type incref %s %d\n",
+//			((PyTypeObject *)op)->tp_name, Py_RefcntSnoop(op));
+
+	_Py_INC_REFTOTAL();
+
+	/* Blah, this should be done at compile time, or maybe in configure. */
+	assert(sizeof(AO_t) == sizeof(Py_ssize_t));
+
+	while (1) {
+
+		void *owner = (void *)AO_load_acquire(&op->ob_refowner);
+		if (_Py_EXPECT(owner == Py_REFOWNER_ASYNC)) {
+			/* This should use a pystate hash table */
+			PyAsyncRefEntry *entry = _Py_GetAsyncRefEntry(pystate, op);
+			entry->diff++;
+			if (entry->diff == 0)
+				entry->obj = NULL;
+			else
+				entry->obj = op;
+			return;
+		} else if (_Py_EXPECT(owner == pystate)) {
+			op->ob_refcnt++;
+			return;
+		} else {
+			_PyGC_RefMode_Promote(op);
+			continue;
+		}
+	}
+}
+
+void
+_Py_DECREF(PyObject *op, register PyState *pystate)
+{
+	assert(pystate != NULL);
+	assert(!pystate->suspended);
+
+//	if (PyType_Check(op) && ((PyTypeObject *)op)->tp_flags & Py_TPFLAGS_HEAPTYPE)
+//		printf("Heap type decref %s %d\n",
+//			((PyTypeObject *)op)->tp_name, Py_RefcntSnoop(op));
+
+	_Py_DEC_REFTOTAL();
+
+	/* Blah, this should be done at compile time, or maybe in configure. */
+	assert(sizeof(AO_t) == sizeof(Py_ssize_t));
+
+	while (1) {
+		void *owner = (void *)AO_load_acquire(&op->ob_refowner);
+		if (_Py_EXPECT(owner == Py_REFOWNER_ASYNC)) {
+			PyAsyncRefEntry *entry = _Py_GetAsyncRefEntry(pystate, op);
+			entry->diff--;
+			if (entry->diff == 0)
+				entry->obj = NULL;
+			else
+				entry->obj = op;
+			return;
+		} else if (_Py_EXPECT(owner == pystate)) {
+			if (op->ob_refcnt > 1)
+				op->ob_refcnt--;
+			else
+				_Py_Dealloc(pystate, op);
+#ifdef Py_REF_DEBUG
+			if (((Py_ssize_t)op->ob_refcnt) < 0)
+				_Py_NegativeRefcount(__FILE__, __LINE__, op, op->ob_refcnt);
+#endif
+			return;
+		} else {
+			_PyGC_RefMode_Promote(op);
+			continue;
+		}
+	}
+}
+
+/* Ensures the DECREF is always asynchronous, and thus will not
+ * recursively call _Py_Dealloc */
+void
+_Py_DECREF_ASYNC(PyObject *op, register PyState *pystate)
+{
+	assert(pystate != NULL);
+	assert(!pystate->suspended);
+
+//	if (PyType_Check(op) && ((PyTypeObject *)op)->tp_flags & Py_TPFLAGS_HEAPTYPE)
+//		printf("Heap type decref %s %d\n",
+//			((PyTypeObject *)op)->tp_name, Py_RefcntSnoop(op));
+
+	_Py_DEC_REFTOTAL();
+
+	/* Blah, this should be done at compile time, or maybe in configure. */
+	assert(sizeof(AO_t) == sizeof(Py_ssize_t));
+
+	while (1) {
+		void *owner = (void *)AO_load_acquire(&op->ob_refowner);
+		if (_Py_EXPECT(owner == Py_REFOWNER_ASYNC)) {
+			PyAsyncRefEntry *entry = _Py_GetAsyncRefEntry(pystate, op);
+			entry->diff--;
+			if (entry->diff == 0)
+				entry->obj = NULL;
+			else
+				entry->obj = op;
+			return;
+		} else {
+			_PyGC_RefMode_Promote(op);
+			continue;
+		}
+	}
+}
+#endif /* WITH_GIL */
+
+Py_ssize_t
+_Py_RefcntSnoop(PyObject *op)
+{
+    PyState *pystate = PyState_Get();
+
+    while (1) {
+        void *owner = (void *)AO_load_acquire(&op->ob_refowner);
+
+        if (owner == pystate)
+            return op->ob_refcnt;
+        else if (owner == (void *)Py_REFOWNER_STATICINIT)
+            _PyGC_RefMode_Promote(op);
+        else
+            return 1000000;  /* Arbitrary large value */
+    }
+}
+
+
+#define GET_SIZE(size_class) ((size_class) <= 0 ? gc_cache_size_classes[-(size_class)] : (size_class))
+
+/* XXX Must match up with PYGC_CACHE_SIZECLASSES */
+static const Py_ssize_t gc_cache_size_classes[] = {
+	32,
+	48,
+	64,
+	96,
+	128,
+	192,
+	256,
+	384,
+	512,
+	768,
+	1024,
+	1536,
+	2048,
+};
+
+static Py_ssize_t
+find_size_class(size_t size)
+{
+	Py_ssize_t i;
+
+	assert(sizeof(gc_cache_size_classes) / sizeof(*gc_cache_size_classes) ==
+			PYGC_CACHE_SIZECLASSES);
+	if (size > gc_cache_size_classes[PYGC_CACHE_SIZECLASSES - 1])
+		return size; /* Too large to cache */
+
+	for (i = 0; ; i++) {
+		if (size <= gc_cache_size_classes[i])
+			return -i;
+	}
+}
+
+
+static void
+PyGC_lock_count(void)
+{
+#if 0
+	static unsigned long long count;
+	count++;
+	if ((count % 1000) == 0)
+		printf("Lock count: %llu\n", count);
+#endif
+}
+
+static PyObject *
 _PyObject_GC_Malloc(size_t basicsize)
 {
-	PyObject *op;
-	PyGC_Head *g = (PyGC_Head *)PyObject_MALLOC(
-                sizeof(PyGC_Head) + basicsize);
-	if (g == NULL)
-		return PyErr_NoMemory();
-	g->gc.gc_refs = GC_UNTRACKED;
-	generations[0].count++; /* number of allocated GC objects */
- 	if (generations[0].count > generations[0].threshold &&
- 	    enabled &&
- 	    generations[0].threshold &&
- 	    !collecting &&
- 	    !PyErr_Occurred()) {
-		collecting = 1;
-		collect_generations();
-		collecting = 0;
-	}
-	op = FROM_GC(g);
-	return op;
-}
-
-PyObject *
-_PyObject_GC_New(PyTypeObject *tp)
-{
-	PyObject *op = _PyObject_GC_Malloc(_PyObject_SIZE(tp));
-	if (op != NULL)
-		op = PyObject_INIT(op, tp);
-	return op;
-}
-
-PyVarObject *
-_PyObject_GC_NewVar(PyTypeObject *tp, Py_ssize_t nitems)
-{
-	const size_t size = _PyObject_VAR_SIZE(tp, nitems);
-	PyVarObject *op = (PyVarObject *) _PyObject_GC_Malloc(size);
-	if (op != NULL)
-		op = PyObject_INIT_VAR(op, tp, nitems);
-	return op;
-}
-
-PyVarObject *
+	PyGC_Head *g = NULL;
+	/* XXX FIXME unsigned -> signed overflow? */
+	//Py_ssize_t size_class = find_size_class(sizeof(PyGC_Head) + basicsize);
+	Py_ssize_t size_class = find_size_class(basicsize);
+
+	if (size_class <= 0) {
+		PyState *pystate = PyState_Get();
+		Py_ssize_t i;
+
+		for (i = 0; i < PYGC_CACHE_COUNT; i++) {
+			if (pystate->gc_object_cache[-size_class][i] != NULL) {
+				g = pystate->gc_object_cache[-size_class][i];
+				pystate->gc_object_cache[-size_class][i] = NULL;
+				g->ob_sizeclass = size_class;
+				assert(!is_tracked(g));
+				//printf("Cache hit!\n");
+				break;
+			}
+		}
+	}
+
+	if (g == NULL) {
+		//printf("Cache miss.\n");
+		g = malloc(GET_SIZE(size_class));
+		if (g == NULL)
+			return PyErr_NoMemory();
+		g->ob_sizeclass = size_class;
+		g->ob_refcnt_trace = GC_UNTRACKED_YOUNG;
+
+		PyThread_lock_acquire(PyGC_lock);
+		PyGC_lock_count();
+
+		generations[0].count++; /* number of allocated GC objects */
+		if (generations[0].count > generations[0].threshold &&
+				enabled &&
+				generations[0].threshold &&
+				!collecting &&
+				!PyErr_Occurred()) {
+			collecting = 1;
+			collect_generations();
+			collecting = 0;
+		}
+
+		gc_list_append(g, _PyGC_generation0);
+
+		PyThread_lock_release(PyGC_lock);
+	}
+
+	return FROM_GC(g);
+}
+
+static PyVarObject *
 _PyObject_GC_Resize(PyVarObject *op, Py_ssize_t nitems)
 {
-	const size_t basicsize = _PyObject_VAR_SIZE(Py_TYPE(op), nitems);
-	PyGC_Head *g = AS_GC(op);
-	g = (PyGC_Head *)PyObject_REALLOC(g,  sizeof(PyGC_Head) + basicsize);
-	if (g == NULL)
-		return (PyVarObject *)PyErr_NoMemory();
+	/* XXX any overflow possible? */
+	/* XXX FIXME Some code assumes a sentinal is allocated.  Blah. */
+	const size_t basicsize = _PyObject_VAR_SIZE(Py_TYPE(op), nitems + 1);
+	PyObject *g = (PyObject *)op;
+	//Py_ssize_t size_class = find_size_class(sizeof(PyGC_Head) + basicsize);
+	Py_ssize_t size_class = find_size_class(basicsize);
+
+	if (is_tracked((PyObject *)op))
+		Py_FatalError("_PyObject_GC_Resize called for tracked object");
+
+	if (size_class == g->ob_sizeclass) {
+		//printf("Resize avoided\n");
+		Py_SIZE(op) = nitems;
+		return op; /* That was easy */
+	}
+
+	//printf("Resizing\n");
+	PyThread_lock_acquire(PyGC_lock);
+
+	g = realloc(g, GET_SIZE(size_class));
+	if (g == NULL) {
+		PyThread_lock_release(PyGC_lock);
+		return (PyVarObject *) PyErr_NoMemory();
+	}
+
+	g->ob_sizeclass = size_class;
+	gc_list_move(g, _PyGC_generation0);
+
+	PyThread_lock_release(PyGC_lock);
+
 	op = (PyVarObject *) FROM_GC(g);
 	Py_SIZE(op) = nitems;
 	return op;
 }
 
-void
-PyObject_GC_Del(void *op)
+static void
+_PyObject_GC_Del(void *arg)
 {
-	PyGC_Head *g = AS_GC(op);
-	if (IS_TRACKED(op))
-		gc_list_remove(g);
+	PyGC_Head *g = AS_GC(arg);
+	Py_ssize_t size_class = g->ob_sizeclass;
+
+	assert(g == arg); /* WTF? */
+
+	if (size_class <= 0 && is_young(g)) {
+		PyState *pystate = PyState_Get();
+		Py_ssize_t i;
+
+		for (i = 0; i < PYGC_CACHE_COUNT; i++) {
+			if (pystate->gc_object_cache[-size_class][i] == NULL) {
+				//printf("Filling cache\n");
+				pystate->gc_object_cache[-size_class][i] = g;
+				return;
+			}
+		}
+	}
+	//printf("Cache full\n");
+
+	PyThread_lock_acquire(PyGC_lock);
+	PyGC_lock_count();
+
+	gc_list_remove(g);
 	if (generations[0].count > 0) {
 		generations[0].count--;
 	}
-	PyObject_FREE(g);
-}
-
-/* for binary compatibility with 2.2 */
-#undef _PyObject_GC_Del
-void
-_PyObject_GC_Del(PyObject *op)
-{
-    PyObject_GC_Del(op);
+
+	PyThread_lock_release(PyGC_lock);
+	free(g);
+}
+
+void
+_PyGC_Object_Cache_Flush(void)
+{
+	PyState *pystate = PyState_Get();
+	Py_ssize_t i, j;
+
+	PyThread_lock_acquire(PyGC_lock);
+	PyGC_lock_count();
+
+	for (i = 0; i < PYGC_CACHE_SIZECLASSES; i++) {
+		for (j = 0; j < PYGC_CACHE_COUNT; j++) {
+			PyGC_Head *g = pystate->gc_object_cache[i][j];
+			pystate->gc_object_cache[i][j] = NULL;
+
+			if (g != NULL) {
+				gc_list_remove(g);
+				if (generations[0].count > 0) {
+					generations[0].count--;
+				}
+
+				assert(g->ob_refcnt == Py_REFCNT_DELETED);
+
+				free(g);
+			}
+		}
+	}
+
+	PyThread_lock_release(PyGC_lock);
+}
+
+void *
+PyObject_New(PyTypeObject *tp)
+{
+	const size_t size = _PyObject_SIZE(tp);
+	PyObject *op = _PyObject_GC_Malloc(size);
+	if (op == NULL)
+		return NULL;
+	assert(tp->tp_itemsize == 0);
+//	if (tp->tp_flags & Py_TPFLAGS_HEAPTYPE)
+//		printf("New obj type %s %d\n", tp->tp_name, Py_RefcntSnoop(tp));
+
+	Py_TYPE(op) = tp;
+	_Py_NewReference(op);
+	Py_INCREF(tp);
+	if (!PyType_HasFeature(tp, Py_TPFLAGS_SKIPWIPE)) {
+		memset(((char *)op) + sizeof(PyObject), '\0',
+			size - sizeof(PyObject));
+		if (PyType_IS_GC(tp))
+			gc_track(op);
+	}
+
+	return op;
+}
+
+void *
+PyObject_NewVar(PyTypeObject *tp, Py_ssize_t nitems)
+{
+	/* XXX FIXME Some code assumes a sentinal is allocated.  Blah. */
+	const size_t size = _PyObject_VAR_SIZE(tp, nitems + 1);
+	PyObject *op = _PyObject_GC_Malloc(size);
+	if (op == NULL)
+		return NULL;
+	assert(tp->tp_itemsize != 0);
+//	if (tp->tp_flags & Py_TPFLAGS_HEAPTYPE)
+//		printf("Newvar obj type %s %d\n", tp->tp_name, Py_RefcntSnoop(tp));
+
+	Py_SIZE(op) = nitems;
+	Py_TYPE(op) = tp;
+	_Py_NewReference(op);
+	Py_INCREF(tp);
+	if (!PyType_HasFeature(tp, Py_TPFLAGS_SKIPWIPE)) {
+		memset(((char *)op) + sizeof(PyVarObject), '\0',
+			size - sizeof(PyVarObject));
+		if (PyType_IS_GC(tp))
+			gc_track(op);
+	}
+
+	return op;
+}
+
+/* Should only be used during tp_dealloc, or in a failed *_New.
+ * Requires object have only one reference, which is consumed. */
+void
+PyObject_Del(void *pyobject)
+{
+    PyObject *op = pyobject;
+    PyState *pystate = PyState_Get();
+    PyTypeObject *tp = Py_TYPE(op);
+//    if (tp->tp_flags & Py_TPFLAGS_HEAPTYPE)
+//        printf("Del obj type %s %d\n", tp->tp_name, Py_RefcntSnoop(tp));
+//
+    if (pystate->critical_section == NULL)
+        /* Not only does this ensure the refcnt assert still works, but
+         * it also prevents any debugging tools from accidentally
+         * grabbing a reference to the about-to-be-deleted object. */
+        Py_FatalError("PyObject_Del requires a critical section");
+
+    /* If called during *_New it's probably still tracked (unless
+     * SKIPWIPE is used) */
+    if (is_tracked(op))
+        gc_untrack(op);
+
+    assert(Py_RefcntSnoop(op) == 1);
+    op->ob_refowner = Py_REFOWNER_DELETED;
+    op->ob_refcnt = Py_REFCNT_DELETED;
+    /* XXX Rename this.  It should call a private _Free function */
+    _PyObject_GC_Del(op);
+    Py_DECREF(tp);
+}
+
+/* Revives an object who's tp_dealloc was called, but wasn't actually
+ * deleted.  Causes the GC to track it again.
+ *
+ * Objects with a weakref field cannot be revived. */
+void
+PyObject_Revive(void *pyobject)
+{
+    PyObject *op = pyobject;
+
+    if (PyType_SUPPORTS_WEAKREFS(Py_TYPE(op)))
+        Py_FatalError("Cannot revive objects that support weakrefs");
+
+    if (PyType_IS_GC(Py_TYPE(op)))
+        gc_track(op);
+}
+
+/* Tracks op, "completing" the allocation process.  This is only useful
+ * for base classes that would rather wipe themselves lazily.
+ *
+ * PyObject_Resize cannot be used until the object has been completed. */
+void
+PyObject_Complete(void *pyobject)
+{
+    PyObject *op = pyobject;
+
+    if (PyType_HasFeature(Py_TYPE(op), Py_TPFLAGS_SKIPWIPE) &&
+            PyType_IS_GC(Py_TYPE(op)))
+        gc_track(op);
+}
+
+void *
+PyObject_Resize(void *pyobject, Py_ssize_t nitems)
+{
+	PyObject *op = pyobject;
+	size_t oldsize = _PyObject_VAR_SIZE(Py_TYPE(op), Py_SIZE(op));
+	/* XXX FIXME Some code assumes a sentinal is allocated.  Blah. */
+	size_t newsize = _PyObject_VAR_SIZE(Py_TYPE(op), nitems + 1);
+
+	_Py_DEC_REFTOTAL();
+	if (PyType_IS_GC(Py_TYPE(op)))
+		gc_untrack(op);
+
+	/* XXX FIXME we're leaving op with its reference forgotten and untracked */
+	_Py_ForgetReference(op);
+	/* XXX FIXME _PyObject_GC_Resize should use newsize, not nitems */
+	op = (PyObject *)_PyObject_GC_Resize((PyVarObject *)op, nitems);
+	if (op == NULL)
+		return NULL;
+	_Py_NewReference(op);
+
+	/* Zero out items added by growing */
+	if (newsize > oldsize)
+		memset(((char *)op) + oldsize, 0, newsize - oldsize);
+	if (PyType_IS_GC(Py_TYPE(op)))
+		gc_track(op);
+	return op;
 }

=== modified file 'Modules/gdbmmodule.c'
--- Modules/gdbmmodule.c	2008-03-16 00:07:10 +0000
+++ Modules/gdbmmodule.c	2008-04-11 02:07:11 +0000
@@ -60,7 +60,7 @@
 {
     dbmobject *dp;
 
-    dp = PyObject_New(dbmobject, &Dbmtype);
+    dp = PyObject_New(&Dbmtype);
     if (dp == NULL)
         return NULL;
     dp->di_size = -1;

=== modified file 'Modules/itertoolsmodule.c'
--- Modules/itertoolsmodule.c	2008-04-01 07:37:58 +0000
+++ Modules/itertoolsmodule.c	2008-04-11 03:15:49 +0000
@@ -34,7 +34,7 @@
 					 &it, &keyfunc))
 		return NULL;
 
-	gbo = (groupbyobject *)type->tp_alloc(type, 0);
+	gbo = PyObject_New(type);
 	if (gbo == NULL)
 		return NULL;
 	gbo->tgtkey = NULL;
@@ -53,13 +53,12 @@
 static void
 groupby_dealloc(groupbyobject *gbo)
 {
-	PyObject_GC_UnTrack(gbo);
 	Py_XDECREF(gbo->it);
 	Py_XDECREF(gbo->keyfunc);
 	Py_XDECREF(gbo->tgtkey);
 	Py_XDECREF(gbo->currkey);
 	Py_XDECREF(gbo->currvalue);
-	Py_TYPE(gbo)->tp_free(gbo);
+	PyObject_Del(gbo);
 }
 
 static int
@@ -177,9 +176,7 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	0,				/* tp_init */
-	0,				/* tp_alloc */
 	groupby_new,			/* tp_new */
-	PyObject_GC_Del,		/* tp_free */
 };
 
 
@@ -198,7 +195,7 @@
 {
 	_grouperobject *igo;
 
-	igo = PyObject_GC_New(_grouperobject, &_grouper_type);
+	igo = PyObject_New(&_grouper_type);
 	if (igo == NULL)
 		return NULL;
 	igo->parent = (PyObject *)parent;
@@ -206,17 +203,15 @@
 	igo->tgtkey = tgtkey;
 	Py_INCREF(tgtkey);
 
-	PyObject_GC_Track(igo);
 	return (PyObject *)igo;
 }
 
 static void
 _grouper_dealloc(_grouperobject *igo)
 {
-	PyObject_GC_UnTrack(igo);
 	Py_DECREF(igo->parent);
 	Py_DECREF(igo->tgtkey);
-	PyObject_GC_Del(igo);
+	PyObject_Del(igo);
 }
 
 static int
@@ -307,9 +302,7 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	0,				/* tp_init */
-	0,				/* tp_alloc */
 	0,				/* tp_new */
-	PyObject_GC_Del,		/* tp_free */
 };
 
  
@@ -348,7 +341,7 @@
 {
 	teedataobject *tdo;
 
-	tdo = PyObject_GC_New(teedataobject, &teedataobject_type);
+	tdo = PyObject_New(&teedataobject_type);
 	if (tdo == NULL)
 		return NULL;
 
@@ -356,7 +349,6 @@
 	tdo->nextlink = NULL;
 	Py_INCREF(it);
 	tdo->it = it;
-	PyObject_GC_Track(tdo);
 	return (PyObject *)tdo;
 }
 
@@ -415,9 +407,8 @@
 static void
 teedataobject_dealloc(teedataobject *tdo)
 {
-	PyObject_GC_UnTrack(tdo);
 	teedataobject_clear(tdo);
-	PyObject_GC_Del(tdo);
+	PyObject_Del(tdo);
 }
 
 PyDoc_STRVAR(teedataobject_doc, "Data container common to multiple tee objects.");
@@ -460,9 +451,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	0,					/* tp_new */
-	PyObject_GC_Del,			/* tp_free */
 };
 
 
@@ -498,14 +487,13 @@
 {
 	teeobject *newto;
 
-	newto = PyObject_GC_New(teeobject, &tee_type);
+	newto = PyObject_New(&tee_type);
 	if (newto == NULL)
 		return NULL;
 	Py_INCREF(to->dataobj);
 	newto->dataobj = to->dataobj;
 	newto->index = to->index;
 	newto->weakreflist = NULL;
-	PyObject_GC_Track(newto);
 	return (PyObject *)newto;
 }
 
@@ -525,19 +513,18 @@
 		goto done;
 	}
 
-	to = PyObject_GC_New(teeobject, &tee_type);
+	to = PyObject_New(&tee_type);
 	if (to == NULL) 
 		goto done;
 	to->dataobj = (teedataobject *)teedataobject_new(it);
 	if (!to->dataobj) {
-		PyObject_GC_Del(to);
+		PyObject_Del(to);
 		to = NULL;
 		goto done;
 	}
 
 	to->index = 0;
 	to->weakreflist = NULL;
-	PyObject_GC_Track(to);
 done:
 	Py_XDECREF(it);
 	return (PyObject *)to;
@@ -556,8 +543,6 @@
 static int
 tee_clear(teeobject *to)
 {
-	if (to->weakreflist != NULL)
-		PyObject_ClearWeakRefs((PyObject *) to);
 	Py_CLEAR(to->dataobj);
 	return 0;
 }
@@ -565,9 +550,8 @@
 static void
 tee_dealloc(teeobject *to)
 {
-	PyObject_GC_UnTrack(to);
 	tee_clear(to);
-	PyObject_GC_Del(to);
+	PyObject_Del(to);
 }
 
 PyDoc_STRVAR(teeobject_doc,
@@ -616,9 +600,7 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	0,				/* tp_init */
-	0,				/* tp_alloc */
 	tee_new,			/* tp_new */
-	PyObject_GC_Del,		/* tp_free */
 };
 
 static PyObject *
@@ -705,7 +687,7 @@
 	}
 
 	/* create cycleobject structure */
-	lz = (cycleobject *)type->tp_alloc(type, 0);
+	lz = PyObject_New(type);
 	if (lz == NULL) {
 		Py_DECREF(it);
 		Py_DECREF(saved);
@@ -721,10 +703,9 @@
 static void
 cycle_dealloc(cycleobject *lz)
 {
-	PyObject_GC_UnTrack(lz);
 	Py_XDECREF(lz->saved);
 	Py_XDECREF(lz->it);
-	Py_TYPE(lz)->tp_free(lz);
+	PyObject_Del(lz);
 }
 
 static int
@@ -812,9 +793,7 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	0,				/* tp_init */
-	0,				/* tp_alloc */
 	cycle_new,			/* tp_new */
-	PyObject_GC_Del,		/* tp_free */
 };
 
 
@@ -848,7 +827,7 @@
 		return NULL;
 
 	/* create dropwhileobject structure */
-	lz = (dropwhileobject *)type->tp_alloc(type, 0);
+	lz = PyObject_New(type);
 	if (lz == NULL) {
 		Py_DECREF(it);
 		return NULL;
@@ -864,10 +843,9 @@
 static void
 dropwhile_dealloc(dropwhileobject *lz)
 {
-	PyObject_GC_UnTrack(lz);
 	Py_XDECREF(lz->func);
 	Py_XDECREF(lz->it);
-	Py_TYPE(lz)->tp_free(lz);
+	PyObject_Del(lz);
 }
 
 static int
@@ -955,9 +933,7 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	0,				/* tp_init */
-	0,				/* tp_alloc */
 	dropwhile_new,			/* tp_new */
-	PyObject_GC_Del,		/* tp_free */
 };
 
 
@@ -991,7 +967,7 @@
 		return NULL;
 
 	/* create takewhileobject structure */
-	lz = (takewhileobject *)type->tp_alloc(type, 0);
+	lz = PyObject_New(type);
 	if (lz == NULL) {
 		Py_DECREF(it);
 		return NULL;
@@ -1007,10 +983,9 @@
 static void
 takewhile_dealloc(takewhileobject *lz)
 {
-	PyObject_GC_UnTrack(lz);
 	Py_XDECREF(lz->func);
 	Py_XDECREF(lz->it);
-	Py_TYPE(lz)->tp_free(lz);
+	PyObject_Del(lz);
 }
 
 static int
@@ -1095,9 +1070,7 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	0,				/* tp_init */
-	0,				/* tp_alloc */
 	takewhile_new,			/* tp_new */
-	PyObject_GC_Del,		/* tp_free */
 };
 
 
@@ -1181,7 +1154,7 @@
 		return NULL;
 
 	/* create isliceobject structure */
-	lz = (isliceobject *)type->tp_alloc(type, 0);
+	lz = PyObject_New(type);
 	if (lz == NULL) {
 		Py_DECREF(it);
 		return NULL;
@@ -1198,9 +1171,8 @@
 static void
 islice_dealloc(isliceobject *lz)
 {
-	PyObject_GC_UnTrack(lz);
 	Py_XDECREF(lz->it);
-	Py_TYPE(lz)->tp_free(lz);
+	PyObject_Del(lz);
 }
 
 static int
@@ -1290,9 +1262,7 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	0,				/* tp_init */
-	0,				/* tp_alloc */
 	islice_new,			/* tp_new */
-	PyObject_GC_Del,		/* tp_free */
 };
 
 
@@ -1325,7 +1295,7 @@
 		return NULL;
 
 	/* create starmapobject structure */
-	lz = (starmapobject *)type->tp_alloc(type, 0);
+	lz = PyObject_New(type);
 	if (lz == NULL) {
 		Py_DECREF(it);
 		return NULL;
@@ -1340,10 +1310,9 @@
 static void
 starmap_dealloc(starmapobject *lz)
 {
-	PyObject_GC_UnTrack(lz);
 	Py_XDECREF(lz->func);
 	Py_XDECREF(lz->it);
-	Py_TYPE(lz)->tp_free(lz);
+	PyObject_Del(lz);
 }
 
 static int
@@ -1422,9 +1391,7 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	0,				/* tp_init */
-	0,				/* tp_alloc */
 	starmap_new,			/* tp_new */
-	PyObject_GC_Del,		/* tp_free */
 };
 
 
@@ -1443,7 +1410,7 @@
 {
 	chainobject *lz;
 
-	lz = (chainobject *)type->tp_alloc(type, 0);
+	lz = PyObject_New(type);
 	if (lz == NULL) {
 		Py_DECREF(source);
 		return NULL;
@@ -1484,10 +1451,9 @@
 static void
 chain_dealloc(chainobject *lz)
 {
-	PyObject_GC_UnTrack(lz);
 	Py_XDECREF(lz->active);
 	Py_XDECREF(lz->source);
-	Py_TYPE(lz)->tp_free(lz);
+	PyObject_Del(lz);
 }
 
 static int
@@ -1590,9 +1556,7 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	0,				/* tp_init */
-	0,				/* tp_alloc */
 	chain_new,			/* tp_new */
-	PyObject_GC_Del,		/* tp_free */
 };
 
 
@@ -1664,7 +1628,7 @@
 	}
 
 	/* create productobject structure */
-	lz = (productobject *)type->tp_alloc(type, 0);
+	lz = PyObject_New(type);
 	if (lz == NULL)
 		goto error;
 
@@ -1685,11 +1649,10 @@
 static void
 product_dealloc(productobject *lz)
 {
-	PyObject_GC_UnTrack(lz);
 	Py_XDECREF(lz->pools);
 	Py_XDECREF(lz->result);
 	PyMem_Free(lz->indices);
-	Py_TYPE(lz)->tp_free(lz);
+	PyObject_Del(lz);
 }
 
 static int
@@ -1733,7 +1696,7 @@
 		Py_ssize_t *indices = lz->indices;
 
 		/* Copy the previous result tuple or re-use it if available */
-		if (Py_REFCNT(result) > 1) {
+		if (!Py_RefcntMatches(result, 1)) {
 			PyObject *old_result = result;
 			result = PyTuple_New(npools);
 			if (result == NULL)
@@ -1747,7 +1710,7 @@
 			Py_DECREF(old_result);
 		}
 		/* Now, we've got the only copy so we can update it in-place */
-		assert (npools==0 || Py_REFCNT(result) == 1);
+		assert(npools==0 || Py_RefcntMatches(result, 1));
 
                 /* Update the pool indices right-to-left.  Only advance to the
                    next pool when the previous one rolls-over */
@@ -1837,9 +1800,7 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	0,				/* tp_init */
-	0,				/* tp_alloc */
 	product_new,			/* tp_new */
-	PyObject_GC_Del,		/* tp_free */
 };
 
 
@@ -1895,7 +1856,7 @@
 		indices[i] = i;
 
 	/* create combinationsobject structure */
-	co = (combinationsobject *)type->tp_alloc(type, 0);
+	co = PyObject_New(type);
 	if (co == NULL)
 		goto error;
 
@@ -1917,11 +1878,10 @@
 static void
 combinations_dealloc(combinationsobject *co)
 {
-	PyObject_GC_UnTrack(co);
 	Py_XDECREF(co->pool);
 	Py_XDECREF(co->result);
 	PyMem_Free(co->indices);
-	Py_TYPE(co)->tp_free(co);
+	PyObject_Del(co);
 }
 
 static int
@@ -1961,7 +1921,7 @@
 		}
 	} else {
 		/* Copy the previous result tuple or re-use it if available */
-		if (Py_REFCNT(result) > 1) {
+		if (!Py_RefcntMatches(result, 1)) {
 			PyObject *old_result = result;
 			result = PyTuple_New(r);
 			if (result == NULL)
@@ -1978,7 +1938,7 @@
 		 * CPython's empty tuple is a singleton and cached in
 		 * PyTuple's freelist.
 		 */
-		assert(r == 0 || Py_REFCNT(result) == 1);
+		assert(r == 0 || Py_RefcntMatches(result, 1));
 
                 /* Scan indices right-to-left until finding one that is not
                    at its maximum (i + n - r). */
@@ -2063,9 +2023,7 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	0,				/* tp_init */
-	0,				/* tp_alloc */
 	combinations_new,			/* tp_new */
-	PyObject_GC_Del,		/* tp_free */
 };
 
 
@@ -2161,7 +2119,7 @@
 		cycles[i] = n - i;
 
 	/* create permutationsobject structure */
-	po = (permutationsobject *)type->tp_alloc(type, 0);
+	po = PyObject_New(type);
 	if (po == NULL)
 		goto error;
 
@@ -2186,12 +2144,11 @@
 static void
 permutations_dealloc(permutationsobject *po)
 {
-	PyObject_GC_UnTrack(po);
 	Py_XDECREF(po->pool);
 	Py_XDECREF(po->result);
 	PyMem_Free(po->indices);
 	PyMem_Free(po->cycles);
-	Py_TYPE(po)->tp_free(po);
+	PyObject_Del(po);
 }
 
 static int
@@ -2235,7 +2192,7 @@
 			goto empty;
 
 		/* Copy the previous result tuple or re-use it if available */
-		if (Py_REFCNT(result) > 1) {
+		if (!Py_RefcntMatches(result, 1)) {
 			PyObject *old_result = result;
 			result = PyTuple_New(r);
 			if (result == NULL)
@@ -2249,7 +2206,7 @@
 			Py_DECREF(old_result);
 		}
 		/* Now, we've got the only copy so we can update it in-place */
-		assert(r == 0 || Py_REFCNT(result) == 1);
+		assert(r == 0 || Py_RefcntMatches(result, 1));
 
                 /* Decrement rightmost cycle, moving leftward upon zero rollover */
 		for (i=r-1 ; i>=0 ; i--) {
@@ -2338,9 +2295,7 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	0,				/* tp_init */
-	0,				/* tp_alloc */
 	permutations_new,			/* tp_new */
-	PyObject_GC_Del,		/* tp_free */
 };
 
 
@@ -2374,7 +2329,7 @@
 		return NULL;
 
 	/* create filterfalseobject structure */
-	lz = (filterfalseobject *)type->tp_alloc(type, 0);
+	lz = PyObject_New(type);
 	if (lz == NULL) {
 		Py_DECREF(it);
 		return NULL;
@@ -2389,10 +2344,9 @@
 static void
 filterfalse_dealloc(filterfalseobject *lz)
 {
-	PyObject_GC_UnTrack(lz);
 	Py_XDECREF(lz->func);
 	Py_XDECREF(lz->it);
-	Py_TYPE(lz)->tp_free(lz);
+	PyObject_Del(lz);
 }
 
 static int
@@ -2482,9 +2436,7 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	0,				/* tp_init */
-	0,				/* tp_alloc */
 	filterfalse_new,		/* tp_new */
-	PyObject_GC_Del,		/* tp_free */
 };
 
 
@@ -2527,7 +2479,7 @@
 	}
 
 	/* create countobject structure */
-	lz = (countobject *)PyObject_New(countobject, &count_type);
+	lz = PyObject_New(&count_type);
 	if (lz == NULL) {
 		Py_XDECREF(long_cnt);
 		return NULL;
@@ -2632,7 +2584,6 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	0,				/* tp_init */
-	0,				/* tp_alloc */
 	count_new,			/* tp_new */
 };
 
@@ -2663,7 +2614,7 @@
 	if (PyTuple_Size(args) == 2 && cnt < 0)
 		cnt = 0;
 
-	ro = (repeatobject *)type->tp_alloc(type, 0);
+	ro = PyObject_New(type);
 	if (ro == NULL)
 		return NULL;
 	Py_INCREF(element);
@@ -2675,9 +2626,8 @@
 static void
 repeat_dealloc(repeatobject *ro)
 {
-	PyObject_GC_UnTrack(ro);
 	Py_XDECREF(ro->element);
-	Py_TYPE(ro)->tp_free(ro);
+	PyObject_Del(ro);
 }
 
 static int
@@ -2768,9 +2718,7 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	0,				/* tp_init */
-	0,				/* tp_alloc */
 	repeat_new,			/* tp_new */
-	PyObject_GC_Del,		/* tp_free */
 };
 
 /* ziplongest object ************************************************************/
@@ -2840,7 +2788,7 @@
 	}
 
 	/* create ziplongestobject structure */
-	lz = (ziplongestobject *)type->tp_alloc(type, 0);
+	lz = PyObject_New(type);
 	if (lz == NULL) {
 		Py_DECREF(ittuple);
 		Py_DECREF(result);
@@ -2858,11 +2806,10 @@
 static void
 zip_longest_dealloc(ziplongestobject *lz)
 {
-	PyObject_GC_UnTrack(lz);
 	Py_XDECREF(lz->ittuple);
 	Py_XDECREF(lz->result);
 	Py_XDECREF(lz->fillvalue);
-	Py_TYPE(lz)->tp_free(lz);
+	PyObject_Del(lz);
 }
 
 static int
@@ -2888,7 +2835,7 @@
 		return NULL;
         if (lz->numactive == 0)
                 return NULL;
-	if (Py_REFCNT(result) == 1) {
+	if (Py_RefcntMatches(result, 1)) {
 		Py_INCREF(result);
 		for (i=0 ; i < tuplesize ; i++) {
 			it = PyTuple_GET_ITEM(lz->ittuple, i);
@@ -2996,9 +2943,7 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	0,				/* tp_init */
-	0,				/* tp_alloc */
 	zip_longest_new,			/* tp_new */
-	PyObject_GC_Del,		/* tp_free */
 };
 
 /* module level code ********************************************************/

=== modified file 'Modules/main.c'
--- Modules/main.c	2008-04-06 17:57:16 +0000
+++ Modules/main.c	2008-04-11 02:07:11 +0000
@@ -240,34 +240,6 @@
 	}
 }
 
-
-/* Wait until threading._shutdown completes, provided
-   the threading module was imported in the first place.
-   The shutdown routine will wait until all non-daemon
-   "threading" threads have completed. */
-#include "abstract.h"
-static void
-WaitForThreadShutdown(void)
-{
-#ifdef WITH_THREAD
-	PyObject *result;
-	PyThreadState *tstate = PyThreadState_GET();
-	PyObject *threading = PyMapping_GetItemString(tstate->interp->modules,
-						      "threading");
-	if (threading == NULL) {
-		/* threading not imported */
-		PyErr_Clear();
-		return;
-	}
-	result = PyObject_CallMethod(threading, "_shutdown", "");
-	if (result == NULL)
-		PyErr_WriteUnraisable(threading);
-	else
-		Py_DECREF(result);
-	Py_DECREF(threading);
-#endif
-}
-
 /* Main program */
 
 int
@@ -600,8 +572,6 @@
 		sts = PyRun_AnyFileFlags(stdin, "<stdin>", &cf) != 0;
 	}
 
-	WaitForThreadShutdown();
-
 	Py_Finalize();
 
 #ifdef __INSURE__

=== modified file 'Modules/mathmodule.c'
--- Modules/mathmodule.c	2008-02-03 16:51:08 +0000
+++ Modules/mathmodule.c	2008-03-24 04:28:04 +0000
@@ -129,6 +129,7 @@
 static PyObject * math_ceil(PyObject *self, PyObject *number) {
 	static PyObject *ceil_str = NULL;
 	PyObject *method;
+	PyObject *result;
 
 	if (ceil_str == NULL) {
 		ceil_str = PyUnicode_InternFromString("__ceil__");
@@ -136,11 +137,15 @@
 			return NULL;
 	}
 
-	method = _PyType_Lookup(Py_TYPE(number), ceil_str);
+	if (_PyType_LookupEx(Py_TYPE(number), ceil_str, &method) < 0)
+		return NULL;
 	if (method == NULL)
 		return math_1_to_int(number, ceil);
-	else
-		return PyObject_CallFunction(method, "O", number);
+	else {
+		result = PyObject_CallFunction(method, "O", number);
+		Py_DECREF(method);
+		return result;
+	}
 }
 
 PyDoc_STRVAR(math_ceil_doc,
@@ -169,6 +174,7 @@
 static PyObject * math_floor(PyObject *self, PyObject *number) {
 	static PyObject *floor_str = NULL;
 	PyObject *method;
+	PyObject *result;
 
 	if (floor_str == NULL) {
 		floor_str = PyUnicode_InternFromString("__floor__");
@@ -176,11 +182,15 @@
 			return NULL;
 	}
 
-	method = _PyType_Lookup(Py_TYPE(number), floor_str);
+	if (_PyType_LookupEx(Py_TYPE(number), floor_str, &method) < 0)
+		return NULL;
 	if (method == NULL)
         	return math_1_to_int(number, floor);
-	else
-		return PyObject_CallFunction(method, "O", number);
+	else {
+		result = PyObject_CallFunction(method, "O", number);
+		Py_DECREF(method);
+		return result;
+	}
 }
 
 PyDoc_STRVAR(math_floor_doc,
@@ -210,6 +220,7 @@
 {
 	static PyObject *trunc_str = NULL;
 	PyObject *trunc;
+	PyObject *result;
 
 	if (Py_TYPE(number)->tp_dict == NULL) {
 		if (PyType_Ready(Py_TYPE(number)) < 0)
@@ -222,14 +233,19 @@
 			return NULL;
 	}
 
-	trunc = _PyType_Lookup(Py_TYPE(number), trunc_str);
+	if (_PyType_LookupEx(Py_TYPE(number), trunc_str, &trunc) < 0)
+		return NULL;
 	if (trunc == NULL) {
 		PyErr_Format(PyExc_TypeError,
 			     "type %.100s doesn't define __trunc__ method",
 			     Py_TYPE(number)->tp_name);
 		return NULL;
 	}
-	return PyObject_CallFunctionObjArgs(trunc, number, NULL);
+	else {
+		result = PyObject_CallFunctionObjArgs(trunc, number, NULL);
+		Py_DECREF(trunc);
+		return result;
+	}
 }
 
 PyDoc_STRVAR(math_trunc_doc,

=== modified file 'Modules/mmapmodule.c'
--- Modules/mmapmodule.c	2008-02-19 14:21:46 +0000
+++ Modules/mmapmodule.c	2008-03-24 04:28:04 +0000
@@ -130,7 +130,7 @@
 	}
 #endif /* UNIX */
 
-	Py_TYPE(m_obj)->tp_free((PyObject*)m_obj);
+	PyObject_Del(m_obj);
 }
 
 static PyObject *
@@ -958,9 +958,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,                                      /* tp_init */
-	PyType_GenericAlloc,			/* tp_alloc */
 	new_mmap_object,			/* tp_new */
-	PyObject_Del,                           /* tp_free */
 };
 
 
@@ -1064,7 +1062,7 @@
 		}
 	}
 #endif
-	m_obj = (mmap_object *)type->tp_alloc(type, 0);
+	m_obj = PyObject_New(type);
 	if (m_obj == NULL) {return NULL;}
 	m_obj->data = NULL;
 	m_obj->size = (size_t) map_size;
@@ -1188,7 +1186,7 @@
 		lseek(fileno, 0, SEEK_SET);
 	}
 
-	m_obj = (mmap_object *)type->tp_alloc(type, 0);
+	m_obj = PyObject_New(&type);
 	if (m_obj == NULL)
 		return NULL;
 	/* Set every field to an invalid marker, so we can safely

=== modified file 'Modules/operator.c'
--- Modules/operator.c	2008-03-17 18:02:30 +0000
+++ Modules/operator.c	2008-04-11 02:07:11 +0000
@@ -67,6 +67,7 @@
 
 spami(isNumberType     , PyNumber_Check)
 spami(truth            , PyObject_IsTrue)
+spami(isShareable      , PyObject_IsShareable)
 spam2(op_add           , PyNumber_Add)
 spam2(op_sub           , PyNumber_Subtract)
 spam2(op_mul           , PyNumber_Multiply)
@@ -164,12 +165,12 @@
 #undef spam2
 #undef spam1o
 #undef spam1o
-#define spam1(OP,DOC) {#OP, OP, METH_VARARGS, PyDoc_STR(DOC)},
-#define spam2(OP,ALTOP,DOC) {#OP, op_##OP, METH_VARARGS, PyDoc_STR(DOC)}, \
-			   {#ALTOP, op_##OP, METH_VARARGS, PyDoc_STR(DOC)}, 
-#define spam1o(OP,DOC) {#OP, OP, METH_O, PyDoc_STR(DOC)},
-#define spam2o(OP,ALTOP,DOC) {#OP, op_##OP, METH_O, PyDoc_STR(DOC)}, \
-			   {#ALTOP, op_##OP, METH_O, PyDoc_STR(DOC)}, 
+#define spam1(OP,DOC) {#OP, OP, METH_VARARGS|METH_SHARED, PyDoc_STR(DOC)},
+#define spam2(OP,ALTOP,DOC) {#OP, op_##OP, METH_VARARGS|METH_SHARED, PyDoc_STR(DOC)}, \
+			   {#ALTOP, op_##OP, METH_VARARGS|METH_SHARED, PyDoc_STR(DOC)}, 
+#define spam1o(OP,DOC) {#OP, OP, METH_O|METH_SHARED, PyDoc_STR(DOC)},
+#define spam2o(OP,ALTOP,DOC) {#OP, op_##OP, METH_O|METH_SHARED, PyDoc_STR(DOC)}, \
+			   {#ALTOP, op_##OP, METH_O|METH_SHARED, PyDoc_STR(DOC)}, 
 
 static struct PyMethodDef operator_methods[] = {
 
@@ -179,6 +180,8 @@
  "isSequenceType(a) -- Return True if a has a sequence type, False otherwise.")
 spam1o(truth,
  "truth(a) -- Return True if a is true, False otherwise.")
+spam1o(isShareable,
+ "isShareable(a) -- Return True if a is shareable, False otherwise.")
 spam2(contains,__contains__,
  "contains(a, b) -- Same as b in a (note reversed operands).")
 spam1(indexOf,
@@ -274,7 +277,7 @@
 		item = args;
 
 	/* create itemgetterobject structure */
-	ig = PyObject_GC_New(itemgetterobject, &itemgetter_type);
+	ig = PyObject_New(&itemgetter_type);
 	if (ig == NULL) 
 		return NULL;	
 	
@@ -282,16 +285,14 @@
 	ig->item = item;
 	ig->nitems = nitems;
 
-	PyObject_GC_Track(ig);
 	return (PyObject *)ig;
 }
 
 static void
 itemgetter_dealloc(itemgetterobject *ig)
 {
-	PyObject_GC_UnTrack(ig);
 	Py_XDECREF(ig->item);
-	PyObject_GC_Del(ig);
+	PyObject_Del(ig);
 }
 
 static int
@@ -360,7 +361,8 @@
 	PyObject_GenericGetAttr,	/* tp_getattro */
 	0,				/* tp_setattro */
 	0,				/* tp_as_buffer */
-	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,	/* tp_flags */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
+		Py_TPFLAGS_SHAREABLE,	/* tp_flags */
 	itemgetter_doc,			/* tp_doc */
 	(traverseproc)itemgetter_traverse,	/* tp_traverse */
 	0,				/* tp_clear */
@@ -377,9 +379,7 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	0,				/* tp_init */
-	0,				/* tp_alloc */
 	itemgetter_new,			/* tp_new */
-	0,				/* tp_free */
 };
 
 
@@ -411,7 +411,7 @@
 		attr = args;
 
 	/* create attrgetterobject structure */
-	ag = PyObject_GC_New(attrgetterobject, &attrgetter_type);
+	ag = PyObject_New(&attrgetter_type);
 	if (ag == NULL) 
 		return NULL;	
 	
@@ -419,16 +419,14 @@
 	ag->attr = attr;
 	ag->nattrs = nattrs;
 
-	PyObject_GC_Track(ag);
 	return (PyObject *)ag;
 }
 
 static void
 attrgetter_dealloc(attrgetterobject *ag)
 {
-	PyObject_GC_UnTrack(ag);
 	Py_XDECREF(ag->attr);
-	PyObject_GC_Del(ag);
+	PyObject_Del(ag);
 }
 
 static int
@@ -534,7 +532,8 @@
 	PyObject_GenericGetAttr,	/* tp_getattro */
 	0,				/* tp_setattro */
 	0,				/* tp_as_buffer */
-	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,	/* tp_flags */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
+		Py_TPFLAGS_SHAREABLE,	/* tp_flags */
 	attrgetter_doc,			/* tp_doc */
 	(traverseproc)attrgetter_traverse,	/* tp_traverse */
 	0,				/* tp_clear */
@@ -551,9 +550,7 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	0,				/* tp_init */
-	0,				/* tp_alloc */
 	attrgetter_new,			/* tp_new */
-	0,				/* tp_free */
 };
 
 
@@ -581,7 +578,7 @@
 	}
 
 	/* create methodcallerobject structure */
-	mc = PyObject_GC_New(methodcallerobject, &methodcaller_type);
+	mc = PyObject_New(&methodcaller_type);
 	if (mc == NULL) 
 		return NULL;	
 
@@ -599,18 +596,16 @@
 	Py_XINCREF(kwds);
 	mc->kwds = kwds;
 
-	PyObject_GC_Track(mc);
 	return (PyObject *)mc;
 }
 
 static void
 methodcaller_dealloc(methodcallerobject *mc)
 {
-	PyObject_GC_UnTrack(mc);
 	Py_XDECREF(mc->name);
 	Py_XDECREF(mc->args);
 	Py_XDECREF(mc->kwds);
-	PyObject_GC_Del(mc);
+	PyObject_Del(mc);
 }
 
 static int
@@ -665,7 +660,8 @@
 	PyObject_GenericGetAttr,	/* tp_getattro */
 	0,				/* tp_setattro */
 	0,				/* tp_as_buffer */
-	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,/* tp_flags */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
+		Py_TPFLAGS_SHAREABLE,	/* tp_flags */
 	methodcaller_doc,			/* tp_doc */
 	(traverseproc)methodcaller_traverse,	/* tp_traverse */
 	0,				/* tp_clear */
@@ -682,9 +678,7 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	0,				/* tp_init */
-	0,				/* tp_alloc */
 	methodcaller_new,		/* tp_new */
-	0,				/* tp_free */
 };
 
 
@@ -696,8 +690,8 @@
 	PyObject *m;
         
 	/* Create the module and add the functions */
-        m = Py_InitModule4("operator", operator_methods, operator_doc,
-		       (PyObject*)NULL, PYTHON_API_VERSION);
+        m = Py_InitModule5("operator", operator_methods, operator_doc,
+		       (PyObject*)NULL, PYTHON_API_VERSION, 1);
 	if (m == NULL)
 		return;
 

=== modified file 'Modules/ossaudiodev.c'
--- Modules/ossaudiodev.c	2007-12-02 14:31:20 +0000
+++ Modules/ossaudiodev.c	2008-03-24 04:28:04 +0000
@@ -133,7 +133,7 @@
         return NULL;
     }
     /* Create and initialize the object */
-    if ((self = PyObject_New(oss_audio_t, &OSSAudioType)) == NULL) {
+    if ((self = PyObject_New(&OSSAudioType)) == NULL) {
         close(fd);
         return NULL;
     }
@@ -181,7 +181,7 @@
         return NULL;
     }
 
-    if ((self = PyObject_New(oss_mixer_t, &OSSMixerType)) == NULL) {
+    if ((self = PyObject_New(&OSSMixerType)) == NULL) {
         close(fd);
         return NULL;
     }

=== modified file 'Modules/parsermodule.c'
--- Modules/parsermodule.c	2008-01-03 23:01:04 +0000
+++ Modules/parsermodule.c	2008-03-24 04:28:04 +0000
@@ -255,7 +255,7 @@
 static PyObject*
 parser_newstobject(node *st, int type)
 {
-    PyST_Object* o = PyObject_New(PyST_Object, &PyST_Type);
+    PyST_Object* o = PyObject_New(&PyST_Type);
 
     if (o != 0) {
         o->st_node = st;

=== modified file 'Modules/posixmodule.c'
--- Modules/posixmodule.c	2008-03-19 21:50:51 +0000
+++ Modules/posixmodule.c	2008-04-11 02:07:11 +0000
@@ -156,6 +156,16 @@
 #endif  /* ! __WATCOMC__ || __QNX__ */
 #endif /* ! __IBMC__ */
 
+#if !defined(HAVE_SPAWNV) && (defined(HAVE_FORK) && defined(HAVE_EXECV))
+#define EMULATE_SPAWNV
+#define HAVE_SPAWNV
+#endif
+
+/* These are broken so we disable them */
+#undef HAVE_FORK
+#undef HAVE_FORK1
+#undef HAVE_FORKPTY
+
 #ifndef _MSC_VER
 
 #if defined(__sgi)&&_COMPILER_VERSION>=700
@@ -3138,6 +3148,64 @@
 #endif /* HAVE_EXECV */
 
 
+#ifdef EMULATE_SPAWNV
+#define _P_WAIT 1
+#define _P_NOWAIT 2
+#define _OLD_P_OVERLAY 42
+#define _P_OVERLAY 43
+/* XXX is this really right?  Am I getting all the spawn semantics right?
+ * Should I even claim I am emulating spawn? */
+static Py_intptr_t
+_py_spawn(int mode, const char *path, char **argvlist, char **envlist)
+{
+	int pid;
+
+	/* We only support _P_WAIT and _P_NOWAIT */
+	assert(mode == _P_WAIT || mode == _P_NOWAIT);
+
+	pid = fork();
+	if (pid == -1)
+		return -1;
+	else if (pid == 0) {
+		/* XXX purge open file descriptors.  Doesn't that mean
+		 * we need an argument telling us which to keep though? */
+		if (envlist == NULL)
+			execv(path, argvlist);
+		else
+			execve(path, argvlist, envlist);
+
+		/* IF we get here then execv{,e} failed */
+		_exit(1);
+	} else {
+		if (mode == _P_WAIT) {
+			int status;
+			/* XXX FIXME loop if the child gets stopped? */
+			if (waitpid(pid, &status, 0) == -1)
+				return -1;
+			return status;
+		}
+		return pid;
+	}
+}
+
+static Py_intptr_t
+_py_spawnv(int mode, const char *path, char **argvlist)
+{
+	return _py_spawn(mode, path, argvlist, NULL);
+}
+
+static Py_intptr_t
+_py_spawnve(int mode, const char *path, char **argvlist, char **envlist)
+{
+	return _py_spawn(mode, path, argvlist, envlist);
+}
+#else
+#define _py_spawnv _spawnv
+#define _py_spawnve _spawnve
+#define _py_spawnvp _spawnvp
+#endif /* EMULATE_SPAWNV */
+
+
 #ifdef HAVE_SPAWNV
 PyDoc_STRVAR(posix_spawnv__doc__,
 "spawnv(mode, path, args)\n\n\
@@ -3208,7 +3276,7 @@
 		mode = _P_OVERLAY;
 
 	Py_BEGIN_ALLOW_THREADS
-	spawnval = _spawnv(mode, path, argvlist);
+	spawnval = _py_spawnv(mode, path, argvlist);
 	Py_END_ALLOW_THREADS
 #endif
 
@@ -3353,7 +3421,7 @@
 		mode = _P_OVERLAY;
 
 	Py_BEGIN_ALLOW_THREADS
-	spawnval = _spawnve(mode, path, argvlist, envlist);
+	spawnval = _py_spawnve(mode, path, argvlist, envlist);
 	Py_END_ALLOW_THREADS
 #endif
 
@@ -3445,7 +3513,7 @@
 #if defined(PYCC_GCC)
 	spawnval = spawnvp(mode, path, argvlist);
 #else
-	spawnval = _spawnvp(mode, path, argvlist);
+	spawnval = _py_spawnvp(mode, path, argvlist);
 #endif
 	Py_END_ALLOW_THREADS
 
@@ -3616,10 +3684,18 @@
 static PyObject *
 posix_fork1(PyObject *self, PyObject *noargs)
 {
-	pid_t pid = fork1();
-	if (pid == -1)
+	pid_t pid;
+
+	PyState_PrepareFork();
+	pid = fork1();
+	if (pid == -1) {
+		PyState_CleanupForkParent();
 		return posix_error();
-	PyOS_AfterFork();
+	} else if (pid == 0) {
+		PyOS_AfterFork();
+		return PyLong_FromLong(0);
+	}
+	PyState_CleanupForkParent();
 	return PyLong_FromLong(pid);
 }
 #endif
@@ -3634,11 +3710,18 @@
 static PyObject *
 posix_fork(PyObject *self, PyObject *noargs)
 {
-	pid_t pid = fork();
-	if (pid == -1)
+	pid_t pid;
+
+	PyState_PrepareFork();
+	pid = fork();
+	if (pid == -1) {
+		PyState_CleanupForkParent();
 		return posix_error();
-	if (pid == 0)
+	} if (pid == 0) {
 		PyOS_AfterFork();
+		return PyLong_FromLong(0);
+	}
+	PyState_CleanupForkParent();
 	return PyLong_FromLong(pid);
 }
 #endif
@@ -7309,11 +7392,13 @@
 #else
         if (ins(d, "P_WAIT", (long)_P_WAIT)) return -1;
         if (ins(d, "P_NOWAIT", (long)_P_NOWAIT)) return -1;
+#ifndef EMULATE_SPAWNV
         if (ins(d, "P_OVERLAY", (long)_OLD_P_OVERLAY)) return -1;
         if (ins(d, "P_NOWAITO", (long)_P_NOWAITO)) return -1;
         if (ins(d, "P_DETACH", (long)_P_DETACH)) return -1;
 #endif
 #endif
+#endif
 
 #if defined(PYOS_OS2)
         if (insertvalues(d)) return -1;

=== modified file 'Modules/pyexpat.c'
--- Modules/pyexpat.c	2008-01-09 00:17:24 +0000
+++ Modules/pyexpat.c	2008-03-24 04:28:04 +0000
@@ -260,39 +260,39 @@
 
 #ifdef FIX_TRACE
 static int
-trace_frame(PyThreadState *tstate, PyFrameObject *f, int code, PyObject *val)
+trace_frame(PyState *pystate, PyFrameObject *f, int code, PyObject *val)
 {
     int result = 0;
-    if (!tstate->use_tracing || tstate->tracing)
+    if (!pystate->use_tracing || pystate->tracing)
 	return 0;
-    if (tstate->c_profilefunc != NULL) {
-	tstate->tracing++;
-	result = tstate->c_profilefunc(tstate->c_profileobj,
+    if (pystate->c_profilefunc != NULL) {
+	pystate->tracing++;
+	result = pystate->c_profilefunc(pystate->c_profileobj,
 				       f, code , val);
-	tstate->use_tracing = ((tstate->c_tracefunc != NULL)
-			       || (tstate->c_profilefunc != NULL));
-	tstate->tracing--;
+	pystate->use_tracing = ((pystate->c_tracefunc != NULL)
+			       || (pystate->c_profilefunc != NULL));
+	pystate->tracing--;
 	if (result)
 	    return result;
     }
-    if (tstate->c_tracefunc != NULL) {
-	tstate->tracing++;
-	result = tstate->c_tracefunc(tstate->c_traceobj,
+    if (pystate->c_tracefunc != NULL) {
+	pystate->tracing++;
+	result = pystate->c_tracefunc(pystate->c_traceobj,
 				     f, code , val);
-	tstate->use_tracing = ((tstate->c_tracefunc != NULL)
-			       || (tstate->c_profilefunc != NULL));
-	tstate->tracing--;
+	pystate->use_tracing = ((pystate->c_tracefunc != NULL)
+			       || (pystate->c_profilefunc != NULL));
+	pystate->tracing--;
     }	
     return result;
 }
 
 static int
-trace_frame_exc(PyThreadState *tstate, PyFrameObject *f)
+trace_frame_exc(PyState *pystate, PyFrameObject *f)
 {
     PyObject *type, *value, *traceback, *arg;
     int err;
 
-    if (tstate->c_tracefunc == NULL)
+    if (pystate->c_tracefunc == NULL)
 	return 0;
 
     PyErr_Fetch(&type, &value, &traceback);
@@ -309,7 +309,7 @@
 	PyErr_Restore(type, value, traceback);
 	return 0;
     }
-    err = trace_frame(tstate, f, PyTrace_EXCEPTION, arg);
+    err = trace_frame(pystate, f, PyTrace_EXCEPTION, arg);
     Py_DECREF(arg);
     if (err == 0)
 	PyErr_Restore(type, value, traceback);
@@ -326,34 +326,34 @@
 call_with_frame(PyCodeObject *c, PyObject* func, PyObject* args,
                 xmlparseobject *self)
 {
-    PyThreadState *tstate = PyThreadState_GET();
+    PyState *pystate = PyState_Get();
     PyFrameObject *f;
     PyObject *res;
 
     if (c == NULL)
         return NULL;
     
-    f = PyFrame_New(tstate, c, PyEval_GetGlobals(), NULL);
+    f = PyFrame_New(pystate, c, PyEval_GetGlobals(), NULL);
     if (f == NULL)
         return NULL;
-    tstate->frame = f;
+    pystate->frame = f;
 #ifdef FIX_TRACE
-    if (trace_frame(tstate, f, PyTrace_CALL, Py_None) < 0) {
+    if (trace_frame(pystate, f, PyTrace_CALL, Py_None) < 0) {
 	return NULL;
     }
 #endif
     res = PyEval_CallObject(func, args);
     if (res == NULL) {
-	if (tstate->curexc_traceback == NULL)
+	if (pystate->curexc_traceback == NULL)
 	    PyTraceBack_Here(f);
         XML_StopParser(self->itself, XML_FALSE);
 #ifdef FIX_TRACE
-	if (trace_frame_exc(tstate, f) < 0) {
+	if (trace_frame_exc(pystate, f) < 0) {
 	    return NULL;
 	}
     }
     else {
-	if (trace_frame(tstate, f, PyTrace_RETURN, res) < 0) {
+	if (trace_frame(pystate, f, PyTrace_RETURN, res) < 0) {
 	    Py_XDECREF(res);
 	    res = NULL;
 	}
@@ -361,7 +361,7 @@
 #else
     }
 #endif
-    tstate->frame = f->f_back;
+    pystate->frame = f->f_back;
     Py_DECREF(f);
     return res;
 }
@@ -1020,7 +1020,7 @@
     new_parser = PyObject_New(xmlparseobject, &Xmlparsetype);
 #else
     /* Python versions 2.2 and later */
-    new_parser = PyObject_GC_New(xmlparseobject, &Xmlparsetype);
+    new_parser = PyObject_New(&Xmlparsetype);
 #endif
 
     if (new_parser == NULL)
@@ -1035,7 +1035,7 @@
             PyObject_Del(new_parser);
 #else
             /* Code for versions 2.2 and later. */
-            PyObject_GC_Del(new_parser);
+            PyObject_Del(new_parser);
 #endif
             return PyErr_NoMemory();
         }
@@ -1052,7 +1052,6 @@
     new_parser->intern = self->intern;
     Py_XINCREF(new_parser->intern);
 #ifdef Py_TPFLAGS_HAVE_GC
-    PyObject_GC_Track(new_parser);
 #else
     PyObject_GC_Init(new_parser);
 #endif
@@ -1219,7 +1218,7 @@
 
 #ifdef Py_TPFLAGS_HAVE_GC
     /* Code for versions 2.2 and later */
-    self = PyObject_GC_New(xmlparseobject, &Xmlparsetype);
+    self = PyObject_New(&Xmlparsetype);
 #else
     self = PyObject_New(xmlparseobject, &Xmlparsetype);
 #endif
@@ -1243,7 +1242,6 @@
     self->intern = intern;
     Py_XINCREF(self->intern);
 #ifdef Py_TPFLAGS_HAVE_GC
-    PyObject_GC_Track(self);
 #else
     PyObject_GC_Init(self);
 #endif
@@ -1276,7 +1274,6 @@
 {
     int i;
 #ifdef Py_TPFLAGS_HAVE_GC
-    PyObject_GC_UnTrack(self);
 #else
     PyObject_GC_Fini(self);
 #endif
@@ -1304,7 +1301,7 @@
     PyObject_Del(self);
 #else
     /* Code for versions 2.2 and later. */
-    PyObject_GC_Del(self);
+    PyObject_Del(self);
 #endif
 }
 

=== modified file 'Modules/python.c'
--- Modules/python.c	2008-04-05 20:41:37 +0000
+++ Modules/python.c	2008-04-11 03:25:45 +0000
@@ -17,9 +17,9 @@
 int
 main(int argc, char **argv)
 {
-	wchar_t **argv_copy = PyMem_Malloc(sizeof(wchar_t*)*argc);
+	wchar_t **argv_copy = malloc(sizeof(wchar_t*)*argc);
 	/* We need a second copies, as Python might modify the first one. */
-	wchar_t **argv_copy2 = PyMem_Malloc(sizeof(wchar_t*)*argc);
+	wchar_t **argv_copy2 = malloc(sizeof(wchar_t*)*argc);
 	int i, res;
 	char *oldloc;
 	/* 754 requires that FP exceptions run in "no stop" mode by default,
@@ -45,7 +45,7 @@
 			fprintf(stderr, "Could not convert argument %d to string", i);
 			return 1;
 		}
-		argv_copy[i] = PyMem_Malloc((argsize+1)*sizeof(wchar_t));
+		argv_copy[i] = malloc((argsize+1)*sizeof(wchar_t));
 		argv_copy2[i] = argv_copy[i];
 		if (!argv_copy[i]) {
 			fprintf(stderr, "out of memory");
@@ -56,10 +56,10 @@
 	setlocale(LC_ALL, oldloc);
 	res = Py_Main(argc, argv_copy);
 	for (i = 0; i < argc; i++) {
-		PyMem_Free(argv_copy2[i]);
+		free(argv_copy2[i]);
 	}
-	PyMem_Free(argv_copy);
-	PyMem_Free(argv_copy2);
+	free(argv_copy);
+	free(argv_copy2);
 	return res;
 }
 #endif

=== modified file 'Modules/readline.c'
--- Modules/readline.c	2007-12-02 14:31:20 +0000
+++ Modules/readline.c	2008-03-24 04:28:04 +0000
@@ -618,9 +618,11 @@
 {
 	int result = 0;
 	if (func != NULL) {
-		PyObject *r;
+		PyObject *r = NULL;
 #ifdef WITH_THREAD
-		PyGILState_STATE gilstate = PyGILState_Ensure();
+		PyState_EnterFrame *enterframe = PyState_Enter();
+		if (enterframe == NULL)
+			goto error;
 #endif
 		r = PyObject_CallFunction(func, NULL);
 		if (r == NULL)
@@ -639,7 +641,7 @@
 		Py_XDECREF(r);
 	  done:
 #ifdef WITH_THREAD
-		PyGILState_Release(gilstate);
+		PyState_Exit(enterframe);
 #endif
 		return result;
 	}
@@ -670,7 +672,7 @@
 	int i;
 	PyObject *m=NULL, *s=NULL, *r=NULL;
 #ifdef WITH_THREAD
-	PyGILState_STATE gilstate = PyGILState_Ensure();
+	PyState_EnterFrame *enterframe = PyState_Enter();
 #endif
 	m = PyList_New(num_matches);
 	if (m == NULL)
@@ -700,7 +702,7 @@
 		Py_XDECREF(r);
 	}
 #ifdef WITH_THREAD
-	PyGILState_Release(gilstate);
+	PyState_Exit(enterframe);
 #endif
 }
 
@@ -712,9 +714,11 @@
 {
 	char *result = NULL;
 	if (completer != NULL) {
-		PyObject *r;
+		PyObject *r = NULL;
 #ifdef WITH_THREAD
-		PyGILState_STATE gilstate = PyGILState_Ensure();
+		PyState_EnterFrame *enterframe = PyState_Enter();
+		if (enterframe == NULL)
+			Py_FatalError("PyState_Enter failed");
 #endif
 		rl_attempted_completion_over = 1;
 		r = PyObject_CallFunction(completer, "si", text, state);
@@ -736,7 +740,7 @@
 		Py_XDECREF(r);
 	  done:
 #ifdef WITH_THREAD
-		PyGILState_Release(gilstate);
+		PyState_Exit(enterframe);
 #endif
 		return result;
 	}
@@ -821,7 +825,7 @@
 	rl_callback_handler_remove();
 }
 
-extern PyThreadState* _PyOS_ReadlineTState;
+extern PyState* _PyOS_ReadlinePyState;
 
 static char *
 readline_until_enter_or_signal(char *prompt, int *signal)
@@ -861,14 +865,19 @@
 			rl_callback_read_char();
 		}
 		else if (errno == EINTR) {
-			int s;
+			//int s;
 #ifdef WITH_THREAD
-			PyEval_RestoreThread(_PyOS_ReadlineTState);
+			//PyEval_RestoreThread(_PyOS_ReadlinePyState);
+			PyState_Resume();
 #endif
+#if 0
 			s = PyErr_CheckSignals();
+#endif
 #ifdef WITH_THREAD
-			PyEval_SaveThread();	
+			//PyEval_SaveThread();
+			PyState_Suspend();
 #endif
+#if 0
 			if (s < 0) {
 				rl_free_line_state();
 				rl_cleanup_after_signal();
@@ -876,6 +885,7 @@
 				*signal = 1;
 				completed_input_string = NULL;
 			}
+#endif
 		}
 	}
 

=== modified file 'Modules/selectmodule.c'
--- Modules/selectmodule.c	2008-03-26 13:45:42 +0000
+++ Modules/selectmodule.c	2008-04-11 03:39:47 +0000
@@ -601,7 +601,7 @@
 newPollObject(void)
 {
         pollObject *self;
-	self = PyObject_New(pollObject, &poll_Type);
+	self = PyObject_New(&poll_Type);
 	if (self == NULL)
 		return NULL;
 	/* ufd_uptodate is a Boolean, denoting whether the 
@@ -727,10 +727,13 @@
 	if (self->epfd >= 0) {
 		int epfd = self->epfd;
 		self->epfd = -1;
-		Py_BEGIN_ALLOW_THREADS
+#warning FIXME epoll should not suspend during dealloc
+		//Py_BEGIN_ALLOW_THREADS
+		PyState_MaybeSuspend(); /* XXX FIXME HACK */
 		if (close(epfd) < 0)
 			save_errno = errno;
-		Py_END_ALLOW_THREADS
+		//Py_END_ALLOW_THREADS
+		PyState_MaybeResume(); /* XXX FIXME HACK */
 	}
 	return save_errno;
 }
@@ -750,8 +753,8 @@
 		return NULL;
 	}
 
-	assert(type != NULL && type->tp_alloc != NULL);
-	self = (pyEpoll_Object *) type->tp_alloc(type, 0);
+	assert(type != NULL);
+	self = PyObject_New(type);
 	if (self == NULL)
 		return NULL;
 
@@ -790,7 +793,7 @@
 pyepoll_dealloc(pyEpoll_Object *self)
 {
 	(void)pyepoll_internal_close(self);
-	Py_TYPE(self)->tp_free(self);
+	PyObject_Del(self);
 }
 
 static PyObject*
@@ -1115,9 +1118,7 @@
 	0,						/* tp_descr_set */
 	0,						/* tp_dictoffset */
 	0,						/* tp_init */
-	0,						/* tp_alloc */
 	pyepoll_new,					/* tp_new */
-	0,						/* tp_free */
 };
 
 #endif /* HAVE_EPOLL */
@@ -1328,9 +1329,7 @@
 	0,						/* tp_descr_set */
 	0,						/* tp_dictoffset */
 	(initproc)kqueue_event_init,			/* tp_init */
-	0,						/* tp_alloc */
 	0,						/* tp_new */
-	0,						/* tp_free */
 };
 
 static PyObject *
@@ -1359,8 +1358,8 @@
 newKqueue_Object(PyTypeObject *type, SOCKET fd)
 {
 	kqueue_queue_Object *self;
-	assert(type != NULL && type->tp_alloc != NULL);
-	self = (kqueue_queue_Object *) type->tp_alloc(type, 0);
+	assert(type != NULL);
+	PyObject_New(type);
 	if (self == NULL) {
 		return NULL;
 	}
@@ -1399,7 +1398,7 @@
 kqueue_queue_dealloc(kqueue_queue_Object *self)
 {
 	kqueue_queue_internal_close(self);
-	Py_TYPE(self)->tp_free(self);
+	PyObject_Del(self);
 }
 
 static PyObject*
@@ -1683,9 +1682,7 @@
 	0,						/* tp_descr_set */
 	0,						/* tp_dictoffset */
 	0,						/* tp_init */
-	0,						/* tp_alloc */
 	kqueue_queue_new,				/* tp_new */
-	0,						/* tp_free */
 };
 
 #endif /* HAVE_KQUEUE */

=== modified file 'Modules/signalmodule.c'
--- Modules/signalmodule.c	2008-03-24 14:05:07 +0000
+++ Modules/signalmodule.c	2008-04-11 16:40:29 +0000
@@ -1,10 +1,9 @@
-
-/* Signal module -- many thanks to Lance Ellinghaus */
-
-/* XXX Signals should be recorded per thread, now we have thread state. */
+/* Signal module -- many thanks to Lance Ellinghaus
+ * Significantly rewritten by Adam Olsen, to use a dedicated signal thread */
 
 #include "Python.h"
-#include "intrcheck.h"
+
+#include "branchobject.h"
 
 #ifdef MS_WINDOWS
 #include <process.h>
@@ -12,11 +11,6 @@
 
 #include <signal.h>
 
-#include <sys/stat.h>
-#ifdef HAVE_SYS_TIME_H
-#include <sys/time.h>
-#endif
-
 #ifndef SIG_ERR
 #define SIG_ERR ((PyOS_sighandler_t)(-1))
 #endif
@@ -28,73 +22,58 @@
 
 #ifndef NSIG
 # if defined(_NSIG)
-#  define NSIG _NSIG		/* For BSD/SysV */
+#  define NSIG _NSIG            /* For BSD/SysV */
 # elif defined(_SIGMAX)
-#  define NSIG (_SIGMAX + 1)	/* For QNX */
+#  define NSIG (_SIGMAX + 1)    /* For QNX */
 # elif defined(SIGMAX)
-#  define NSIG (SIGMAX + 1)	/* For djgpp */
+#  define NSIG (SIGMAX + 1)     /* For djgpp */
 # else
-#  define NSIG 64		/* Use a reasonable default value */
+#  define NSIG 64               /* Use a reasonable default value */
 # endif
 #endif
 
+#define _PySIGNAL_WAKEUP SIGUSR2
+
 
 /*
-   NOTES ON THE INTERACTION BETWEEN SIGNALS AND THREADS
-
-   When threads are supported, we want the following semantics:
-
-   - only the main thread can set a signal handler
-   - any thread can get a signal handler
-   - signals are only delivered to the main thread
-
-   I.e. we don't support "synchronous signals" like SIGFPE (catching
-   this doesn't make much sense in Python anyway) nor do we support
-   signals as a means of inter-thread communication, since not all
-   thread implementations support that (at least our thread library
-   doesn't).
-
-   We still have the problem that in some implementations signals
-   generated by the keyboard (e.g. SIGINT) are delivered to all
-   threads (e.g. SGI), while in others (e.g. Solaris) such signals are
-   delivered to one random thread (an intermediate possibility would
-   be to deliver it to the main thread -- POSIX?).  For now, we have
-   a working implementation that works in all three cases -- the
-   handler ignores signals if getpid() isn't the same as in the main
-   thread.  XXX This is a hack.
-
-   GNU pth is a user-space threading library, and as such, all threads
-   run within the same process. In this case, if the currently running
-   thread is not the main_thread, send the signal to the main_thread.
-*/
-
-#ifdef WITH_THREAD
-#include <sys/types.h> /* For pid_t */
+ * NOTES ON THE INTERACTION BETWEEN SIGNALS AND THREADS
+ *
+ * There isn't much, really.  A dedicated thread now asks what signals
+ * are pending, and the real signal handlers are never invoked.  This
+ * means the various syscalls will NOT get interrupted (unless something
+ * else interferes.)
+ *
+ * This is less portable though.  In old LinuxThread (linux kernels 2.0
+ * and 2.1) the SIGUSR1 and SIGUSR2 signals are unavailable, but we need
+ * one to do our own wakeups.  Signal handling with LinuxThreads is
+ * broken anyway though, as most signals will only be pending on the
+ * main thread, not the signal thread (meaning they'll never get
+ * processed.)
+ */
+
 #include "pythread.h"
-static long main_thread;
-static pid_t main_pid;
-#endif
+static PyObject *signal_branch;
+static PyThread_type_handle *signal_branch_handle;
+static int signal_branch_waiting;
+static int signal_branch_wakeup_sent;
+static int signal_branch_reload;
+static int signal_branch_quit;
+static PyCritical *signal_branch_crit;
+static PyObject *sigint_branch;
+static PyObject *old_sigint_handler;
+static PyMethodDef kbdint_raiser_method_def;
 
 static struct {
-        int tripped;
-        PyObject *func;
+    int banned;  /* We won't touch this signal */
+    int old_ignored;  /* When python initialized the signal was SIG_IGN (not SIG_DFL) */
+    int watched;  /* signal_waiter is watching for this signal */
+    PyObject *func;
 } Handlers[NSIG];
 
-static sig_atomic_t wakeup_fd = -1;
-
-/* Speed up sigcheck() when none tripped */
-static volatile sig_atomic_t is_tripped = 0;
-
 static PyObject *DefaultHandler;
 static PyObject *IgnoreHandler;
 static PyObject *IntHandler;
 
-/* On Solaris 8, gcc will produce a warning that the function
-   declaration is not a prototype. This is caused by the definition of
-   SIG_DFL as (void (*)())0; the correct declaration would have been
-   (void (*)(int))0. */
-
-static PyOS_sighandler_t old_siginthandler = SIG_DFL;
 
 #ifdef HAVE_GETITIMER
 static PyObject *ItimerError;
@@ -140,59 +119,186 @@
 }
 #endif
 
+
 static PyObject *
 signal_default_int_handler(PyObject *self, PyObject *args)
 {
-	PyErr_SetNone(PyExc_KeyboardInterrupt);
-	return NULL;
+    PyObject *kbdint_raiser_method, *x;
+    PyObject *m = PyImport_ImportModule("signal");
+    if (m == NULL)
+        return NULL;
+
+    kbdint_raiser_method = PyCFunction_NewEx(&kbdint_raiser_method_def, m, m);
+    if (kbdint_raiser_method == NULL)
+        return NULL;
+
+    x = PyObject_CallMethod(sigint_branch, "add", "O", kbdint_raiser_method);
+    Py_DECREF(kbdint_raiser_method);
+    if (x == NULL)
+        return NULL;
+    Py_DECREF(x);
+
+    Py_INCREF(Py_None);
+    return Py_None;
 }
 
 PyDoc_STRVAR(default_int_handler_doc,
 "default_int_handler(...)\n\
 \n\
 The default handler for SIGINT installed by Python.\n\
-It raises KeyboardInterrupt.");
-
-
-static int
-checksignals_witharg(void * unused)
+It causes KeyboardInterrupt to be raised from a hidden branch above\n\
+the __main__ module.");
+
+
+static PyObject *
+kbdint_raiser(PyObject *self)
 {
-	return PyErr_CheckSignals();
+    PyErr_SetNone(PyExc_KeyboardInterrupt);
+    return NULL;
 }
 
 static void
-signal_handler(int sig_num)
-{
-#ifdef WITH_THREAD
-#ifdef WITH_PTH
-	if (PyThread_get_thread_ident() != main_thread) {
-		pth_raise(*(pth_t *) main_thread, sig_num);
-		return;
-	}
-#endif
-	/* See NOTES section above */
-	if (getpid() == main_pid) {
-#endif
-		Handlers[sig_num].tripped = 1;
-                /* Set is_tripped after setting .tripped, as it gets
-                   cleared in PyErr_CheckSignals() before .tripped. */
-		is_tripped = 1;
-		Py_AddPendingCall(checksignals_witharg, NULL);
-		if (wakeup_fd != -1)
-			write(wakeup_fd, "\0", 1);
-#ifdef WITH_THREAD
-	}
-#endif
-#ifdef SIGCHLD
-	if (sig_num == SIGCHLD) {
-		/* To avoid infinite recursion, this signal remains
-		   reset until explicit re-instated.
-		   Don't clear the 'func' field as it is our pointer
-		   to the Python handler... */
-		return;
-	}
-#endif
-	PyOS_setsig(sig_num, signal_handler);
+dummy(int sig_num)
+{
+    Py_FatalError("dummy should never be called");
+}
+
+static PyObject *
+signal_waiter(PyObject *self)
+{
+    sigset_t set, wakeupset;
+    int sig, wakeupsig;
+    int i;
+    PyObject *func, *x;
+    PyObject *retval = NULL;
+
+    sigemptyset(&wakeupset);
+    sigaddset(&wakeupset, _PySIGNAL_WAKEUP);
+
+    PyCritical_Enter(signal_branch_crit);
+#warning signal_branch_handle is not set in a safe way
+    /* XXX FIXME there's no guarantee the main thread won't use
+     * signal_branch_handle before we've set it. */
+    signal_branch_handle = PyThread_get_handle();
+
+    PyOS_setsig(_PySIGNAL_WAKEUP, dummy);
+
+    while (1) {
+        if (signal_branch_reload) {
+            /* Stop watching old signals */
+            sigemptyset(&set);
+            for (i = 1; i < NSIG; i++) {
+                if (Handlers[i].banned)
+                    continue;
+
+                if (Handlers[i].watched &&
+                        (Handlers[i].func == DefaultHandler ||
+                        Handlers[i].func == IgnoreHandler)) {
+                    void (*func)(int);
+                    if (Handlers[i].func == IgnoreHandler)
+                        func = SIG_IGN;
+                    else
+                        func = SIG_DFL;
+
+                    PyOS_setsig(i, func);
+                    sigaddset(&set, i);
+                    pthread_sigmask(SIG_UNBLOCK, &set, NULL);
+                    Handlers[i].watched = 0;
+                }
+            }
+
+            /* Start watching new signals.  Also sets the set for sigwait */
+            sigemptyset(&set);
+            for (i = 1; i < NSIG; i++) {
+                if (Handlers[i].banned)
+                    continue;
+
+                if (!Handlers[i].watched &&
+                        Handlers[i].func != DefaultHandler &&
+                        Handlers[i].func != IgnoreHandler) {
+                    sigaddset(&set, i);
+                    pthread_sigmask(SIG_BLOCK, &set, NULL);
+                    PyOS_setsig(i, dummy);
+                    Handlers[i].watched = 1;
+                } else if (Handlers[i].watched)
+                    sigaddset(&set, i);
+            }
+
+            /* We always watch for _PySIGNAL_WAKEUP, even though we only
+             * block it around sigwait */
+            sigaddset(&set, _PySIGNAL_WAKEUP);
+            signal_branch_reload = 0;
+        }
+
+        if (signal_branch_quit) {
+            Py_INCREF(Py_None);
+            retval = Py_None;
+            break;
+        }
+
+        pthread_sigmask(SIG_BLOCK, &wakeupset, NULL);
+        signal_branch_waiting = 1;
+        PyCritical_Exit(signal_branch_crit);
+        PyState_Suspend();
+
+        errno = 0;
+        if (sigwait(&set, &sig)) {
+            /* XXX I've seen some mention that gdb can cause sigwait to
+             * be interrupted.  If verified, this needs to be modified
+             * to loop on EINTR */
+            if (errno == EINTR)
+                Py_FatalError("sigwait failed with EINTR!");
+            Py_FatalError("sigwait failed!");
+        }
+
+        PyState_Resume();
+        PyCritical_Enter(signal_branch_crit);
+        signal_branch_waiting = 0;
+        if (sig != _PySIGNAL_WAKEUP && signal_branch_wakeup_sent) {
+            /* Purge any pending wakeups */
+            sigwait(&wakeupset, &wakeupsig);
+            assert(wakeupsig == _PySIGNAL_WAKEUP);
+        }
+        signal_branch_wakeup_sent = 0;
+        pthread_sigmask(SIG_UNBLOCK, &wakeupset, NULL);
+
+        assert(sig >= 1 && sig < NSIG);
+        if (sig != _PySIGNAL_WAKEUP) {
+            func = Handlers[sig].func;
+            Py_INCREF(func);
+            if (func == DefaultHandler || func == IgnoreHandler)
+                /* XXX FIXME the signal handler could be changed at the
+                 * same time we get a signal for it, meaning we
+                 * legitimately have no handler by the time we get here */
+                Py_FatalError("sigwait got signal without handler");
+            PyCritical_Exit(signal_branch_crit);
+            x = PyObject_CallFunction(func, "iO", sig, Py_None);
+            Py_DECREF(func);
+            Py_XDECREF(x);
+            PyCritical_Enter(signal_branch_crit);
+            if (x == NULL)
+                break;
+        }
+    }
+
+    /* Reset all signals to their original handlers */
+    sigemptyset(&set);
+    for (i = 1; i < NSIG; i++) {
+        if (!Handlers[i].banned) {
+            if (!Handlers[i].old_ignored)
+                PyOS_setsig(i, SIG_DFL);
+            else
+                PyOS_setsig(i, SIG_IGN);
+            sigaddset(&set, i);
+            Handlers[i].watched = 0;
+        }
+    }
+    pthread_sigmask(SIG_UNBLOCK, &set, NULL);
+    PyOS_setsig(_PySIGNAL_WAKEUP, SIG_DFL);
+    PyCritical_Exit(signal_branch_crit);
+    PyThread_free_handle(signal_branch_handle);
+    signal_branch_handle = NULL;
+    return retval;
 }
 
 
@@ -200,11 +306,11 @@
 static PyObject *
 signal_alarm(PyObject *self, PyObject *args)
 {
-	int t;
-	if (!PyArg_ParseTuple(args, "i:alarm", &t))
-		return NULL;
-	/* alarm() returns the number of seconds remaining */
-	return PyLong_FromLong((long)alarm(t));
+    int t;
+    if (!PyArg_ParseTuple(args, "i:alarm", &t))
+        return NULL;
+    /* alarm() returns the number of seconds remaining */
+    return PyLong_FromLong((long)alarm(t));
 }
 
 PyDoc_STRVAR(alarm_doc,
@@ -213,71 +319,45 @@
 Arrange for SIGALRM to arrive after the given number of seconds.");
 #endif
 
-#ifdef HAVE_PAUSE
-static PyObject *
-signal_pause(PyObject *self)
-{
-	Py_BEGIN_ALLOW_THREADS
-	(void)pause();
-	Py_END_ALLOW_THREADS
-	/* make sure that any exceptions that got raised are propagated
-	 * back into Python
-	 */
-	if (PyErr_CheckSignals())
-		return NULL;
-
-	Py_INCREF(Py_None);
-	return Py_None;
-}
-PyDoc_STRVAR(pause_doc,
-"pause()\n\
-\n\
-Wait until a signal arrives.");
-
-#endif
-
 
 static PyObject *
 signal_signal(PyObject *self, PyObject *args)
 {
-	PyObject *obj;
-	int sig_num;
-	PyObject *old_handler;
-	void (*func)(int);
-	if (!PyArg_ParseTuple(args, "iO:signal", &sig_num, &obj))
-		return NULL;
-#ifdef WITH_THREAD
-	if (PyThread_get_thread_ident() != main_thread) {
-		PyErr_SetString(PyExc_ValueError,
-				"signal only works in main thread");
-		return NULL;
-	}
-#endif
-	if (sig_num < 1 || sig_num >= NSIG) {
-		PyErr_SetString(PyExc_ValueError,
-				"signal number out of range");
-		return NULL;
-	}
-	if (obj == IgnoreHandler)
-		func = SIG_IGN;
-	else if (obj == DefaultHandler)
-		func = SIG_DFL;
-	else if (!PyCallable_Check(obj)) {
-		PyErr_SetString(PyExc_TypeError,
-"signal handler must be signal.SIG_IGN, signal.SIG_DFL, or a callable object");
-		return NULL;
-	}
-	else
-		func = signal_handler;
-	if (PyOS_setsig(sig_num, func) == SIG_ERR) {
-		PyErr_SetFromErrno(PyExc_RuntimeError);
-		return NULL;
-	}
-	old_handler = Handlers[sig_num].func;
-	Handlers[sig_num].tripped = 0;
-	Py_INCREF(obj);
-	Handlers[sig_num].func = obj;
-	return old_handler;
+    PyObject *obj;
+    int sig_num;
+    PyObject *old_handler;
+
+    if (!PyArg_ParseTuple(args, "iO:signal", &sig_num, &obj))
+        return NULL;
+
+    if (sig_num < 1 || sig_num >= NSIG) {
+        PyErr_SetString(PyExc_ValueError, "signal number out of range");
+        return NULL;
+    }
+    if (obj != IgnoreHandler && obj != DefaultHandler &&
+            !PyCallable_Check(obj)) {
+        PyErr_SetString(PyExc_TypeError, "signal handler must be "
+            "signal.SIG_IGN, signal.SIG_DFL, or a callable object");
+        return NULL;
+    }
+    if (!PyObject_IsShareable(obj)) {
+        PyErr_SetString(PyExc_TypeError, "signal handler must be "
+            "shareable");
+        return NULL;
+    }
+
+    PyCritical_Enter(signal_branch_crit);
+    Py_INCREF(obj);
+    old_handler = Handlers[sig_num].func;
+    Handlers[sig_num].func = obj;
+    signal_branch_reload = 1;
+    if (signal_branch_waiting && !signal_branch_wakeup_sent) {
+        PyThread_send_signal(signal_branch_handle, _PySIGNAL_WAKEUP);
+        signal_branch_wakeup_sent = 1;
+    }
+    PyCritical_Exit(signal_branch_crit);
+
+    return old_handler;
 }
 
 PyDoc_STRVAR(signal_doc,
@@ -288,25 +368,28 @@
 returned.  See getsignal() for possible return values.\n\
 \n\
 *** IMPORTANT NOTICE ***\n\
-A signal handler function is called with two arguments:\n\
-the first is the signal number, the second is the interrupted stack frame.");
+A signal handler function is called with only *one* argument: the signal number.");
 
 
 static PyObject *
 signal_getsignal(PyObject *self, PyObject *args)
 {
-	int sig_num;
-	PyObject *old_handler;
-	if (!PyArg_ParseTuple(args, "i:getsignal", &sig_num))
-		return NULL;
-	if (sig_num < 1 || sig_num >= NSIG) {
-		PyErr_SetString(PyExc_ValueError,
-				"signal number out of range");
-		return NULL;
-	}
-	old_handler = Handlers[sig_num].func;
-	Py_INCREF(old_handler);
-	return old_handler;
+    int sig_num;
+    PyObject *old_handler;
+
+    if (!PyArg_ParseTuple(args, "i:getsignal", &sig_num))
+        return NULL;
+
+    if (sig_num < 1 || sig_num >= NSIG) {
+        PyErr_SetString(PyExc_ValueError, "signal number out of range");
+        return NULL;
+    }
+
+    PyCritical_Enter(signal_branch_crit);
+    old_handler = Handlers[sig_num].func;
+    Py_INCREF(old_handler);
+    PyCritical_Exit(signal_branch_crit);
+    return old_handler;
 }
 
 PyDoc_STRVAR(getsignal_doc,
@@ -318,80 +401,6 @@
 None -- if an unknown handler is in effect\n\
 anything else -- the callable Python object used as a handler");
 
-#ifdef HAVE_SIGINTERRUPT
-PyDoc_STRVAR(siginterrupt_doc,
-"siginterrupt(sig, flag) -> None\n\
-change system call restart behaviour: if flag is False, system calls\n\
-will be restarted when interrupted by signal sig, else system calls\n\
-will be interrupted.");
-
-static PyObject *
-signal_siginterrupt(PyObject *self, PyObject *args)
-{
-	int sig_num;
-	int flag;
-
-	if (!PyArg_ParseTuple(args, "ii:siginterrupt", &sig_num, &flag))
-		return NULL;
-	if (sig_num < 1 || sig_num >= NSIG) {
-		PyErr_SetString(PyExc_ValueError,
-				"signal number out of range");
-		return NULL;
-	}
-	if (siginterrupt(sig_num, flag)<0) {
-		PyErr_SetFromErrno(PyExc_RuntimeError);
-		return NULL;
-	}
-
-	Py_INCREF(Py_None);
-	return Py_None;
-}
-
-#endif
-
-static PyObject *
-signal_set_wakeup_fd(PyObject *self, PyObject *args)
-{
-	struct stat buf;
-	int fd, old_fd;
-	if (!PyArg_ParseTuple(args, "i:set_wakeup_fd", &fd))
-		return NULL;
-#ifdef WITH_THREAD
-	if (PyThread_get_thread_ident() != main_thread) {
-		PyErr_SetString(PyExc_ValueError,
-				"set_wakeup_fd only works in main thread");
-		return NULL;
-	}
-#endif
-	if (fd != -1 && fstat(fd, &buf) != 0) {
-		PyErr_SetString(PyExc_ValueError, "invalid fd");
-		return NULL;
-	}
-	old_fd = wakeup_fd;
-	wakeup_fd = fd;
-	return PyLong_FromLong(old_fd);
-}
-
-PyDoc_STRVAR(set_wakeup_fd_doc,
-"set_wakeup_fd(fd) -> fd\n\
-\n\
-Sets the fd to be written to (with '\\0') when a signal\n\
-comes in.  A library can use this to wakeup select or poll.\n\
-The previous fd is returned.\n\
-\n\
-The fd must be non-blocking.");
-
-/* C API for the same, without all the error checking */
-int
-PySignal_SetWakeupFd(int fd)
-{
-	int old_fd = wakeup_fd;
-	if (fd < 0)
-		fd = -1;
-	wakeup_fd = fd;
-	return old_fd;
-}
-
 
 #ifdef HAVE_SETITIMER
 static PyObject *
@@ -456,29 +465,28 @@
 /* List of functions defined in the module */
 static PyMethodDef signal_methods[] = {
 #ifdef HAVE_ALARM
-	{"alarm",	        signal_alarm, METH_VARARGS, alarm_doc},
+    {"alarm",               signal_alarm, METH_VARARGS, alarm_doc},
 #endif
 #ifdef HAVE_SETITIMER
-    {"setitimer",       signal_setitimer, METH_VARARGS, setitimer_doc},
+    {"setitimer",           signal_setitimer, METH_VARARGS, setitimer_doc},
 #endif
 #ifdef HAVE_GETITIMER
-	{"getitimer",       signal_getitimer, METH_VARARGS, getitimer_doc},
-#endif
-	{"signal",	        signal_signal, METH_VARARGS, signal_doc},
-	{"getsignal",	        signal_getsignal, METH_VARARGS, getsignal_doc},
-	{"set_wakeup_fd",	signal_set_wakeup_fd, METH_VARARGS, set_wakeup_fd_doc},
-#ifdef HAVE_SIGINTERRUPT
- 	{"siginterrupt",	signal_siginterrupt, METH_VARARGS, siginterrupt_doc},
-#endif
-#ifdef HAVE_PAUSE
-	{"pause",	        (PyCFunction)signal_pause,
-	 METH_NOARGS,pause_doc},
-#endif
-	{"default_int_handler", signal_default_int_handler,
-	 METH_VARARGS, default_int_handler_doc},
-	{NULL,			NULL}		/* sentinel */
+    {"getitimer",           signal_getitimer, METH_VARARGS, getitimer_doc},
+#endif
+    {"signal",              signal_signal, METH_VARARGS, signal_doc},
+    {"getsignal",           signal_getsignal, METH_VARARGS, getsignal_doc},
+    {"default_int_handler", signal_default_int_handler, METH_SHARED | METH_VARARGS,
+        default_int_handler_doc},
+    {NULL,                  NULL}  /* sentinel */
 };
 
+/* This are NOT exported methods.  They are only used internally
+ * by the signal machinery */
+static PyMethodDef signal_waiter_method_def = {"signal_waiter",
+    (PyCFunction)signal_waiter, METH_NOARGS | METH_SHARED, NULL};
+static PyMethodDef kbdint_raiser_method_def = {"kbdint_raiser",
+    (PyCFunction)kbdint_raiser, METH_NOARGS | METH_SHARED, NULL};
+
 
 PyDoc_STRVAR(module_doc,
 "This module provides mechanisms to use signal handlers in Python.\n\
@@ -491,7 +499,6 @@
 getitimer() -- get current value of timer [Unix only]\n\
 signal() -- set the action for a given signal\n\
 getsignal() -- get the signal action for a given signal\n\
-pause() -- wait until a signal arrives [Unix only]\n\
 default_int_handler() -- default SIGINT handler\n\
 \n\
 signal constants:\n\
@@ -516,254 +523,179 @@
 A signal handler function is called with two arguments:\n\
 the first is the signal number, the second is the interrupted stack frame.");
 
-PyMODINIT_FUNC
-initsignal(void)
+void
+_PySignal_Init(void)
 {
-	PyObject *m, *d, *x;
-	int i;
-
-#ifdef WITH_THREAD
-	main_thread = PyThread_get_thread_ident();
-	main_pid = getpid();
-#endif
-
-	/* Create the module and add the functions */
-	m = Py_InitModule3("signal", signal_methods, module_doc);
-	if (m == NULL)
-		return;
-
-	/* Add some symbolic constants to the module */
-	d = PyModule_GetDict(m);
-
-	x = DefaultHandler = PyLong_FromVoidPtr((void *)SIG_DFL);
-        if (!x || PyDict_SetItemString(d, "SIG_DFL", x) < 0)
-                goto finally;
-
-	x = IgnoreHandler = PyLong_FromVoidPtr((void *)SIG_IGN);
-        if (!x || PyDict_SetItemString(d, "SIG_IGN", x) < 0)
-                goto finally;
-
-        x = PyLong_FromLong((long)NSIG);
-        if (!x || PyDict_SetItemString(d, "NSIG", x) < 0)
-                goto finally;
-        Py_DECREF(x);
-
-	x = IntHandler = PyDict_GetItemString(d, "default_int_handler");
-        if (!x)
-                goto finally;
-	Py_INCREF(IntHandler);
-
-	Handlers[0].tripped = 0;
-	for (i = 1; i < NSIG; i++) {
-		void (*t)(int);
-		t = PyOS_getsig(i);
-		Handlers[i].tripped = 0;
-		if (t == SIG_DFL)
-			Handlers[i].func = DefaultHandler;
-		else if (t == SIG_IGN)
-			Handlers[i].func = IgnoreHandler;
-		else
-			Handlers[i].func = Py_None; /* None of our business */
-		Py_INCREF(Handlers[i].func);
-	}
-	if (Handlers[SIGINT].func == DefaultHandler) {
-		/* Install default int handler */
-		Py_INCREF(IntHandler);
-		Py_DECREF(Handlers[SIGINT].func);
-		Handlers[SIGINT].func = IntHandler;
-		old_siginthandler = PyOS_setsig(SIGINT, signal_handler);
-	}
+    sigset_t set;
+    PyObject *m, *d, *x;
+    PyObject *signal_waiter_method;
+    int i;
+
+    /* Create the module and add the functions */
+    m = Py_InitModule3("signal", signal_methods, module_doc);
+    if (m == NULL)
+            Py_FatalError("failed to initialize signalmodule");
+    /* XXX FIXME is fixup redundant here? */
+    _PyImport_FixupExtension("signal", "signal");
+
+    /* Add some symbolic constants to the module */
+    d = PyModule_GetDict(m);
+
+    DefaultHandler = PyLong_FromVoidPtr((void *)SIG_DFL);
+    if (DefaultHandler == NULL ||
+            PyDict_SetItemString(d, "SIG_DFL", DefaultHandler) < 0)
+        Py_FatalError("failed to initialize SIG_DFL");
+
+    IgnoreHandler = PyLong_FromVoidPtr((void *)SIG_IGN);
+    if (IgnoreHandler == NULL ||
+            PyDict_SetItemString(d, "SIG_IGN", IgnoreHandler) < 0)
+        Py_FatalError("failed to initialize SIG_IGN");
+
+    x = PyLong_FromLong((long)NSIG);
+    if (x == NULL || PyDict_SetItemString(d, "NSIG", x) < 0)
+        Py_FatalError("failed to initialize NSIG");
+    Py_DECREF(x);
+
+    IntHandler = PyDict_GetItemString(d, "default_int_handler");
+    if (IntHandler == NULL)
+        Py_FatalError("failed to initialize default_int_handler");
+    Py_INCREF(IntHandler);
+
+
+#define add_signal(name) \
+    x = PyLong_FromLong(name); \
+    if (x == NULL) \
+        Py_FatalError("failed to create signal constant " #name); \
+    if (PyDict_SetItemString(d, #name, x) < 0) \
+        Py_FatalError("failed to add signal constant " #name); \
+    Py_DECREF(x);
 
 #ifdef SIGHUP
-	x = PyLong_FromLong(SIGHUP);
-	PyDict_SetItemString(d, "SIGHUP", x);
-        Py_XDECREF(x);
+    add_signal(SIGHUP);
 #endif
 #ifdef SIGINT
-	x = PyLong_FromLong(SIGINT);
-	PyDict_SetItemString(d, "SIGINT", x);
-        Py_XDECREF(x);
+    add_signal(SIGINT);
 #endif
 #ifdef SIGBREAK
-	x = PyLong_FromLong(SIGBREAK);
-	PyDict_SetItemString(d, "SIGBREAK", x);
-        Py_XDECREF(x);
+    add_signal(SIGBREAK);
 #endif
 #ifdef SIGQUIT
-	x = PyLong_FromLong(SIGQUIT);
-	PyDict_SetItemString(d, "SIGQUIT", x);
-        Py_XDECREF(x);
+    add_signal(SIGQUIT);
 #endif
 #ifdef SIGILL
-	x = PyLong_FromLong(SIGILL);
-	PyDict_SetItemString(d, "SIGILL", x);
-        Py_XDECREF(x);
+    add_signal(SIGILL);
 #endif
 #ifdef SIGTRAP
-	x = PyLong_FromLong(SIGTRAP);
-	PyDict_SetItemString(d, "SIGTRAP", x);
-        Py_XDECREF(x);
+    add_signal(SIGTRAP);
 #endif
 #ifdef SIGIOT
-	x = PyLong_FromLong(SIGIOT);
-	PyDict_SetItemString(d, "SIGIOT", x);
-        Py_XDECREF(x);
+    add_signal(SIGIOT);
 #endif
 #ifdef SIGABRT
-	x = PyLong_FromLong(SIGABRT);
-	PyDict_SetItemString(d, "SIGABRT", x);
-        Py_XDECREF(x);
+    add_signal(SIGABRT);
 #endif
 #ifdef SIGEMT
-	x = PyLong_FromLong(SIGEMT);
-	PyDict_SetItemString(d, "SIGEMT", x);
-        Py_XDECREF(x);
+    add_signal(SIGEMT);
 #endif
 #ifdef SIGFPE
-	x = PyLong_FromLong(SIGFPE);
-	PyDict_SetItemString(d, "SIGFPE", x);
-        Py_XDECREF(x);
+    add_signal(SIGFPE);
 #endif
 #ifdef SIGKILL
-	x = PyLong_FromLong(SIGKILL);
-	PyDict_SetItemString(d, "SIGKILL", x);
-        Py_XDECREF(x);
+    add_signal(SIGKILL);
 #endif
 #ifdef SIGBUS
-	x = PyLong_FromLong(SIGBUS);
-	PyDict_SetItemString(d, "SIGBUS", x);
-        Py_XDECREF(x);
+    add_signal(SIGBUS);
 #endif
 #ifdef SIGSEGV
-	x = PyLong_FromLong(SIGSEGV);
-	PyDict_SetItemString(d, "SIGSEGV", x);
-        Py_XDECREF(x);
+    add_signal(SIGSEGV);
 #endif
 #ifdef SIGSYS
-	x = PyLong_FromLong(SIGSYS);
-	PyDict_SetItemString(d, "SIGSYS", x);
-        Py_XDECREF(x);
+    add_signal(SIGSYS);
 #endif
 #ifdef SIGPIPE
-	x = PyLong_FromLong(SIGPIPE);
-	PyDict_SetItemString(d, "SIGPIPE", x);
-        Py_XDECREF(x);
+    add_signal(SIGPIPE);
 #endif
 #ifdef SIGALRM
-	x = PyLong_FromLong(SIGALRM);
-	PyDict_SetItemString(d, "SIGALRM", x);
-        Py_XDECREF(x);
+    add_signal(SIGALRM);
 #endif
 #ifdef SIGTERM
-	x = PyLong_FromLong(SIGTERM);
-	PyDict_SetItemString(d, "SIGTERM", x);
-        Py_XDECREF(x);
+    add_signal(SIGTERM);
 #endif
 #ifdef SIGUSR1
-	x = PyLong_FromLong(SIGUSR1);
-	PyDict_SetItemString(d, "SIGUSR1", x);
-        Py_XDECREF(x);
+    add_signal(SIGUSR1);
 #endif
 #ifdef SIGUSR2
-	x = PyLong_FromLong(SIGUSR2);
-	PyDict_SetItemString(d, "SIGUSR2", x);
-        Py_XDECREF(x);
+    add_signal(SIGUSR2);
 #endif
 #ifdef SIGCLD
-	x = PyLong_FromLong(SIGCLD);
-	PyDict_SetItemString(d, "SIGCLD", x);
-        Py_XDECREF(x);
+    add_signal(SIGCLD);
 #endif
 #ifdef SIGCHLD
-	x = PyLong_FromLong(SIGCHLD);
-	PyDict_SetItemString(d, "SIGCHLD", x);
-        Py_XDECREF(x);
+    add_signal(SIGCHLD);
 #endif
 #ifdef SIGPWR
-	x = PyLong_FromLong(SIGPWR);
-	PyDict_SetItemString(d, "SIGPWR", x);
-        Py_XDECREF(x);
+    add_signal(SIGPWR);
 #endif
 #ifdef SIGIO
-	x = PyLong_FromLong(SIGIO);
-	PyDict_SetItemString(d, "SIGIO", x);
-        Py_XDECREF(x);
+    add_signal(SIGIO);
 #endif
 #ifdef SIGURG
-	x = PyLong_FromLong(SIGURG);
-	PyDict_SetItemString(d, "SIGURG", x);
-        Py_XDECREF(x);
+    add_signal(SIGURG);
 #endif
 #ifdef SIGWINCH
-	x = PyLong_FromLong(SIGWINCH);
-	PyDict_SetItemString(d, "SIGWINCH", x);
-        Py_XDECREF(x);
+    add_signal(SIGWINCH);
 #endif
 #ifdef SIGPOLL
-	x = PyLong_FromLong(SIGPOLL);
-	PyDict_SetItemString(d, "SIGPOLL", x);
-        Py_XDECREF(x);
+    add_signal(SIGPOLL);
 #endif
 #ifdef SIGSTOP
-	x = PyLong_FromLong(SIGSTOP);
-	PyDict_SetItemString(d, "SIGSTOP", x);
-        Py_XDECREF(x);
+    add_signal(SIGSTOP);
 #endif
 #ifdef SIGTSTP
-	x = PyLong_FromLong(SIGTSTP);
-	PyDict_SetItemString(d, "SIGTSTP", x);
-        Py_XDECREF(x);
+    add_signal(SIGTSTP);
 #endif
 #ifdef SIGCONT
-	x = PyLong_FromLong(SIGCONT);
-	PyDict_SetItemString(d, "SIGCONT", x);
-        Py_XDECREF(x);
+    add_signal(SIGCONT);
 #endif
 #ifdef SIGTTIN
-	x = PyLong_FromLong(SIGTTIN);
-	PyDict_SetItemString(d, "SIGTTIN", x);
-        Py_XDECREF(x);
+    add_signal(SIGTTIN);
 #endif
 #ifdef SIGTTOU
-	x = PyLong_FromLong(SIGTTOU);
-	PyDict_SetItemString(d, "SIGTTOU", x);
-        Py_XDECREF(x);
+    add_signal(SIGTTOU);
 #endif
 #ifdef SIGVTALRM
-	x = PyLong_FromLong(SIGVTALRM);
-	PyDict_SetItemString(d, "SIGVTALRM", x);
-        Py_XDECREF(x);
+    add_signal(SIGVTALRM);
 #endif
 #ifdef SIGPROF
-	x = PyLong_FromLong(SIGPROF);
-	PyDict_SetItemString(d, "SIGPROF", x);
-        Py_XDECREF(x);
+    add_signal(SIGPROF);
 #endif
 #ifdef SIGXCPU
-	x = PyLong_FromLong(SIGXCPU);
-	PyDict_SetItemString(d, "SIGXCPU", x);
-        Py_XDECREF(x);
+    add_signal(SIGXCPU);
 #endif
 #ifdef SIGXFSZ
-	x = PyLong_FromLong(SIGXFSZ);
-	PyDict_SetItemString(d, "SIGXFSZ", x);
-        Py_XDECREF(x);
+    add_signal(SIGXFSZ);
 #endif
 #ifdef SIGRTMIN
-        x = PyLong_FromLong(SIGRTMIN);
-        PyDict_SetItemString(d, "SIGRTMIN", x);
-        Py_XDECREF(x);
+    add_signal(SIGRTMIN);
 #endif
 #ifdef SIGRTMAX
-        x = PyLong_FromLong(SIGRTMAX);
-        PyDict_SetItemString(d, "SIGRTMAX", x);
-        Py_XDECREF(x);
+    add_signal(SIGRTMAX);
 #endif
 #ifdef SIGINFO
-	x = PyLong_FromLong(SIGINFO);
-	PyDict_SetItemString(d, "SIGINFO", x);
-        Py_XDECREF(x);
-#endif
+    add_signal(SIGINFO);
+#endif
+
+
+#ifdef SIGPIPE
+    PyOS_setsig(SIGPIPE, SIG_IGN);
+#endif
+#ifdef SIGXFZ
+    PyOS_setsig(SIGXFZ, SIG_IGN);
+#endif
+#ifdef SIGXFSZ
+    PyOS_setsig(SIGXFSZ, SIG_IGN);
+#endif
+
 
 #ifdef ITIMER_REAL
     x = PyLong_FromLong(ITIMER_REAL);
@@ -787,143 +719,221 @@
     PyDict_SetItemString(d, "ItimerError", ItimerError);
 #endif
 
-        if (!PyErr_Occurred())
-                return;
-
-	/* Check for errors */
-  finally:
-        return;
-}
-
-static void
-finisignal(void)
-{
-	int i;
-	PyObject *func;
-
-	PyOS_setsig(SIGINT, old_siginthandler);
-	old_siginthandler = SIG_DFL;
-
-	for (i = 1; i < NSIG; i++) {
-		func = Handlers[i].func;
-		Handlers[i].tripped = 0;
-		Handlers[i].func = NULL;
-		if (i != SIGINT && func != NULL && func != Py_None &&
-		    func != DefaultHandler && func != IgnoreHandler)
-			PyOS_setsig(i, SIG_DFL);
-		Py_XDECREF(func);
-	}
-
-	Py_XDECREF(IntHandler);
-	IntHandler = NULL;
-	Py_XDECREF(DefaultHandler);
-	DefaultHandler = NULL;
-	Py_XDECREF(IgnoreHandler);
-	IgnoreHandler = NULL;
-}
-
-
-/* Declared in pyerrors.h */
-int
-PyErr_CheckSignals(void)
-{
-	int i;
-	PyObject *f;
-
-	if (!is_tripped)
-		return 0;
-
-#ifdef WITH_THREAD
-	if (PyThread_get_thread_ident() != main_thread)
-		return 0;
-#endif
-
-	/*
-	 * The is_stripped variable is meant to speed up the calls to
-	 * PyErr_CheckSignals (both directly or via pending calls) when no
-	 * signal has arrived. This variable is set to 1 when a signal arrives
-	 * and it is set to 0 here, when we know some signals arrived. This way
-	 * we can run the registered handlers with no signals blocked.
-	 *
-	 * NOTE: with this approach we can have a situation where is_tripped is
-	 *       1 but we have no more signals to handle (Handlers[i].tripped
-	 *       is 0 for every signal i). This won't do us any harm (except
-	 *       we're gonna spent some cycles for nothing). This happens when
-	 *       we receive a signal i after we zero is_tripped and before we
-	 *       check Handlers[i].tripped.
-	 */
-	is_tripped = 0;
-
-	if (!(f = (PyObject *)PyEval_GetFrame()))
-		f = Py_None;
-
-	for (i = 1; i < NSIG; i++) {
-		if (Handlers[i].tripped) {
-			PyObject *result = NULL;
-			PyObject *arglist = Py_BuildValue("(iO)", i, f);
-			Handlers[i].tripped = 0;
-
-			if (arglist) {
-				result = PyEval_CallObject(Handlers[i].func,
-							   arglist);
-				Py_DECREF(arglist);
-			}
-			if (!result)
-				return -1;
-
-			Py_DECREF(result);
-		}
-	}
-
-	return 0;
-}
-
-
-/* Replacements for intrcheck.c functionality
- * Declared in pyerrors.h
- */
-void
-PyErr_SetInterrupt(void)
-{
-	is_tripped = 1;
-	Handlers[SIGINT].tripped = 1;
-	Py_AddPendingCall((int (*)(void *))PyErr_CheckSignals, NULL);
-}
-
-void
-PyOS_InitInterrupts(void)
-{
-	initsignal();
-	_PyImport_FixupExtension("signal", "signal");
-}
-
-void
-PyOS_FiniInterrupts(void)
-{
-	finisignal();
-}
-
-int
-PyOS_InterruptOccurred(void)
-{
-	if (Handlers[SIGINT].tripped) {
-#ifdef WITH_THREAD
-		if (PyThread_get_thread_ident() != main_thread)
-			return 0;
-#endif
-		Handlers[SIGINT].tripped = 0;
-		return 1;
-	}
-	return 0;
-}
-
-void
-PyOS_AfterFork(void)
-{
-#ifdef WITH_THREAD
-	PyEval_ReInitThreads();
-	main_thread = PyThread_get_thread_ident();
-	main_pid = getpid();
-	_PyImport_ReInitLock();
+    if (PyErr_Occurred())
+        Py_FatalError("Failed to initialize signal module");
+
+
+    sigemptyset(&set);
+    for (i = 1; i < NSIG; i++) {
+        void (*t)(int);
+        t = PyOS_getsig(i);
+        if (t == SIG_DFL) {
+            Handlers[i].watched = 1;
+            Handlers[i].old_ignored = 0;
+            Handlers[i].func = DefaultHandler;
+            sigaddset(&set, i);
+        } else if (t == SIG_IGN) {
+            Handlers[i].watched = 1;
+            Handlers[i].old_ignored = 1;
+            Handlers[i].func = IgnoreHandler;
+            sigaddset(&set, i);
+        } else {
+            Handlers[i].banned = 1; /* None of our business */
+            Handlers[i].func = Py_None;
+        }
+        Py_INCREF(Handlers[i].func);
+    }
+    pthread_sigmask(SIG_BLOCK, &set, NULL);
+
+    signal_branch_crit = PyCritical_Allocate(PyCRITICAL_NORMAL);
+    if (signal_branch_crit == NULL)
+        Py_FatalError("failed to initialize signal_branch_crit");
+
+    signal_branch = PyObject_CallObject((PyObject *)&PyBranch_Type, NULL);
+    if (signal_branch == NULL)
+        Py_FatalError("failed to initialize signal_branch");
+    x = PyObject_CallMethod(signal_branch, "__enter__", "");
+    if (x == NULL)
+        Py_FatalError("failed to call signal_branch.__enter__()");
+    Py_DECREF(x);
+
+    signal_branch_reload = 1;
+    signal_waiter_method = PyCFunction_NewEx(&signal_waiter_method_def, m, m);
+    if (signal_waiter_method == NULL)
+        Py_FatalError("failed to create signal_waiter_method");
+    x = PyObject_CallMethod(signal_branch, "add", "O", signal_waiter_method);
+    Py_DECREF(signal_waiter_method);
+    if (x == NULL)
+        Py_FatalError("failed to call signal_branch.add()");
+    Py_DECREF(x);
+}
+
+void
+_PySignal_Fini(void)
+{
+    int i;
+    PyObject *x;
+    PyObject *e_type, *e_val, *e_tb;
+
+    PyCritical_Enter(signal_branch_crit);
+    signal_branch_quit = 1;
+    if (signal_branch_waiting && !signal_branch_wakeup_sent) {
+        PyThread_send_signal(signal_branch_handle, _PySIGNAL_WAKEUP);
+        signal_branch_wakeup_sent = 1;
+    }
+    PyCritical_Exit(signal_branch_crit);
+
+    /* XXX This is all a big bodge */
+    PyErr_Fetch(&e_type, &e_val, &e_tb);
+    PyErr_NormalizeException(&e_type, &e_val, &e_tb);
+    if (e_type == NULL) {
+        Py_INCREF(Py_None);
+        e_type = Py_None;
+        Py_INCREF(Py_None);
+        e_val = Py_None;
+    }
+    if (e_tb == NULL) {
+        Py_INCREF(Py_None);
+        e_tb = Py_None;
+    }
+    assert(e_type && e_val && e_tb);
+    x = PyObject_CallMethod(signal_branch, "__exit__", "OOO", e_type, e_val, e_tb);
+    /* XXX any DECREFs needed? */
+    if (x == NULL)
+        Py_FatalError("failed to call signal_branch.__exit__()");
+    Py_DECREF(x);
+    Py_CLEAR(signal_branch);
+    /* XXX reraise or whatever as required by __exit__ specs */
+
+    PyCritical_Free(signal_branch_crit);
+    signal_branch_crit = NULL;
+
+    for (i = 1; i < NSIG; i++)
+        Py_CLEAR(Handlers[i].func);
+    Py_CLEAR(IntHandler);
+    Py_CLEAR(DefaultHandler);
+    Py_CLEAR(IgnoreHandler);
+}
+
+void
+_PySignal_InitSigInt(int handle_sigint)
+{
+    PyObject *x;
+
+    sigint_branch = PyObject_CallObject((PyObject *)&PyBranch_Type, NULL);
+    if (sigint_branch == NULL)
+        Py_FatalError("failed to initialize sigint_branch");
+    x = PyObject_CallMethod(sigint_branch, "__enter__", "");
+    if (x == NULL)
+        Py_FatalError("failed to call sigint_branch.__enter__()");
+    Py_DECREF(x);
+
+    if (handle_sigint) {
+        PyObject *m = PyImport_ImportModule("signal");
+        if (!m)
+            Py_FatalError("Can't import signal module");
+
+        old_sigint_handler = PyObject_CallMethod(m, "signal", "iO", SIGINT, IntHandler);
+        if (old_sigint_handler == NULL)
+            Py_FatalError("Failed to install sigint handler");
+    }
+}
+
+void
+_PySignal_FiniSigInt(void)
+{
+    PyObject *x;
+    PyObject *e_type, *e_val, *e_tb;
+
+    if (old_sigint_handler) {
+        PyObject *m = PyImport_ImportModule("signal");
+        if (!m)
+            Py_FatalError("Can't import signal module");
+
+        x = PyObject_CallMethod(m, "signal", "iO", SIGINT, old_sigint_handler);
+        if (x == NULL)
+            Py_FatalError("Failed to uninstall sigint handler");
+        Py_DECREF(x);
+        Py_CLEAR(old_sigint_handler);
+    }
+
+    /* XXX This is all a big bodge */
+    PyErr_Fetch(&e_type, &e_val, &e_tb);
+    PyErr_NormalizeException(&e_type, &e_val, &e_tb);
+    if (e_type == NULL) {
+        Py_INCREF(Py_None);
+        e_type = Py_None;
+        Py_INCREF(Py_None);
+        e_val = Py_None;
+    }
+    if (e_tb == NULL) {
+        Py_INCREF(Py_None);
+        e_tb = Py_None;
+    }
+    assert(e_type && e_val && e_tb);
+    x = PyObject_CallMethod(sigint_branch, "__exit__", "OOO", e_type, e_val, e_tb);
+    /* XXX any DECREFs needed? */
+    if (x == NULL)
+        PyErr_Print();
+        //Py_FatalError("failed to call sigint_branch.__exit__()");
+    Py_XDECREF(x);
+    Py_CLEAR(sigint_branch);
+    /* XXX reraise or whatever as required by __exit__ specs */
+}
+
+
+/* Wrappers around sigaction() or signal(). */
+PyOS_sighandler_t
+PyOS_getsig(int sig)
+{
+#ifdef HAVE_SIGACTION
+    struct sigaction context;
+    if (sigaction(sig, NULL, &context) == -1)
+        return SIG_ERR;
+    return context.sa_handler;
+#else
+    PyOS_sighandler_t handler;
+/* Special signal handling for the secure CRT in Visual Studio 2005 */
+#if defined(_MSC_VER) && _MSC_VER >= 1400
+    switch (sig) {
+        /* Only these signals are valid */
+        case SIGINT:
+        case SIGILL:
+        case SIGFPE:
+        case SIGSEGV:
+        case SIGTERM:
+        case SIGBREAK:
+        case SIGABRT:
+            break;
+        /* Don't call signal() with other values or it will assert */
+        default:
+            return SIG_ERR;
+    }
+#endif /* _MSC_VER && _MSC_VER >= 1400 */
+    handler = signal(sig, SIG_IGN);
+    if (handler != SIG_ERR)
+        signal(sig, handler);
+    return handler;
+#endif
+}
+
+PyOS_sighandler_t
+PyOS_setsig(int sig, PyOS_sighandler_t handler)
+{
+#ifdef HAVE_SIGACTION
+    struct sigaction context, ocontext;
+    context.sa_handler = handler;
+    sigemptyset(&context.sa_mask);
+    context.sa_flags = 0;
+    if (sigaction(sig, &context, &ocontext) == -1)
+            return SIG_ERR;
+    return ocontext.sa_handler;
+#else
+    PyOS_sighandler_t oldhandler;
+    oldhandler = signal(sig, handler);
+#ifdef HAVE_SIGINTERRUPT
+    siginterrupt(sig, 1);
+#endif
+    return oldhandler;
 #endif
 }

=== modified file 'Modules/socketmodule.c'
--- Modules/socketmodule.c	2008-03-18 18:26:33 +0000
+++ Modules/socketmodule.c	2008-04-11 02:07:12 +0000
@@ -185,8 +185,8 @@
 #endif
 
 #ifdef USE_GETADDRINFO_LOCK
-#define ACQUIRE_GETADDRINFO_LOCK PyThread_acquire_lock(netdb_lock, 1);
-#define RELEASE_GETADDRINFO_LOCK PyThread_release_lock(netdb_lock);
+#define ACQUIRE_GETADDRINFO_LOCK PyThread_lock_acquire(netdb_lock);
+#define RELEASE_GETADDRINFO_LOCK PyThread_lock_release(netdb_lock);
 #else
 #define ACQUIRE_GETADDRINFO_LOCK
 #define RELEASE_GETADDRINFO_LOCK
@@ -733,7 +733,7 @@
 /* Lock to allow python interpreter to continue, but only allow one
    thread to be in gethostbyname or getaddrinfo */
 #if defined(USE_GETHOSTBYNAME_LOCK) || defined(USE_GETADDRINFO_LOCK)
-PyThread_type_lock netdb_lock;
+PyThread_type_lock *netdb_lock;
 #endif
 
 
@@ -1985,13 +1985,6 @@
 	res = internal_connect(s, SAS2SA(&addrbuf), addrlen, &timeout);
 	Py_END_ALLOW_THREADS
 
-	/* Signals are not errors (though they may raise exceptions).  Adapted
-	   from PyErr_SetFromErrnoWithFilenameObject(). */
-#ifdef EINTR
-	if (res == EINTR && PyErr_CheckSignals())
-		return NULL;
-#endif
-
 	return PyLong_FromLong((long) res);
 }
 
@@ -2727,7 +2720,7 @@
 {
 	if (s->sock_fd != -1)
 		(void) SOCKETCLOSE(s->sock_fd);
-	Py_TYPE(s)->tp_free((PyObject *)s);
+	PyObject_Del(s);
 }
 
 
@@ -2760,7 +2753,7 @@
 {
 	PyObject *new;
 
-	new = type->tp_alloc(type, 0);
+	new = PyObject_New(type);
 	if (new != NULL) {
 		((PySocketSockObject *)new)->sock_fd = -1;
 		((PySocketSockObject *)new)->sock_timeout = -1.0;
@@ -2853,9 +2846,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	sock_initobj,				/* tp_init */
-	PyType_GenericAlloc,			/* tp_alloc */
 	sock_new,				/* tp_new */
-	PyObject_Del,				/* tp_free */
 };
 
 
@@ -3079,7 +3070,7 @@
 #endif
 #else /* not HAVE_GETHOSTBYNAME_R */
 #ifdef USE_GETHOSTBYNAME_LOCK
-	PyThread_acquire_lock(netdb_lock, 1);
+	ACQUIRE_GETADDRINFO_LOCK
 #endif
 	h = gethostbyname(name);
 #endif /* HAVE_GETHOSTBYNAME_R */
@@ -3092,7 +3083,7 @@
 	ret = gethost_common(h, (struct sockaddr *)&addr, sizeof(addr),
 			     sa->sa_family);
 #ifdef USE_GETHOSTBYNAME_LOCK
-	PyThread_release_lock(netdb_lock);
+    RELEASE_GETADDRINFO_LOCK
 #endif
 	return ret;
 }
@@ -3175,14 +3166,14 @@
 #endif
 #else /* not HAVE_GETHOSTBYNAME_R */
 #ifdef USE_GETHOSTBYNAME_LOCK
-	PyThread_acquire_lock(netdb_lock, 1);
+	ACQUIRE_GETADDRINFO_LOCK
 #endif
 	h = gethostbyaddr(ap, al, af);
 #endif /* HAVE_GETHOSTBYNAME_R */
 	Py_END_ALLOW_THREADS
 	ret = gethost_common(h, (struct sockaddr *)&addr, sizeof(addr), af);
 #ifdef USE_GETHOSTBYNAME_LOCK
-	PyThread_release_lock(netdb_lock);
+	RELEASE_GETADDRINFO_LOCK
 #endif
 	return ret;
 }

=== modified file 'Modules/threadmodule.c'
--- Modules/threadmodule.c	2007-12-19 02:45:37 +0000
+++ Modules/threadmodule.c	2008-03-24 04:28:04 +0000
@@ -27,10 +27,13 @@
 {
 	assert(self->lock_lock);
 	/* Unlock the lock so it's safe to free it */
-	PyThread_acquire_lock(self->lock_lock, 0);
-	PyThread_release_lock(self->lock_lock);
+	/* XXX This is madness.  If another thread holds the lock
+	 * despite having no refcount then they may try to get it
+	 * again anyway. */
+	PyThread_lock_acquire(self->lock_lock);
+	PyThread_lock_release(self->lock_lock);
 	
-	PyThread_free_lock(self->lock_lock);
+	PyThread_lock_free(self->lock_lock);
 	PyObject_Del(self);
 }
 
@@ -39,11 +42,11 @@
 {
 	int i = 1;
 
-	if (!PyArg_ParseTuple(args, "|i:acquire", &i))
+	if (!PyArg_ParseTuple(args, ":acquire"))
 		return NULL;
 
 	Py_BEGIN_ALLOW_THREADS
-	i = PyThread_acquire_lock(self->lock_lock, i);
+	i = PyThread_lock_acquire(self->lock_lock);
 	Py_END_ALLOW_THREADS
 
 	return PyBool_FromLong((long)i);
@@ -63,14 +66,16 @@
 static PyObject *
 lock_PyThread_release_lock(lockobject *self)
 {
+	/* XXX This sanity check contains a race condition.  It needs
+	 * to be replaced with much more robust locking anyway. */
 	/* Sanity check: the lock must be locked */
-	if (PyThread_acquire_lock(self->lock_lock, 0)) {
-		PyThread_release_lock(self->lock_lock);
+	if (_PyThread_lock_tryacquire(self->lock_lock)) {
+		PyThread_lock_release(self->lock_lock);
 		PyErr_SetString(ThreadError, "release unlocked lock");
 		return NULL;
 	}
 
-	PyThread_release_lock(self->lock_lock);
+	PyThread_lock_release(self->lock_lock);
 	Py_INCREF(Py_None);
 	return Py_None;
 }
@@ -86,8 +91,8 @@
 static PyObject *
 lock_locked_lock(lockobject *self)
 {
-	if (PyThread_acquire_lock(self->lock_lock, 0)) {
-		PyThread_release_lock(self->lock_lock);
+	if (_PyThread_lock_tryacquire(self->lock_lock)) {
+		PyThread_lock_release(self->lock_lock);
 		return PyBool_FromLong(0L);
 	}
 	return PyBool_FromLong(1L);
@@ -146,7 +151,7 @@
 	self = PyObject_New(lockobject, &Locktype);
 	if (self == NULL)
 		return NULL;
-	self->lock_lock = PyThread_allocate_lock();
+	self->lock_lock = PyThread_lock_allocate();
 	if (self->lock_lock == NULL) {
 		PyObject_Del(self);
 		self = NULL;
@@ -181,7 +186,7 @@
 		return NULL;
 	}
 
-	self = (localobject *)type->tp_alloc(type, 0);
+	self = PyObject_NEW(localobject, type);
 	if (self == NULL)
 		return NULL;
 
@@ -250,7 +255,7 @@
 	}
 
 	local_clear(self);
-	Py_TYPE(self)->tp_free((PyObject*)self);
+	PyObject_DEL(self);
 }
 
 static PyObject *
@@ -371,9 +376,7 @@
 	/* tp_descr_set      */ 0,
 	/* tp_dictoffset     */ offsetof(localobject, dict),
 	/* tp_init           */ 0,
-	/* tp_alloc          */ 0,
 	/* tp_new            */ local_new,
-	/* tp_free           */ 0, /* Low-level free-mem routine */
 	/* tp_is_gc          */ 0, /* For PyObject_IS_GC */
 };
 
@@ -413,12 +416,16 @@
 t_bootstrap(void *boot_raw)
 {
 	struct bootstate *boot = (struct bootstate *) boot_raw;
-	PyThreadState *tstate;
+	//PyThreadState *tstate;
+	PyState_EnterTag entertag;
 	PyObject *res;
 
-	tstate = PyThreadState_New(boot->interp);
+	//tstate = PyThreadState_New(boot->interp);
+	entertag = PyState_Enter();
+	if (!entertag)
+		Py_FatalError("PyState_Enter failed");
 
-	PyEval_AcquireThread(tstate);
+	//PyEval_AcquireThread(tstate);
 	res = PyEval_CallObjectWithKeywords(
 		boot->func, boot->args, boot->keyw);
 	if (res == NULL) {
@@ -443,14 +450,19 @@
 	Py_DECREF(boot->args);
 	Py_XDECREF(boot->keyw);
 	PyMem_DEL(boot_raw);
-	PyThreadState_Clear(tstate);
-	PyThreadState_DeleteCurrent();
+	//PyThreadState_Clear(tstate);
+	//PyThreadState_DeleteCurrent();
+	PyState_Exit(entertag);
 	PyThread_exit_thread();
 }
 
 static PyObject *
 thread_PyThread_start_new_thread(PyObject *self, PyObject *fargs)
 {
+#if 1
+	PyErr_SetString(PyExc_TypeError, "thread.start_new_thread is disabled");
+	return NULL;
+#else
 	PyObject *func, *args, *keyw = NULL;
 	struct bootstate *boot;
 	long ident;
@@ -476,7 +488,7 @@
 	boot = PyMem_NEW(struct bootstate, 1);
 	if (boot == NULL)
 		return PyErr_NoMemory();
-	boot->interp = PyThreadState_GET()->interp;
+	boot->interp = PyThreadState_Get()->interp;
 	boot->func = func;
 	boot->args = args;
 	boot->keyw = keyw;
@@ -494,6 +506,7 @@
 		return NULL;
 	}
 	return PyLong_FromLong(ident);
+#endif
 }
 
 PyDoc_STRVAR(start_new_doc,

=== modified file 'Modules/timemodule.c'
--- Modules/timemodule.c	2008-04-07 03:17:54 +0000
+++ Modules/timemodule.c	2008-04-11 02:07:12 +0000
@@ -2,6 +2,8 @@
 /* Time module */
 
 #include "Python.h"
+#include "cancelobject.h"
+#include "pythread.h"
 #include "structseq.h"
 #include "timefuncs.h"
 
@@ -44,6 +46,7 @@
 #include <windows.h>
 #include "pythread.h"
 
+#if 0
 /* helper to allow us to interrupt sleep() on Windows*/
 static HANDLE hInterruptEvent = NULL;
 static BOOL WINAPI PyCtrlHandler(DWORD dwCtrlType)
@@ -56,6 +59,7 @@
 	return FALSE;
 }
 static long main_thread;
+#endif
 
 #if defined(__BORLANDC__)
 /* These overrides not needed for Win32 */
@@ -793,7 +797,7 @@
 #ifdef HAVE_CLOCK
 	{"clock",	time_clock, METH_NOARGS, clock_doc},
 #endif
-	{"sleep",	time_sleep, METH_VARARGS, sleep_doc},
+	{"sleep",	time_sleep, METH_VARARGS|METH_SHARED, sleep_doc},
 	{"gmtime",	time_gmtime, METH_VARARGS, gmtime_doc},
 	{"localtime",	time_localtime, METH_VARARGS, localtime_doc},
 	{"asctime",	time_asctime, METH_VARARGS, asctime_doc},
@@ -877,6 +881,8 @@
 	/* Set, or reset, module variables like time.timezone */
 	inittimezone(m);
 
+#if 0
+/* This Ctrl-C blurb is unnecessary now */
 #ifdef MS_WINDOWS
 	/* Helper to allow interrupts for Windows.
 	   If Ctrl+C event delivered while not sleeping
@@ -886,6 +892,7 @@
 	hInterruptEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
 	SetConsoleCtrlHandler( PyCtrlHandler, TRUE);
 #endif /* MS_WINDOWS */
+#endif
 	if (!initialized) {
 		PyStructSequence_InitType(&StructTimeType,
 					  &struct_time_type_desc);
@@ -936,105 +943,43 @@
 }
 
 
-/* Implement floatsleep() for various platforms.
+/* Implement floatsleep().
    When interrupted (or when another error occurs), return -1 and
    set an exception; else return 0. */
+static void
+sleep_wakeup(PyCancelQueue *queue, void *arg)
+{
+    PyThread_type_flag *flag = arg;
+    PyThread_flag_set(flag);
+}
 
 static int
 floatsleep(double secs)
 {
-/* XXX Should test for MS_WINDOWS first! */
-#if defined(HAVE_SELECT) && !defined(__EMX__)
-	struct timeval t;
-	double frac;
-	frac = fmod(secs, 1.0);
-	secs = floor(secs);
-	t.tv_sec = (long)secs;
-	t.tv_usec = (long)(frac*1000000.0);
-	Py_BEGIN_ALLOW_THREADS
-	if (select(0, (fd_set *)0, (fd_set *)0, (fd_set *)0, &t) != 0) {
-#ifdef EINTR
-		if (errno != EINTR) {
-#else
-		if (1) {
-#endif
-			Py_BLOCK_THREADS
-			PyErr_SetFromErrno(PyExc_IOError);
-			return -1;
-		}
-	}
-	Py_END_ALLOW_THREADS
-#elif defined(__WATCOMC__) && !defined(__QNX__)
-	/* XXX Can't interrupt this sleep */
-	Py_BEGIN_ALLOW_THREADS
-	delay((int)(secs * 1000 + 0.5));  /* delay() uses milliseconds */
-	Py_END_ALLOW_THREADS
-#elif defined(MS_WINDOWS)
-	{
-		double millisecs = secs * 1000.0;
-		unsigned long ul_millis;
-
-		if (millisecs > (double)ULONG_MAX) {
-			PyErr_SetString(PyExc_OverflowError,
-					"sleep length is too large");
-			return -1;
-		}
-		Py_BEGIN_ALLOW_THREADS
-		/* Allow sleep(0) to maintain win32 semantics, and as decreed
-		 * by Guido, only the main thread can be interrupted.
-		 */
-		ul_millis = (unsigned long)millisecs;
-		if (ul_millis == 0 ||
-		    main_thread != PyThread_get_thread_ident())
-			Sleep(ul_millis);
-		else {
-			DWORD rc;
-			ResetEvent(hInterruptEvent);
-			rc = WaitForSingleObject(hInterruptEvent, ul_millis);
-			if (rc == WAIT_OBJECT_0) {
-				/* Yield to make sure real Python signal
-				 * handler called.
-				 */
-				Sleep(1);
-				Py_BLOCK_THREADS
-				errno = EINTR;
-				PyErr_SetFromErrno(PyExc_IOError);
-				return -1;
-			}
-		}
-		Py_END_ALLOW_THREADS
-	}
-#elif defined(PYOS_OS2)
-	/* This Sleep *IS* Interruptable by Exceptions */
-	Py_BEGIN_ALLOW_THREADS
-	if (DosSleep(secs * 1000) != NO_ERROR) {
-		Py_BLOCK_THREADS
-		PyErr_SetFromErrno(PyExc_IOError);
-		return -1;
-	}
-	Py_END_ALLOW_THREADS
-#elif defined(PLAN9)
-	{
-		double millisecs = secs * 1000.0;
-		if (millisecs > (double)LONG_MAX) {
-			PyErr_SetString(PyExc_OverflowError, "sleep length is too large");
-			return -1;
-		}
-		/* This sleep *CAN BE* interrupted. */
-		Py_BEGIN_ALLOW_THREADS
-		if(sleep((long)millisecs) < 0){
-			Py_BLOCK_THREADS
-			PyErr_SetFromErrno(PyExc_IOError);
-			return -1;
-		}
-		Py_END_ALLOW_THREADS
-	}
-#else
-	/* XXX Can't interrupt this sleep */
-	Py_BEGIN_ALLOW_THREADS
-	sleep((int)secs);
-	Py_END_ALLOW_THREADS
-#endif
-
-	return 0;
+    PyState *pystate = PyState_Get();
+    /* We reuse condition_flag here.  It shouldn't be in use at this
+     * point anyway */
+    PyThread_type_flag *flag = pystate->condition_flag;
+    PyCancelObject *cancel_scope;
+    int value;
+
+    cancel_scope = PyCancel_New(sleep_wakeup, flag, pystate);
+
+    PyCancel_Push(cancel_scope);
+    PyState_Suspend();
+
+    value = PyThread_flag_timedwait(flag, secs);
+
+    PyState_Resume();
+    PyCancel_Pop(cancel_scope);
+
+    PyThread_flag_clear(flag);
+    Py_DECREF(cancel_scope);
+
+    if (value) {
+        PyErr_SetString(PyExc_Cancelled, "sleep cancelled");
+        return -1;
+    }
+
+    return 0;
 }

=== modified file 'Modules/unicodedata.c'
--- Modules/unicodedata.c	2007-12-19 02:45:37 +0000
+++ Modules/unicodedata.c	2008-03-24 04:28:04 +0000
@@ -83,7 +83,7 @@
                      Py_UCS4 (*normalization)(Py_UCS4))
 {
 	PreviousDBVersion *self;
-	self = PyObject_New(PreviousDBVersion, &UCD_Type);
+	self = PyObject_New(&UCD_Type);
 	if (self == NULL)
 		return NULL;
 	self->name = name;
@@ -1134,7 +1134,7 @@
 	sizeof(PreviousDBVersion),	/*tp_basicsize*/
 	0,			/*tp_itemsize*/
 	/* methods */
-	(destructor)PyObject_Del, /*tp_dealloc*/
+	(destructor)PyObject_Del,	/*tp_dealloc*/
 	0,			/*tp_print*/
 	0,                      /*tp_getattr*/
 	0,			/*tp_setattr*/
@@ -1166,9 +1166,7 @@
         0,                      /*tp_descr_set*/
         0,                      /*tp_dictoffset*/
         0,                      /*tp_init*/
-        0,                      /*tp_alloc*/
         0,                      /*tp_new*/
-        0,                      /*tp_free*/
         0,                      /*tp_is_gc*/
 };
 

=== modified file 'Modules/xxmodule.c'
--- Modules/xxmodule.c	2007-12-19 02:45:37 +0000
+++ Modules/xxmodule.c	2008-03-24 04:28:04 +0000
@@ -134,9 +134,7 @@
         0,                      /*tp_descr_set*/
         0,                      /*tp_dictoffset*/
         0,                      /*tp_init*/
-        0,                      /*tp_alloc*/
         0,                      /*tp_new*/
-        0,                      /*tp_free*/
         0,                      /*tp_is_gc*/
 };
 /* --------------------------------------------------------------------- */
@@ -252,9 +250,7 @@
 	0,			/*tp_descr_set*/
 	0,			/*tp_dictoffset*/
 	0,			/*tp_init*/
-	0,			/*tp_alloc*/
 	0,			/*tp_new*/
-	0,			/*tp_free*/
 	0,			/*tp_is_gc*/
 };
 
@@ -307,9 +303,7 @@
 	0,			/*tp_descr_set*/
 	0,			/*tp_dictoffset*/
 	0,			/*tp_init*/
-	0,			/*tp_alloc*/
 	0, /* see initxx */	/*tp_new*/
-	0,			/*tp_free*/
 	0,			/*tp_is_gc*/
 };
 

=== modified file 'Modules/xxsubtype.c'
--- Modules/xxsubtype.c	2007-12-02 14:31:20 +0000
+++ Modules/xxsubtype.c	2008-03-24 04:28:04 +0000
@@ -137,7 +137,6 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	(initproc)spamlist_init,		/* tp_init */
-	0,					/* tp_alloc */
 	0,					/* tp_new */
 };
 
@@ -228,7 +227,6 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	(initproc)spamdict_init,		/* tp_init */
-	0,					/* tp_alloc */
 	0,					/* tp_new */
 };
 

=== modified file 'Modules/zipimport.c'
--- Modules/zipimport.c	2008-01-18 09:56:22 +0000
+++ Modules/zipimport.c	2008-03-24 04:28:04 +0000
@@ -167,11 +167,10 @@
 static void
 zipimporter_dealloc(ZipImporter *self)
 {
-	PyObject_GC_UnTrack(self);
 	Py_XDECREF(self->archive);
 	Py_XDECREF(self->prefix);
 	Py_XDECREF(self->files);
-	Py_TYPE(self)->tp_free((PyObject *)self);
+	PyObject_Del(self);
 }
 
 static PyObject *
@@ -588,9 +587,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	(initproc)zipimporter_init,		/* tp_init */
-	PyType_GenericAlloc,			/* tp_alloc */
 	PyType_GenericNew,			/* tp_new */
-	PyObject_GC_Del,			/* tp_free */
 };
 
 

=== modified file 'Modules/zlibmodule.c'
--- Modules/zlibmodule.c	2008-04-09 08:37:03 +0000
+++ Modules/zlibmodule.c	2008-04-11 02:07:12 +0000
@@ -25,15 +25,15 @@
    de/compress objects.
  */
 
-static PyThread_type_lock zlib_lock = NULL; /* initialized on module load */
+static PyThread_type_lock *zlib_lock = NULL; /* initialized on module load */
 
 #define ENTER_ZLIB \
 	Py_BEGIN_ALLOW_THREADS \
-	PyThread_acquire_lock(zlib_lock, 1); \
+	PyThread_lock_acquire(zlib_lock); \
 	Py_END_ALLOW_THREADS
 
 #define LEAVE_ZLIB \
-	PyThread_release_lock(zlib_lock);
+	PyThread_lock_release(zlib_lock);
 
 #else
 
@@ -92,7 +92,7 @@
 newcompobject(PyTypeObject *type)
 {
     compobject *self;
-    self = PyObject_New(compobject, type);
+    self = PyObject_New(type);
     if (self == NULL)
 	return NULL;
     self->is_initialised = 0;
@@ -1052,6 +1052,6 @@
     PyModule_AddStringConstant(m, "__version__", "1.0");
 
 #ifdef WITH_THREAD
-    zlib_lock = PyThread_allocate_lock();
+    zlib_lock = PyThread_lock_allocate();
 #endif /* WITH_THREAD */
 }

=== modified file 'Objects/abstract.c'
--- Objects/abstract.c	2008-04-10 22:21:23 +0000
+++ Objects/abstract.c	2008-04-11 02:07:13 +0000
@@ -6,6 +6,8 @@
 #include "longintrepr.h"
 
 
+static PyObject *__bases__ = NULL;
+
 
 /* Shorthands to return certain errors */
 
@@ -731,8 +733,9 @@
         if (PyType_Ready(Py_TYPE(obj)) < 0)
             goto done;
 
-    /* Find the (unbound!) __format__ method (a borrowed reference) */
-    meth = _PyType_Lookup(Py_TYPE(obj), str__format__);
+    /* Find the (unbound!) __format__ method */
+    if (_PyType_LookupEx(Py_TYPE(obj), str__format__, &meth) < 0)
+        goto done;
     if (meth == NULL) {
         PyErr_Format(PyExc_TypeError,
                 "Type %.100s doesn't define __format__",
@@ -742,6 +745,7 @@
 
     /* And call it, binding it to the value */
     result = PyObject_CallFunctionObjArgs(meth, obj, format_spec, NULL);
+    Py_DECREF(meth);
 
     if (result && !PyUnicode_Check(result)) {
         PyErr_SetString(PyExc_TypeError,
@@ -2462,14 +2466,8 @@
 static PyObject *
 abstract_get_bases(PyObject *cls)
 {
-	static PyObject *__bases__ = NULL;
 	PyObject *bases;
 
-	if (__bases__ == NULL) {
-		__bases__ = PyUnicode_InternFromString("__bases__");
-		if (__bases__ == NULL)
-			return NULL;
-	}
 	Py_ALLOW_RECURSION
 	bases = PyObject_GetAttr(cls, __bases__);
 	Py_END_ALLOW_RECURSION
@@ -2719,6 +2717,13 @@
 	return recursive_issubclass(derived, cls, Py_GetRecursionLimit());
 }
 
+/* Used when it's not safe to call arbitrary code */
+int
+_PyObject_IsSubclassSimple(PyObject *derived, PyObject *cls)
+{
+	return recursive_issubclass(derived, cls, Py_GetRecursionLimit());
+}
+
 
 PyObject *
 PyObject_GetIter(PyObject *o)
@@ -2764,3 +2769,13 @@
 		PyErr_Clear();
 	return result;
 }
+
+
+void
+_PyAbstract_Init(void)
+{
+    __bases__ = PyUnicode_InternFromString("__bases__");
+    if (__bases__ == NULL)
+        /* XXX FIXME This will actually lead to recursion loop with Py_FatalError */
+        Py_FatalError("Unable to initialize __bases__");
+}

=== modified file 'Objects/boolobject.c'
--- Objects/boolobject.c	2007-09-21 20:19:23 +0000
+++ Objects/boolobject.c	2008-03-24 04:28:03 +0000
@@ -80,6 +80,12 @@
 	return PyBool_FromLong((a == Py_True) ^ (b == Py_True));
 }
 
+static int
+bool_isshareable (PyObject *self)
+{
+	return 1;
+}
+
 /* Doc string */
 
 PyDoc_STRVAR(bool_doc,
@@ -153,7 +159,7 @@
 	0,					/* tp_getattro */
 	0,					/* tp_setattro */
 	0,					/* tp_as_buffer */
-	Py_TPFLAGS_DEFAULT,			/* tp_flags */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_SHAREABLE,	/* tp_flags */
 	bool_doc,				/* tp_doc */
 	0,					/* tp_traverse */
 	0,					/* tp_clear */
@@ -170,8 +176,14 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	bool_new,				/* tp_new */
+	0,					/* tp_is_gc */
+	0,					/* tp_bases */
+	0,					/* tp_mro */
+	0,					/* tp_cache */
+	0,					/* tp_subclasses */
+	0,					/* tp_weaklist */
+	bool_isshareable,			/* tp_isshareable */
 };
 
 /* The objects representing bool values False and True */

=== added file 'Objects/branchobject.c'
--- Objects/branchobject.c	1970-01-01 00:00:00 +0000
+++ Objects/branchobject.c	2008-04-09 16:19:13 +0000
@@ -0,0 +1,759 @@
+
+#include "Python.h"
+#include "ceval.h"
+#include "cancelobject.h"
+#include "monitorobject.h"
+#include "branchobject.h"
+
+
+/* Branch methods */
+
+static void branch_basecancel(PyCancelQueue *queue, void *arg);
+static void branchchild_cancel(PyCancelQueue *queue, void *arg);
+static int branch_add_common(PyBranchObject *self, PyObject *args,
+    PyObject *kwds, char *name, int saveresult);
+static void branch_threadbootstrap(void *arg);
+static int branch_spawn_thread(PyBranchObject *self, PyObject *func,
+    PyObject *args, PyObject *kwds, char *name, int save_result);
+
+static void BranchChild_Delete(PyBranchChild *child);
+
+static void branch_cleanchildren(PyBranchObject *self);
+static PyObject *Branch_getresults(PyBranchObject *self);
+static void Branch_raiseexception(PyBranchObject *self);
+
+static PyObject *
+Branch_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
+{
+    PyBranchObject *self;
+
+    assert(type != NULL);
+
+    self = PyObject_New(type);
+    if (self == NULL)
+        return NULL;
+
+    self->crit = PyCritical_Allocate(PyCRITICAL_NORMAL);
+    if (self->crit == NULL) {
+#warning Branch_new should not call PyObject_Del
+        PyObject_Del(self);
+        PyErr_NoMemory();
+        return NULL;
+    }
+
+    self->col_state = BRANCH_NEW;
+    self->col_ownerthread = NULL;
+    self->col_threads = NULL;
+    PyLinkedList_InitBase(&self->children,
+        offsetof(PyBranchChild, children_links));
+    PyLinkedList_InitBase(&self->alive,
+        offsetof(PyBranchChild, alive_links));
+    PyLinkedList_InitBase(&self->deletable,
+        offsetof(PyBranchChild, alive_links));
+
+    self->col_basecancel = NULL;
+
+    self->col_cancelling = 0;
+    self->col_resultcount = 0;
+    self->col_exceptioncount = 0;
+
+    return (PyObject *)self;
+}
+
+static void
+Branch_dealloc(PyBranchObject *self)
+{
+    PyBranchChild *child = NULL;
+
+    if (self->col_state != BRANCH_NEW && self->col_state != BRANCH_DEAD)
+        Py_FatalError("Invalid state in Branch_dealloc()");
+
+    PyCritical_Free(self->crit);
+
+    assert(self->col_basecancel == NULL);
+
+    assert(PyLinkedList_Empty(&self->alive));
+
+    while (PyLinkedList_Next(&self->children, &child)) {
+        Py_CLEAR(child->result);
+        PyLinkedList_Append(&self->deletable, child);
+        self->col_resultcount--;
+    }
+
+    branch_cleanchildren(self);
+
+    assert(self->col_resultcount == 0);
+    assert(self->col_exceptioncount == 0);
+    assert(PyLinkedList_Empty(&self->children));
+    assert(PyLinkedList_Empty(&self->deletable));
+
+    PyObject_Del(self);
+}
+
+static PyBranchChild *
+BranchChild_New(PyBranchObject *branch, PyObject *func, PyObject *args,
+        PyObject *kwds, int new_pystate)
+{
+    PyBranchChild *child;
+
+    child = malloc(sizeof(PyBranchChild));
+    if (child == NULL) {
+        PyErr_NoMemory();
+        return NULL;
+    }
+
+    if (new_pystate) {
+        child->pystate = _PyState_New();
+        if (child->pystate == NULL) {
+            free(child);
+            PyErr_NoMemory();
+            return NULL;
+        }
+    } else
+        child->pystate = PyState_Get();
+
+    child->cancel_scope = PyCancel_New(branchchild_cancel, NULL, child->pystate);
+    if (child->cancel_scope == NULL) {
+        if (new_pystate)
+            _PyState_Delete(child->pystate);
+        free(child);
+        PyErr_NoMemory();
+        return NULL;
+    }
+    child->branch = branch;
+    child->dead = PyThread_flag_allocate();
+    if (child->dead == NULL) {
+        Py_DECREF(child->cancel_scope);
+        if (new_pystate)
+            _PyState_Delete(child->pystate);
+        free(child);
+        PyErr_NoMemory();
+        return NULL;
+    }
+
+    child->waitfor.lock = PyThread_lock_allocate();
+    if (child->waitfor.lock == NULL) {
+        Py_DECREF(child->cancel_scope);
+        if (new_pystate)
+            _PyState_Delete(child->pystate);
+        PyThread_flag_free(child->dead);
+        free(child);
+        PyErr_NoMemory();
+        return NULL;
+    }
+
+    Py_INCREF(func);
+    child->func = func;
+    Py_INCREF(args);
+    child->args = args;
+    Py_XINCREF(kwds);
+    child->kwds = kwds;
+
+    child->save_result = 0;
+    child->result = NULL;
+    child->exception = NULL;
+    PyLinkedList_InitNode(&child->children_links);
+    PyLinkedList_InitNode(&child->alive_links);
+
+    child->waitfor.self = child;
+    child->waitfor.blocker = NULL;
+    child->waitfor.checking_deadlock = 0;
+    child->waitfor.abortfunc = NULL;
+    PyLinkedList_InitNode(&child->waitfor.inspection_links);
+
+    return child;
+}
+
+static void
+BranchChild_Delete(PyBranchChild *child)
+{
+    Py_DECREF(child->cancel_scope);
+
+    assert(PyLinkedList_Detached(&child->children_links));
+    assert(PyLinkedList_Detached(&child->alive_links));
+
+    assert(child->result == NULL);
+    assert(child->exception == NULL);
+
+    PyThread_flag_free(child->dead);
+
+    Py_XDECREF(child->func);
+    Py_XDECREF(child->args);
+    Py_XDECREF(child->kwds);
+
+    assert(child->waitfor.blocker == NULL);
+    assert(child->waitfor.checking_deadlock == 0);
+    assert(PyLinkedList_Detached(&child->waitfor.inspection_links));
+    PyThread_lock_free(child->waitfor.lock);
+
+    free(child);
+}
+
+static void
+branchchild_cancel(PyCancelQueue *queue, void *arg)
+{
+    Py_FatalError("branchchild_cancel called");
+    /* XXX FIXME */
+}
+
+static PyObject *
+Branch___enter__(PyBranchObject *self)
+{
+    PyCancelObject *basecancel;
+    PyBranchChild *mainchild = BranchChild_New(self, Py_None, Py_None, Py_None, 0);
+    if (mainchild == NULL)
+        return NULL;
+
+    basecancel = PyCancel_New(branch_basecancel, self, PyState_Get());
+    if (basecancel == NULL) {
+        BranchChild_Delete(mainchild);
+        return NULL;
+    }
+
+    PyCritical_Enter(self->crit);
+
+    if (self->col_state != BRANCH_NEW) {
+        PyCritical_Exit(self->crit);
+
+        Py_DECREF(basecancel);
+        BranchChild_Delete(mainchild);
+        PyErr_SetString(PyExc_TypeError, "branch.__enter__() called in "
+            "wrong state");
+        return NULL;
+    }
+
+    self->col_mainthread = mainchild;
+    PyLinkedList_Append(&self->children, mainchild);
+    PyLinkedList_Append(&self->alive, mainchild);
+    /* XXX setup cancel stack for current thread */
+    self->col_basecancel = basecancel;
+    PyCancel_Push(self->col_basecancel);
+    PyCancel_Push(self->col_mainthread->cancel_scope);
+
+    self->col_state = BRANCH_ALIVE;
+
+    PyCritical_Exit(self->crit);
+
+    Py_INCREF(self);
+    return (PyObject *)self;
+}
+
+static PyObject *
+Branch___exit__(PyBranchObject *self, PyObject *args)
+{
+    PyCancelQueue queue;
+    int run_queue = 0;
+    PyObject *type, *val, *tb;
+    int delete_child = 0;
+
+    if (!PyArg_ParseTuple(args, "OOO", &type, &val, &tb))
+        Py_FatalError("Branch.__exit__() got bad arguments");
+
+    if (type == Py_None)
+        val = NULL;
+    else {
+        Py_INCREF(type);
+        Py_INCREF(val);
+        Py_INCREF(tb);
+        val = PyErr_SimplifyException(type, val, tb);
+    }
+
+    PyCritical_Enter(self->crit);
+
+    assert(self->col_state == BRANCH_ALIVE);
+    self->col_state = BRANCH_DYING;
+
+    /* XXX pop cancel stack for current thread */
+    if (val != NULL) {
+        self->col_exceptioncount++;
+        self->col_mainthread->exception = val;
+        if (self->col_exceptioncount == 1) {
+            PyBranchChild *child = NULL;
+
+            PyCancelQueue_Init(&queue);
+            while (PyLinkedList_Next(&self->alive, &child))
+                PyCancelQueue_Cancel(&queue, child->cancel_scope);
+            run_queue = 1;
+        }
+    } else
+        delete_child = 1;
+
+    PyCritical_Exit(self->crit);
+
+    if (run_queue)
+        PyCancelQueue_Finish(&queue);
+
+    PyCritical_Enter(self->crit);
+    PyThread_flag_set(self->col_mainthread->dead);
+
+    PyCancel_Pop(self->col_mainthread->cancel_scope);
+
+    PyLinkedList_Remove(&self->col_mainthread->alive_links);
+    if (delete_child) {
+        PyLinkedList_Append(&self->deletable, self->col_mainthread);
+        self->col_mainthread = NULL;
+    }
+
+    while (!PyLinkedList_Empty(&self->alive)) {
+        PyBranchChild *child = PyLinkedList_First(&self->alive);
+
+        PyCritical_Exit(self->crit);
+        _PyMonitorSpace_WaitForBranchChild(child);
+        PyCritical_Enter(self->crit);
+    }
+
+    assert(self->col_state == BRANCH_DYING);
+    self->col_state = BRANCH_DEAD;
+
+    PyCancel_Pop(self->col_basecancel);
+    Py_CLEAR(self->col_basecancel);
+
+    branch_cleanchildren(self);
+
+    PyCritical_Exit(self->crit);
+    /* Now that we're dead it's safe to check our variables without
+     * holding the crit */
+
+    if (self->col_exceptioncount && self->col_resultcount) {
+        /* Purge the results so they're not mixed with the exceptions */
+        PyBranchChild *child = NULL;
+
+        while (PyLinkedList_Next(&self->children, &child)) {
+            if (child->result != NULL) {
+                Py_CLEAR(child->result);
+                PyLinkedList_Append(&self->deletable, &child);
+                self->col_resultcount--;
+            }
+        }
+
+        assert(self->col_resultcount == 0);
+    }
+
+    branch_cleanchildren(self);
+
+    if (self->col_exceptioncount) {
+        Branch_raiseexception(self);
+        return NULL;
+    } else {
+        Py_INCREF(Py_None);
+        return Py_None;
+    }
+}
+
+static void
+branch_basecancel(PyCancelQueue *queue, void *arg)
+{
+    PyBranchChild *child = NULL;
+    PyBranchObject *self = (PyBranchObject *)arg;
+
+    PyCritical_Enter(self->crit);
+    self->col_cancelling = 1;
+
+    while (PyLinkedList_Next(&self->alive, &child))
+        PyCancelQueue_Cancel(queue, child->cancel_scope);
+    PyCritical_Exit(self->crit);
+}
+
+static PyObject *
+Branch_add(PyBranchObject *self, PyObject *args, PyObject *kwds)
+{
+    if (!branch_add_common(self, args, kwds, "branch.add", 0))
+        return NULL;
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+static PyObject *
+Branch_addresult(PyBranchObject *self, PyObject *args, PyObject *kwds)
+{
+    if (!branch_add_common(self, args, kwds, "branch.addresult", 1))
+        return NULL;
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+static int
+branch_add_common(PyBranchObject *self, PyObject *args, PyObject *kwds,
+        char *name, int saveresult)
+{
+    PyObject *func;
+    PyObject *smallargs;
+
+    if (PyTuple_Size(args) < 1) {
+        PyErr_Format(PyExc_TypeError, "%s() needs a function to be "
+            "called", name);
+        return 0;
+    }
+
+    func = PyTuple_GetItem(args, 0);
+
+    if (!PyObject_IsShareable(func)) {
+        PyErr_Format(PyExc_TypeError, "%s()'s function argument must be "
+            "shareable, '%s' object is not", name, func->ob_type->tp_name);
+        return 0;
+    }
+
+    smallargs = PyTuple_GetSlice(args, 1, PyTuple_Size(args));
+    if (smallargs == NULL) {
+        return 0;
+    }
+
+    if (!PyArg_RequireShareable(name, smallargs, kwds)) {
+        Py_DECREF(smallargs);
+        return 0;
+    }
+
+    if (!branch_spawn_thread(self, func, smallargs, kwds, name, saveresult)) {
+        Py_DECREF(smallargs);
+        return 0;
+    }
+
+    Py_DECREF(smallargs);
+    return 1;
+}
+
+static int
+branch_spawn_thread(PyBranchObject *self, PyObject *func, PyObject *args,
+        PyObject *kwds, char *name, int save_result)
+{
+    PyBranchChild *child;
+    PyObject *exc;
+    const char *format;
+
+    child = BranchChild_New(self, func, args, kwds, 1);
+    if (child == NULL)
+        return 0;
+    child->save_result = save_result;
+
+    if (self->col_cancelling)
+        /* XXX FIXME this is a hack! */
+        child->cancel_scope->cancelled = 1;
+
+    PyCritical_Enter(self->crit);
+
+    if (self->col_state != BRANCH_ALIVE) {
+        exc = PyExc_TypeError;
+        format = "%s() called in wrong state";
+        goto failed;
+    }
+
+    if (PyState_Get()->import_depth)
+        Py_FatalError("importing is not thread-safe");
+
+    PyLinkedList_Append(&self->children, child);
+    PyLinkedList_Append(&self->alive, child);
+
+    if (PyThread_start_new_thread(NULL, branch_threadbootstrap, child) < 0) {
+        exc = PyExc_RuntimeError;
+        format = "%s can't spawn new thread";
+        goto failed;
+    }
+
+    PyCritical_Exit(self->crit);
+    return 1;
+
+failed:
+    if (!PyLinkedList_Detached(&child->children_links))
+        PyLinkedList_Remove(&child->children_links);
+    if (!PyLinkedList_Detached(&child->alive_links))
+        PyLinkedList_Remove(&child->alive_links);
+    PyCritical_Exit(self->crit);
+
+    if (child->pystate)
+        _PyState_Delete(child->pystate);
+    BranchChild_Delete(child);
+
+    if (exc != NULL)
+        PyErr_Format(exc, format, name);
+    else
+        PyErr_NoMemory();
+
+    return 0;
+}
+
+static void
+branch_threadbootstrap(void *arg)
+{
+    PyCancelQueue queue;
+    int run_queue = 0;
+    PyBranchChild *child = (PyBranchChild *)arg;
+    PyState_EnterFrame enterframe;
+    PyBranchObject *branch = child->branch;
+    int delete_child = 0;
+
+    if (_PyState_EnterPreallocated(&enterframe, child->pystate)) {
+        /* Because we preallocate everything, it should be
+         * impossible to fail. */
+        Py_FatalError("PyState_EnterPreallocated failed");
+    }
+
+    Py_INCREF(branch);
+
+    _PyMonitorSpace_BlockOnSelf(&child->waitfor);
+
+    PyCancel_Push(child->cancel_scope);
+
+    child->result = PyObject_Call(child->func, child->args, child->kwds);
+    if (!PyArg_RequireShareableReturn("branch._threadbootstrap",
+            child->func, child->result))
+        Py_CLEAR(child->result);
+
+    Py_CLEAR(child->func);
+    Py_CLEAR(child->args);
+    Py_CLEAR(child->kwds);
+
+    if (child->result != NULL) {
+        if (!child->save_result)
+            Py_DECREF(child->result);
+    } else {
+        PyObject *type, *val, *tb;
+        PyErr_Fetch(&type, &val, &tb);
+        child->exception = PyErr_SimplifyException(type, val, tb);
+    }
+
+    PyCritical_Enter(branch->crit);
+
+    if (child->result != NULL) {
+        if (child->save_result)
+            branch->col_resultcount++;
+        else {
+            /* XXX child->result was DECREF'd earlier */
+            child->result = NULL;
+            delete_child = 1;
+        }
+    } else {
+        branch->col_exceptioncount++;
+        if (branch->col_exceptioncount == 1) {
+            PyBranchChild *otherchild = NULL;
+
+            PyCancelQueue_Init(&queue);
+            while (PyLinkedList_Next(&branch->alive, &otherchild))
+                PyCancelQueue_Cancel(&queue, otherchild->cancel_scope);
+            run_queue = 1;
+        }
+    }
+
+    PyCritical_Exit(branch->crit);
+
+    if (run_queue)
+        PyCancelQueue_Finish(&queue);
+
+    _PyMonitorSpace_UnblockOnSelf(&child->waitfor);
+
+    PyCritical_Enter(branch->crit);
+    PyCancel_Pop(child->cancel_scope);
+
+    PyLinkedList_Remove(&child->alive_links);
+
+    if (delete_child)
+        PyLinkedList_Append(&branch->deletable, child);
+
+    PyThread_flag_set(child->dead);
+
+    if (branch->col_state == BRANCH_ALIVE)
+        branch_cleanchildren(branch);
+
+    /* After the main thread regains the critical and finds no threads
+     * left, it starts skipping the critical.  Therefor it's not safe to
+     * touch the branch after we release this critical. */
+    PyCritical_Exit(branch->crit);
+
+    Py_DECREF(branch);
+
+    _PyState_ExitPreallocated(&enterframe);
+}
+
+static void
+branch_cleanchildren(PyBranchObject *self)
+{
+    /* Assumes self->crit is already held */
+
+    while (!PyLinkedList_Empty(&self->deletable)) {
+        PyBranchChild *child = PyLinkedList_First(&self->deletable);
+
+        PyLinkedList_Remove(&child->children_links);
+        PyLinkedList_Remove(&child->alive_links);
+
+        BranchChild_Delete(child);
+    }
+}
+
+static PyObject *
+Branch_getresults(PyBranchObject *self)
+{
+    PyObject *results;
+    PyBranchChild *child = NULL;
+    Py_ssize_t i;
+
+    PyCritical_Enter(self->crit);
+    if (self->col_state != BRANCH_DEAD) {
+        PyCritical_Exit(self->crit);
+        PyErr_SetString(PyExc_TypeError, "branch.getresults() called in "
+            "wrong state");
+        return NULL;
+    }
+    PyCritical_Exit(self->crit);
+
+    /* Once we know the state is BRANCH_DEAD we can rely on the
+     * MonitorSpace's locking to protect us.  A branch is not shareable. */
+
+    assert(!self->col_exceptioncount);
+
+    results = PyList_New(self->col_resultcount);
+    if (results == NULL)
+        return NULL;
+
+    i = 0;
+    while (PyLinkedList_Next(&self->children, &child)) {
+        assert(i < self->col_resultcount);
+
+        assert(child->exception == NULL);
+        assert(child->result != NULL);
+
+        /* Copy across, stealing references */
+        PyList_SET_ITEM(results, i, child->result);
+        child->result = NULL;
+        PyLinkedList_Append(&self->deletable, child);
+        i++;
+    }
+    assert(i == self->col_resultcount);
+    self->col_resultcount = 0;
+    branch_cleanchildren(self);
+    return results;
+}
+
+static void
+Branch_raiseexception(PyBranchObject *self)
+{
+    PyBranchChild *child = NULL;
+    PyObject *causes;
+    PyObject *interesting = NULL;
+    int multiple = 0;
+    PyObject *type, *val, *tb;
+    Py_ssize_t i;
+
+    assert(self->col_state == BRANCH_DEAD);
+    assert(self->col_resultcount == 0);
+    assert(self->col_exceptioncount);
+
+    causes = PyTuple_New(self->col_exceptioncount);
+    if (causes == NULL) {
+        while (PyLinkedList_Next(&self->children, &child)) {
+            Py_CLEAR(child->exception);
+            PyLinkedList_Append(&self->deletable, child);
+        }
+        self->col_exceptioncount = 0;
+        branch_cleanchildren(self);
+
+        PyErr_NoMemory();
+        return;
+    }
+
+    i = 0;
+    while (PyLinkedList_Next(&self->children, &child)) {
+        assert(i < self->col_exceptioncount);
+
+        assert(child->result == NULL);
+        assert(child->exception != NULL);
+
+        if (!PyErr_GivenExceptionMatches(child->exception,
+                PyExc_Cancelled)) {
+            if (interesting != NULL) {
+                Py_DECREF(interesting);
+                interesting = NULL;
+                multiple = 1;
+            } else if (!multiple) {
+                Py_INCREF(child->exception);
+                interesting = child->exception;
+            }
+        }
+
+        Py_INCREF(child->exception);
+        PyTuple_SET_ITEM(causes, i, child->exception);
+        Py_CLEAR(child->exception);
+        PyLinkedList_Append(&self->deletable, child);
+        i++;
+    }
+
+    if (interesting) {
+        PyErr_SetObject((PyObject *)Py_TYPE(interesting),
+            ((PyBaseExceptionObject *)interesting)->args);
+        Py_DECREF(interesting);
+    } else if (self->col_cancelling && !multiple)
+        PyErr_SetNone(PyExc_Cancelled);
+    else
+        PyErr_SetNone(PyExc_MultipleError);
+
+    PyErr_Fetch(&type, &val, &tb);
+    PyErr_NormalizeException(&type, &val, &tb);
+    PyException_SetCause(val, causes); /* Consumes a reference to causes */
+    PyErr_Restore(type, val, tb);
+
+    assert(i == self->col_exceptioncount);
+    self->col_exceptioncount = 0;
+    branch_cleanchildren(self);
+    return;
+}
+
+PyDoc_STRVAR(Branch___enter____doc__, "");
+PyDoc_STRVAR(Branch___exit____doc__, "");
+PyDoc_STRVAR(Branch_add__doc__, "add(func, *args, **kwargs) -> None");
+PyDoc_STRVAR(Branch_addresult__doc__, "addresult(func, *args, **kwargs) -> None");
+PyDoc_STRVAR(Branch_getresults__doc__, "getresults() -> list");
+
+static PyMethodDef Branch_methods[] = {
+    {"__enter__",       (PyCFunction)Branch___enter__,  METH_NOARGS,
+        Branch___enter____doc__},
+    {"__exit__",        (PyCFunction)Branch___exit__,   METH_VARARGS,
+        Branch___exit____doc__},
+    {"add",             (PyCFunction)Branch_add,        METH_VARARGS | METH_KEYWORDS,
+        Branch_add__doc__},
+    {"addresult",       (PyCFunction)Branch_addresult,  METH_VARARGS | METH_KEYWORDS,
+        Branch_addresult__doc__},
+    {"getresults",      (PyCFunction)Branch_getresults, METH_NOARGS,
+        Branch_getresults__doc__},
+    {NULL,              NULL}  /* sentinel */
+};
+
+PyTypeObject PyBranch_Type = {
+    PyVarObject_HEAD_INIT(&PyType_Type, 0)
+    "_threadtoolsmodule.branch",        /*tp_name*/
+    sizeof(PyBranchObject),             /*tp_basicsize*/
+    0,                                  /*tp_itemsize*/
+    (destructor)Branch_dealloc,         /*tp_dealloc*/
+    0,                                  /*tp_print*/
+    0,                                  /*tp_getattr*/
+    0,                                  /*tp_setattr*/
+    0,                                  /*tp_compare*/
+    0,                                  /*tp_repr*/
+    0,                                  /*tp_as_number*/
+    0,                                  /*tp_as_sequence*/
+    0,                                  /*tp_as_mapping*/
+    0,                                  /*tp_hash*/
+    0,                                  /*tp_call*/
+    0,                                  /*tp_str*/
+    PyObject_GenericGetAttr,            /*tp_getattro*/
+    0,                                  /*tp_setattro*/
+    0,                                  /*tp_as_buffer*/
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_SHAREABLE,  /*tp_flags*/
+    0,                                  /*tp_doc*/
+    0,                                  /*tp_traverse*/
+    0,                                  /*tp_clear*/
+    0,                                  /*tp_richcompare*/
+    0,                                  /*tp_weaklistoffset*/
+    0,                                  /*tp_iter*/
+    0,                                  /*tp_iternext*/
+    Branch_methods,                     /*tp_methods*/
+    0,                                  /*tp_members*/
+    0,                                  /*tp_getset*/
+    0,                                  /*tp_base*/
+    0,                                  /*tp_dict*/
+    0,                                  /*tp_descr_get*/
+    0,                                  /*tp_descr_set*/
+    0,                                  /*tp_dictoffset*/
+    0,                                  /*tp_init*/
+    Branch_new,                         /*tp_new*/
+};
+

=== modified file 'Objects/bytesobject.c'
--- Objects/bytesobject.c	2008-03-28 00:55:15 +0000
+++ Objects/bytesobject.c	2008-04-11 02:07:13 +0000
@@ -16,7 +16,7 @@
 int
 PyBytes_Init(void)
 {
-    nullbytes = PyObject_New(PyBytesObject, &PyBytes_Type);
+    nullbytes = PyObject_New(&PyBytes_Type);
     if (nullbytes == NULL)
         return 0;
     nullbytes->ob_bytes = NULL;
@@ -110,7 +110,7 @@
 
     assert(size >= 0);
 
-    new = PyObject_New(PyBytesObject, &PyBytes_Type);
+    new = PyObject_New(&PyBytes_Type);
     if (new == NULL)
         return NULL;
 
@@ -1008,7 +1008,7 @@
     if (self->ob_bytes != 0) {
         PyMem_Free(self->ob_bytes);
     }
-    Py_TYPE(self)->tp_free((PyObject *)self);
+    PyObject_Del(self);
 }
 
 
@@ -3149,7 +3149,8 @@
     PyObject_GenericGetAttr,            /* tp_getattro */
     0,                                  /* tp_setattro */
     &bytes_as_buffer,                   /* tp_as_buffer */
-    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |
+        Py_TPFLAGS_SHAREABLE,           /* tp_flags */
     bytes_doc,                          /* tp_doc */
     0,                                  /* tp_traverse */
     0,                                  /* tp_clear */
@@ -3166,9 +3167,7 @@
     0,                                  /* tp_descr_set */
     0,                                  /* tp_dictoffset */
     (initproc)bytes_init,               /* tp_init */
-    PyType_GenericAlloc,                /* tp_alloc */
     PyType_GenericNew,                  /* tp_new */
-    PyObject_Del,                       /* tp_free */
 };
 
 /*********************** Bytes Iterator ****************************/
@@ -3182,9 +3181,8 @@
 static void
 bytesiter_dealloc(bytesiterobject *it)
 {
-    _PyObject_GC_UNTRACK(it);
     Py_XDECREF(it->it_seq);
-    PyObject_GC_Del(it);
+    PyObject_Del(it);
 }
 
 static int
@@ -3279,12 +3277,11 @@
         PyErr_BadInternalCall();
         return NULL;
     }
-    it = PyObject_GC_New(bytesiterobject, &PyBytesIter_Type);
+    it = PyObject_New(&PyBytesIter_Type);
     if (it == NULL)
         return NULL;
     it->it_index = 0;
     Py_INCREF(seq);
     it->it_seq = (PyBytesObject *)seq;
-    _PyObject_GC_TRACK(it);
     return (PyObject *)it;
 }

=== added file 'Objects/cancelobject.c'
--- Objects/cancelobject.c	1970-01-01 00:00:00 +0000
+++ Objects/cancelobject.c	2008-04-09 16:14:16 +0000
@@ -0,0 +1,317 @@
+
+#include "Python.h"
+#include "cancelobject.h"
+#include "pystate.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* PyCancel */
+
+PyCancelObject *
+PyCancel_New(void (*callback)(PyCancelQueue *, void *), void *arg,
+        PyState *pystate)
+{
+    PyCancelObject *scope;
+
+    assert(callback);
+    assert(pystate);
+
+    scope = PyObject_New(&PyCancel_Type);
+    if (scope == NULL)
+        return NULL;
+    scope->callback_finished = PyThread_flag_allocate();
+    if (!scope->callback_finished) {
+        PyObject_Del(scope);
+        PyErr_NoMemory();
+        return NULL;
+    }
+
+    scope->cancelled = 0;
+    PyLinkedList_InitNode(&scope->stack_links);
+    scope->callback = callback;
+    scope->callback_activated = 0;
+    scope->arg = arg;
+    scope->pystate = pystate;
+    PyLinkedList_InitNode(&scope->queue_links);
+
+    return scope;
+}
+
+void
+PyCancel_Push(PyCancelObject *scope)
+{
+    PyState *pystate = PyState_Get();
+    PyCancelQueue queue;
+    PyCancelObject *parent;
+
+    PyCancelQueue_Init(&queue);
+
+    PyCritical_Enter(pystate->cancel_crit);
+    assert(PyLinkedList_Detached(&scope->stack_links));
+
+    parent = PyLinkedList_Last(&pystate->cancel_stack);
+    if (parent) {
+        if (parent->cancelled) {
+            /* Enqueue this scope, so that it gets notified its parent
+             * is cancelled.  The lock will be released by the queue. */
+
+            PyLinkedList_Append(&queue.list, scope);
+            Py_INCREF(scope);
+            scope->callback_activated = 1;
+        }
+    }
+    PyLinkedList_Append(&pystate->cancel_stack, scope);
+    PyCritical_Exit(pystate->cancel_crit);
+
+    PyCancelQueue_Finish(&queue);
+}
+
+void
+PyCancel_Pop(PyCancelObject *scope)
+{
+    PyState *pystate = PyState_Get();
+    int activated;
+
+    PyCritical_Enter(pystate->cancel_crit);
+    if (PyLinkedList_Last(&pystate->cancel_stack) != scope)
+        Py_FatalError("Popping wrong cancel scope");
+
+    PyLinkedList_Remove(&scope->stack_links);
+
+    activated = scope->callback_activated;
+    PyCritical_Exit(pystate->cancel_crit);
+
+    if (activated)
+        PyThread_flag_wait(scope->callback_finished);
+}
+
+static void
+cancel_dealloc(PyCancelObject *scope)
+{
+    assert(PyLinkedList_Detached(&scope->stack_links));
+    assert(PyLinkedList_Detached(&scope->queue_links));
+
+    PyThread_flag_free(scope->callback_finished);
+
+    PyObject_Del(scope);
+}
+
+static int
+cancel_traverse(PyCancelObject *scope, visitproc visit, void *arg)
+{
+    return 0;
+}
+
+static PyObject *
+cancel_cancel(PyCancelObject *scope)
+{
+    PyCancelQueue queue;
+
+    PyCancelQueue_Init(&queue);
+    PyCancelQueue_Cancel(&queue, scope);
+    PyCancelQueue_Finish(&queue);
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+static int
+cancel_isshareable(PyObject *obj)
+{
+    return 1;
+}
+
+PyDoc_STRVAR(cancel_doc,
+"FIXME");
+
+static PyMethodDef cancel_methods[] = {
+    {"cancel", (PyCFunction)cancel_cancel, METH_NOARGS|METH_SHARED, cancel_doc},
+    {NULL, NULL}                            /* sentinel */
+};
+
+PyTypeObject PyCancel_Type = {
+    PyVarObject_HEAD_INIT(&PyType_Type, 0)
+    "cancel",
+    sizeof(PyCancelObject),
+    0,
+    (destructor)cancel_dealloc,             /* tp_dealloc */
+    0,                                      /* tp_print */
+    0,                                      /* tp_getattr */
+    0,                                      /* tp_setattr */
+    0,                                      /* tp_compare */
+    0,                                      /* tp_repr */
+    0,                                      /* tp_as_number */
+    0,                                      /* tp_as_sequence */
+    0,                                      /* tp_as_mapping */
+    0,                                      /* tp_hash */
+    0,                                      /* tp_call */
+    0,                                      /* tp_str */
+    PyObject_GenericGetAttr,                /* tp_getattro */
+    0,                                      /* tp_setattro */
+    0,                                      /* tp_as_buffer */
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,/* tp_flags */
+    0,                                      /* tp_doc */
+    (traverseproc)cancel_traverse,          /* tp_traverse */
+    0,                                      /* tp_clear */
+    0,                                      /* tp_richcompare */
+    0,                                      /* tp_weaklistoffset */
+    0,                                      /* tp_iter */
+    0,                                      /* tp_iternext */
+    cancel_methods,                         /* tp_methods */
+    0,                                      /* tp_members */
+    0,                                      /* tp_getset */
+    0,                                      /* tp_base */
+    0,                                      /* tp_dict */
+    0,                                      /* tp_descr_get */
+    0,                                      /* tp_descr_set */
+    0,                                      /* tp_dictoffset */
+    0,                                      /* tp_init */
+    0,                                      /* tp_new */
+    0,                                      /* tp_is_gc */
+    0,                                      /* tp_bases */
+    0,                                      /* tp_mro */
+    0,                                      /* tp_cache */
+    0,                                      /* tp_subclasses */
+    0,                                      /* tp_weaklist */
+    cancel_isshareable,                     /* tp_isshareable */
+};
+
+
+void
+PyCancelQueue_Init(PyCancelQueue *queue)
+{
+    PyLinkedList_InitBase(&queue->list,
+        offsetof(PyCancelObject, queue_links));
+}
+
+/* This scope was cancelled.  It is *NOT* added to the queue - only its
+ * children are, so that they can be notified */
+void
+PyCancelQueue_Cancel(PyCancelQueue *queue, PyCancelObject *scope)
+{
+    PyCancelObject *child;
+
+    PyCritical_Enter(scope->pystate->cancel_crit);
+    if (!scope->cancelled && PyLinkedList_Detached(&scope->stack_links))
+        scope->cancelled = 1;
+    else if (!scope->cancelled) {
+        scope->cancelled = 1;
+
+        child = PyLinkedList_After(&scope->pystate->cancel_stack, scope);
+        if (child) {
+            /* Ask the queue to notify the child that we got cancelled.
+             * Their lock is left acquired, and will be released by the
+             * queue after it finishes. */
+
+            PyLinkedList_Append(&queue->list, child);
+            Py_INCREF(child);
+            assert(!child->callback_activated);
+            child->callback_activated = 1;
+        }
+    }
+    PyCritical_Exit(scope->pystate->cancel_crit);
+}
+
+void
+PyCancelQueue_Finish(PyCancelQueue *queue)
+{
+    while (!PyLinkedList_Empty(&queue->list)) {
+        PyCancelObject *scope = PyLinkedList_First(&queue->list);
+        PyLinkedList_Remove(&scope->queue_links);
+
+        scope->callback(queue, scope->arg);
+        PyThread_flag_set(scope->callback_finished);
+
+        Py_DECREF(scope);
+    }
+}
+
+
+/* Returns 0 if we're not in an cancelled state,
+ * 1 and raises an exception if we are */
+int
+PyCancel_CheckCancelled(void)
+{
+    PyState *pystate = PyState_Get();
+    PyCancelObject *scope = PyLinkedList_Last(&pystate->cancel_stack);
+
+    PyCritical_Enter(pystate->cancel_crit);
+    if (scope->cancelled) {
+        PyCritical_Exit(pystate->cancel_crit);
+        PyErr_SetNone(PyExc_Cancelled);
+        return 1;
+    }
+    PyCritical_Exit(pystate->cancel_crit);
+    return 0;
+}
+
+
+#warning blah blah signal cancel API should have retries
+/* XXX FIXME the signal handler thread should be used to send the signal multiple times, if the first attempt doesn't work.  Actually, the signal handler itself should mark it as received, and the retry should check if the call actually stopped.
+ * Or should whoever's running the cancel callback do the retry?  Just have them stick around until the cancellation process finishes.
+ */
+void
+PyCancel_SignalEnter(void)
+{
+    // wipe state
+    // allocate lock
+    // allocate semaphore
+    // setup cancel callback
+    // PyState_Suspend();
+    // grab lock
+    // mark as active (cancel callback may now actually send signal)
+    // release lock
+    Py_FatalError("PyCancel_SignalEnter not implemented");
+}
+
+void
+PyCancel_SignalExit(void)
+{
+    // grab lock
+    // mark as inactive
+    // post semaphore
+    // XXX FIXME blah, I need more work to coordinate teardown with the cancel callback
+    // release lock
+    // PyState_Resume();
+    // Remove cancel callback
+    // ??? release lock
+    // ??? release semaphore
+    // I need to track that the cancel callback has started, and if so I have to wake them up and then either wait for them to signal me that they've exited, or let them do the cleanup.  The number of context switches seems the same either way, and I think it'd be simpler if it was always this function doing the cleanup.
+    // XXX FIXME this should also save errno
+    Py_FatalError("PyCancel_SignalExit not implemented");
+}
+
+int
+PyCancel_Poll(int fd)
+{
+    Py_FatalError("PyCancel_Poll not implemented");
+}
+
+#if 0
+int
+PyCancel_WaitForMultipleObjects(...)
+{
+    Py_FatalError("PyCancel_WaitForMultipleObjects not implemented");
+}
+#endif
+
+int
+PyCancel_Sleep(double secs)
+{
+    Py_FatalError("PyCancel_Sleep not implemented");
+}
+
+/* XXX FIXME consider replacing this with Sleep(Inf) */
+int
+PyCancel_SleepForever(void)
+{
+    Py_FatalError("PyCancel_SleepForever not implemented");
+}
+
+
+#ifdef __cplusplus
+}
+#endif

=== modified file 'Objects/cellobject.c'
--- Objects/cellobject.c	2008-03-19 21:50:51 +0000
+++ Objects/cellobject.c	2008-04-11 02:07:13 +0000
@@ -7,13 +7,12 @@
 {
 	PyCellObject *op;
 
-	op = (PyCellObject *)PyObject_GC_New(PyCellObject, &PyCell_Type);
+	op = PyObject_New(&PyCell_Type);
 	if (op == NULL)
 		return NULL;
 	op->ob_ref = obj;
 	Py_XINCREF(obj);
-
-	_PyObject_GC_TRACK(op);
+	PyObject_Complete(op);
 	return (PyObject *)op;
 }
 
@@ -46,9 +45,8 @@
 static void
 cell_dealloc(PyCellObject *op)
 {
-	_PyObject_GC_UNTRACK(op);
 	Py_XDECREF(op->ob_ref);
-	PyObject_GC_Del(op);
+	PyObject_Del(op);
 }
 
 static int
@@ -125,7 +123,7 @@
 	PyObject_GenericGetAttr,		/* tp_getattro */
 	0,					/* tp_setattro */
 	0,					/* tp_as_buffer */
-	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,/* tp_flags */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_SKIPWIPE, /* tp_flags */
  	0,					/* tp_doc */
  	(traverseproc)cell_traverse,		/* tp_traverse */
  	(inquiry)cell_clear,			/* tp_clear */

=== modified file 'Objects/classobject.c'
--- Objects/classobject.c	2008-02-16 07:38:31 +0000
+++ Objects/classobject.c	2008-03-24 04:28:03 +0000
@@ -2,17 +2,23 @@
 
 #include "Python.h"
 #include "structmember.h"
+#include "pythread.h"
 
 #define TP_DESCR_GET(t) ((t)->tp_descr_get)
 
+//#define USE_METHOD_FREELIST
+
+#ifdef USE_METHOD_FREELIST
 /* Free list for method objects to safe malloc/free overhead
  * The im_self element is used to chain the elements.
  */
 static PyMethodObject *free_list;
+static PyThread_type_lock *free_list_lock;
 static int numfree = 0;
 #ifndef PyMethod_MAXFREELIST
 #define PyMethod_MAXFREELIST 256
 #endif
+#endif
 
 PyObject *
 PyMethod_Function(PyObject *im)
@@ -43,31 +49,34 @@
 PyMethod_New(PyObject *func, PyObject *self)
 {
 	register PyMethodObject *im;
-	if (!PyCallable_Check(func)) {
-		PyErr_BadInternalCall();
-		return NULL;
-	}
-	if (self == NULL) {
-		PyErr_BadInternalCall();
-		return NULL;
-	}
+	if (!PyCallable_Check(func) || self == NULL) {
+		PyErr_BadInternalCall();
+		return NULL;
+	}
+#ifdef USE_METHOD_FREELIST
+	PyThread_lock_acquire(free_list_lock);
 	im = free_list;
 	if (im != NULL) {
 		free_list = (PyMethodObject *)(im->im_self);
+		PyThread_lock_release(free_list_lock);
 		PyObject_INIT(im, &PyMethod_Type);
 		numfree--;
 	}
 	else {
-		im = PyObject_GC_New(PyMethodObject, &PyMethod_Type);
+		PyThread_lock_release(free_list_lock);
+#endif
+		im = PyObject_New(&PyMethod_Type);
 		if (im == NULL)
 			return NULL;
+#ifdef USE_METHOD_FREELIST
 	}
+#endif
 	im->im_weakreflist = NULL;
 	Py_INCREF(func);
 	im->im_func = func;
 	Py_XINCREF(self);
 	im->im_self = self;
-	_PyObject_GC_TRACK(im);
+	PyObject_Complete(im);
 	return (PyObject *)im;
 }
 
@@ -114,22 +123,22 @@
 	PyTypeObject *tp = obj->ob_type;
 	PyObject *descr = NULL;
 
-	{
-		if (tp->tp_dict == NULL) {
-			if (PyType_Ready(tp) < 0)
-				return NULL;
-		}
-		descr = _PyType_Lookup(tp, name);
+	if (tp->tp_dict == NULL) {
+		if (PyType_Ready(tp) < 0)
+			return NULL;
 	}
+	if (_PyType_LookupEx(tp, name, &descr) < 0)
+		return NULL;
 
 	if (descr != NULL) {
 		descrgetfunc f = TP_DESCR_GET(descr->ob_type);
-		if (f != NULL)
-			return f(descr, obj, (PyObject *)obj->ob_type);
-		else {
-			Py_INCREF(descr);
+		if (f != NULL) {
+			PyObject *result = f(descr, obj,
+				(PyObject *)obj->ob_type);
+			Py_DECREF(descr);
+			return result;
+		} else
 			return descr;
-		}
 	}
 
 	return PyObject_GetAttr(im->im_func, name);
@@ -168,19 +177,23 @@
 static void
 method_dealloc(register PyMethodObject *im)
 {
-	_PyObject_GC_UNTRACK(im);
-	if (im->im_weakreflist != NULL)
-		PyObject_ClearWeakRefs((PyObject *)im);
 	Py_DECREF(im->im_func);
 	Py_XDECREF(im->im_self);
+#ifdef USE_METHOD_FREELIST
+	PyThread_lock_acquire(free_list_lock);
 	if (numfree < PyMethod_MAXFREELIST) {
 		im->im_self = (PyObject *)free_list;
 		free_list = im;
 		numfree++;
+		PyThread_lock_release(free_list_lock);
 	}
 	else {
-		PyObject_GC_Del(im);
+		PyThread_lock_release(free_list_lock);
+		PyObject_Del(im);
 	}
+#else
+	PyObject_Del(im);
+#endif
 }
 
 static PyObject *
@@ -339,6 +352,13 @@
 	return PyMethod_New(PyMethod_GET_FUNCTION(meth), obj);
 }
 
+static int
+method_isshareable(PyMethodObject *a)
+{
+	return (PyObject_IsShareable(a->im_func) &&
+		(a->im_self == NULL || PyObject_IsShareable(a->im_self)));
+}
+
 PyTypeObject PyMethod_Type = {
 	PyVarObject_HEAD_INIT(&PyType_Type, 0)
 	"method",
@@ -359,7 +379,7 @@
 	method_getattro,			/* tp_getattro */
 	PyObject_GenericSetAttr,		/* tp_setattro */
 	0,					/* tp_as_buffer */
-	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC, /* tp_flags */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_SKIPWIPE, /* tp_flags */
 	method_doc,				/* tp_doc */
 	(traverseproc)method_traverse,		/* tp_traverse */
 	0,					/* tp_clear */
@@ -376,25 +396,48 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	method_new,				/* tp_new */
+	0,					/* tp_is_gc */
+	0,					/* tp_bases */
+	0,					/* tp_mro */
+	0,					/* tp_cache */
+	0,					/* tp_subclasses */
+	0,					/* tp_weaklist */
+	(isshareablefunc)method_isshareable,	/* tp_isshareable */
 };
 
+void
+_PyMethod_Init(void)
+{
+#ifdef USE_METHOD_FREELIST
+	free_list_lock = PyThread_lock_allocate();
+	if (!free_list_lock)
+		Py_FatalError("unable to allocate lock");
+#endif
+}
+
 /* Clear out the free list */
 
 int
 PyMethod_ClearFreeList(void)
 {
+#ifdef USE_METHOD_FREELIST
 	int freelist_size = numfree;
 	
 	while (free_list) {
 		PyMethodObject *im = free_list;
 		free_list = (PyMethodObject *)(im->im_self);
-		PyObject_GC_Del(im);
+		PyObject_Del(im);
 		numfree--;
 	}
+
+	PyThread_lock_free(free_list_lock);
+	free_list_lock = NULL;
 	assert(numfree == 0);
 	return freelist_size;
+#else
+	return 0;
+#endif
 }
 
 void
@@ -410,12 +453,10 @@
 PyObject *
 PyInstanceMethod_New(PyObject *func) {
 	PyInstanceMethodObject *method;
-	method = PyObject_GC_New(PyInstanceMethodObject,
-				 &PyInstanceMethod_Type);
+	method = PyObject_New(&PyInstanceMethod_Type);
 	if (method == NULL) return NULL;
 	Py_INCREF(func);
 	method->func = func;
-	_PyObject_GC_TRACK(method);
 	return (PyObject *)method;
 }
 
@@ -464,16 +505,18 @@
 		if (PyType_Ready(tp) < 0)
 			return NULL;
 	}
-	descr = _PyType_Lookup(tp, name);
+	if (_PyType_LookupEx(tp, name, &descr) < 0)
+		return NULL;
 
 	if (descr != NULL) {
 		descrgetfunc f = TP_DESCR_GET(descr->ob_type);
-		if (f != NULL)
-			return f(descr, self, (PyObject *)self->ob_type);
-		else {
-			Py_INCREF(descr);
+		if (f != NULL) {
+			PyObject *result = f(descr, self,
+				(PyObject *)self->ob_type);
+			Py_DECREF(descr);
+			return result;
+		} else
 			return descr;
-		}
 	}
 
 	return PyObject_GetAttr(PyInstanceMethod_GET_FUNCTION(self), name);
@@ -481,9 +524,8 @@
 
 static void
 instancemethod_dealloc(PyObject *self) {
-	_PyObject_GC_UNTRACK(self);
 	Py_DECREF(PyInstanceMethod_GET_FUNCTION(self));
-	PyObject_GC_Del(self);
+	PyObject_Del(self);
 }
 
 static int
@@ -641,6 +683,5 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	instancemethod_new,			/* tp_new */
 };

=== modified file 'Objects/cobject.c'
--- Objects/cobject.c	2007-07-21 17:22:18 +0000
+++ Objects/cobject.c	2008-03-24 04:28:03 +0000
@@ -21,7 +21,7 @@
 {
     PyCObject *self;
 
-    self = PyObject_NEW(PyCObject, &PyCObject_Type);
+    self = PyObject_New(&PyCObject_Type);
     if (self == NULL)
         return NULL;
     self->cobject=cobj;
@@ -43,7 +43,7 @@
                         " description");
         return NULL;
     }
-    self = PyObject_NEW(PyCObject, &PyCObject_Type);
+    self = PyObject_New(&PyCObject_Type);
     if (self == NULL)
         return NULL;
     self->cobject = cobj;
@@ -122,7 +122,7 @@
         else
             (self->destructor)(self->cobject);
     }
-    PyObject_DEL(self);
+    PyObject_Del(self);
 }
 
 

=== modified file 'Objects/codeobject.c'
--- Objects/codeobject.c	2008-01-26 09:39:23 +0000
+++ Objects/codeobject.c	2008-03-24 04:28:03 +0000
@@ -81,7 +81,7 @@
 			continue;
 		PyUnicode_InternInPlace(&PyTuple_GET_ITEM(consts, i));
 	}
-	co = PyObject_NEW(PyCodeObject, &PyCode_Type);
+	co = PyObject_New(&PyCode_Type);
 	if (co != NULL) {
 		co->co_argcount = argcount;
 		co->co_kwonlyargcount = kwonlyargcount;
@@ -283,8 +283,8 @@
 	Py_XDECREF(co->co_name);
 	Py_XDECREF(co->co_lnotab);
         if (co->co_zombieframe != NULL)
-                PyObject_GC_Del(co->co_zombieframe);
-	PyObject_DEL(co);
+                PyObject_Del(co->co_zombieframe);
+	PyObject_Del(co);
 }
 
 static PyObject *
@@ -427,7 +427,6 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	0,				/* tp_init */
-	0,				/* tp_alloc */
 	code_new,			/* tp_new */
 };
 

=== modified file 'Objects/complexobject.c'
--- Objects/complexobject.c	2008-03-28 10:53:29 +0000
+++ Objects/complexobject.c	2008-04-11 02:07:13 +0000
@@ -192,9 +192,11 @@
 {
 	PyObject *op;
 
-	op = type->tp_alloc(type, 0);
-	if (op != NULL)
-		((PyComplexObject *)op)->cval = cval;
+	op = PyObject_New(type);
+	if (op == NULL)
+		return NULL;
+	((PyComplexObject *)op)->cval = cval;
+	PyObject_Complete(op);
 	return op;
 }
 
@@ -204,11 +206,17 @@
 	register PyComplexObject *op;
 
 	/* Inline PyObject_New */
-	op = (PyComplexObject *) PyObject_MALLOC(sizeof(PyComplexObject));
+	//op = (PyComplexObject *) PyObject_MALLOC(sizeof(PyComplexObject));
+	//op = (PyComplexObject *)_PyObject_GC_Malloc(sizeof(PyComplexObject));
+	/* XXX FIXME _PyObject_GC_Malloc already calls PyErr_NoMemory */
+	//if (op == NULL)
+	//	return PyErr_NoMemory();
+	//PyObject_INIT(op, &PyComplex_Type);
+	op = PyObject_New(&PyComplex_Type);
 	if (op == NULL)
-		return PyErr_NoMemory();
-	PyObject_INIT(op, &PyComplex_Type);
+		return NULL;
 	op->cval = cval;
+	PyObject_Complete(op);
 	return (PyObject *) op;
 }
 
@@ -277,10 +285,11 @@
 
         {
 		PyObject *complexfunc;
-		complexfunc = _PyType_Lookup(op->ob_type, complex_str);
-		/* complexfunc is a borrowed reference */
+		if (_PyType_LookupEx(op->ob_type, complex_str, &complexfunc) < 0)
+			return cv;
 		if (complexfunc) {
 			newop = PyObject_CallFunctionObjArgs(complexfunc, op, NULL);
+			Py_DECREF(complexfunc);
 			if (!newop)
 				return cv;
 		}
@@ -309,7 +318,7 @@
 static void
 complex_dealloc(PyObject *op)
 {
-	op->ob_type->tp_free(op);
+	PyObject_Del(op);
 }
 
 
@@ -1050,7 +1059,8 @@
 	PyObject_GenericGetAttr,		/* tp_getattro */
 	0,					/* tp_setattro */
 	0,					/* tp_as_buffer */
-	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |
+		Py_TPFLAGS_SHAREABLE | Py_TPFLAGS_SKIPWIPE, /* tp_flags */
 	complex_doc,				/* tp_doc */
 	0,					/* tp_traverse */
 	0,					/* tp_clear */
@@ -1067,9 +1077,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	PyType_GenericAlloc,			/* tp_alloc */
 	complex_new,				/* tp_new */
-	PyObject_Del,           		/* tp_free */
 };
 
 #endif

=== modified file 'Objects/descrobject.c'
--- Objects/descrobject.c	2008-02-16 07:38:31 +0000
+++ Objects/descrobject.c	2008-03-24 04:28:03 +0000
@@ -2,14 +2,14 @@
 
 #include "Python.h"
 #include "structmember.h" /* Why is this not included in Python.h? */
+#include "monitorobject.h"
 
 static void
 descr_dealloc(PyDescrObject *descr)
 {
-	_PyObject_GC_UNTRACK(descr);
 	Py_XDECREF(descr->d_type);
 	Py_XDECREF(descr->d_name);
-	PyObject_GC_Del(descr);
+	PyObject_Del(descr);
 }
 
 static PyObject *
@@ -58,6 +58,13 @@
 			  "<slot wrapper '%V' of '%s' objects>");
 }
 
+static PyObject *
+finalizeattr_repr(PyFinalizeAttrDescrObject *descr)
+{
+    return descr_repr((PyDescrObject *)descr,
+        "<finalizeattr '%V' of '%s' objects>");
+}
+
 static int
 descr_check(PyDescrObject *descr, PyObject *obj, PyObject **pres)
 {
@@ -134,6 +141,12 @@
 
 	if (descr_check((PyDescrObject *)descr, obj, &res))
 		return res;
+	if (PyMonitor_Check(obj) &&
+			!PyMonitorSpace_IsCurrent(PyMonitor_GetMonitorSpace(obj))) {
+		PyErr_SetString(PyExc_AttributeError,
+			descr->d_member->name);
+		return NULL;
+	}
 	return PyMember_GetOne((char *)obj, descr->d_member);
 }
 
@@ -163,9 +176,49 @@
 	return PyWrapper_New((PyObject *)descr, obj);
 }
 
+static PyObject *
+finalizeattr_get(PyFinalizeAttrDescrObject *descr, PyObject *obj, PyObject *type)
+{
+    PyObject *res, *core;
+
+    if (descr_check((PyDescrObject *)descr, obj, &res))
+        return res;
+
+    core = PyObject_GetAttrString(obj, "__finalizecore__");
+    if (core == NULL && PyErr_ExceptionMatches(PyExc_AttributeError)) {
+        PyErr_Clear();
+        Py_INCREF(Py_None);
+        core = Py_None;
+    }
+
+    if (core == NULL)
+        return NULL;
+
+    if (core == Py_None) {
+        PyObject *dict;
+
+        Py_DECREF(core);
+
+        dict = PyObject_GetAttrString(obj, "__dict__");
+        if (dict == NULL)
+            return NULL;
+
+        if (PyDict_GetItemEx(dict, descr->d_name, &res) > 0)
+            PyErr_Format(PyExc_AttributeError,
+                "'%.50s' object has no attribute '%.400s'",
+                ((PyTypeObject *)type)->tp_name,
+                PyUnicode_AsString(descr->d_name));
+        Py_DECREF(dict);
+        return res;
+    } else {
+        res = PyObject_GetAttr(core, descr->d_name);
+        Py_DECREF(core);
+        return res;
+    }
+}
+
 static int
-descr_setcheck(PyDescrObject *descr, PyObject *obj, PyObject *value,
-	       int *pres)
+descr_setcheck(PyDescrObject *descr, PyObject *obj)
 {
 	assert(obj != NULL);
 	if (!PyObject_TypeCheck(obj, descr->d_type)) {
@@ -175,8 +228,7 @@
 			     descr_name(descr), "?",
 			     descr->d_type->tp_name,
 			     obj->ob_type->tp_name);
-		*pres = -1;
-		return 1;
+		return -1;
 	}
 	return 0;
 }
@@ -184,20 +236,25 @@
 static int
 member_set(PyMemberDescrObject *descr, PyObject *obj, PyObject *value)
 {
-	int res;
-
-	if (descr_setcheck((PyDescrObject *)descr, obj, value, &res))
-		return res;
+	if (descr_setcheck((PyDescrObject *)descr, obj))
+		return -1;
+	if (PyMonitor_Check(obj) &&
+			!PyMonitorSpace_IsCurrent(PyMonitor_GetMonitorSpace(obj))) {
+		PyErr_Format(PyExc_AttributeError,
+			"descriptor '%.200s' for '%.100s' objects "
+			"can't be applied from outside of Monitor",
+			descr->d_member->name,
+			descr->d_type->tp_name);
+		return -1;
+	}
 	return PyMember_SetOne((char *)obj, descr->d_member, value);
 }
 
 static int
 getset_set(PyGetSetDescrObject *descr, PyObject *obj, PyObject *value)
 {
-	int res;
-
-	if (descr_setcheck((PyDescrObject *)descr, obj, value, &res))
-		return res;
+	if (descr_setcheck((PyDescrObject *)descr, obj))
+		return -1;
 	if (descr->d_getset->set != NULL)
 		return descr->d_getset->set(obj, value,
 					    descr->d_getset->closure);
@@ -208,6 +265,50 @@
 	return -1;
 }
 
+static int
+finalizeattr_set(PyFinalizeAttrDescrObject *descr, PyObject *obj, PyObject *value)
+{
+    PyObject *core;
+
+    if (descr_setcheck((PyDescrObject *)descr, obj))
+        return -1;
+
+    core = PyObject_GetAttrString(obj, "__finalizecore__");
+    if (core == NULL && PyErr_ExceptionMatches(PyExc_AttributeError)) {
+        PyErr_Clear();
+        Py_INCREF(Py_None);
+        core = Py_None;
+    }
+
+    if (core == NULL)
+        return -1;
+
+    if (core == Py_None) {
+        int res;
+        PyObject *dict;
+
+        Py_DECREF(core);
+
+        dict = PyObject_GetAttrString(obj, "__dict__");
+        if (dict == NULL)
+            return -1;
+
+        if (value == NULL)
+            res = PyDict_DelItem(dict, descr->d_name);
+        else
+            res = PyDict_SetItem(dict, descr->d_name, value);
+        Py_DECREF(dict);
+        return res;
+    } else {
+        if (PyObject_SetAttr(core, descr->d_name, value) == -1) {
+            Py_DECREF(core);
+            return -1;
+        }
+        Py_DECREF(core);
+        return 0;
+    }
+}
+
 static PyObject *
 methoddescr_call(PyMethodDescrObject *descr, PyObject *args, PyObject *kwds)
 {
@@ -375,6 +476,17 @@
 	{0}
 };
 
+static PyObject *
+finalizeattr_get_doc(PyFinalizeAttrDescrObject *descr, void *closure)
+{
+    return PyUnicode_FromString("Finalize Attribute proxy");
+}
+
+static PyGetSetDef finalizeattr_getset[] = {
+    {"__doc__", (getter)finalizeattr_get_doc},
+    {0}
+};
+
 static int
 descr_traverse(PyObject *self, visitproc visit, void *arg)
 {
@@ -383,6 +495,13 @@
 	return 0;
 }
 
+static int
+descr_isshareable(PyObject *self)
+{
+	/* XXX FIXME Pure hack */
+	return 1;
+}
+
 PyTypeObject PyMethodDescr_Type = {
 	PyVarObject_HEAD_INIT(&PyType_Type, 0)
 	"method_descriptor",
@@ -403,7 +522,7 @@
 	PyObject_GenericGetAttr,		/* tp_getattro */
 	0,					/* tp_setattro */
 	0,					/* tp_as_buffer */
-	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC, /* tp_flags */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_SKIPWIPE, /* tp_flags */
 	0,					/* tp_doc */
 	descr_traverse,				/* tp_traverse */
 	0,					/* tp_clear */
@@ -441,7 +560,7 @@
 	PyObject_GenericGetAttr,		/* tp_getattro */
 	0,					/* tp_setattro */
 	0,					/* tp_as_buffer */
-	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC, /* tp_flags */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_SKIPWIPE, /* tp_flags */
 	0,					/* tp_doc */
 	descr_traverse,				/* tp_traverse */
 	0,					/* tp_clear */
@@ -478,7 +597,7 @@
 	PyObject_GenericGetAttr,		/* tp_getattro */
 	0,					/* tp_setattro */
 	0,					/* tp_as_buffer */
-	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC, /* tp_flags */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_SKIPWIPE, /* tp_flags */
 	0,					/* tp_doc */
 	descr_traverse,				/* tp_traverse */
 	0,					/* tp_clear */
@@ -493,6 +612,16 @@
 	0,					/* tp_dict */
 	(descrgetfunc)member_get,		/* tp_descr_get */
 	(descrsetfunc)member_set,		/* tp_descr_set */
+	0,					/* tp_dictoffset */
+	0,					/* tp_init */
+	0,					/* tp_new */
+	0,					/* tp_is_gc */
+	0,					/* tp_bases */
+	0,					/* tp_mro */
+	0,					/* tp_cache */
+	0,					/* tp_subclasses */
+	0,					/* tp_weaklist */
+	descr_isshareable,			/* tp_isshareable */
 };
 
 PyTypeObject PyGetSetDescr_Type = {
@@ -515,7 +644,7 @@
 	PyObject_GenericGetAttr,		/* tp_getattro */
 	0,					/* tp_setattro */
 	0,					/* tp_as_buffer */
-	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC, /* tp_flags */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_SKIPWIPE, /* tp_flags */
 	0,					/* tp_doc */
 	descr_traverse,				/* tp_traverse */
 	0,					/* tp_clear */
@@ -530,6 +659,16 @@
 	0,					/* tp_dict */
 	(descrgetfunc)getset_get,		/* tp_descr_get */
 	(descrsetfunc)getset_set,		/* tp_descr_set */
+	0,					/* tp_dictoffset */
+	0,					/* tp_init */
+	0,					/* tp_new */
+	0,					/* tp_is_gc */
+	0,					/* tp_bases */
+	0,					/* tp_mro */
+	0,					/* tp_cache */
+	0,					/* tp_subclasses */
+	0,					/* tp_weaklist */
+	descr_isshareable,			/* tp_isshareable */
 };
 
 PyTypeObject PyWrapperDescr_Type = {
@@ -552,7 +691,7 @@
 	PyObject_GenericGetAttr,		/* tp_getattro */
 	0,					/* tp_setattro */
 	0,					/* tp_as_buffer */
-	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC, /* tp_flags */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_SKIPWIPE, /* tp_flags */
 	0,					/* tp_doc */
 	descr_traverse,				/* tp_traverse */
 	0,					/* tp_clear */
@@ -567,6 +706,63 @@
 	0,					/* tp_dict */
 	(descrgetfunc)wrapperdescr_get,		/* tp_descr_get */
 	0,					/* tp_descr_set */
+	0,					/* tp_dictoffset */
+	0,					/* tp_init */
+	0,					/* tp_new */
+	0,					/* tp_is_gc */
+	0,					/* tp_bases */
+	0,					/* tp_mro */
+	0,					/* tp_cache */
+	0,					/* tp_subclasses */
+	0,					/* tp_weaklist */
+	descr_isshareable,			/* tp_isshareable */
+};
+
+PyTypeObject PyFinalizeAttrDescr_Type = {
+	PyVarObject_HEAD_INIT(&PyType_Type, 0)
+	"finalizeattr_descriptor",
+	sizeof(PyFinalizeAttrDescrObject),
+	0,
+	(destructor)descr_dealloc,		/* tp_dealloc */
+	0,					/* tp_print */
+	0,					/* tp_getattr */
+	0,					/* tp_setattr */
+	0,					/* tp_compare */
+	(reprfunc)finalizeattr_repr,		/* tp_repr */
+	0,					/* tp_as_number */
+	0,					/* tp_as_sequence */
+	0,					/* tp_as_mapping */
+	0,					/* tp_hash */
+	0,					/* tp_call */
+	0,					/* tp_str */
+	PyObject_GenericGetAttr,		/* tp_getattro */
+	0,					/* tp_setattro */
+	0,					/* tp_as_buffer */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_SKIPWIPE, /* tp_flags */
+	0,					/* tp_doc */
+	descr_traverse,				/* tp_traverse */
+	0,					/* tp_clear */
+	0,					/* tp_richcompare */
+	0,					/* tp_weaklistoffset */
+	0,					/* tp_iter */
+	0,					/* tp_iternext */
+	0,					/* tp_methods */
+	descr_members,				/* tp_members */
+	finalizeattr_getset,			/* tp_getset */
+	0,					/* tp_base */
+	0,					/* tp_dict */
+	(descrgetfunc)finalizeattr_get,		/* tp_descr_get */
+	(descrsetfunc)finalizeattr_set,		/* tp_descr_set */
+	0,					/* tp_dictoffset */
+	0,					/* tp_init */
+	0,					/* tp_new */
+	0,					/* tp_is_gc */
+	0,					/* tp_bases */
+	0,					/* tp_mro */
+	0,					/* tp_cache */
+	0,					/* tp_subclasses */
+	0,					/* tp_weaklist */
+	descr_isshareable,			/* tp_isshareable */
 };
 
 static PyDescrObject *
@@ -574,7 +770,7 @@
 {
 	PyDescrObject *descr;
 
-	descr = (PyDescrObject *)PyType_GenericAlloc(descrtype, 0);
+	descr = PyObject_New(descrtype);
 	if (descr != NULL) {
 		Py_XINCREF(type);
 		descr->d_type = type;
@@ -594,8 +790,10 @@
 
 	descr = (PyMethodDescrObject *)descr_new(&PyMethodDescr_Type,
 						 type, method->ml_name);
-	if (descr != NULL)
-		descr->d_method = method;
+	if (descr == NULL)
+		return NULL;
+	descr->d_method = method;
+	PyObject_Complete(descr);
 	return (PyObject *)descr;
 }
 
@@ -606,8 +804,10 @@
 
 	descr = (PyMethodDescrObject *)descr_new(&PyClassMethodDescr_Type,
 						 type, method->ml_name);
-	if (descr != NULL)
-		descr->d_method = method;
+	if (descr == NULL)
+		return NULL;
+	descr->d_method = method;
+	PyObject_Complete(descr);
 	return (PyObject *)descr;
 }
 
@@ -618,8 +818,10 @@
 
 	descr = (PyMemberDescrObject *)descr_new(&PyMemberDescr_Type,
 						 type, member->name);
-	if (descr != NULL)
-		descr->d_member = member;
+	if (descr == NULL)
+		return NULL;
+	descr->d_member = member;
+	PyObject_Complete(descr);
 	return (PyObject *)descr;
 }
 
@@ -630,8 +832,10 @@
 
 	descr = (PyGetSetDescrObject *)descr_new(&PyGetSetDescr_Type,
 						 type, getset->name);
-	if (descr != NULL)
-		descr->d_getset = getset;
+	if (descr == NULL)
+		return NULL;
+	descr->d_getset = getset;
+	PyObject_Complete(descr);
 	return (PyObject *)descr;
 }
 
@@ -642,13 +846,27 @@
 
 	descr = (PyWrapperDescrObject *)descr_new(&PyWrapperDescr_Type,
 						 type, base->name);
-	if (descr != NULL) {
-		descr->d_base = base;
-		descr->d_wrapped = wrapped;
-	}
+	if (descr == NULL)
+		return NULL;
+	descr->d_base = base;
+	descr->d_wrapped = wrapped;
+	PyObject_Complete(descr);
 	return (PyObject *)descr;
 }
 
+PyObject *
+PyDescr_NewFinalizeAttr(PyTypeObject *type, PyObject *name)
+{
+    PyFinalizeAttrDescrObject *descr;
+
+    descr = (PyFinalizeAttrDescrObject *)descr_new(&PyFinalizeAttrDescr_Type,
+        type, PyUnicode_AsString(name));
+    if (descr == NULL)
+        return NULL;
+    PyObject_Complete(descr);
+    return (PyObject *)descr;
+}
+
 
 /* --- Readonly proxy for dictionaries (actually any mapping) --- */
 
@@ -749,9 +967,8 @@
 static void
 proxy_dealloc(proxyobject *pp)
 {
-	_PyObject_GC_UNTRACK(pp);
 	Py_DECREF(pp->dict);
-	PyObject_GC_Del(pp);
+	PyObject_Del(pp);
 }
 
 static PyObject *
@@ -807,7 +1024,7 @@
 	PyObject_GenericGetAttr,		/* tp_getattro */
 	0,					/* tp_setattro */
 	0,					/* tp_as_buffer */
-	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC, /* tp_flags */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_SKIPWIPE, /* tp_flags */
  	0,					/* tp_doc */
 	proxy_traverse,				/* tp_traverse */
  	0,					/* tp_clear */
@@ -829,11 +1046,11 @@
 {
 	proxyobject *pp;
 
-	pp = PyObject_GC_New(proxyobject, &PyDictProxy_Type);
+	pp = PyObject_New(&PyDictProxy_Type);
 	if (pp != NULL) {
 		Py_INCREF(dict);
 		pp->dict = dict;
-		_PyObject_GC_TRACK(pp);
+		PyObject_Complete(pp);
 	}
 	return (PyObject *)pp;
 }
@@ -853,12 +1070,9 @@
 static void
 wrapper_dealloc(wrapperobject *wp)
 {
-	PyObject_GC_UnTrack(wp);
-	Py_TRASHCAN_SAFE_BEGIN(wp)
 	Py_XDECREF(wp->descr);
 	Py_XDECREF(wp->self);
-	PyObject_GC_Del(wp);
-	Py_TRASHCAN_SAFE_END(wp)
+	PyObject_Del(wp);
 }
 
 static int
@@ -967,6 +1181,14 @@
 	return 0;
 }
 
+static int
+wrapper_isshareable(wrapperobject *wp)
+{
+	/* XXX FIXME I doubt this is sufficiently strict */
+	return PyObject_IsShareable((PyObject *)wp->descr->d_type) &&
+		PyObject_IsShareable(wp->self);
+}
+
 static PyTypeObject wrappertype = {
 	PyVarObject_HEAD_INIT(&PyType_Type, 0)
 	"method-wrapper",			/* tp_name */
@@ -988,7 +1210,7 @@
 	PyObject_GenericGetAttr,		/* tp_getattro */
 	0,					/* tp_setattro */
 	0,					/* tp_as_buffer */
-	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC, /* tp_flags */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_SKIPWIPE, /* tp_flags */
  	0,					/* tp_doc */
 	wrapper_traverse,			/* tp_traverse */
  	0,					/* tp_clear */
@@ -1003,6 +1225,16 @@
 	0,					/* tp_dict */
 	0,					/* tp_descr_get */
 	0,					/* tp_descr_set */
+	0,					/* tp_dictoffset */
+	0,					/* tp_init */
+	0,					/* tp_new */
+	0,					/* tp_is_gc */
+	0,					/* tp_bases */
+	0,					/* tp_mro */
+	0,					/* tp_cache */
+	0,					/* tp_subclasses */
+	0,					/* tp_weaklist */
+	(isshareablefunc)wrapper_isshareable,	/* tp_isshareable */
 };
 
 PyObject *
@@ -1015,13 +1247,13 @@
 	descr = (PyWrapperDescrObject *)d;
 	assert(PyObject_IsInstance(self, (PyObject *)(descr->d_type)));
 
-	wp = PyObject_GC_New(wrapperobject, &wrappertype);
+	wp = PyObject_New(&wrappertype);
 	if (wp != NULL) {
 		Py_INCREF(descr);
 		wp->descr = descr;
 		Py_INCREF(self);
 		wp->self = self;
-		_PyObject_GC_TRACK(wp);
+		PyObject_Complete(wp);
 	}
 	return (PyObject *)wp;
 }
@@ -1123,12 +1355,11 @@
 {
 	propertyobject *gs = (propertyobject *)self;
 
-	_PyObject_GC_UNTRACK(self);
 	Py_XDECREF(gs->prop_get);
 	Py_XDECREF(gs->prop_set);
 	Py_XDECREF(gs->prop_del);
 	Py_XDECREF(gs->prop_doc);
-	self->ob_type->tp_free(self);
+	PyObject_Del(self);
 }
 
 static PyObject *
@@ -1321,7 +1552,7 @@
 	0,					/* tp_setattro */
 	0,					/* tp_as_buffer */
 	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
-		Py_TPFLAGS_BASETYPE,		/* tp_flags */
+		Py_TPFLAGS_BASETYPE | Py_TPFLAGS_SHAREABLE,	/* tp_flags */
  	property_doc,				/* tp_doc */
 	property_traverse,			/* tp_traverse */
  	0,					/* tp_clear */
@@ -1338,7 +1569,5 @@
 	property_descr_set,			/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	property_init,				/* tp_init */
-	PyType_GenericAlloc,			/* tp_alloc */
 	PyType_GenericNew,			/* tp_new */
-	PyObject_GC_Del,               		/* tp_free */
 };

=== modified file 'Objects/dictobject.c'
--- Objects/dictobject.c	2008-02-25 12:39:23 +0000
+++ Objects/dictobject.c	2008-03-24 04:28:03 +0000
@@ -8,6 +8,8 @@
 */
 
 #include "Python.h"
+#include "pystate.h"
+#include "pythread.h"
 #include "stringlib/eq.h"
 
 
@@ -25,6 +27,138 @@
 	Py_DECREF(tup);
 }
 
+static inline int
+block_unshareable_keyvalue(PyObject *mp, PyObject *key, PyObject *value)
+{
+	if (PySharedDict_Check(mp) && !PyObject_IsShareable(key)) {
+		PyErr_Format(PyExc_TypeError,
+			"%.200s key must be shareable, "
+			"'%s' object is not",
+			mp->ob_type->tp_name, key->ob_type->tp_name);
+		return 1;
+	}
+	if (PySharedDict_Check(mp) && !PyObject_IsShareable(value)) {
+		PyErr_Format(PyExc_TypeError,
+			"%.200s value must be shareable, "
+			"'%s' object is not",
+			mp->ob_type->tp_name, value->ob_type->tp_name);
+		return 1;
+	}
+	return 0;
+}
+
+void
+_pydictlock_initstate_read(PyDict_LockState *lockstate)
+{
+    lockstate->doing_write = 0;
+    lockstate->skipped_lock = 0;
+}
+
+void
+_pydictlock_initstate_write(PyDict_LockState *lockstate)
+{
+    lockstate->doing_write = 1;
+    lockstate->skipped_lock = 0;
+}
+
+void
+_pydictlock_initstate_notshared(PyDict_LockState *lockstate)
+{
+    lockstate->doing_write = -1;
+    lockstate->skipped_lock = -1;
+}
+
+void
+_pydictlock_acquire(PyDictObject *mp, PyDict_LockState *lockstate)
+{
+    /* XXX FIXME this should allow a NULL lockstate if mp isn't a shareddict */
+    assert(lockstate);
+
+    if (PySharedDict_Check(mp)) {
+        PySharedDictObject *sd = (PySharedDictObject *)mp;
+        assert(lockstate->doing_write == 0 || lockstate->doing_write == 1);
+        assert(lockstate->skipped_lock == 0 || lockstate->skipped_lock == 1);
+
+        if (lockstate->doing_write) {
+            assert(!lockstate->skipped_lock);
+            if (PyState_Get()->critical_section != NULL)
+                Py_FatalError("shareddict cannot be modified while in "
+                    "a critical section");
+            PyCritical_Enter(sd->crit);
+
+            /* If the shareddict has entered readonly mode we use this
+             * expensive fallback to reset it.  This *should* be fairly
+             * rare. */
+            while (AO_load_acquire(&sd->readonly_mode)) {
+                //fprintf(stderr, "%p Restoring read-write mode with %d %p\n",
+                //    sd, sd->read_count, PyState_Get());
+                PyCritical_Exit(sd->crit);
+                PyState_StopTheWorld();
+                AO_store_full(&sd->readonly_mode, 0);
+                sd->read_count = 0;
+                PyState_StartTheWorld();
+                PyCritical_Enter(sd->crit);
+            }
+
+            sd->read_count = 0;
+        } else {
+            /* XXX FIXME this should use a stack-allocated critical
+             * section if not using a real one */
+            if (AO_load_acquire(&sd->readonly_mode))
+                lockstate->skipped_lock = 1;
+            else {
+                PyCritical_Enter(sd->crit);
+                if (AO_load_acquire(&sd->readonly_mode)) {
+                    lockstate->skipped_lock = 1;
+                    PyCritical_Exit(sd->crit);
+                } else {
+                    sd->read_count++;
+                    //fprintf(stderr, "%p Read count %d\n", sd, sd->read_count);
+                    //sd->read_count = 1;  /* XXX FIXME currently disabled */
+                    if (sd->read_count >= 1000) {
+                        /* Enter read-only mode */
+                        //fprintf(stderr, "%p Entering read-only mode with %d\n",
+                        //    sd, sd->read_count);
+                        AO_store_full(&sd->readonly_mode, 1);
+                        PyCritical_Exit(sd->crit);
+                        lockstate->skipped_lock = 1;
+                    } else
+                        lockstate->skipped_lock = 0;
+                }
+            }
+        }
+    }
+
+    /* It is an invariant that acquire/release are not called while the
+     * dict would need to be resized. */
+    assert(!(mp->ma_fill*3 >= (mp->ma_mask+1)*2));
+}
+
+void
+_pydictlock_release(PyDictObject *mp, PyDict_LockState *lockstate)
+{
+    assert(lockstate);
+
+    /* It is an invariant that acquire/release are not called while the
+     * dict would need to be resized. */
+    assert(!(mp->ma_fill*3 >= (mp->ma_mask+1)*2));
+
+    if (PySharedDict_Check(mp)) {
+        PySharedDictObject *sd = (PySharedDictObject *)mp;
+        assert(lockstate->doing_write == 0 || lockstate->doing_write == 1);
+        assert(lockstate->skipped_lock == 0 || lockstate->skipped_lock == 1);
+
+        if (lockstate->doing_write) {
+            assert(!lockstate->skipped_lock);
+            PyCritical_Exit(sd->crit);
+        } else {
+            /* XXX FIXME exit stack-allocated critical */
+            if (!lockstate->skipped_lock)
+                PyCritical_Exit(sd->crit);
+        }
+    }
+}
+
 /* Define this out if you don't want conversion statistics on exit. */
 #undef SHOW_CONVERSION_COUNTS
 
@@ -148,7 +282,8 @@
 
 /* forward declarations */
 static PyDictEntry *
-lookdict_unicode(PyDictObject *mp, PyObject *key, long hash);
+lookdict_unicode(PyDictObject *mp, PyObject *key, long hash,
+    PyDict_LockState *lockstate);
 
 #ifdef SHOW_CONVERSION_COUNTS
 static long created = 0L;
@@ -198,26 +333,50 @@
 #define EMPTY_TO_MINSIZE(mp) do {					\
 	memset((mp)->ma_smalltable, 0, sizeof((mp)->ma_smalltable));	\
 	(mp)->ma_used = (mp)->ma_fill = 0;				\
+	(mp)->ma_rebuilds = 0;						\
 	INIT_NONZERO_DICT_SLOTS(mp);					\
     } while(0)
 
+//#define USE_DICT_FREELIST
+
+#ifdef USE_DICT_FREELIST
 /* Dictionary reuse scheme to save calls to malloc, free, and memset */
 #ifndef PyDict_MAXFREELIST
 #define PyDict_MAXFREELIST 80
 #endif
 static PyDictObject *free_list[PyDict_MAXFREELIST];
 static int numfree = 0;
+/* This lock is only used while the GIL is already held */
+static PyThread_type_lock *free_dicts_lock;
+#endif
+
+/* Even type and object's initialization calls us, so we need a bare
+ * minimum of functionality to be ready even before them. */
+void
+_PyDict_PreInit(void)
+{
+#ifdef USE_DICT_FREELIST
+	free_dicts_lock = PyThread_lock_allocate();
+	if (!free_dicts_lock)
+		Py_FatalError("unable to allocate lock");
+#endif
+}
 
 void
 PyDict_Fini(void)
 {
+#ifdef USE_DICT_FREELIST
 	PyDictObject *op;
 
+	PyThread_lock_free(free_dicts_lock);
+	free_dicts_lock = NULL;
+
 	while (numfree) {
 		op = free_list[--numfree];
 		assert(PyDict_CheckExact(op));
-		PyObject_GC_Del(op);
+		PyObject_Del(op);
 	}
+#endif
 }
 
 PyObject *
@@ -235,8 +394,11 @@
 		Py_AtExit(show_alloc);
 #endif
 	}
+#ifdef USE_DICT_FREELIST
+	PyThread_lock_acquire(free_dicts_lock);
 	if (numfree) {
 		mp = free_list[--numfree];
+		PyThread_lock_release(free_dicts_lock);
 		assert (mp != NULL);
 		assert (Py_TYPE(mp) == &PyDict_Type);
 		_Py_NewReference((PyObject *)mp);
@@ -250,19 +412,22 @@
 		count_reuse++;
 #endif
 	} else {
-		mp = PyObject_GC_New(PyDictObject, &PyDict_Type);
+		PyThread_lock_release(free_dicts_lock);
+#endif
+		mp = PyObject_New(&PyDict_Type);
 		if (mp == NULL)
 			return NULL;
 		EMPTY_TO_MINSIZE(mp);
+#ifdef USE_DICT_FREELIST
 #ifdef SHOW_ALLOC_COUNT
 		count_alloc++;
 #endif
 	}
+#endif
 	mp->ma_lookup = lookdict_unicode;
 #ifdef SHOW_CONVERSION_COUNTS
 	++created;
 #endif
-	_PyObject_GC_TRACK(mp);
 	return (PyObject *)mp;
 }
 
@@ -291,17 +456,23 @@
 PyDictEntry*.
 */
 static PyDictEntry *
-lookdict(PyDictObject *mp, PyObject *key, register long hash)
+lookdict(PyDictObject *mp, PyObject *key, register long hash,
+		PyDict_LockState *lockstate)
 {
 	register size_t i;
 	register size_t perturb;
 	register PyDictEntry *freeslot;
-	register size_t mask = (size_t)mp->ma_mask;
+	register size_t mask;
 	PyDictEntry *ep0 = mp->ma_table;
 	register PyDictEntry *ep;
 	register int cmp;
 	PyObject *startkey;
+	unsigned long long rebuilds;
 
+start:
+	mask = (size_t)mp->ma_mask;
+	ep0 = mp->ma_table;
+	rebuilds = mp->ma_rebuilds;
 	i = (size_t)hash & mask;
 	ep = &ep0[i];
 	if (ep->me_key == NULL || ep->me_key == key)
@@ -313,22 +484,32 @@
 		if (ep->me_hash == hash) {
 			startkey = ep->me_key;
 			Py_INCREF(startkey);
+			_pydictlock_release(mp, lockstate);
 			cmp = PyObject_RichCompareBool(startkey, key, Py_EQ);
-			Py_DECREF(startkey);
-			if (cmp < 0)
+			_pydictlock_acquire(mp, lockstate);
+			if (cmp < 0) {
+				_pydictlock_release(mp, lockstate);
+				Py_DECREF(startkey);
+				_pydictlock_acquire(mp, lockstate);
 				return NULL;
-			if (ep0 == mp->ma_table && ep->me_key == startkey) {
-				if (cmp > 0)
-					return ep;
 			}
-			else {
+			/* XXX use branch hinting? */
+			if (rebuilds != mp->ma_rebuilds || ep->me_key != startkey) {
 				/* The compare did major nasty stuff to the
 				 * dict:  start over.
 				 * XXX A clever adversary could prevent this
 				 * XXX from terminating.
- 				 */
- 				return lookdict(mp, key, hash);
- 			}
+				 */
+				_pydictlock_release(mp, lockstate);
+				Py_DECREF(startkey);
+				_pydictlock_acquire(mp, lockstate);
+				goto start;
+			}
+			assert(ep0 == mp->ma_table);
+			assert(mask == (size_t)mp->ma_mask);
+			Py_DECREF(startkey);
+			if (cmp > 0)
+				return ep;
 		}
 		freeslot = NULL;
 	}
@@ -345,22 +526,32 @@
 		if (ep->me_hash == hash && ep->me_key != dummy) {
 			startkey = ep->me_key;
 			Py_INCREF(startkey);
+			_pydictlock_release(mp, lockstate);
 			cmp = PyObject_RichCompareBool(startkey, key, Py_EQ);
-			Py_DECREF(startkey);
-			if (cmp < 0)
+			_pydictlock_acquire(mp, lockstate);
+			if (cmp < 0) {
+				_pydictlock_release(mp, lockstate);
+				Py_DECREF(startkey);
+				_pydictlock_acquire(mp, lockstate);
 				return NULL;
-			if (ep0 == mp->ma_table && ep->me_key == startkey) {
-				if (cmp > 0)
-					return ep;
 			}
-			else {
+			/* XXX use branch hinting? */
+			if (rebuilds != mp->ma_rebuilds || ep->me_key != startkey) {
 				/* The compare did major nasty stuff to the
 				 * dict:  start over.
 				 * XXX A clever adversary could prevent this
 				 * XXX from terminating.
  				 */
- 				return lookdict(mp, key, hash);
- 			}
+				_pydictlock_release(mp, lockstate);
+				Py_DECREF(startkey);
+				_pydictlock_acquire(mp, lockstate);
+				goto start;
+			}
+			Py_DECREF(startkey);
+			assert(ep0 == mp->ma_table);
+			assert(mask == (size_t)mp->ma_mask);
+			if (cmp > 0)
+				return ep;
 		}
 		else if (ep->me_key == dummy && freeslot == NULL)
 			freeslot = ep;
@@ -380,7 +571,8 @@
  * This is valuable because dicts with only unicode keys are very common.
  */
 static PyDictEntry *
-lookdict_unicode(PyDictObject *mp, PyObject *key, register long hash)
+lookdict_unicode(PyDictObject *mp, PyObject *key, register long hash,
+		PyDict_LockState *lockstate)
 {
 	register size_t i;
 	register size_t perturb;
@@ -389,6 +581,8 @@
 	PyDictEntry *ep0 = mp->ma_table;
 	register PyDictEntry *ep;
 
+	assert(lockstate);
+
 	/* Make sure this function doesn't have to handle non-unicode keys,
 	   including subclasses of str; e.g., one reason to subclass
 	   unicodes is to override __eq__, and for speed we don't cater to
@@ -398,7 +592,7 @@
 		++converted;
 #endif
 		mp->ma_lookup = lookdict;
-		return lookdict(mp, key, hash);
+		return lookdict(mp, key, hash, lockstate);
 	}
 	i = hash & mask;
 	ep = &ep0[i];
@@ -438,26 +632,31 @@
 Returns -1 if an error occurred, or 0 on success.
 */
 static int
-insertdict(register PyDictObject *mp, PyObject *key, long hash, PyObject *value)
+insertdict(register PyDictObject *mp, PyObject *key, long hash,
+		PyObject *value, PyDict_LockState *lockstate)
 {
 	PyObject *old_value;
 	register PyDictEntry *ep;
 	typedef PyDictEntry *(*lookupfunc)(PyDictObject *, PyObject *, long);
 
 	assert(mp->ma_lookup != NULL);
-	ep = mp->ma_lookup(mp, key, hash);
+	ep = mp->ma_lookup(mp, key, hash, lockstate);
 	if (ep == NULL) {
+		_pydictlock_release(mp, lockstate);
 		Py_DECREF(key);
 		Py_DECREF(value);
+		_pydictlock_acquire(mp, lockstate);
 		return -1;
 	}
+
 	if (ep->me_value != NULL) {
 		old_value = ep->me_value;
 		ep->me_value = value;
+		_pydictlock_release(mp, lockstate);
 		Py_DECREF(old_value); /* which **CAN** re-enter */
 		Py_DECREF(key);
-	}
-	else {
+		_pydictlock_acquire(mp, lockstate);
+	} else {
 		if (ep->me_key == NULL)
 			mp->ma_fill++;
 		else {
@@ -570,6 +769,7 @@
 	mp->ma_used = 0;
 	i = mp->ma_fill;
 	mp->ma_fill = 0;
+	mp->ma_rebuilds++;
 
 	/* Copy the data over; this is refcount-neutral for active entries;
 	   dummy entries aren't copied over, of course */
@@ -622,10 +822,12 @@
 PyObject *
 PyDict_GetItem(PyObject *op, PyObject *key)
 {
+	PyState *pystate = PyState_Get();
 	long hash;
 	PyDictObject *mp = (PyDictObject *)op;
 	PyDictEntry *ep;
-	PyThreadState *tstate;
+	PyDict_LockState lockstate;
+
 	if (!PyDict_Check(op))
 		return NULL;
 	if (!PyUnicode_CheckExact(key) ||
@@ -638,22 +840,24 @@
 		}
 	}
 
-	/* We can arrive here with a NULL tstate during initialization:
+	_pydictlock_initstate_notshared(&lockstate);
+
+	/* We can arrive here with a NULL pystate during initialization:
 	   try running "python -Wi" for an example related to string
 	   interning.  Let's just hope that no exception occurs then... */
-	tstate = _PyThreadState_Current;
-	if (tstate != NULL && tstate->curexc_type != NULL) {
+	/* XXX It's now impossible to have a NULL pystate */
+	if (pystate != NULL && pystate->curexc_type != NULL) {
 		/* preserve the existing exception */
 		PyObject *err_type, *err_value, *err_tb;
 		PyErr_Fetch(&err_type, &err_value, &err_tb);
-		ep = (mp->ma_lookup)(mp, key, hash);
+		ep = (mp->ma_lookup)(mp, key, hash, &lockstate);
 		/* ignore errors */
 		PyErr_Restore(err_type, err_value, err_tb);
 		if (ep == NULL)
 			return NULL;
 	}
 	else {
-		ep = (mp->ma_lookup)(mp, key, hash);
+		ep = (mp->ma_lookup)(mp, key, hash, &lockstate);
 		if (ep == NULL) {
 			PyErr_Clear();
 			return NULL;
@@ -672,6 +876,7 @@
 	long hash;
         PyDictObject*mp = (PyDictObject *)op;
 	PyDictEntry *ep;
+	PyDict_LockState lockstate;
 
 	if (!PyDict_Check(op)) {
 		PyErr_BadInternalCall();
@@ -686,12 +891,60 @@
 		}
 	}
 
-	ep = (mp->ma_lookup)(mp, key, hash);
+	_pydictlock_initstate_notshared(&lockstate);
+
+	ep = (mp->ma_lookup)(mp, key, hash, &lockstate);
 	if (ep == NULL)
 		return NULL;
 	return ep->me_value;
 }
 
+/* Yet another variant of PyDict_GetItem().  Return values:
+ * -1 Error, exception set (value set to NULL)
+ *  0 Success (value filled in with *NEW* reference)
+ * +1 Not found, no exception set (value set to NULL)
+ */
+int
+PyDict_GetItemEx(PyObject *op, PyObject *key, PyObject **value)
+{
+    long hash;
+    PyDictObject *mp = (PyDictObject *)op;
+    PyDictEntry *ep;
+    PyDict_LockState lockstate;
+
+    *value = NULL;
+
+    if (!PyDict_Check(op)) {
+        PyErr_BadInternalCall();
+        return -1;
+    }
+    if (!PyUnicode_CheckExact(key) ||
+            (hash = ((PyUnicodeObject *) key)->hash) == -1) {
+        hash = PyObject_Hash(key);
+        if (hash == -1) {
+            return -1;
+        }
+    }
+
+    _pydictlock_initstate_read(&lockstate);
+
+    _pydictlock_acquire(mp, &lockstate);
+    ep = (mp->ma_lookup)(mp, key, hash, &lockstate);
+    if (ep == NULL) {
+        _pydictlock_release(mp, &lockstate);
+        return -1;
+    }
+
+    *value = ep->me_value;
+    Py_XINCREF(*value);
+    _pydictlock_release(mp, &lockstate);
+
+    if (*value)
+        return 0;
+    else
+        return 1;
+}
+
 /* CAUTION: PyDict_SetItem() must guarantee that it won't resize the
  * dictionary if it's merely replacing the value for an existing key.
  * This means that it's safe to loop over a dictionary with PyDict_Next()
@@ -701,9 +954,12 @@
 int
 PyDict_SetItem(register PyObject *op, PyObject *key, PyObject *value)
 {
+	PyState *pystate = PyState_Get();
 	register PyDictObject *mp;
 	register long hash;
 	register Py_ssize_t n_used;
+	PyDict_LockState lockstate;
+	int result;
 
 	if (!PyDict_Check(op)) {
 		PyErr_BadInternalCall();
@@ -712,19 +968,26 @@
 	assert(key);
 	assert(value);
 	mp = (PyDictObject *)op;
+	if (block_unshareable_keyvalue(op, key, value))
+		return -1;
 	if (!PyUnicode_CheckExact(key) ||
-	    (hash = ((PyUnicodeObject *) key)->hash) == -1)
-	{
+			(hash = ((PyUnicodeObject *) key)->hash) == -1) {
 		hash = PyObject_Hash(key);
 		if (hash == -1)
 			return -1;
 	}
+	_pydictlock_initstate_write(&lockstate);
+
+	_pydictlock_acquire(mp, &lockstate);
 	assert(mp->ma_fill <= mp->ma_mask);  /* at least one empty slot */
 	n_used = mp->ma_used;
-	Py_INCREF(value);
-	Py_INCREF(key);
-	if (insertdict(mp, key, hash, value) != 0)
+	Py_INCREF_PS(value);
+	Py_INCREF_PS(key);
+	if (insertdict(mp, key, hash, value, &lockstate) != 0) {
+		_pydictlock_release(mp, &lockstate);
 		return -1;
+	}
+
 	/* If we added a key, we can safely resize.  Otherwise just return!
 	 * If fill >= 2/3 size, adjust size.  Normally, this doubles or
 	 * quaduples the size, but it's also possible for the dict to shrink
@@ -739,9 +1002,13 @@
 	 * Very large dictionaries (over 50K items) use doubling instead.
 	 * This may help applications with severe memory constraints.
 	 */
-	if (!(mp->ma_used > n_used && mp->ma_fill*3 >= (mp->ma_mask+1)*2))
+	if (!(mp->ma_used > n_used && mp->ma_fill*3 >= (mp->ma_mask+1)*2)) {
+		_pydictlock_release(mp, &lockstate);
 		return 0;
-	return dictresize(mp, (mp->ma_used > 50000 ? 2 : 4) * mp->ma_used);
+	}
+	result = dictresize(mp, (mp->ma_used > 50000 ? 2 : 4) * mp->ma_used);
+	_pydictlock_release(mp, &lockstate);
+	return result;
 }
 
 int
@@ -751,6 +1018,7 @@
 	register long hash;
 	register PyDictEntry *ep;
 	PyObject *old_value, *old_key;
+	PyDict_LockState lockstate;
 
 	if (!PyDict_Check(op)) {
 		PyErr_BadInternalCall();
@@ -764,10 +1032,16 @@
 			return -1;
 	}
 	mp = (PyDictObject *)op;
-	ep = (mp->ma_lookup)(mp, key, hash);
-	if (ep == NULL)
+	_pydictlock_initstate_write(&lockstate);
+
+	_pydictlock_acquire(mp, &lockstate);
+	ep = (mp->ma_lookup)(mp, key, hash, &lockstate);
+	if (ep == NULL) {
+		_pydictlock_release(mp, &lockstate);
 		return -1;
+	}
 	if (ep->me_value == NULL) {
+		_pydictlock_release(mp, &lockstate);
 		set_key_error(key);
 		return -1;
 	}
@@ -777,6 +1051,7 @@
 	old_value = ep->me_value;
 	ep->me_value = NULL;
 	mp->ma_used--;
+	_pydictlock_release(mp, &lockstate);
 	Py_DECREF(old_value);
 	Py_DECREF(old_key);
 	return 0;
@@ -793,10 +1068,14 @@
 #ifdef Py_DEBUG
 	Py_ssize_t i, n;
 #endif
+	PyDict_LockState lockstate;
 
 	if (!PyDict_Check(op))
 		return;
 	mp = (PyDictObject *)op;
+	_pydictlock_initstate_write(&lockstate);
+
+	_pydictlock_acquire(mp, &lockstate);
 #ifdef Py_DEBUG
 	n = mp->ma_mask + 1;
 	i = 0;
@@ -826,6 +1105,7 @@
 		EMPTY_TO_MINSIZE(mp);
 	}
 	/* else it's a small table that's already empty */
+	_pydictlock_release(mp, &lockstate);
 
 	/* Now we can finally clear things.  If C had refcounts, we could
 	 * assert that the refcount on table is 1 now, i.e. that this function
@@ -872,12 +1152,18 @@
 	register Py_ssize_t i;
 	register Py_ssize_t mask;
 	register PyDictEntry *ep;
+	PyDict_LockState lockstate;
 
 	if (!PyDict_Check(op))
 		return 0;
 	i = *ppos;
 	if (i < 0)
 		return 0;
+
+	_pydictlock_initstate_notshared(&lockstate);
+	_pydictlock_acquire((PyDictObject *)op, &lockstate);
+	_pydictlock_release((PyDictObject *)op, &lockstate);
+
 	ep = ((PyDictObject *)op)->ma_table;
 	mask = ((PyDictObject *)op)->ma_mask;
 	while (i <= mask && ep[i].me_value == NULL)
@@ -899,12 +1185,18 @@
 	register Py_ssize_t i;
 	register Py_ssize_t mask;
 	register PyDictEntry *ep;
+	PyDict_LockState lockstate;
 
 	if (!PyDict_Check(op))
 		return 0;
 	i = *ppos;
 	if (i < 0)
 		return 0;
+
+	_pydictlock_initstate_notshared(&lockstate);
+	_pydictlock_acquire((PyDictObject *)op, &lockstate);
+	_pydictlock_release((PyDictObject *)op, &lockstate);
+
 	ep = ((PyDictObject *)op)->ma_table;
 	mask = ((PyDictObject *)op)->ma_mask;
 	while (i <= mask && ep[i].me_value == NULL)
@@ -920,6 +1212,47 @@
 	return 1;
 }
 
+/* Variant of PyDict_Next that provides *NEW* references to key and value */
+int
+PyDict_NextEx(PyObject *op, Py_ssize_t *ppos, PyObject **pkey, PyObject **pvalue)
+{
+	register Py_ssize_t i;
+	register Py_ssize_t mask;
+	register PyDictEntry *ep;
+	PyDict_LockState lockstate;
+
+	if (!PyDict_Check(op))
+		return 0;
+	i = *ppos;
+	if (i < 0)
+		return 0;
+
+	_pydictlock_initstate_read(&lockstate);
+
+	_pydictlock_acquire((PyDictObject *)op, &lockstate);
+	ep = ((PyDictObject *)op)->ma_table;
+	mask = ((PyDictObject *)op)->ma_mask;
+	while (i <= mask && ep[i].me_value == NULL)
+		i++;
+	*ppos = i+1;
+	if (i > mask) {
+		_pydictlock_release((PyDictObject *)op, &lockstate);
+		return 0;
+	}
+
+	if (pkey) {
+		*pkey = ep[i].me_key;
+		Py_INCREF(*pkey);
+	}
+	if (pvalue) {
+		*pvalue = ep[i].me_value;
+		Py_INCREF(*pvalue);
+	}
+
+	_pydictlock_release((PyDictObject *)op, &lockstate);
+	return 1;
+}
+
 /* Methods */
 
 static void
@@ -927,8 +1260,6 @@
 {
 	register PyDictEntry *ep;
 	Py_ssize_t fill = mp->ma_fill;
- 	PyObject_GC_UnTrack(mp);
-	Py_TRASHCAN_SAFE_BEGIN(mp)
 	for (ep = mp->ma_table; fill > 0; ep++) {
 		if (ep->me_key) {
 			--fill;
@@ -938,11 +1269,25 @@
 	}
 	if (mp->ma_table != mp->ma_smalltable)
 		PyMem_DEL(mp->ma_table);
+#ifdef USE_DICT_FREELIST
+	PyThread_lock_acquire(free_dicts_lock);
 	if (numfree < PyDict_MAXFREELIST && Py_TYPE(mp) == &PyDict_Type)
 		free_list[numfree++] = mp;
-	else
-		Py_TYPE(mp)->tp_free((PyObject *)mp);
-	Py_TRASHCAN_SAFE_END(mp)
+		PyThread_lock_release(free_dicts_lock);
+	} else {
+		PyThread_lock_release(free_dicts_lock);
+#endif
+		PyObject_Del(mp);
+#ifdef USE_DICT_FREELIST
+	}
+#endif
+}
+
+static void
+shareddict_dealloc(PySharedDictObject *mp)
+{
+    PyCritical_Free(mp->crit);
+    dict_dealloc((PyDictObject *)mp);
 }
 
 static PyObject *
@@ -974,13 +1319,12 @@
 	/* Do repr() on each key+value pair, and insert ": " between them.
 	   Note that repr may mutate the dict. */
 	i = 0;
-	while (PyDict_Next((PyObject *)mp, &i, &key, &value)) {
+	while (PyDict_NextEx((PyObject *)mp, &i, &key, &value)) {
 		int status;
-		/* Prevent repr from deleting value during key format. */
-		Py_INCREF(value);
 		s = PyObject_Repr(key);
 		PyUnicode_Append(&s, colon);
 		PyUnicode_AppendAndDel(&s, PyObject_Repr(value));
+		Py_DECREF(key);
 		Py_DECREF(value);
 		if (s == NULL)
 			goto Done;
@@ -1024,10 +1368,54 @@
 	return result;
 }
 
+static PyObject *
+shareddict_repr(PyDictObject *mp)
+{
+	PyObject *s = NULL, *inner = NULL, *name = NULL, *format = NULL;
+	PyObject *t = NULL;
+
+	format = PyUnicode_FromString("%s(%s)");
+	if (format == NULL)
+		goto Done;
+
+	name = PyObject_GetAttrString((PyObject *)Py_TYPE(mp), "__name__");
+	if (name == NULL)
+		goto Done;
+
+	inner = dict_repr(mp);
+	if (inner == NULL)
+		goto Done;
+
+	t = PyTuple_New(2);
+	if (t == NULL)
+		goto Done;
+	PyTuple_SET_ITEM(t, 0, name);
+	name = NULL;
+	PyTuple_SET_ITEM(t, 1, inner);
+	inner = NULL;
+
+	s = PyUnicode_Format(format, t);
+
+Done:
+	Py_XDECREF(format);
+	Py_XDECREF(name);
+	Py_XDECREF(inner);
+	Py_XDECREF(t);
+	return s;
+}
+
 static Py_ssize_t
 dict_length(PyDictObject *mp)
 {
-	return mp->ma_used;
+    Py_ssize_t len;
+    PyDict_LockState lockstate;
+
+    _pydictlock_initstate_read(&lockstate);
+    _pydictlock_acquire(mp, &lockstate);
+    len = mp->ma_used;
+    _pydictlock_release(mp, &lockstate);
+
+    return len;
 }
 
 static PyObject *
@@ -1036,35 +1424,51 @@
 	PyObject *v;
 	long hash;
 	PyDictEntry *ep;
+	PyDict_LockState lockstate;
+
+	if (!PyUnicode_CheckExact(key) ||
+	    (hash = ((PyUnicodeObject *) key)->hash) == -1) {
+		hash = PyObject_Hash(key);
+		if (hash == -1)
+			return NULL;
+	}
+
+	_pydictlock_initstate_read(&lockstate);
+
+	_pydictlock_acquire(mp, &lockstate);
 	assert(mp->ma_table != NULL);
-	if (!PyUnicode_CheckExact(key) ||
-	    (hash = ((PyUnicodeObject *) key)->hash) == -1) {
-		hash = PyObject_Hash(key);
-		if (hash == -1)
-			return NULL;
+	ep = (mp->ma_lookup)(mp, key, hash, &lockstate);
+	if (ep == NULL) {
+		_pydictlock_release(mp, &lockstate);
+		return NULL;
 	}
-	ep = (mp->ma_lookup)(mp, key, hash);
-	if (ep == NULL)
-		return NULL;
 	v = ep->me_value;
 	if (v == NULL) {
+		_pydictlock_release(mp, &lockstate);
 		if (!PyDict_CheckExact(mp)) {
 			/* Look up __missing__ method if we're a subclass. */
-		    	PyObject *missing;
+			PyObject *missing;
 			static PyObject *missing_str = NULL;
+
 			if (missing_str == NULL)
 				missing_str =
 				  PyUnicode_InternFromString("__missing__");
-			missing = _PyType_Lookup(Py_TYPE(mp), missing_str);
-			if (missing != NULL)
-				return PyObject_CallFunctionObjArgs(missing,
+
+			if (_PyType_LookupEx(Py_TYPE(mp), missing_str, &missing) < 0)
+				return NULL;
+			if (missing != NULL) {
+				v = PyObject_CallFunctionObjArgs(missing,
 					(PyObject *)mp, key, NULL);
+				Py_DECREF(missing);
+				return v;
+			}
 		}
 		set_key_error(key);
 		return NULL;
-	}
-	else
+	} else {
 		Py_INCREF(v);
+		_pydictlock_release(mp, &lockstate);
+	}
 	return v;
 }
 
@@ -1090,19 +1494,29 @@
 	register Py_ssize_t i, j;
 	PyDictEntry *ep;
 	Py_ssize_t mask, n;
+	PyDict_LockState lockstate;
+	unsigned long long rebuilds;
 
   again:
+	_pydictlock_initstate_read(&lockstate);
+
+	_pydictlock_acquire(mp, &lockstate);
 	n = mp->ma_used;
+	rebuilds = mp->ma_rebuilds;
+	_pydictlock_release(mp, &lockstate);
 	v = PyList_New(n);
 	if (v == NULL)
 		return NULL;
-	if (n != mp->ma_used) {
+	_pydictlock_acquire(mp, &lockstate);
+	if (rebuilds != mp->ma_rebuilds) {
+		_pydictlock_release(mp, &lockstate);
 		/* Durnit.  The allocations caused the dict to resize.
 		 * Just start over, this shouldn't normally happen.
 		 */
 		Py_DECREF(v);
 		goto again;
 	}
+	assert(n == mp->ma_used);
 	ep = mp->ma_table;
 	mask = mp->ma_mask;
 	for (i = 0, j = 0; i <= mask; i++) {
@@ -1114,6 +1528,7 @@
 		}
 	}
 	assert(j == n);
+	_pydictlock_release(mp, &lockstate);
 	return v;
 }
 
@@ -1124,19 +1539,29 @@
 	register Py_ssize_t i, j;
 	PyDictEntry *ep;
 	Py_ssize_t mask, n;
+	PyDict_LockState lockstate;
+	unsigned long long rebuilds;
 
   again:
+	_pydictlock_initstate_read(&lockstate);
+
+	_pydictlock_acquire(mp, &lockstate);
 	n = mp->ma_used;
+	rebuilds = mp->ma_rebuilds;
+	_pydictlock_release(mp, &lockstate);
 	v = PyList_New(n);
 	if (v == NULL)
 		return NULL;
-	if (n != mp->ma_used) {
+	_pydictlock_acquire(mp, &lockstate);
+	if (rebuilds != mp->ma_rebuilds) {
+		_pydictlock_release(mp, &lockstate);
 		/* Durnit.  The allocations caused the dict to resize.
 		 * Just start over, this shouldn't normally happen.
 		 */
 		Py_DECREF(v);
 		goto again;
 	}
+	assert(n == mp->ma_used);
 	ep = mp->ma_table;
 	mask = mp->ma_mask;
 	for (i = 0, j = 0; i <= mask; i++) {
@@ -1148,6 +1573,7 @@
 		}
 	}
 	assert(j == n);
+	_pydictlock_release(mp, &lockstate);
 	return v;
 }
 
@@ -1159,13 +1585,20 @@
 	Py_ssize_t mask;
 	PyObject *item, *key, *value;
 	PyDictEntry *ep;
+	PyDict_LockState lockstate;
+	unsigned long long rebuilds;
+
+  again:
+	_pydictlock_initstate_read(&lockstate);
 
 	/* Preallocate the list of tuples, to avoid allocations during
 	 * the loop over the items, which could trigger GC, which
 	 * could resize the dict. :-(
 	 */
-  again:
+	_pydictlock_acquire(mp, &lockstate);
 	n = mp->ma_used;
+	rebuilds = mp->ma_rebuilds;
+	_pydictlock_release(mp, &lockstate);
 	v = PyList_New(n);
 	if (v == NULL)
 		return NULL;
@@ -1177,7 +1610,9 @@
 		}
 		PyList_SET_ITEM(v, i, item);
 	}
-	if (n != mp->ma_used) {
+	_pydictlock_acquire(mp, &lockstate);
+	if (rebuilds != mp->ma_rebuilds) {
+		_pydictlock_release(mp, &lockstate);
 		/* Durnit.  The allocations caused the dict to resize.
 		 * Just start over, this shouldn't normally happen.
 		 */
@@ -1185,6 +1620,7 @@
 		goto again;
 	}
 	/* Nothing we do below makes any function calls. */
+	assert(n == mp->ma_used);
 	ep = mp->ma_table;
 	mask = mp->ma_mask;
 	for (i = 0, j = 0; i <= mask; i++) {
@@ -1199,6 +1635,7 @@
 		}
 	}
 	assert(j == n);
+	_pydictlock_release(mp, &lockstate);
 	return v;
 }
 
@@ -1215,6 +1652,8 @@
 	if (!PyArg_UnpackTuple(args, "fromkeys", 1, 2, &seq, &value))
 		return NULL;
 
+	assert(PyType_Check(cls));
+
 	d = PyObject_CallObject(cls, NULL);
 	if (d == NULL)
 		return NULL;
@@ -1225,6 +1664,9 @@
 		Py_ssize_t pos = 0;
 		PyObject *key;
 		long hash;
+		PyDict_LockState lockstate;
+
+		_pydictlock_initstate_notshared(&lockstate);
 
 		if (dictresize(mp, PySet_GET_SIZE(seq)))
 			return NULL;
@@ -1232,8 +1674,10 @@
 		while (_PyDict_Next(seq, &pos, &key, &oldvalue, &hash)) {
 			Py_INCREF(key);
 			Py_INCREF(value);
-			if (insertdict(mp, key, hash, value))
+			if (insertdict(mp, key, hash, value, &lockstate)) {
+				Py_DECREF(d);
 				return NULL;
+			}
 		}
 		return d;
 	}
@@ -1243,6 +1687,9 @@
 		Py_ssize_t pos = 0;
 		PyObject *key;
 		long hash;
+		PyDict_LockState lockstate;
+
+		_pydictlock_initstate_notshared(&lockstate);
 
 		if (dictresize(mp, PySet_GET_SIZE(seq)))
 			return NULL;
@@ -1250,8 +1697,10 @@
 		while (_PySet_NextEntry(seq, &pos, &key, &hash)) {
 			Py_INCREF(key);
 			Py_INCREF(value);
-			if (insertdict(mp, key, hash, value))
+			if (insertdict(mp, key, hash, value, &lockstate)) {
+				Py_DECREF(d);
 				return NULL;
+			}
 		}
 		return d;
 	}
@@ -1290,7 +1739,8 @@
 }
 
 static int
-dict_update_common(PyObject *self, PyObject *args, PyObject *kwds, char *methname)
+dict_update_common(PyObject *self, PyObject *args, PyObject *kwds,
+		char *methname)
 {
 	PyObject *arg = NULL;
 	int result = 0;
@@ -1324,7 +1774,7 @@
    PyDict_{Update,Merge} update/merge from a mapping object.
 
    PyDict_MergeFromSeq2 updates/merges from any iterable object
-   producing iterable objects of length 2.
+   that produces iterable objects of length 2.
 */
 
 int
@@ -1346,6 +1796,7 @@
 	for (i = 0; ; ++i) {
 		PyObject *key, *value;
 		Py_ssize_t n;
+		int status;
 
 		fast = NULL;
 		item = PyIter_Next(it);
@@ -1377,8 +1828,14 @@
 		/* Update/merge with this (key, value) pair. */
 		key = PySequence_Fast_GET_ITEM(fast, 0);
 		value = PySequence_Fast_GET_ITEM(fast, 1);
-		if (override || PyDict_GetItem(d, key) == NULL) {
-			int status = PyDict_SetItem(d, key, value);
+		if (override) {
+			status = PyDict_SetItem(d, key, value);
+			if (status < 0)
+				goto Fail;
+		} else if ((status = PyDict_Contains(d, key))) {
+			if (status < 0)
+				goto Fail;
+			status = PyDict_SetItem(d, key, value);
 			if (status < 0)
 				goto Fail;
 		}
@@ -1406,10 +1863,6 @@
 int
 PyDict_Merge(PyObject *a, PyObject *b, int override)
 {
-	register PyDictObject *mp, *other;
-	register Py_ssize_t i;
-	PyDictEntry *entry;
-
 	/* We accept for the argument either a concrete dictionary object,
 	 * or an abstract "mapping" object.  For the former, we can do
 	 * things quite efficiently.  For the latter, we only require that
@@ -1419,9 +1872,17 @@
 		PyErr_BadInternalCall();
 		return -1;
 	}
-	mp = (PyDictObject*)a;
-	if (PyDict_Check(b)) {
-		other = (PyDictObject*)b;
+	if (PyDict_CheckExact(b) && !PySharedDict_Check(a)) {
+		register PyDictObject *mp = (PyDictObject *)a;
+		register PyDictObject *other = (PyDictObject *)b;
+		register Py_ssize_t i;
+		PyDictEntry *entry;
+		PyDict_LockState lockstate;
+
+		/* This branch is only used for normal dicts, so no
+		 * locking is necessary */
+		_pydictlock_initstate_notshared(&lockstate);
+
 		if (other == mp || other->ma_used == 0)
 			/* a.update(a) or a.update({}); nothing to do */
 			return 0;
@@ -1444,16 +1905,18 @@
 			if (entry->me_value != NULL &&
 			    (override ||
 			     PyDict_GetItem(a, entry->me_key) == NULL)) {
+				if (block_unshareable_keyvalue(a, entry->me_key,
+						entry->me_value))
+					return -1;
 				Py_INCREF(entry->me_key);
 				Py_INCREF(entry->me_value);
 				if (insertdict(mp, entry->me_key,
 					       (long)entry->me_hash,
-					       entry->me_value) != 0)
+					       entry->me_value, &lockstate) != 0)
 					return -1;
 			}
 		}
-	}
-	else {
+	} else {
 		/* Do it the generic, slower way */
 		PyObject *keys = PyMapping_Keys(b);
 		PyObject *iter;
@@ -1474,7 +1937,11 @@
 			return -1;
 
 		for (key = PyIter_Next(iter); key; key = PyIter_Next(iter)) {
-			if (!override && PyDict_GetItem(a, key) != NULL) {
+			if (!override && (status = PyDict_Contains(a, key))) {
+				if (status < 0) {
+					Py_DECREF(iter);
+					return -1;
+				}
 				Py_DECREF(key);
 				continue;
 			}
@@ -1531,7 +1998,7 @@
 		PyErr_BadInternalCall();
 		return -1;
 	}
-	return ((PyDictObject *)mp)->ma_used;
+	return dict_length((PyDictObject *)mp);
 }
 
 PyObject *
@@ -1569,41 +2036,41 @@
  * Uses only Py_EQ comparison.
  */
 static int
-dict_equal(PyDictObject *a, PyDictObject *b)
+dict_equal(PyObject *a, PyObject *b)
 {
-	Py_ssize_t i;
-
-	if (a->ma_used != b->ma_used)
-		/* can't be equal if # of entries differ */
-		return 0;
-
-	/* Same # of entries -- check all of 'em.  Exit early on any diff. */
-	for (i = 0; i <= a->ma_mask; i++) {
-		PyObject *aval = a->ma_table[i].me_value;
-		if (aval != NULL) {
-			int cmp;
-			PyObject *bval;
-			PyObject *key = a->ma_table[i].me_key;
-			/* temporarily bump aval's refcount to ensure it stays
-			   alive until we're done with it */
-			Py_INCREF(aval);
-			/* ditto for key */
-			Py_INCREF(key);
-			bval = PyDict_GetItemWithError((PyObject *)b, key);
-			Py_DECREF(key);
-			if (bval == NULL) {
-				Py_DECREF(aval);
-				if (PyErr_Occurred())
-					return -1;
-				return 0;
-			}
-			cmp = PyObject_RichCompareBool(aval, bval, Py_EQ);
-			Py_DECREF(aval);
-			if (cmp <= 0)  /* error or not equal */
-				return cmp;
- 		}
-	}
-	return 1;
+    PyObject *key, *value;
+    Py_ssize_t i;
+
+    if (PyDict_Size(a) != PyDict_Size(b))
+        /* can't be equal if # of entries differ */
+        return 0;
+
+    /* Same # of entries -- check all of 'em.  Exit early on any diff. */
+    i = 0;
+    while (PyDict_NextEx(a, &i, &key, &value)) {
+        PyObject *bvalue;
+        int cmp;
+
+        if (PyDict_GetItemEx(b, key, &bvalue) < 0) {
+            Py_DECREF(key);
+            Py_DECREF(value);
+            return -1;
+        }
+        if (bvalue == NULL) {
+            Py_DECREF(key);
+            Py_DECREF(value);
+            return 0;
+        }
+
+        cmp = PyObject_RichCompareBool(value, bvalue, Py_EQ);
+        Py_DECREF(key);
+        Py_DECREF(value);
+        Py_DECREF(bvalue);
+        if (cmp <= 0)  /* error or not equal */
+            return cmp;
+    }
+
+    return 1;
  }
 
 static PyObject *
@@ -1616,7 +2083,7 @@
 		res = Py_NotImplemented;
 	}
 	else if (op == Py_EQ || op == Py_NE) {
-		cmp = dict_equal((PyDictObject *)v, (PyDictObject *)w);
+		cmp = dict_equal(v, w);
 		if (cmp < 0)
 			return NULL;
 		res = (cmp == (op == Py_EQ)) ? Py_True : Py_False;
@@ -1630,47 +2097,37 @@
 static PyObject *
 dict_contains(register PyDictObject *mp, PyObject *key)
 {
-	long hash;
-	PyDictEntry *ep;
-
-	if (!PyUnicode_CheckExact(key) ||
-	    (hash = ((PyUnicodeObject *) key)->hash) == -1) {
-		hash = PyObject_Hash(key);
-		if (hash == -1)
-			return NULL;
-	}
-	ep = (mp->ma_lookup)(mp, key, hash);
-	if (ep == NULL)
-		return NULL;
-	return PyBool_FromLong(ep->me_value != NULL);
+    PyObject *value;
+
+    if (PyDict_GetItemEx((PyObject *)mp, key, &value) < 0)
+        return NULL;
+
+    if (value == NULL)
+        return PyBool_FromLong(0);
+    else {
+        Py_DECREF(value);
+        return PyBool_FromLong(1);
+    }
 }
 
 static PyObject *
 dict_get(register PyDictObject *mp, PyObject *args)
 {
-	PyObject *key;
-	PyObject *failobj = Py_None;
-	PyObject *val = NULL;
-	long hash;
-	PyDictEntry *ep;
-
-	if (!PyArg_UnpackTuple(args, "get", 1, 2, &key, &failobj))
-		return NULL;
-
-	if (!PyUnicode_CheckExact(key) ||
-	    (hash = ((PyUnicodeObject *) key)->hash) == -1) {
-		hash = PyObject_Hash(key);
-		if (hash == -1)
-			return NULL;
-	}
-	ep = (mp->ma_lookup)(mp, key, hash);
-	if (ep == NULL)
-		return NULL;
-	val = ep->me_value;
-	if (val == NULL)
-		val = failobj;
-	Py_INCREF(val);
-	return val;
+    PyObject *key;
+    PyObject *failobj = Py_None;
+    PyObject *val;
+
+    if (!PyArg_UnpackTuple(args, "get", 1, 2, &key, &failobj))
+        return NULL;
+
+    if (PyDict_GetItemEx((PyObject *)mp, key, &val) < 0)
+        return NULL;
+
+    if (val == NULL) {
+        Py_INCREF(failobj);
+        return failobj;
+    } else
+        return val;
 }
 
 
@@ -1682,6 +2139,7 @@
 	PyObject *val = NULL;
 	long hash;
 	PyDictEntry *ep;
+	PyDict_LockState lockstate;
 
 	if (!PyArg_UnpackTuple(args, "setdefault", 1, 2, &key, &failobj))
 		return NULL;
@@ -1692,16 +2150,32 @@
 		if (hash == -1)
 			return NULL;
 	}
-	ep = (mp->ma_lookup)(mp, key, hash);
-	if (ep == NULL)
-		return NULL;
+	if (block_unshareable_keyvalue((PyObject *)mp, key, val))
+		return NULL;
+
+	_pydictlock_initstate_write(&lockstate);
+
+	_pydictlock_acquire(mp, &lockstate);
+	ep = (mp->ma_lookup)(mp, key, hash, &lockstate);
+	if (ep == NULL) {
+		_pydictlock_release(mp, &lockstate);
+		return NULL;
+	}
 	val = ep->me_value;
-	if (val == NULL) {
+	if (val != NULL) {
+		Py_INCREF(val);
+		_pydictlock_release(mp, &lockstate);
+	} else {
+		_pydictlock_release(mp, &lockstate);
+		/* XXX FIXME: This uses two separate operations, meaning
+		 * it's not atomic.  This is wrong, but is it important
+		 * enough to fix? */
 		val = failobj;
 		if (PyDict_SetItem((PyObject*)mp, key, failobj))
 			val = NULL;
+		else
+			Py_INCREF(failobj);
 	}
-	Py_XINCREF(val);
 	return val;
 }
 
@@ -1720,10 +2194,23 @@
 	PyDictEntry *ep;
 	PyObject *old_value, *old_key;
 	PyObject *key, *deflt = NULL;
+	PyDict_LockState lockstate;
 
 	if(!PyArg_UnpackTuple(args, "pop", 1, 2, &key, &deflt))
 		return NULL;
+
+	if (!PyUnicode_CheckExact(key) ||
+	    (hash = ((PyUnicodeObject *) key)->hash) == -1) {
+		hash = PyObject_Hash(key);
+		if (hash == -1)
+			return NULL;
+	}
+
+	_pydictlock_initstate_write(&lockstate);
+
+	_pydictlock_acquire(mp, &lockstate);
 	if (mp->ma_used == 0) {
+		_pydictlock_release(mp, &lockstate);
 		if (deflt) {
 			Py_INCREF(deflt);
 			return deflt;
@@ -1732,16 +2219,13 @@
 				"pop(): dictionary is empty");
 		return NULL;
 	}
-	if (!PyUnicode_CheckExact(key) ||
-	    (hash = ((PyUnicodeObject *) key)->hash) == -1) {
-		hash = PyObject_Hash(key);
-		if (hash == -1)
-			return NULL;
+	ep = (mp->ma_lookup)(mp, key, hash, &lockstate);
+	if (ep == NULL) {
+		_pydictlock_release(mp, &lockstate);
+		return NULL;
 	}
-	ep = (mp->ma_lookup)(mp, key, hash);
-	if (ep == NULL)
-		return NULL;
 	if (ep->me_value == NULL) {
+		_pydictlock_release(mp, &lockstate);
 		if (deflt) {
 			Py_INCREF(deflt);
 			return deflt;
@@ -1755,6 +2239,7 @@
 	old_value = ep->me_value;
 	ep->me_value = NULL;
 	mp->ma_used--;
+	_pydictlock_release(mp, &lockstate);
 	Py_DECREF(old_key);
 	return old_value;
 }
@@ -1765,6 +2250,7 @@
 	Py_ssize_t i = 0;
 	PyDictEntry *ep;
 	PyObject *res;
+	PyDict_LockState lockstate;
 
 	/* Allocate the result tuple before checking the size.  Believe it
 	 * or not, this allocation could trigger a garbage collection which
@@ -1778,7 +2264,12 @@
 	res = PyTuple_New(2);
 	if (res == NULL)
 		return NULL;
+
+	_pydictlock_initstate_write(&lockstate);
+
+	_pydictlock_acquire(mp, &lockstate);
 	if (mp->ma_used == 0) {
+		_pydictlock_release(mp, &lockstate);
 		Py_DECREF(res);
 		PyErr_SetString(PyExc_KeyError,
 				"popitem(): dictionary is empty");
@@ -1814,6 +2305,7 @@
 	mp->ma_used--;
 	assert(mp->ma_table[0].me_value == NULL);
 	mp->ma_table[0].me_hash = i + 1;  /* next place to start */
+	_pydictlock_release(mp, &lockstate);
 	return res;
 }
 
@@ -1824,9 +2316,11 @@
 	PyObject *pk;
 	PyObject *pv;
 
-	while (PyDict_Next(op, &i, &pk, &pv)) {
+	while (PyDict_NextEx(op, &i, &pk, &pv)) {
 		Py_VISIT(pk);
 		Py_VISIT(pv);
+		Py_DECREF(pk);
+		Py_DECREF(pv);
 	}
 	return 0;
 }
@@ -1834,8 +2328,19 @@
 static int
 dict_tp_clear(PyObject *op)
 {
-	PyDict_Clear(op);
-	return 0;
+    if (PySharedDict_Check(op)) {
+        PySharedDictObject *sd = (PySharedDictObject *)op;
+        if (sd->readonly_mode) {
+            /* tp_clear should only be called from the tracing GC, in
+             * which case the world is already stopped.  Since a second
+             * attempt to stop the world would hang, we cheat and
+             * directly reset to read-write mode. */
+            sd->readonly_mode = 0;
+            sd->read_count = 0;
+        }
+    }
+    PyDict_Clear(op);
+    return 0;
 }
 
 static PyObject *dictiter_new(PyDictObject *, PyTypeObject *);
@@ -1922,6 +2427,8 @@
 	long hash;
 	PyDictObject *mp = (PyDictObject *)op;
 	PyDictEntry *ep;
+	int res;
+	PyDict_LockState lockstate;
 
 	if (!PyUnicode_CheckExact(key) ||
 	    (hash = ((PyUnicodeObject *) key)->hash) == -1) {
@@ -1929,8 +2436,14 @@
 		if (hash == -1)
 			return -1;
 	}
-	ep = (mp->ma_lookup)(mp, key, hash);
-	return ep == NULL ? -1 : (ep->me_value != NULL);
+
+	_pydictlock_initstate_read(&lockstate);
+
+	_pydictlock_acquire(mp, &lockstate);
+	ep = (mp->ma_lookup)(mp, key, hash, &lockstate);
+	res = ep == NULL ? -1 : (ep->me_value != NULL);
+	_pydictlock_release(mp, &lockstate);
+	return res;
 }
 
 /* Internal version of PyDict_Contains used when the hash value is already known */
@@ -1939,9 +2452,16 @@
 {
 	PyDictObject *mp = (PyDictObject *)op;
 	PyDictEntry *ep;
-
-	ep = (mp->ma_lookup)(mp, key, hash);
-	return ep == NULL ? -1 : (ep->me_value != NULL);
+	int res;
+	PyDict_LockState lockstate;
+
+	_pydictlock_initstate_read(&lockstate);
+
+	_pydictlock_acquire(mp, &lockstate);
+	ep = (mp->ma_lookup)(mp, key, hash, &lockstate);
+	res = ep == NULL ? -1 : (ep->me_value != NULL);
+	_pydictlock_release(mp, &lockstate);
+	return res;
 }
 
 /* Hack to implement "key in dict" */
@@ -1963,12 +2483,10 @@
 {
 	PyObject *self;
 
-	assert(type != NULL && type->tp_alloc != NULL);
-	self = type->tp_alloc(type, 0);
+	assert(type != NULL);
+	self = PyObject_New(type);
 	if (self != NULL) {
 		PyDictObject *d = (PyDictObject *)self;
-		/* It's guaranteed that tp->alloc zeroed out the struct. */
-		assert(d->ma_table == NULL && d->ma_fill == 0 && d->ma_used == 0);
 		INIT_NONZERO_DICT_SLOTS(d);
 		d->ma_lookup = lookdict_unicode;
 #ifdef SHOW_CONVERSION_COUNTS
@@ -1978,6 +2496,27 @@
 	return self;
 }
 
+static PyObject *
+shareddict_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
+{
+    PySharedDictObject *self = (PySharedDictObject *)dict_new(
+        type, args, kwds);
+
+    if (self == NULL)
+        return NULL;
+
+    self->readonly_mode = 0;
+    self->read_count = 0;
+    self->crit = PyCritical_Allocate(PyCRITICAL_NORMAL);
+    if (self->crit == NULL) {
+        Py_DECREF(self);
+        PyErr_NoMemory();
+        return NULL;
+    }
+
+    return (PyObject *)self;
+}
+
 static int
 dict_init(PyObject *self, PyObject *args, PyObject *kwds)
 {
@@ -1990,6 +2529,12 @@
 	return dictiter_new(dict, &PyDictIterKey_Type);
 }
 
+static int
+shareddict_isshareable (PyObject *self)
+{
+	return 1;
+}
+
 PyDoc_STRVAR(dictionary_doc,
 "dict() -> new empty dictionary.\n"
 "dict(mapping) -> new dictionary initialized from a mapping object's\n"
@@ -2022,7 +2567,8 @@
 	0,					/* tp_setattro */
 	0,					/* tp_as_buffer */
 	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
-		Py_TPFLAGS_BASETYPE | Py_TPFLAGS_DICT_SUBCLASS,	/* tp_flags */
+		Py_TPFLAGS_BASETYPE | Py_TPFLAGS_DICT_SUBCLASS |
+		Py_TPFLAGS_SHAREABLE, /* tp_flags */
 	dictionary_doc,				/* tp_doc */
 	dict_traverse,				/* tp_traverse */
 	dict_tp_clear,				/* tp_clear */
@@ -2039,9 +2585,56 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	dict_init,				/* tp_init */
-	PyType_GenericAlloc,			/* tp_alloc */
 	dict_new,				/* tp_new */
-	PyObject_GC_Del,        		/* tp_free */
+};
+
+PyTypeObject PySharedDict_Type = {
+	PyVarObject_HEAD_INIT(&PyType_Type, 0)
+	"shareddict",
+	sizeof(PySharedDictObject),
+	0,
+	(destructor)shareddict_dealloc,		/* tp_dealloc */
+	0,					/* tp_print */
+	0,					/* tp_getattr */
+	0,					/* tp_setattr */
+	0,					/* tp_compare */
+	(reprfunc)shareddict_repr,		/* tp_repr */
+	0,					/* tp_as_number */
+	0,					/* tp_as_sequence */
+	0,					/* tp_as_mapping */
+	0,					/* tp_hash */
+	0,					/* tp_call */
+	0,					/* tp_str */
+	0,					/* tp_getattro */
+	0,					/* tp_setattro */
+	0,					/* tp_as_buffer */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
+		Py_TPFLAGS_DICT_SUBCLASS |
+		Py_TPFLAGS_SHAREABLE,		/* tp_flags */
+	dictionary_doc,				/* tp_doc */
+	dict_traverse,				/* tp_traverse */
+	dict_tp_clear,				/* tp_clear */
+	0,					/* tp_richcompare */
+	0,					/* tp_weaklistoffset */
+	0,					/* tp_iter */
+	0,					/* tp_iternext */
+	0,					/* tp_methods */
+	0,					/* tp_members */
+	0,					/* tp_getset */
+	0,					/* tp_base */
+	0,					/* tp_dict */
+	0,					/* tp_descr_get */
+	0,					/* tp_descr_set */
+	0,					/* tp_dictoffset */
+	dict_init,				/* tp_init */
+	shareddict_new,				/* tp_new */
+	0,					/* tp_is_gc */
+	0,					/* tp_bases */
+	0,					/* tp_mro */
+	0,					/* tp_cache */
+	0,					/* tp_subclasses */
+	0,					/* tp_weaklist */
+	shareddict_isshareable,			/* tp_isshareable */
 };
 
 /* For backward compatibility with old dictionary interface */
@@ -2059,6 +2652,19 @@
 }
 
 int
+PyDict_GetItemStringEx(PyObject *d, const char *key, PyObject **value)
+{
+	PyObject *keyobj;
+	int retvalue;
+	keyobj = PyUnicode_FromString(key);
+	if (keyobj == NULL)
+		return -1;
+	retvalue = PyDict_GetItemEx(d, keyobj, value);
+	Py_DECREF(keyobj);
+	return retvalue;
+}
+
+int
 PyDict_SetItemString(PyObject *v, const char *key, PyObject *item)
 {
 	PyObject *kv;
@@ -2085,6 +2691,19 @@
 	return err;
 }
 
+int
+PyDict_ContainsString(PyObject *d, const char *key)
+{
+	PyObject *keyobj;
+	int retvalue;
+	keyobj = PyUnicode_FromString(key);
+	if (keyobj == NULL)
+		return -1;
+	retvalue = PyDict_Contains(d, keyobj);
+	Py_DECREF(keyobj);
+	return retvalue;
+}
+
 /* Dictionary iterator types */
 
 typedef struct {
@@ -2100,14 +2719,14 @@
 dictiter_new(PyDictObject *dict, PyTypeObject *itertype)
 {
 	dictiterobject *di;
-	di = PyObject_New(dictiterobject, itertype);
+	di = PyObject_New(itertype);
 	if (di == NULL)
 		return NULL;
 	Py_INCREF(dict);
 	di->di_dict = dict;
-	di->di_used = dict->ma_used;
+	di->di_used = dict_length(dict);
 	di->di_pos = 0;
-	di->len = dict->ma_used;
+	di->len = di->di_used;
 	if (itertype == &PyDictIterItem_Type) {
 		di->di_result = PyTuple_Pack(2, Py_None, Py_None);
 		if (di->di_result == NULL) {
@@ -2132,7 +2751,7 @@
 dictiter_len(dictiterobject *di)
 {
 	Py_ssize_t len = 0;
-	if (di->di_dict != NULL && di->di_used == di->di_dict->ma_used)
+	if (di->di_dict != NULL && di->di_used == dict_length(di->di_dict))
 		len = di->len;
 	return PyLong_FromSize_t(len);
 }
@@ -2146,43 +2765,68 @@
  	{NULL,		NULL}		/* sentinel */
 };
 
+/* On success, returns 0 and sets key and value (with NEW references)
+ * On failure, returns -1, sets neither, and invalidates di */
+static int
+dictiter_iternext_common(dictiterobject *di, PyObject **key, PyObject **value)
+{
+    register Py_ssize_t i, mask;
+    register PyDictEntry *ep;
+    PyDictObject *d = di->di_dict;
+    PyDict_LockState lockstate;
+
+    if (d == NULL)
+        return -1;
+    assert (PyDict_Check(d));
+
+    _pydictlock_initstate_read(&lockstate);
+
+    _pydictlock_acquire(d, &lockstate);
+    /* We don't bother to check ma_rebuilds here.  We're not caching
+     * ma_table or ma_mask, so ma_used is good enough. */
+    if (di->di_used != d->ma_used) {
+        _pydictlock_release(d, &lockstate);
+        PyErr_SetString(PyExc_RuntimeError,
+                        "dictionary changed size during iteration");
+        di->di_used = -1; /* Make this state sticky */
+        return -1;
+    }
+
+    i = di->di_pos;
+    if (i < 0)
+        goto fail;
+    ep = d->ma_table;
+    mask = d->ma_mask;
+    while (i <= mask && ep[i].me_value == NULL)
+        i++;
+    di->di_pos = i+1;
+    if (i > mask)
+        goto fail;
+
+    di->len--;
+    *key = ep[i].me_key;
+    *value = ep[i].me_value;
+    Py_INCREF(*key);
+    Py_INCREF(*value);
+
+    _pydictlock_release(d, &lockstate);
+    return 0;
+
+fail:
+    _pydictlock_release(d, &lockstate);
+    Py_DECREF(d);
+    di->di_dict = NULL;
+    return -1;
+}
+
 static PyObject *dictiter_iternextkey(dictiterobject *di)
 {
-	PyObject *key;
-	register Py_ssize_t i, mask;
-	register PyDictEntry *ep;
-	PyDictObject *d = di->di_dict;
-
-	if (d == NULL)
-		return NULL;
-	assert (PyDict_Check(d));
-
-	if (di->di_used != d->ma_used) {
-		PyErr_SetString(PyExc_RuntimeError,
-				"dictionary changed size during iteration");
-		di->di_used = -1; /* Make this state sticky */
-		return NULL;
-	}
-
-	i = di->di_pos;
-	if (i < 0)
-		goto fail;
-	ep = d->ma_table;
-	mask = d->ma_mask;
-	while (i <= mask && ep[i].me_value == NULL)
-		i++;
-	di->di_pos = i+1;
-	if (i > mask)
-		goto fail;
-	di->len--;
-	key = ep[i].me_key;
-	Py_INCREF(key);
-	return key;
-
-fail:
-	Py_DECREF(d);
-	di->di_dict = NULL;
-	return NULL;
+    PyObject *key, *value;
+
+    if (dictiter_iternext_common(di, &key, &value))
+        return NULL;
+    Py_DECREF(value);
+    return key;
 }
 
 PyTypeObject PyDictIterKey_Type = {
@@ -2218,43 +2862,15 @@
 	0,
 };
 
-static PyObject *dictiter_iternextvalue(dictiterobject *di)
+static PyObject *
+dictiter_iternextvalue(dictiterobject *di)
 {
-	PyObject *value;
-	register Py_ssize_t i, mask;
-	register PyDictEntry *ep;
-	PyDictObject *d = di->di_dict;
-
-	if (d == NULL)
-		return NULL;
-	assert (PyDict_Check(d));
-
-	if (di->di_used != d->ma_used) {
-		PyErr_SetString(PyExc_RuntimeError,
-				"dictionary changed size during iteration");
-		di->di_used = -1; /* Make this state sticky */
-		return NULL;
-	}
-
-	i = di->di_pos;
-	mask = d->ma_mask;
-	if (i < 0 || i > mask)
-		goto fail;
-	ep = d->ma_table;
-	while ((value=ep[i].me_value) == NULL) {
-		i++;
-		if (i > mask)
-			goto fail;
-	}
-	di->di_pos = i+1;
-	di->len--;
-	Py_INCREF(value);
-	return value;
-
-fail:
-	Py_DECREF(d);
-	di->di_dict = NULL;
-	return NULL;
+    PyObject *key, *value;
+
+    if (dictiter_iternext_common(di, &key, &value))
+        return NULL;
+    Py_DECREF(key);
+    return value;
 }
 
 PyTypeObject PyDictIterValue_Type = {
@@ -2292,55 +2908,25 @@
 
 static PyObject *dictiter_iternextitem(dictiterobject *di)
 {
-	PyObject *key, *value, *result = di->di_result;
-	register Py_ssize_t i, mask;
-	register PyDictEntry *ep;
-	PyDictObject *d = di->di_dict;
-
-	if (d == NULL)
-		return NULL;
-	assert (PyDict_Check(d));
-
-	if (di->di_used != d->ma_used) {
-		PyErr_SetString(PyExc_RuntimeError,
-				"dictionary changed size during iteration");
-		di->di_used = -1; /* Make this state sticky */
-		return NULL;
-	}
-
-	i = di->di_pos;
-	if (i < 0)
-		goto fail;
-	ep = d->ma_table;
-	mask = d->ma_mask;
-	while (i <= mask && ep[i].me_value == NULL)
-		i++;
-	di->di_pos = i+1;
-	if (i > mask)
-		goto fail;
-
-	if (result->ob_refcnt == 1) {
-		Py_INCREF(result);
-		Py_DECREF(PyTuple_GET_ITEM(result, 0));
-		Py_DECREF(PyTuple_GET_ITEM(result, 1));
-	} else {
-		result = PyTuple_New(2);
-		if (result == NULL)
-			return NULL;
-	}
-	di->len--;
-	key = ep[i].me_key;
-	value = ep[i].me_value;
-	Py_INCREF(key);
-	Py_INCREF(value);
-	PyTuple_SET_ITEM(result, 0, key);
-	PyTuple_SET_ITEM(result, 1, value);
-	return result;
-
-fail:
-	Py_DECREF(d);
-	di->di_dict = NULL;
-	return NULL;
+    PyObject *key, *value;
+    PyObject *result = di->di_result;
+
+    if (dictiter_iternext_common(di, &key, &value))
+        return NULL;
+
+    if (Py_RefcntMatches(result, 1)) {
+        Py_INCREF(result);
+        Py_DECREF(PyTuple_GET_ITEM(result, 0));
+        Py_DECREF(PyTuple_GET_ITEM(result, 1));
+    } else {
+        result = PyTuple_New(2);
+        if (result == NULL)
+            return NULL;
+    }
+
+    PyTuple_SET_ITEM(result, 0, key);
+    PyTuple_SET_ITEM(result, 1, value);
+    return result;
 }
 
 PyTypeObject PyDictIterItem_Type = {
@@ -2401,7 +2987,7 @@
 {
 	Py_ssize_t len = 0;
 	if (dv->dv_dict != NULL)
-		len = dv->dv_dict->ma_used;
+		len = dict_length(dv->dv_dict);
 	return len;
 }
 
@@ -2420,7 +3006,7 @@
 			     type->tp_name, dict->ob_type->tp_name);
 		return NULL;
 	}
-	dv = PyObject_New(dictviewobject, type);
+	dv = PyObject_New(type);
 	if (dv == NULL)
 		return NULL;
 	Py_INCREF(dict);
@@ -2704,19 +3290,22 @@
 dictitems_contains(dictviewobject *dv, PyObject *obj)
 {
 	PyObject *key, *value, *found;
+	int res;
+
 	if (dv->dv_dict == NULL)
 		return 0;
 	if (!PyTuple_Check(obj) || PyTuple_GET_SIZE(obj) != 2)
 		return 0;
+
 	key = PyTuple_GET_ITEM(obj, 0);
 	value = PyTuple_GET_ITEM(obj, 1);
-	found = PyDict_GetItem((PyObject *)dv->dv_dict, key);
-	if (found == NULL) {
-		if (PyErr_Occurred())
-			return -1;
+	if (PyDict_GetItemEx((PyObject *)dv->dv_dict, key, &found) < 0)
+		return -1;
+	if (found == NULL)
 		return 0;
-	}
-	return PyObject_RichCompareBool(value, found, Py_EQ);
+	res = PyObject_RichCompareBool(value, found, Py_EQ);
+	Py_DECREF(found);
+	return res;
 }
 
 static PySequenceMethods dictitems_as_sequence = {

=== modified file 'Objects/enumobject.c'
--- Objects/enumobject.c	2007-12-19 02:45:37 +0000
+++ Objects/enumobject.c	2008-03-24 04:28:03 +0000
@@ -21,7 +21,7 @@
 					 &seq))
 		return NULL;
 
-	en = (enumobject *)type->tp_alloc(type, 0);
+	en = PyObject_New(type);
 	if (en == NULL)
 		return NULL;
 	en->en_index = 0;
@@ -42,11 +42,10 @@
 static void
 enum_dealloc(enumobject *en)
 {
-	PyObject_GC_UnTrack(en);
 	Py_XDECREF(en->en_sit);
 	Py_XDECREF(en->en_result);
 	Py_XDECREF(en->en_longindex);
-	Py_TYPE(en)->tp_free(en);
+	PyObject_Del(en);
 }
 
 static int
@@ -122,7 +121,7 @@
 	}
 	en->en_index++;
 
-	if (result->ob_refcnt == 1) {
+	if (Py_RefcntMatches(result, 1)) {
 		Py_INCREF(result);
 		Py_DECREF(PyTuple_GET_ITEM(result, 0));
 		Py_DECREF(PyTuple_GET_ITEM(result, 1));
@@ -169,7 +168,8 @@
 	0,                              /* tp_setattro */
 	0,                              /* tp_as_buffer */
 	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
-		Py_TPFLAGS_BASETYPE,    /* tp_flags */
+		Py_TPFLAGS_BASETYPE | Py_TPFLAGS_SHAREABLE,
+					/* tp_flags */
 	enum_doc,                       /* tp_doc */
 	(traverseproc)enum_traverse,    /* tp_traverse */
 	0,                              /* tp_clear */
@@ -186,9 +186,7 @@
 	0,                              /* tp_descr_set */
 	0,                              /* tp_dictoffset */
 	0,                              /* tp_init */
-	PyType_GenericAlloc,            /* tp_alloc */
 	enum_new,                       /* tp_new */
-	PyObject_GC_Del,                /* tp_free */
 };
 
 /* Reversed Object ***************************************************************/
@@ -222,7 +220,7 @@
 	if (n == -1)
 		return NULL;
 
-	ro = (reversedobject *)type->tp_alloc(type, 0);
+	ro = PyObject_New(type);
 	if (ro == NULL)
 		return NULL;
 
@@ -235,9 +233,8 @@
 static void
 reversed_dealloc(reversedobject *ro)
 {
-	PyObject_GC_UnTrack(ro);
 	Py_XDECREF(ro->seq);
-	Py_TYPE(ro)->tp_free(ro);
+	PyObject_Del(ro);
 }
 
 static int
@@ -316,7 +313,8 @@
 	0,                              /* tp_setattro */
 	0,                              /* tp_as_buffer */
 	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
-		Py_TPFLAGS_BASETYPE,    /* tp_flags */
+		Py_TPFLAGS_BASETYPE | Py_TPFLAGS_SHAREABLE,
+					/* tp_flags */
 	reversed_doc,                   /* tp_doc */
 	(traverseproc)reversed_traverse,/* tp_traverse */
 	0,                              /* tp_clear */
@@ -333,7 +331,5 @@
 	0,                              /* tp_descr_set */
 	0,                              /* tp_dictoffset */
 	0,                              /* tp_init */
-	PyType_GenericAlloc,            /* tp_alloc */
 	reversed_new,                   /* tp_new */
-	PyObject_GC_Del,                /* tp_free */
 };

=== modified file 'Objects/exceptions.c'
--- Objects/exceptions.c	2007-12-19 02:45:37 +0000
+++ Objects/exceptions.c	2008-04-08 01:25:28 +0000
@@ -23,7 +23,7 @@
 {
     PyBaseExceptionObject *self;
 
-    self = (PyBaseExceptionObject *)type->tp_alloc(type, 0);
+    self = PyObject_New(type);
     if (!self)
         return NULL;
     /* the dict is created on the fly in PyObject_GenericSetAttr */
@@ -66,9 +66,8 @@
 static void
 BaseException_dealloc(PyBaseExceptionObject *self)
 {
-    _PyObject_GC_UNTRACK(self);
     BaseException_clear(self);
-    Py_TYPE(self)->tp_free((PyObject *)self);
+    PyObject_Del(self);
 }
 
 static int
@@ -327,7 +326,7 @@
     PyObject_GenericSetAttr,    /*tp_setattro*/
     0,                          /*tp_as_buffer*/
     Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC |
-    	Py_TPFLAGS_BASE_EXC_SUBCLASS,  /*tp_flags*/
+    	Py_TPFLAGS_BASE_EXC_SUBCLASS | Py_TPFLAGS_SHAREABLE,  /*tp_flags*/
     PyDoc_STR("Common base class for all exceptions"), /* tp_doc */
     (traverseproc)BaseException_traverse, /* tp_traverse */
     (inquiry)BaseException_clear, /* tp_clear */
@@ -344,7 +343,6 @@
     0,                          /* tp_descr_set */
     offsetof(PyBaseExceptionObject, dict), /* tp_dictoffset */
     (initproc)BaseException_init, /* tp_init */
-    0,                          /* tp_alloc */
     BaseException_new,          /* tp_new */
 };
 /* the CPython API expects exceptions to be (PyObject *) - both a hold-over
@@ -362,11 +360,11 @@
     sizeof(PyBaseExceptionObject), \
     0, (destructor)BaseException_dealloc, 0, 0, 0, 0, 0, 0, 0, \
     0, 0, 0, 0, 0, 0, 0, \
-    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC, \
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_SHAREABLE, \
     PyDoc_STR(EXCDOC), (traverseproc)BaseException_traverse, \
     (inquiry)BaseException_clear, 0, 0, 0, 0, 0, 0, 0, &_ ## EXCBASE, \
     0, 0, 0, offsetof(PyBaseExceptionObject, dict), \
-    (initproc)BaseException_init, 0, BaseException_new,\
+    (initproc)BaseException_init, BaseException_new,\
 }; \
 PyObject *PyExc_ ## EXCNAME = (PyObject *)&_PyExc_ ## EXCNAME
 
@@ -377,11 +375,11 @@
     sizeof(Py ## EXCSTORE ## Object), \
     0, (destructor)EXCSTORE ## _dealloc, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
     0, 0, 0, 0, 0, \
-    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC, \
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_SHAREABLE, \
     PyDoc_STR(EXCDOC), (traverseproc)EXCSTORE ## _traverse, \
     (inquiry)EXCSTORE ## _clear, 0, 0, 0, 0, 0, 0, 0, &_ ## EXCBASE, \
     0, 0, 0, offsetof(Py ## EXCSTORE ## Object, dict), \
-    (initproc)EXCSTORE ## _init, 0, BaseException_new,\
+    (initproc)EXCSTORE ## _init, BaseException_new,\
 }; \
 PyObject *PyExc_ ## EXCNAME = (PyObject *)&_PyExc_ ## EXCNAME
 
@@ -392,12 +390,12 @@
     sizeof(Py ## EXCSTORE ## Object), 0, \
     (destructor)EXCSTORE ## _dealloc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
     (reprfunc)EXCSTR, 0, 0, 0, \
-    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC, \
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_SHAREABLE, \
     PyDoc_STR(EXCDOC), (traverseproc)EXCSTORE ## _traverse, \
     (inquiry)EXCSTORE ## _clear, 0, 0, 0, 0, EXCMETHODS, \
     EXCMEMBERS, 0, &_ ## EXCBASE, \
     0, 0, 0, offsetof(Py ## EXCSTORE ## Object, dict), \
-    (initproc)EXCSTORE ## _init, 0, BaseException_new,\
+    (initproc)EXCSTORE ## _init, BaseException_new,\
 }; \
 PyObject *PyExc_ ## EXCNAME = (PyObject *)&_PyExc_ ## EXCNAME
 
@@ -463,9 +461,8 @@
 static void
 SystemExit_dealloc(PySystemExitObject *self)
 {
-    _PyObject_GC_UNTRACK(self);
     SystemExit_clear(self);
-    Py_TYPE(self)->tp_free((PyObject *)self);
+    PyObject_Del(self);
 }
 
 static int
@@ -568,9 +565,8 @@
 static void
 EnvironmentError_dealloc(PyEnvironmentErrorObject *self)
 {
-    _PyObject_GC_UNTRACK(self);
     EnvironmentError_clear(self);
-    Py_TYPE(self)->tp_free((PyObject *)self);
+    PyObject_Del(self);
 }
 
 static int
@@ -689,9 +685,8 @@
 static void
 WindowsError_dealloc(PyWindowsErrorObject *self)
 {
-    _PyObject_GC_UNTRACK(self);
     WindowsError_clear(self);
-    Py_TYPE(self)->tp_free((PyObject *)self);
+    PyObject_Del(self);
 }
 
 static int
@@ -797,6 +792,24 @@
 
 
 /*
+ *    DeadlockError extends RuntimeError
+ */
+SimpleExtendsException(PyExc_RuntimeError, DeadlockError,
+                       "Entrance to MonitorSpace deadlocked.");
+
+/*
+ *    HardDeadlockError extends DeadlockError
+ */
+SimpleExtendsException(PyExc_DeadlockError, HardDeadlockError,
+                       "Entrance to MonitorSpace deadlocked.  Preemption was necessary.");
+
+/*
+ *    SoftDeadlockError extends DeadlockError
+ */
+SimpleExtendsException(PyExc_DeadlockError, SoftDeadlockError,
+                       "Entrance to MonitorSpace deadlocked.  Aborting was possible.");
+
+/*
  *    NotImplementedError extends RuntimeError
  */
 SimpleExtendsException(PyExc_RuntimeError, NotImplementedError,
@@ -887,9 +900,8 @@
 static void
 SyntaxError_dealloc(PySyntaxErrorObject *self)
 {
-    _PyObject_GC_UNTRACK(self);
     SyntaxError_clear(self);
-    Py_TYPE(self)->tp_free((PyObject *)self);
+    PyObject_Del(self);
 }
 
 static int
@@ -1314,9 +1326,8 @@
 static void
 UnicodeError_dealloc(PyUnicodeErrorObject *self)
 {
-    _PyObject_GC_UNTRACK(self);
     UnicodeError_clear(self);
-    Py_TYPE(self)->tp_free((PyObject *)self);
+    PyObject_Del(self);
 }
 
 static int
@@ -1415,11 +1426,11 @@
     sizeof(PyUnicodeErrorObject), 0,
     (destructor)UnicodeError_dealloc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     (reprfunc)UnicodeEncodeError_str, 0, 0, 0,
-    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_SHAREABLE,
     PyDoc_STR("Unicode encoding error."), (traverseproc)UnicodeError_traverse,
     (inquiry)UnicodeError_clear, 0, 0, 0, 0, 0, UnicodeError_members,
     0, &_PyExc_UnicodeError, 0, 0, 0, offsetof(PyUnicodeErrorObject, dict),
-    (initproc)UnicodeEncodeError_init, 0, BaseException_new,
+    (initproc)UnicodeEncodeError_init, BaseException_new,
 };
 PyObject *PyExc_UnicodeEncodeError = (PyObject *)&_PyExc_UnicodeEncodeError;
 
@@ -1510,11 +1521,11 @@
     sizeof(PyUnicodeErrorObject), 0,
     (destructor)UnicodeError_dealloc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     (reprfunc)UnicodeDecodeError_str, 0, 0, 0,
-    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_SHAREABLE,
     PyDoc_STR("Unicode decoding error."), (traverseproc)UnicodeError_traverse,
     (inquiry)UnicodeError_clear, 0, 0, 0, 0, 0, UnicodeError_members,
     0, &_PyExc_UnicodeError, 0, 0, 0, offsetof(PyUnicodeErrorObject, dict),
-    (initproc)UnicodeDecodeError_init, 0, BaseException_new,
+    (initproc)UnicodeDecodeError_init, BaseException_new,
 };
 PyObject *PyExc_UnicodeDecodeError = (PyObject *)&_PyExc_UnicodeDecodeError;
 
@@ -1596,11 +1607,11 @@
     sizeof(PyUnicodeErrorObject), 0,
     (destructor)UnicodeError_dealloc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     (reprfunc)UnicodeTranslateError_str, 0, 0, 0,
-    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_SHAREABLE,
     PyDoc_STR("Unicode translation error."), (traverseproc)UnicodeError_traverse,
     (inquiry)UnicodeError_clear, 0, 0, 0, 0, 0, UnicodeError_members,
     0, &_PyExc_UnicodeError, 0, 0, 0, offsetof(PyUnicodeErrorObject, dict),
-    (initproc)UnicodeTranslateError_init, 0, BaseException_new,
+    (initproc)UnicodeTranslateError_init, BaseException_new,
 };
 PyObject *PyExc_UnicodeTranslateError = (PyObject *)&_PyExc_UnicodeTranslateError;
 
@@ -1676,6 +1687,16 @@
  */
 SimpleExtendsException(PyExc_Exception, BufferError, "Buffer error.");
 
+/*
+ *    MultipleError extends Exception
+ */
+SimpleExtendsException(PyExc_Exception, MultipleError, "Multiple errors.");
+
+/*
+ *    Cancelled extends Exception
+ */
+SimpleExtendsException(PyExc_Exception, Cancelled, "Thread cancelled by parent.");
+
 
 /* Warning category docstrings */
 
@@ -1818,6 +1839,9 @@
 #endif
     PRE_INIT(EOFError)
     PRE_INIT(RuntimeError)
+    PRE_INIT(DeadlockError)
+    PRE_INIT(HardDeadlockError)
+    PRE_INIT(SoftDeadlockError)
     PRE_INIT(NotImplementedError)
     PRE_INIT(NameError)
     PRE_INIT(UnboundLocalError)
@@ -1835,6 +1859,7 @@
     PRE_INIT(UnicodeTranslateError)
     PRE_INIT(AssertionError)
     PRE_INIT(ArithmeticError)
+    PRE_INIT(Cancelled)
     PRE_INIT(FloatingPointError)
     PRE_INIT(OverflowError)
     PRE_INIT(ZeroDivisionError)
@@ -1842,6 +1867,7 @@
     PRE_INIT(ReferenceError)
     PRE_INIT(BufferError)
     PRE_INIT(MemoryError)
+    PRE_INIT(MultipleError)
     PRE_INIT(Warning)
     PRE_INIT(UserWarning)
     PRE_INIT(DeprecationWarning)
@@ -1879,6 +1905,9 @@
 #endif
     POST_INIT(EOFError)
     POST_INIT(RuntimeError)
+    POST_INIT(DeadlockError)
+    POST_INIT(HardDeadlockError)
+    POST_INIT(SoftDeadlockError)
     POST_INIT(NotImplementedError)
     POST_INIT(NameError)
     POST_INIT(UnboundLocalError)
@@ -1896,6 +1925,7 @@
     POST_INIT(UnicodeTranslateError)
     POST_INIT(AssertionError)
     POST_INIT(ArithmeticError)
+    POST_INIT(Cancelled)
     POST_INIT(FloatingPointError)
     POST_INIT(OverflowError)
     POST_INIT(ZeroDivisionError)
@@ -1903,6 +1933,7 @@
     POST_INIT(ReferenceError)
     POST_INIT(BufferError)
     POST_INIT(MemoryError)
+    POST_INIT(MultipleError)
     POST_INIT(Warning)
     POST_INIT(UserWarning)
     POST_INIT(DeprecationWarning)

=== modified file 'Objects/fileobject.c'
--- Objects/fileobject.c	2007-12-03 22:54:21 +0000
+++ Objects/fileobject.c	2008-03-24 04:28:03 +0000
@@ -100,7 +100,7 @@
 					"EOF when reading a line");
 		}
 		else if (s[len-1] == '\n') {
-			if (result->ob_refcnt == 1)
+			if (Py_RefcntSnoop(result) == 1)
 				_PyString_Resize(&result, len-1);
 			else {
 				PyObject *v;
@@ -120,7 +120,7 @@
 					"EOF when reading a line");
 		}
 		else if (s[len-1] == '\n') {
-			if (result->ob_refcnt == 1)
+			if (Py_RefcntSnoop(result) == 1)
 				PyUnicode_Resize(&result, len-1);
 			else {
 				PyObject *v;
@@ -341,9 +341,9 @@
 {
 	PyStdPrinter_Object *self;
 
-	assert(type != NULL && type->tp_alloc != NULL);
+	assert(type != NULL);
 
-	self = (PyStdPrinter_Object *) type->tp_alloc(type, 0);
+	self = PyObject_New(type);
 	if (self != NULL) {
 		self->fd = -1;
 	}
@@ -369,8 +369,7 @@
 		return NULL;
 	}
 
-	self = PyObject_New(PyStdPrinter_Object,
-			    &PyStdPrinter_Type);
+	self = PyObject_New(&PyStdPrinter_Type);
         if (self != NULL) {
 		self->fd = fd;
 	}
@@ -518,9 +517,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	fileio_init,				/* tp_init */
-	PyType_GenericAlloc,			/* tp_alloc */
 	stdprinter_new,				/* tp_new */
-	PyObject_Del,				/* tp_free */
 };
 
 

=== modified file 'Objects/floatobject.c'
--- Objects/floatobject.c	2008-03-28 10:53:29 +0000
+++ Objects/floatobject.c	2008-04-11 02:07:13 +0000
@@ -5,6 +5,7 @@
    for any kind of float exception without losing portability. */
 
 #include "Python.h"
+#include "pythread.h"
 #include "structseq.h"
 
 #include "formatter_unicode.h"
@@ -26,38 +27,51 @@
 extern int finite(double);
 #endif
 
+#ifdef WITH_GIL
+#define USE_FLOAT_FREELIST
+#endif
+
+#ifdef USE_FLOAT_FREELIST
 /* Special free list -- see comments for same code in intobject.c. */
 #define BLOCK_SIZE	1000	/* 1K less typical malloc overhead */
 #define BHEAD_SIZE	8	/* Enough for a 64-bit pointer */
 #define N_FLOATOBJECTS	((BLOCK_SIZE - BHEAD_SIZE) / sizeof(PyFloatObject))
 
-struct _floatblock {
+typedef struct _floatblock {
 	struct _floatblock *next;
 	PyFloatObject objects[N_FLOATOBJECTS];
-};
-
-typedef struct _floatblock PyFloatBlock;
+} PyFloatBlock;
 
 static PyFloatBlock *block_list = NULL;
 static PyFloatObject *free_list = NULL;
 
 static PyFloatObject *
-fill_free_list(void)
+add_float_block(void)
 {
-	PyFloatObject *p, *q;
+	PyFloatBlock *block;
+	int i;
+
 	/* XXX Float blocks escape the object heap. Use PyObject_MALLOC ??? */
-	p = (PyFloatObject *) PyMem_MALLOC(sizeof(PyFloatBlock));
-	if (p == NULL)
-		return (PyFloatObject *) PyErr_NoMemory();
-	((PyFloatBlock *)p)->next = block_list;
-	block_list = (PyFloatBlock *)p;
-	p = &((PyFloatBlock *)p)->objects[0];
-	q = p + N_FLOATOBJECTS;
-	while (--q > p)
-		Py_TYPE(q) = (struct _typeobject *)(q-1);
-	Py_TYPE(q) = NULL;
-	return p + N_FLOATOBJECTS - 1;
+	block = PyMem_MALLOC(sizeof(PyFloatBlock));
+	if (block == NULL)
+		return NULL;
+
+	block->next = block_list;
+	block_list = block;
+
+	for (i = 0; i < N_FLOATOBJECTS; i++) {
+		PyObject *op = (PyObject *)&block->objects[i];
+		PyObject dummy = PyObject_HEAD_INIT_NOCOMMA(&PyFloat_Type);
+		*op = dummy;
+		if ((i + 1) < N_FLOATOBJECTS)
+			Py_TYPE(op) = (struct _typeobject *)(&block->objects[i + 1]);
+		else
+			Py_TYPE(op) = NULL;
+	}
+
+	return &block->objects[0];
 }
+#endif
 
 double
 PyFloat_GetMax(void)
@@ -148,14 +162,25 @@
 PyFloat_FromDouble(double fval)
 {
 	register PyFloatObject *op;
+	static unsigned int count;
+	count++;
+#ifdef USE_FLOAT_FREELIST
 	if (free_list == NULL) {
-		if ((free_list = fill_free_list()) == NULL)
+		if ((free_list = add_float_block()) == NULL) {
+			PyErr_NoMemory();
 			return NULL;
+		}
 	}
 	/* Inline PyObject_New */
 	op = free_list;
 	free_list = (PyFloatObject *)Py_TYPE(op);
 	PyObject_INIT(op, &PyFloat_Type);
+#else
+	op = PyObject_New(&PyFloat_Type);
+	//printf("New float %p\n", op);
+	if (op == NULL)
+		return NULL;
+#endif
 	op->ob_fval = fval;
 	return (PyObject *) op;
 }
@@ -269,12 +294,15 @@
 static void
 float_dealloc(PyFloatObject *op)
 {
+#ifdef USE_FLOAT_FREELIST
 	if (PyFloat_CheckExact(op)) {
 		Py_TYPE(op) = (struct _typeobject *)free_list;
 		free_list = op;
 	}
 	else
-		Py_TYPE(op)->tp_free((PyObject *)op);
+#endif
+		PyObject_Del(op);
+	//printf("Deleted float %p\n", op);
 }
 
 double
@@ -1201,7 +1229,8 @@
 	if (tmp == NULL)
 		return NULL;
 	assert(PyFloat_CheckExact(tmp));
-	newobj = type->tp_alloc(type, 0);
+	newobj = PyObject_New(type);
+	//printf("New float subtype_new %p\n", newobj);
 	if (newobj == NULL) {
 		Py_DECREF(tmp);
 		return NULL;
@@ -1464,7 +1493,8 @@
 	PyObject_GenericGetAttr,		/* tp_getattro */
 	0,					/* tp_setattro */
 	0,					/* tp_as_buffer */
-	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |
+		Py_TPFLAGS_SHAREABLE,		/* tp_flags */
 	float_doc,				/* tp_doc */
  	0,					/* tp_traverse */
 	0,					/* tp_clear */
@@ -1481,7 +1511,6 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	float_new,				/* tp_new */
 };
 
@@ -1546,6 +1575,7 @@
 void
 PyFloat_CompactFreeList(size_t *pbc, size_t *pbf, size_t *bsum)
 {
+#ifdef USE_FLOAT_FREELIST
 	PyFloatObject *p;
 	PyFloatBlock *list, *next;
 	unsigned i;
@@ -1562,7 +1592,7 @@
 		for (i = 0, p = &list->objects[0];
 		     i < N_FLOATOBJECTS;
 		     i++, p++) {
-			if (PyFloat_CheckExact(p) && Py_REFCNT(p) != 0)
+			if (PyFloat_CheckExact(p) && !Py_RefcntMatches(p, 1))
 				frem++;
 		}
 		next = list->next;
@@ -1573,7 +1603,7 @@
 			     i < N_FLOATOBJECTS;
 			     i++, p++) {
 				if (!PyFloat_CheckExact(p) ||
-				    Py_REFCNT(p) == 0) {
+				    Py_RefcntMatches(p, 1)) {
 					Py_TYPE(p) = (struct _typeobject *)
 						free_list;
 					free_list = p;
@@ -1590,11 +1620,13 @@
 	*pbc = bc;
 	*pbf = bf;
 	*bsum = fsum;
+#endif
 }
 
 void
 PyFloat_Fini(void)
 {
+#ifdef USE_FLOAT_FREELIST
 	PyFloatObject *p;
 	PyFloatBlock *list;
 	unsigned i;
@@ -1624,7 +1656,7 @@
 			     i < N_FLOATOBJECTS;
 			     i++, p++) {
 				if (PyFloat_CheckExact(p) &&
-				    Py_REFCNT(p) != 0) {
+				    !Py_RefcntMatches(p, 1)) {
 					char buf[100];
 					format_float(buf, sizeof(buf), p, PREC_STR);
 					/* XXX(twouters) cast refcount to
@@ -1633,12 +1665,13 @@
 					 */
 					fprintf(stderr,
 			     "#   <float at %p, refcnt=%ld, val=%s>\n",
-						p, (long)Py_REFCNT(p), buf);
+						p, (long)Py_RefcntSnoop(p), buf);
 				}
 			}
 			list = list->next;
 		}
 	}
+#endif
 }
 
 /*----------------------------------------------------------------------------

=== modified file 'Objects/frameobject.c'
--- Objects/frameobject.c	2008-02-16 07:38:31 +0000
+++ Objects/frameobject.c	2008-03-24 04:28:03 +0000
@@ -6,6 +6,7 @@
 #include "frameobject.h"
 #include "opcode.h"
 #include "structmember.h"
+#include "pythread.h"
 
 #undef MIN
 #undef MAX
@@ -406,52 +407,59 @@
    frames could provoke free_list into growing without bound.
 */
 
+#ifdef WITH_GIL
+#define USE_FRAME_FREELIST
+#endif
+
+#ifdef USE_FRAME_FREELIST
 static PyFrameObject *free_list = NULL;
 static int numfree = 0;		/* number of frames currently in free_list */
 /* max value for numfree */
 #define PyFrame_MAXFREELIST 200	
+#endif
 
 static void
 frame_dealloc(PyFrameObject *f)
 {
+	PyState *pystate = PyState_Get();
 	PyObject **p, **valuestack;
 	PyCodeObject *co;
 
-	PyObject_GC_UnTrack(f);
-	Py_TRASHCAN_SAFE_BEGIN(f)
 	/* Kill all local variables */
 	valuestack = f->f_valuestack;
 	for (p = f->f_localsplus; p < valuestack; p++)
-		Py_CLEAR(*p);
+		Py_CLEAR_PS(*p);
 
 	/* Free stack */
 	if (f->f_stacktop != NULL) {
 		for (p = valuestack; p < f->f_stacktop; p++)
-			Py_XDECREF(*p);
+			Py_XDECREF_PS(*p);
 	}
 
-	Py_XDECREF(f->f_back);
-	Py_DECREF(f->f_builtins);
-	Py_DECREF(f->f_globals);
-	Py_CLEAR(f->f_locals);
-	Py_CLEAR(f->f_trace);
-	Py_CLEAR(f->f_exc_type);
-	Py_CLEAR(f->f_exc_value);
-	Py_CLEAR(f->f_exc_traceback);
+	Py_XDECREF_PS(f->f_back);
+	Py_DECREF_PS(f->f_builtins);
+	Py_DECREF_PS(f->f_globals);
+	Py_CLEAR_PS(f->f_locals);
+	Py_CLEAR_PS(f->f_trace);
+	Py_CLEAR_PS(f->f_exc_type);
+	Py_CLEAR_PS(f->f_exc_value);
+	Py_CLEAR_PS(f->f_exc_traceback);
 
 	co = f->f_code;
+#ifdef USE_FRAME_FREELIST
 	if (co->co_zombieframe == NULL)
 		co->co_zombieframe = f;
 	else if (numfree < PyFrame_MAXFREELIST) {
 		++numfree;
 		f->f_back = free_list;
 		free_list = f;
-	}
-	else 
-		PyObject_GC_Del(f);
+	} else
+		PyObject_Del(f);
+#else
+	PyObject_Del(f);
+#endif
 
-	Py_DECREF(co);
-	Py_TRASHCAN_SAFE_END(f)
+	Py_DECREF_PS(co);
 }
 
 static int
@@ -561,10 +569,10 @@
 }
 
 PyFrameObject *
-PyFrame_New(PyThreadState *tstate, PyCodeObject *code, PyObject *globals,
+PyFrame_New(PyState *pystate, PyCodeObject *code, PyObject *globals,
 	    PyObject *locals)
 {
-	PyFrameObject *back = tstate->frame;
+	PyFrameObject *back = pystate->frame;
 	PyFrameObject *f;
 	PyObject *builtins;
 	Py_ssize_t i;
@@ -577,7 +585,8 @@
 	}
 #endif
 	if (back == NULL || back->f_globals != globals) {
-		builtins = PyDict_GetItem(globals, builtin_object);
+		if (PyDict_GetItemEx(globals, builtin_object, &builtins) < 0)
+			return NULL;
 		if (builtins) {
 			if (PyModule_Check(builtins)) {
 				builtins = PyModule_GetDict(builtins);
@@ -587,7 +596,7 @@
 				builtins = NULL;
 		}
 		if (builtins == NULL) {
-			/* No builtins!	 Make up a minimal one
+			/* No builtins!  Make up a minimal one
 			   Give them 'None', at least. */
 			builtins = PyDict_New();
 			if (builtins == NULL ||
@@ -596,7 +605,7 @@
 				return NULL;
 		}
 		else
-			Py_INCREF(builtins);
+			Py_INCREF_PS(builtins);
 
 	}
 	else {
@@ -604,27 +613,31 @@
 		   Save a lookup and a call. */
 		builtins = back->f_builtins;
 		assert(builtins != NULL && PyDict_Check(builtins));
-		Py_INCREF(builtins);
+		Py_INCREF_PS(builtins);
 	}
+#ifdef USE_FRAME_FREELIST
 	if (code->co_zombieframe != NULL) {
 		f = code->co_zombieframe;
 		code->co_zombieframe = NULL;
 		_Py_NewReference((PyObject *)f);
 		assert(f->f_code == code);
-	}
-	else {
+	} else
+#endif
+        {
 		Py_ssize_t extras, ncells, nfrees;
 		ncells = PyTuple_GET_SIZE(code->co_cellvars);
 		nfrees = PyTuple_GET_SIZE(code->co_freevars);
 		extras = code->co_stacksize + code->co_nlocals + ncells +
 		    nfrees;
+#ifdef USE_FRAME_FREELIST
 		if (free_list == NULL) {
-		    f = PyObject_GC_NewVar(PyFrameObject, &PyFrame_Type,
-			extras);
+#endif
+		    f = PyObject_NewVar(&PyFrame_Type, extras);
 		    if (f == NULL) {
-			    Py_DECREF(builtins);
+			    Py_DECREF_PS(builtins);
 			    return NULL;
 		    }
+#ifdef USE_FRAME_FREELIST
 		}
 		else {
 		    assert(numfree > 0);
@@ -632,14 +645,23 @@
 		    f = free_list;
 		    free_list = free_list->f_back;
 		    if (Py_SIZE(f) < extras) {
+#if 0
 			    f = PyObject_GC_Resize(PyFrameObject, f, extras);
 			    if (f == NULL) {
-				    Py_DECREF(builtins);
+				    Py_DECREF_PS(builtins);
 				    return NULL;
 			    }
+#else
+			    PyObject *tmp = PyObject_Resize(f, extras);
+			    if (tmp == NULL) {
+				Py_DECREF(f);
+				return NULL;
+			    }
+#endif
 		    }
 		    _Py_NewReference((PyObject *)f);
 		}
+#endif
 
 		f->f_code = code;
 		extras = code->co_nlocals + ncells + nfrees;
@@ -652,10 +674,10 @@
 	}
 	f->f_stacktop = f->f_valuestack;
 	f->f_builtins = builtins;
-	Py_XINCREF(back);
+	Py_XINCREF_PS(back);
 	f->f_back = back;
-	Py_INCREF(code);
-	Py_INCREF(globals);
+	Py_INCREF_PS(code);
+	Py_INCREF_PS(globals);
 	f->f_globals = globals;
 	/* Most functions have CO_NEWLOCALS and CO_OPTIMIZED set. */
 	if ((code->co_flags & (CO_NEWLOCALS | CO_OPTIMIZED)) ==
@@ -664,7 +686,7 @@
 	else if (code->co_flags & CO_NEWLOCALS) {
 		locals = PyDict_New();
 		if (locals == NULL) {
-			Py_DECREF(f);
+			Py_DECREF_PS(f);
 			return NULL;
 		}
 		f->f_locals = locals;
@@ -672,16 +694,15 @@
 	else {
 		if (locals == NULL)
 			locals = globals;
-		Py_INCREF(locals);
+		Py_INCREF_PS(locals);
 		f->f_locals = locals;
 	}
-	f->f_tstate = tstate;
+	f->f_pystate = pystate;
 
 	f->f_lasti = -1;
 	f->f_lineno = code->co_firstlineno;
 	f->f_iblock = 0;
 
-	_PyObject_GC_TRACK(f);
 	return f;
 }
 
@@ -900,16 +921,20 @@
 int
 PyFrame_ClearFreeList(void)
 {
+#ifdef USE_FRAME_FREELIST
 	int freelist_size = numfree;
-	
+
 	while (free_list != NULL) {
 		PyFrameObject *f = free_list;
 		free_list = free_list->f_back;
-		PyObject_GC_Del(f);
+		PyObject_Del(f);
 		--numfree;
 	}
 	assert(numfree == 0);
 	return freelist_size;
+#else
+	return 0;
+#endif
 }
 
 void

=== modified file 'Objects/funcobject.c'
--- Objects/funcobject.c	2007-12-19 02:45:37 +0000
+++ Objects/funcobject.c	2008-03-24 04:28:03 +0000
@@ -9,8 +9,7 @@
 PyObject *
 PyFunction_New(PyObject *code, PyObject *globals)
 {
-	PyFunctionObject *op = PyObject_GC_New(PyFunctionObject,
-					    &PyFunction_Type);
+	PyFunctionObject *op = PyObject_New(&PyFunction_Type);
 	static PyObject *__name__ = 0;
 	if (op != NULL) {
 		PyObject *doc;
@@ -50,15 +49,14 @@
 				return NULL;
 			}
 		}
-		module = PyDict_GetItem(globals, __name__);
-		if (module) {
-		    Py_INCREF(module);
-		    op->func_module = module;
+		if (PyDict_GetItemEx(globals, __name__, &module) < 0) {
+			Py_DECREF(op);
+			return NULL;
 		}
+		op->func_module = module;
 	}
 	else
 		return NULL;
-	_PyObject_GC_TRACK(op);
 	return (PyObject *)op;
 }
 
@@ -549,9 +547,6 @@
 static void
 func_dealloc(PyFunctionObject *op)
 {
-	_PyObject_GC_UNTRACK(op);
-	if (op->func_weakreflist != NULL)
-		PyObject_ClearWeakRefs((PyObject *) op);
 	Py_DECREF(op->func_code);
 	Py_DECREF(op->func_globals);
 	Py_XDECREF(op->func_module);
@@ -562,7 +557,7 @@
 	Py_XDECREF(op->func_dict);
 	Py_XDECREF(op->func_closure);
 	Py_XDECREF(op->func_annotations);
-	PyObject_GC_Del(op);
+	PyObject_Del(op);
 }
 
 static PyObject*
@@ -650,6 +645,13 @@
 	return PyMethod_New(func, obj);
 }
 
+static int
+func_isshareable(PyFunctionObject *f)
+{
+	/* XXX FIXME this is a bodge.  Shareable should be a flag and result in the usual shareable limitations */
+	return PyObject_IsShareable(f->func_globals);
+}
+
 PyTypeObject PyFunction_Type = {
 	PyVarObject_HEAD_INIT(&PyType_Type, 0)
 	"function",
@@ -687,8 +689,14 @@
 	0,					/* tp_descr_set */
 	offsetof(PyFunctionObject, func_dict),	/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	func_new,				/* tp_new */
+	0,					/* tp_is_gc */
+	0,					/* tp_bases */
+	0,					/* tp_mro */
+	0,					/* tp_cache */
+	0,					/* tp_subclasses */
+	0,					/* tp_weaklist */
+	(isshareablefunc)func_isshareable,	/* tp_isshareable */
 };
 
 
@@ -719,9 +727,8 @@
 static void
 cm_dealloc(classmethod *cm)
 {
-	_PyObject_GC_UNTRACK((PyObject *)cm);
 	Py_XDECREF(cm->cm_callable);
-	Py_TYPE(cm)->tp_free((PyObject *)cm);
+	PyObject_Del(cm);
 }
 
 static int
@@ -775,6 +782,12 @@
 	return 0;
 }
 
+static int
+cm_isshareable(classmethod *cm)
+{
+	return PyObject_IsShareable(cm->cm_callable);
+}
+
 PyDoc_STRVAR(classmethod_doc,
 "classmethod(function) -> method\n\
 \n\
@@ -816,7 +829,8 @@
 	PyObject_GenericGetAttr,		/* tp_getattro */
 	0,					/* tp_setattro */
 	0,					/* tp_as_buffer */
-	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |
+		Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_SHAREABLE,
 	classmethod_doc,			/* tp_doc */
 	(traverseproc)cm_traverse,		/* tp_traverse */
 	(inquiry)cm_clear,			/* tp_clear */
@@ -833,16 +847,20 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	cm_init,				/* tp_init */
-	PyType_GenericAlloc,			/* tp_alloc */
 	PyType_GenericNew,			/* tp_new */
-	PyObject_GC_Del,	                /* tp_free */
+	0,					/* tp_is_gc */
+	0,					/* tp_bases */
+	0,					/* tp_mro */
+	0,					/* tp_cache */
+	0,					/* tp_subclasses */
+	0,					/* tp_weaklist */
+	(isshareablefunc)cm_isshareable,	/* tp_isshareable */
 };
 
 PyObject *
 PyClassMethod_New(PyObject *callable)
 {
-	classmethod *cm = (classmethod *)
-		PyType_GenericAlloc(&PyClassMethod_Type, 0);
+	classmethod *cm = PyObject_New(&PyClassMethod_Type);
 	if (cm != NULL) {
 		Py_INCREF(callable);
 		cm->cm_callable = callable;
@@ -875,9 +893,8 @@
 static void
 sm_dealloc(staticmethod *sm)
 {
-	_PyObject_GC_UNTRACK((PyObject *)sm);
 	Py_XDECREF(sm->sm_callable);
-	Py_TYPE(sm)->tp_free((PyObject *)sm);
+	PyObject_Del(sm);
 }
 
 static int
@@ -925,6 +942,12 @@
 	return 0;
 }
 
+static int
+sm_isshareable(staticmethod *sm)
+{
+	return PyObject_IsShareable(sm->sm_callable);
+}
+
 PyDoc_STRVAR(staticmethod_doc,
 "staticmethod(function) -> method\n\
 \n\
@@ -963,7 +986,8 @@
 	PyObject_GenericGetAttr,		/* tp_getattro */
 	0,					/* tp_setattro */
 	0,					/* tp_as_buffer */
-	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |
+		Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_SHAREABLE,
 	staticmethod_doc,			/* tp_doc */
 	(traverseproc)sm_traverse,		/* tp_traverse */
 	(inquiry)sm_clear,			/* tp_clear */
@@ -980,16 +1004,20 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	sm_init,				/* tp_init */
-	PyType_GenericAlloc,			/* tp_alloc */
 	PyType_GenericNew,			/* tp_new */
-	PyObject_GC_Del,           		/* tp_free */
+	0,					/* tp_is_gc */
+	0,					/* tp_bases */
+	0,					/* tp_mro */
+	0,					/* tp_cache */
+	0,					/* tp_subclasses */
+	0,					/* tp_weaklist */
+	(isshareablefunc)sm_isshareable,	/* tp_isshareable */
 };
 
 PyObject *
 PyStaticMethod_New(PyObject *callable)
 {
-	staticmethod *sm = (staticmethod *)
-		PyType_GenericAlloc(&PyStaticMethod_Type, 0);
+	staticmethod *sm = PyObject_New(&PyStaticMethod_Type);
 	if (sm != NULL) {
 		Py_INCREF(callable);
 		sm->sm_callable = callable;

=== modified file 'Objects/genobject.c'
--- Objects/genobject.c	2008-01-27 15:18:18 +0000
+++ Objects/genobject.c	2008-03-24 04:28:03 +0000
@@ -18,33 +18,22 @@
 static void
 gen_dealloc(PyGenObject *gen)
 {
-	PyObject *self = (PyObject *) gen;
-
-	_PyObject_GC_UNTRACK(gen);
-
-	if (gen->gi_weakreflist != NULL)
-		PyObject_ClearWeakRefs(self);
-
-	_PyObject_GC_TRACK(self);
-
 	if (gen->gi_frame != NULL && gen->gi_frame->f_stacktop != NULL) {
-		/* Generator is paused, so we need to close */
-		Py_TYPE(gen)->tp_del(self);
-		if (self->ob_refcnt > 0)
-			return;		/* resurrected.  :( */
+		/* XXX We should require all generators with "try"
+		 * blocks to be bound to the stack before first running
+		 * them, making this impossible. */
+#warning XXX FIXME paused generators are deleted without closing
 	}
 
-	_PyObject_GC_UNTRACK(self);
 	Py_CLEAR(gen->gi_frame);
-	Py_CLEAR(gen->gi_code);
-	PyObject_GC_Del(gen);
+	PyObject_Del(gen);
 }
 
 
 static PyObject *
 gen_send_ex(PyGenObject *gen, PyObject *arg, int exc)
 {
-	PyThreadState *tstate = PyThreadState_GET();
+	PyState *pystate = PyState_Get();
 	PyFrameObject *f = gen->gi_frame;
 	PyObject *result;
 
@@ -76,9 +65,9 @@
 
 	/* Generators always return to their most recent caller, not
 	 * necessarily their creator. */
-	Py_XINCREF(tstate->frame);
+	Py_XINCREF(pystate->frame);
 	assert(f->f_back == NULL);
-	f->f_back = tstate->frame;
+	f->f_back = pystate->frame;
 
 	gen->gi_running = 1;
 	result = PyEval_EvalFrameEx(f, exc);
@@ -87,7 +76,7 @@
 	/* Don't keep the reference to f_back any longer than necessary.  It
 	 * may keep a chain of frames alive or it could create a reference
 	 * cycle. */
-	assert(f->f_back == tstate->frame);
+	assert(f->f_back == pystate->frame);
 	Py_CLEAR(f->f_back);
 
 	/* If the generator just returned (as opposed to yielding), signal
@@ -144,67 +133,6 @@
 	return NULL;
 }
 
-static void
-gen_del(PyObject *self)
-{
-        PyObject *res;
-        PyObject *error_type, *error_value, *error_traceback;
-	PyGenObject *gen = (PyGenObject *)self;
-
-	if (gen->gi_frame == NULL || gen->gi_frame->f_stacktop == NULL)
-		/* Generator isn't paused, so no need to close */
-		return;
-
-        /* Temporarily resurrect the object. */
-        assert(self->ob_refcnt == 0);
-        self->ob_refcnt = 1;
-
-        /* Save the current exception, if any. */
-        PyErr_Fetch(&error_type, &error_value, &error_traceback);
-
-	res = gen_close(gen, NULL);
-
-	if (res == NULL)
-		PyErr_WriteUnraisable(self);
-	else
-		Py_DECREF(res);
-
-        /* Restore the saved exception. */
-        PyErr_Restore(error_type, error_value, error_traceback);
-
-        /* Undo the temporary resurrection; can't use DECREF here, it would
-         * cause a recursive call.
-         */
-        assert(self->ob_refcnt > 0);
-        if (--self->ob_refcnt == 0)
-                return; /* this is the normal path out */
-
-        /* close() resurrected it!  Make it look like the original Py_DECREF
-         * never happened.
-         */
-        {
-                Py_ssize_t refcnt = self->ob_refcnt;
-                _Py_NewReference(self);
-                self->ob_refcnt = refcnt;
-        }
-        assert(PyType_IS_GC(self->ob_type) &&
-               _Py_AS_GC(self)->gc.gc_refs != _PyGC_REFS_UNTRACKED);
-
-        /* If Py_REF_DEBUG, _Py_NewReference bumped _Py_RefTotal, so
-         * we need to undo that. */
-        _Py_DEC_REFTOTAL;
-        /* If Py_TRACE_REFS, _Py_NewReference re-added self to the object
-         * chain, so no more to do there.
-         * If COUNT_ALLOCS, the original decref bumped tp_frees, and
-         * _Py_NewReference bumped tp_allocs:  both of those need to be
-         * undone.
-         */
-#ifdef COUNT_ALLOCS
-        --self->ob_type->tp_frees;
-        --self->ob_type->tp_allocs;
-#endif
-}
-
 
 
 PyDoc_STRVAR(throw_doc,
@@ -335,22 +263,19 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	0,					/* tp_new */
-	0,					/* tp_free */
 	0,					/* tp_is_gc */
 	0,					/* tp_bases */
 	0,					/* tp_mro */
 	0,					/* tp_cache */
 	0,					/* tp_subclasses */
 	0,					/* tp_weaklist */
-	gen_del,				/* tp_del */
 };
 
 PyObject *
 PyGen_New(PyFrameObject *f)
 {
-	PyGenObject *gen = PyObject_GC_New(PyGenObject, &PyGen_Type);
+	PyGenObject *gen = PyObject_New(&PyGen_Type);
 	if (gen == NULL) {
 		Py_DECREF(f);
 		return NULL;
@@ -360,7 +285,6 @@
 	gen->gi_code = (PyObject *)(f->f_code);
 	gen->gi_running = 0;
 	gen->gi_weakreflist = NULL;
-	_PyObject_GC_TRACK(gen);
 	return (PyObject *)gen;
 }
 

=== modified file 'Objects/iterobject.c'
--- Objects/iterobject.c	2008-03-13 02:09:15 +0000
+++ Objects/iterobject.c	2008-04-11 02:34:27 +0000
@@ -17,22 +17,20 @@
 		PyErr_BadInternalCall();
 		return NULL;
 	}	
-	it = PyObject_GC_New(seqiterobject, &PySeqIter_Type);
+	it = PyObject_New(&PySeqIter_Type);
 	if (it == NULL)
 		return NULL;
 	it->it_index = 0;
 	Py_INCREF(seq);
 	it->it_seq = seq;
-	_PyObject_GC_TRACK(it);
 	return (PyObject *)it;
 }
 
 static void
 iter_dealloc(seqiterobject *it)
 {
-	_PyObject_GC_UNTRACK(it);
 	Py_XDECREF(it->it_seq);
-	PyObject_GC_Del(it);
+	PyObject_Del(it);
 }
 
 static int
@@ -138,23 +136,21 @@
 PyCallIter_New(PyObject *callable, PyObject *sentinel)
 {
 	calliterobject *it;
-	it = PyObject_GC_New(calliterobject, &PyCallIter_Type);
+	it = PyObject_New(&PyCallIter_Type);
 	if (it == NULL)
 		return NULL;
 	Py_INCREF(callable);
 	it->it_callable = callable;
 	Py_INCREF(sentinel);
 	it->it_sentinel = sentinel;
-	_PyObject_GC_TRACK(it);
 	return (PyObject *)it;
 }
 static void
 calliter_dealloc(calliterobject *it)
 {
-	_PyObject_GC_UNTRACK(it);
 	Py_XDECREF(it->it_callable);
 	Py_XDECREF(it->it_sentinel);
-	PyObject_GC_Del(it);
+	PyObject_Del(it);
 }
 
 static int

=== modified file 'Objects/listobject.c'
--- Objects/listobject.c	2008-03-14 13:28:59 +0000
+++ Objects/listobject.c	2008-04-11 02:07:13 +0000
@@ -1,6 +1,7 @@
 /* List object implementation */
 
 #include "Python.h"
+#include "pythread.h"
 
 #ifdef STDC_HEADERS
 #include <stddef.h>
@@ -63,6 +64,7 @@
 	return 0;
 }
 
+#ifdef USE_LIST_FREELIST
 /* Debug statistic to compare allocations with reuse through the free list */
 #undef SHOW_ALLOC_COUNT
 #ifdef SHOW_ALLOC_COUNT
@@ -87,17 +89,34 @@
 #endif
 static PyListObject *free_list[PyList_MAXFREELIST];
 static int numfree = 0;
+static PyThread_type_lock *free_lists_lock;
+#endif
+
+void
+_PyList_Init(void)
+{
+#ifdef USE_LIST_FREELIST
+	free_lists_lock = PyThread_lock_allocate();
+	if (!free_lists_lock)
+		Py_FatalError("unable to allocate lock");
+#endif
+}
 
 void
 PyList_Fini(void)
 {
+#ifdef USE_LIST_FREELIST
 	PyListObject *op;
 
 	while (numfree) {
 		op = free_list[--numfree];
 		assert(PyList_CheckExact(op));
-		PyObject_GC_Del(op);
+		PyObject_Del(op);
 	}
+
+	PyThread_lock_free(free_lists_lock);
+	free_lists_lock = NULL;
+#endif
 }
 
 PyObject *
@@ -121,21 +140,28 @@
 	/* Check for overflow */
 	if (nbytes / sizeof(PyObject *) != (size_t)size)
 		return PyErr_NoMemory();
+#ifdef USE_LIST_FREELIST
+	PyThread_lock_acquire(free_lists_lock);
 	if (numfree) {
 		numfree--;
 		op = free_list[numfree];
-		_Py_NewReference((PyObject *)op);
+		PyThread_lock_release(free_lists_lock);
+		//_Py_NewReference((PyObject *)op);
 #ifdef SHOW_ALLOC_COUNT
 		count_reuse++;
 #endif
 	} else {
-		op = PyObject_GC_New(PyListObject, &PyList_Type);
+		PyThread_lock_release(free_lists_lock);
+#endif
+		op = PyObject_New(&PyList_Type);
 		if (op == NULL)
 			return NULL;
+#ifdef USE_LIST_FREELIST
 #ifdef SHOW_ALLOC_COUNT
 		count_alloc++;
 #endif
 	}
+#endif
 	if (size <= 0)
 		op->ob_item = NULL;
 	else {
@@ -148,7 +174,7 @@
 	}
 	Py_SIZE(op) = size;
 	op->allocated = size;
-	_PyObject_GC_TRACK(op);
+
 	return (PyObject *) op;
 }
 
@@ -284,8 +310,6 @@
 list_dealloc(PyListObject *op)
 {
 	Py_ssize_t i;
-	PyObject_GC_UnTrack(op);
-	Py_TRASHCAN_SAFE_BEGIN(op)
 	if (op->ob_item != NULL) {
 		/* Do it backwards, for Christian Tismer.
 		   There's a simple test case where somehow this reduces
@@ -297,11 +321,18 @@
 		}
 		PyMem_FREE(op->ob_item);
 	}
-	if (numfree < PyList_MAXFREELIST && PyList_CheckExact(op))
+#ifdef USE_LIST_FREELIST
+	PyThread_lock_acquire(free_lists_lock);
+	if (numfree < PyList_MAXFREELIST && PyList_CheckExact(op)) {
 		free_list[numfree++] = op;
-	else
-		Py_TYPE(op)->tp_free((PyObject *)op);
-	Py_TRASHCAN_SAFE_END(op)
+		PyThread_lock_release(free_lists_lock);
+	} else {
+		PyThread_lock_release(free_lists_lock);
+#endif
+		PyObject_Del(op);
+#ifdef USE_LIST_FREELIST
+	}
+#endif
 }
 
 static PyObject *
@@ -1816,7 +1847,7 @@
 {
 	sortwrapperobject *so;
 
-	so = PyObject_New(sortwrapperobject, &PySortWrapper_Type);
+	so = PyObject_New(&PySortWrapper_Type);
 	if (so == NULL)
 		return NULL;
 	so->key = key;
@@ -2228,7 +2259,7 @@
 	if (!PyArg_ParseTupleAndKeywords(args, kw, "|O:list", kwlist, &arg))
 		return -1;
 
-	/* Verify list invariants established by PyType_GenericAlloc() */
+	/* Verify list invariants established by PyObject_New() */
 	assert(0 <= Py_SIZE(self));
 	assert(Py_SIZE(self) <= self->allocated || self->allocated == -1);
 	assert(self->ob_item != NULL ||
@@ -2547,7 +2578,8 @@
 	0,					/* tp_setattro */
 	0,					/* tp_as_buffer */
 	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
-		Py_TPFLAGS_BASETYPE | Py_TPFLAGS_LIST_SUBCLASS,	/* tp_flags */
+		Py_TPFLAGS_BASETYPE | Py_TPFLAGS_LIST_SUBCLASS |
+		Py_TPFLAGS_SHAREABLE,		/* tp_flags */
  	list_doc,				/* tp_doc */
  	(traverseproc)list_traverse,		/* tp_traverse */
  	(inquiry)list_clear,			/* tp_clear */
@@ -2564,9 +2596,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	(initproc)list_init,			/* tp_init */
-	PyType_GenericAlloc,			/* tp_alloc */
 	PyType_GenericNew,			/* tp_new */
-	PyObject_GC_Del,			/* tp_free */
 };
 
 
@@ -2634,22 +2664,20 @@
 		PyErr_BadInternalCall();
 		return NULL;
 	}
-	it = PyObject_GC_New(listiterobject, &PyListIter_Type);
+	it = PyObject_New(&PyListIter_Type);
 	if (it == NULL)
 		return NULL;
 	it->it_index = 0;
 	Py_INCREF(seq);
 	it->it_seq = (PyListObject *)seq;
-	_PyObject_GC_TRACK(it);
 	return (PyObject *)it;
 }
 
 static void
 listiter_dealloc(listiterobject *it)
 {
-	_PyObject_GC_UNTRACK(it);
 	Py_XDECREF(it->it_seq);
-	PyObject_GC_Del(it);
+	PyObject_Del(it);
 }
 
 static int
@@ -2750,23 +2778,21 @@
 {
 	listreviterobject *it;
 
-	it = PyObject_GC_New(listreviterobject, &PyListRevIter_Type);
+	it = PyObject_New(&PyListRevIter_Type);
 	if (it == NULL)
 		return NULL;
 	assert(PyList_Check(seq));
 	it->it_index = PyList_GET_SIZE(seq) - 1;
 	Py_INCREF(seq);
 	it->it_seq = seq;
-	PyObject_GC_Track(it);
 	return (PyObject *)it;
 }
 
 static void
 listreviter_dealloc(listreviterobject *it)
 {
-	PyObject_GC_UnTrack(it);
 	Py_XDECREF(it->it_seq);
-	PyObject_GC_Del(it);
+	PyObject_Del(it);
 }
 
 static int

=== modified file 'Objects/longobject.c'
--- Objects/longobject.c	2008-03-28 10:53:29 +0000
+++ Objects/longobject.c	2008-03-24 04:28:03 +0000
@@ -52,7 +52,7 @@
 /* If a freshly-allocated long is already shared, it must
    be a small integer, so negating it must go to PyLong_FromLong */
 #define NEGATE(x) \
-	do if (Py_REFCNT(x) == 1) Py_SIZE(x) = -Py_SIZE(x);  \
+	do if (Py_RefcntMatches(x, 1)) Py_SIZE(x) = -Py_SIZE(x);  \
 	   else { PyObject* tmp=PyLong_FromLong(-MEDIUM_VALUE(x));  \
 		   Py_DECREF(x); (x) = (PyLongObject*)tmp; }	   \
         while(0)
@@ -83,12 +83,6 @@
 static PyLongObject *muladd1(PyLongObject *, wdigit, wdigit);
 static PyLongObject *divrem1(PyLongObject *, digit, digit *);
 
-#define SIGCHECK(PyTryBlock) \
-	if (--_Py_Ticker < 0) { \
-		_Py_Ticker = _Py_CheckInterval; \
-		if (PyErr_CheckSignals()) PyTryBlock \
-	}
-
 /* Normalize (remove leading zeros from) a long int object.
    Doesn't attempt to free the storage--in most cases, due to the nature
    of the algorithms used, this could save at most be one word anyway. */
@@ -112,7 +106,7 @@
 PyLongObject *
 _PyLong_New(Py_ssize_t size)
 {
-	PyLongObject *result;
+	//PyLongObject *result;
 	/* Can't use sizeof(PyLongObject) here, since the
 	   compiler takes padding at the end into account.
 	   As the consequence, this would waste 2 bytes on
@@ -120,13 +114,18 @@
 	   This computation would be incorrect on systems
 	   which have padding before the digits; with 16-bit
 	   digits this should not happen. */
-	result = PyObject_MALLOC(sizeof(PyVarObject) + 
-				 size*sizeof(digit));
-	if (!result) {
-		PyErr_NoMemory();
-		return NULL;
-	}
-	return (PyLongObject*)PyObject_INIT_VAR(result, &PyLong_Type, size);
+	//result = PyObject_MALLOC(sizeof(PyVarObject) + 
+	//			 size*sizeof(digit));
+	//result = (PyLongObject *) _PyObject_GC_Malloc(sizeof(PyVarObject) +
+	//		size * sizeof(digit));
+	/* XXX FIXME _PyObject_GC_Malloc already calls PyErr_NoMemory */
+	//if (!result) {
+	//	PyErr_NoMemory();
+	//	return NULL;
+	//}
+	//return (PyLongObject*)PyObject_INIT_VAR(result, &PyLong_Type, size);
+	/* XXX FIXME reduce extra size somehow */
+	return PyObject_NewVar(&PyLong_Type, size);
 }
 
 PyObject *
@@ -166,6 +165,15 @@
 
 	CHECK_SMALL_INT(ival);
 
+#if 0
+	{
+		static AO_t count;
+		AO_t cur = AO_fetch_and_add1_full(&count);
+		if ((cur % 100) == 0)
+			printf("count: %llu\n", (unsigned long long)cur);
+	}
+#endif
+
 	if (ival < 0) {
 		ival = -ival;
 		sign = -1;
@@ -1512,11 +1520,11 @@
 			pin = scratch->ob_digit; /* no need to use a again */
 			if (pin[size - 1] == 0)
 				--size;
-			SIGCHECK({
+			if (PyState_Tick()) {
 				Py_DECREF(scratch);
 				Py_DECREF(str);
 				return NULL;
-			})
+			}
 
 			/* Break rem into digits. */
 			assert(ntostore > 0);
@@ -2041,7 +2049,7 @@
 	}
 
 	assert(size_v >= size_w && size_w > 1); /* Assert checks by div() */
-	assert(Py_REFCNT(v) == 1); /* Since v will be used as accumulator! */
+	assert(Py_RefcntMatches(v, 1)); /* Since v will be used as accumulator! */
 	assert(size_w == ABS(Py_SIZE(w))); /* That's how d was calculated */
 
 	size_v = ABS(Py_SIZE(v));
@@ -2054,11 +2062,11 @@
 		stwodigits carry = 0;
 		int i;
 
-		SIGCHECK({
+		if (PyState_Tick()) {
 			Py_DECREF(a);
 			a = NULL;
 			break;
-		})
+		}
 		if (vj == w->ob_digit[size_w-1])
 			q = PyLong_MASK;
 		else
@@ -2127,7 +2135,7 @@
 static void
 long_dealloc(PyObject *v)
 {
-	Py_TYPE(v)->tp_free(v);
+	PyObject_Del(v);
 }
 
 static PyObject *
@@ -2394,10 +2402,10 @@
 			digit *pa = a->ob_digit + i + 1;
 			digit *paend = a->ob_digit + size_a;
 
-			SIGCHECK({
+			if (PyState_Tick()) {
 				Py_DECREF(z);
 				return NULL;
-			})
+			}
 
 			carry = *pz + f * f;
 			*pz++ = (digit)(carry & PyLong_MASK);
@@ -2432,10 +2440,10 @@
 			digit *pb = b->ob_digit;
 			digit *pbend = b->ob_digit + size_b;
 
-			SIGCHECK({
+			if (PyState_Tick()) {
 				Py_DECREF(z);
 				return NULL;
-			})
+			}
 
 			while (pb < pbend) {
 				carry += *pz + *pb++ * f;
@@ -3509,7 +3517,7 @@
 	n = Py_SIZE(tmp);
 	if (n < 0)
 		n = -n;
-	newobj = (PyLongObject *)type->tp_alloc(type, n);
+	newobj = PyObject_NewVar(type, n);
 	if (newobj == NULL) {
 		Py_DECREF(tmp);
 		return NULL;
@@ -3533,6 +3541,12 @@
 	return PyLong_FromLong((Py_intptr_t)context);
 }
 
+static int
+long_isshareable (PyObject *v)
+{
+	return PyLong_CheckExact(v);
+}
+
 static PyObject *
 long__format__(PyObject *self, PyObject *args)
 {
@@ -3679,7 +3693,8 @@
 	0,					/* tp_setattro */
 	0,					/* tp_as_buffer */
 	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |
-		Py_TPFLAGS_LONG_SUBCLASS,	/* tp_flags */
+		Py_TPFLAGS_LONG_SUBCLASS |
+		Py_TPFLAGS_SHAREABLE,		/* tp_flags */
 	long_doc,				/* tp_doc */
 	0,					/* tp_traverse */
 	0,					/* tp_clear */
@@ -3696,40 +3711,29 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	long_new,				/* tp_new */
-	PyObject_Del,                           /* tp_free */
+	0,					/* tp_is_gc */
+	0,					/* tp_bases */
+	0,					/* tp_mro */
+	0,					/* tp_cache */
+	0,					/* tp_subclasses */
+	0,					/* tp_weaklist */
+	long_isshareable,			/* tp_isshareable */
 };
 
+static const PyLongObject dummy = 
+	{PyVarObject_HEAD_INIT_NOCOMMA(&PyLong_Type, 0)};
+
 int
 _PyLong_Init(void)
 {
 #if NSMALLNEGINTS + NSMALLPOSINTS > 0
-	int ival, size;
+	int ival;
 	PyLongObject *v = small_ints;
-
 	for (ival = -NSMALLNEGINTS; ival <  NSMALLPOSINTS; ival++, v++) {
-		size = (ival < 0) ? -1 : ((ival == 0) ? 0 : 1);
-		if (Py_TYPE(v) == &PyLong_Type) {
-			/* The element is already initialized, most likely
-			 * the Python interpreter was initialized before.
-			 */
-			Py_ssize_t refcnt;
-			PyObject* op = (PyObject*)v;
-
-			refcnt = Py_REFCNT(op) < 0 ? 0 : Py_REFCNT(op);
-			_Py_NewReference(op);
-			/* _Py_NewReference sets the ref count to 1 but
-			 * the ref count might be larger. Set the refcnt
-			 * to the original refcnt + 1 */	 
-			Py_REFCNT(op) = refcnt + 1;
-			assert(Py_SIZE(op) == size);
-			assert(v->ob_digit[0] == abs(ival));
-		}
-		else {
-			PyObject_INIT(v, &PyLong_Type);
-		}
-		Py_SIZE(v) = size;
+		*v = dummy;
+		Py_SIZE(v) = (ival < 0) ? -1 : ((ival == 0) ? 0 : 1);
+		v->ob_digit[0] = -ival;
 		v->ob_digit[0] = abs(ival);
 	}
 #endif
@@ -3739,15 +3743,4 @@
 void
 PyLong_Fini(void)
 {
-	/* Integers are currently statically allocated. Py_DECREF is not
-	   needed, but Python must forget about the reference or multiple
-	   reinitializations will fail. */
-#if NSMALLNEGINTS + NSMALLPOSINTS > 0
-	int i;
-	PyLongObject *v = small_ints;
-	for (i = 0; i < NSMALLNEGINTS + NSMALLPOSINTS; i++, v++) {
-		_Py_DEC_REFTOTAL;
-		_Py_ForgetReference((PyObject*)v);
-	}
-#endif
 }

=== modified file 'Objects/memoryobject.c'
--- Objects/memoryobject.c	2007-12-02 14:31:20 +0000
+++ Objects/memoryobject.c	2008-03-24 04:28:03 +0000
@@ -31,9 +31,9 @@
 {
 	PyMemoryViewObject *mview;
 
-	mview = (PyMemoryViewObject *)PyObject_New(PyMemoryViewObject,
-						   &PyMemoryView_Type);
-	if (mview == NULL) return NULL;
+	mview = PyObject_New(&PyMemoryView_Type);
+	if (mview == NULL)
+		return NULL;
 	mview->base = NULL;
 	mview->view = *info;
 	return (PyObject *)mview;
@@ -51,8 +51,7 @@
                 return NULL;
         }
 
-        mview = (PyMemoryViewObject *)PyObject_New(PyMemoryViewObject,
-                                                   &PyMemoryView_Type);
+        mview = PyObject_New(&PyMemoryView_Type);
         if (mview == NULL) return NULL;
 
         mview->base = NULL;
@@ -221,7 +220,7 @@
                 return NULL;
         }
 
-        mem = PyObject_New(PyMemoryViewObject, &PyMemoryView_Type);
+        mem = PyObject_New(&PyMemoryView_Type);
         if (mem == NULL) return NULL;
 
         view = &PyMemoryView(mem);
@@ -236,7 +235,7 @@
         }
 
         if (PyObject_GetBuffer(obj, view, flags) != 0) {
-                PyObject_DEL(mem);
+                PyObject_Del(mem);
                 return NULL;
         }
 
@@ -248,7 +247,7 @@
         }
         /* otherwise a copy is needed */
         if (buffertype == PyBUF_WRITE) {
-                PyObject_DEL(mem);
+                PyObject_Del(mem);
                 PyErr_SetString(PyExc_BufferError,
                                 "writable contiguous buffer requested "
                                 "for a non-contiguousobject.");
@@ -432,7 +431,7 @@
             }
             Py_CLEAR(self->base);
         }
-        PyObject_DEL(self);
+        PyObject_Del(self);
 }
 
 static PyObject *
@@ -584,7 +583,7 @@
 	PyObject_GenericGetAttr,		/* tp_getattro */
 	0,					/* tp_setattro */
 	&memory_as_buffer,			/* tp_as_buffer */
-	Py_TPFLAGS_DEFAULT,			/* tp_flags */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_SHAREABLE,	/* tp_flags */
 	memory_doc,				/* tp_doc */
 	0,					/* tp_traverse */
 	0,					/* tp_clear */
@@ -601,6 +600,5 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	memory_new,				/* tp_new */
 };

=== modified file 'Objects/methodobject.c'
--- Objects/methodobject.c	2008-02-16 07:38:31 +0000
+++ Objects/methodobject.c	2008-04-11 03:01:03 +0000
@@ -3,37 +3,47 @@
 
 #include "Python.h"
 #include "structmember.h"
+#include "pythread.h"
 
+#ifdef USE_METHOD_FREELIST
 /* Free list for method objects to safe malloc/free overhead
  * The m_self element is used to chain the objects.
  */
 static PyCFunctionObject *free_list = NULL;
+static PyThread_type_lock *free_list_lock;
 static int numfree = 0;
 #ifndef PyCFunction_MAXFREELIST
 #define PyCFunction_MAXFREELIST 256
 #endif
+#endif
 
 PyObject *
 PyCFunction_NewEx(PyMethodDef *ml, PyObject *self, PyObject *module)
 {
 	PyCFunctionObject *op;
+#ifdef USE_METHOD_FREELIST
+	PyThread_lock_acquire(free_list_lock);
 	op = free_list;
 	if (op != NULL) {
 		free_list = (PyCFunctionObject *)(op->m_self);
+		PyThread_lock_release(free_list_lock);
 		PyObject_INIT(op, &PyCFunction_Type);
 		numfree--;
 	}
 	else {
-		op = PyObject_GC_New(PyCFunctionObject, &PyCFunction_Type);
+		PyThread_lock_release(free_list_lock);
+#endif
+		op = PyObject_New(&PyCFunction_Type);
 		if (op == NULL)
 			return NULL;
+#ifdef USE_METHOD_FREELIST
 	}
+#endif
 	op->m_ml = ml;
 	Py_XINCREF(self);
 	op->m_self = self;
 	Py_XINCREF(module);
 	op->m_module = module;
-	_PyObject_GC_TRACK(op);
 	return (PyObject *)op;
 }
 
@@ -75,7 +85,8 @@
 	PyObject *self = PyCFunction_GET_SELF(func);
 	Py_ssize_t size;
 
-	switch (PyCFunction_GET_FLAGS(func) & ~(METH_CLASS | METH_STATIC | METH_COEXIST)) {
+	switch (PyCFunction_GET_FLAGS(func) & ~(METH_CLASS | METH_STATIC |
+			METH_COEXIST | METH_SHARED)) {
 	case METH_VARARGS:
 		if (kw == NULL || PyDict_Size(kw) == 0)
 			return (*meth)(self, arg);
@@ -121,17 +132,23 @@
 static void
 meth_dealloc(PyCFunctionObject *m)
 {
-	_PyObject_GC_UNTRACK(m);
 	Py_XDECREF(m->m_self);
 	Py_XDECREF(m->m_module);
+#ifdef USE_METHOD_FREELIST
+	PyThread_lock_acquire(free_list_lock);
 	if (numfree < PyCFunction_MAXFREELIST) {
 		m->m_self = (PyObject *)free_list;
 		free_list = m;
 		numfree++;
+		PyThread_lock_release(free_list_lock);
 	}
 	else {
-		PyObject_GC_Del(m);
+		PyThread_lock_release(free_list_lock);
+		PyObject_Del(m);
 	}
+#else
+	PyObject_Del(m);
+#endif
 }
 
 static PyObject *
@@ -244,6 +261,14 @@
 	return x;
 }
 
+static int
+meth_isshareable(PyCFunctionObject *a)
+{
+	if (a->m_ml->ml_flags & METH_SHARED)
+		return 1;
+	return 0;
+}
+
 
 PyTypeObject PyCFunction_Type = {
 	PyVarObject_HEAD_INIT(&PyType_Type, 0)
@@ -278,6 +303,18 @@
 	meth_getsets,				/* tp_getset */
 	0,					/* tp_base */
 	0,					/* tp_dict */
+	0,					/* tp_descr_get */
+	0,					/* tp_descr_set */
+	0,					/* tp_dictoffset */
+	0,					/* tp_init */
+	0,					/* tp_new */
+	0,					/* tp_is_gc */
+	0,					/* tp_bases */
+	0,					/* tp_mro */
+	0,					/* tp_cache */
+	0,					/* tp_subclasses */
+	0,					/* tp_weaklist */
+	(isshareablefunc)meth_isshareable,	/* tp_isshareable */
 };
 
 /* Find a method in a method chain */
@@ -317,21 +354,36 @@
 	return Py_FindMethodInChain(&chain, self, name);
 }
 
+void
+_PyCFunction_Init(void)
+{
+#ifdef USE_METHOD_FREELIST
+	free_list_lock = PyThread_lock_allocate();
+	if (!free_list_lock)
+		Py_FatalError("unable to allocate lock");
+#endif
+}
+
 /* Clear out the free list */
 
 int
 PyCFunction_ClearFreeList(void)
 {
+#ifdef USE_METHOD_FREELIST
 	int freelist_size = numfree;
 	
 	while (free_list) {
 		PyCFunctionObject *v = free_list;
 		free_list = (PyCFunctionObject *)(v->m_self);
-		PyObject_GC_Del(v);
+		PyObject_Del(v);
 		numfree--;
 	}
+
 	assert(numfree == 0);
 	return freelist_size;
+#else
+	return 0;
+#endif
 }
 
 void

=== modified file 'Objects/moduleobject.c'
--- Objects/moduleobject.c	2007-12-19 02:45:37 +0000
+++ Objects/moduleobject.c	2008-03-24 04:28:03 +0000
@@ -17,13 +17,22 @@
 PyObject *
 PyModule_New(const char *name)
 {
+	return PyModule_NewEx(name, 0);
+}
+
+PyObject *
+PyModule_NewEx(const char *name, int shared)
+{
 	PyModuleObject *m;
 	PyObject *nameobj;
-	m = PyObject_GC_New(PyModuleObject, &PyModule_Type);
+	m = PyObject_New(&PyModule_Type);
 	if (m == NULL)
 		return NULL;
 	nameobj = PyUnicode_FromString(name);
-	m->md_dict = PyDict_New();
+	if (shared)
+		m->md_dict = PyObject_CallObject((PyObject *)&PySharedDict_Type, NULL);
+	else
+		m->md_dict = PyDict_New();
 	if (m->md_dict == NULL || nameobj == NULL)
 		goto fail;
 	if (PyDict_SetItemString(m->md_dict, "__name__", nameobj) != 0)
@@ -33,7 +42,6 @@
 	if (PyDict_SetItemString(m->md_dict, "__package__", Py_None) != 0)
 		goto fail;
 	Py_DECREF(nameobj);
-	PyObject_GC_Track(m);
 	return (PyObject *)m;
 
  fail:
@@ -61,19 +69,22 @@
 {
 	PyObject *d;
 	PyObject *nameobj;
+	const char *retval;
 	if (!PyModule_Check(m)) {
 		PyErr_BadArgument();
 		return NULL;
 	}
 	d = ((PyModuleObject *)m)->md_dict;
-	if (d == NULL ||
-	    (nameobj = PyDict_GetItemString(d, "__name__")) == NULL ||
-	    !PyUnicode_Check(nameobj))
-	{
+	if (d == NULL || PyDict_GetItemStringEx(d, "__name__", &nameobj) > 0) {
 		PyErr_SetString(PyExc_SystemError, "nameless module");
 		return NULL;
 	}
-	return PyUnicode_AsString(nameobj);
+	if (nameobj == NULL)
+		return NULL;
+	retval = PyUnicode_AsString(nameobj);
+	Py_DECREF(nameobj);
+#warning XXX FIXME PyModule_GetName is racey (not thread-safe)
+	return retval;
 }
 
 const char *
@@ -116,7 +127,7 @@
 
 	/* First, clear only names starting with a single underscore */
 	pos = 0;
-	while (PyDict_Next(d, &pos, &key, &value)) {
+	while (PyDict_NextEx(d, &pos, &key, &value)) {
 		if (value != Py_None && PyUnicode_Check(key)) {
 			const char *s = PyUnicode_AsString(key);
 			if (s[0] == '_' && s[1] != '_') {
@@ -125,11 +136,13 @@
 				PyDict_SetItem(d, key, Py_None);
 			}
 		}
+		Py_DECREF(key);
+		Py_DECREF(value);
 	}
 
 	/* Next, clear all names except for __builtins__ */
 	pos = 0;
-	while (PyDict_Next(d, &pos, &key, &value)) {
+	while (PyDict_NextEx(d, &pos, &key, &value)) {
 		if (value != Py_None && PyUnicode_Check(key)) {
 			const char *s = PyUnicode_AsString(key);
 			if (s[0] != '_' || strcmp(s, "__builtins__") != 0) {
@@ -138,6 +151,8 @@
 				PyDict_SetItem(d, key, Py_None);
 			}
 		}
+		Py_DECREF(key);
+		Py_DECREF(value);
 	}
 
 	/* Note: we leave __builtins__ in place, so that destructors
@@ -173,12 +188,12 @@
 static void
 module_dealloc(PyModuleObject *m)
 {
-	PyObject_GC_UnTrack(m);
 	if (m->md_dict != NULL) {
-		_PyModule_Clear((PyObject *)m);
+		// XXX FIXME Not safe during tp_dealloc, and unnecessary anyway?
+		//_PyModule_Clear((PyObject *)m);
 		Py_DECREF(m->md_dict);
 	}
-	Py_TYPE(m)->tp_free((PyObject *)m);
+	PyObject_Del(m);
 }
 
 static PyObject *
@@ -210,6 +225,18 @@
 	return 0;
 }
 
+static int
+module_isshareable(PyModuleObject *m)
+{
+#warning XXX FIXME HACK pretending certain modules are shareable
+	const char *name = PyModule_GetName((PyObject *)m);
+	if (strcmp(name, "sys") == 0 || strcmp(name, "os") == 0 ||
+			strcmp(name, "io") == 0)
+		return 1;
+
+	return PyObject_IsShareable(m->md_dict);
+}
+
 PyDoc_STRVAR(module_doc,
 "module(name[, doc])\n\
 \n\
@@ -237,7 +264,8 @@
 	PyObject_GenericSetAttr,		/* tp_setattro */
 	0,					/* tp_as_buffer */
 	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
-		Py_TPFLAGS_BASETYPE,		/* tp_flags */
+		Py_TPFLAGS_BASETYPE |
+		Py_TPFLAGS_SHAREABLE,		/* tp_flags */
 	module_doc,				/* tp_doc */
 	(traverseproc)module_traverse,		/* tp_traverse */
 	0,					/* tp_clear */
@@ -254,7 +282,12 @@
 	0,					/* tp_descr_set */
 	offsetof(PyModuleObject, md_dict),	/* tp_dictoffset */
 	(initproc)module_init,			/* tp_init */
-	PyType_GenericAlloc,			/* tp_alloc */
 	PyType_GenericNew,			/* tp_new */
-	PyObject_GC_Del,		        /* tp_free */
+	0,					/* tp_is_gc */
+	0,					/* tp_bases */
+	0,					/* tp_mro */
+	0,					/* tp_cache */
+	0,					/* tp_subclasses */
+	0,					/* tp_weaklist */
+	(isshareablefunc)module_isshareable,	/* tp_isshareable */
 };

=== added file 'Objects/monitorobject.c'
--- Objects/monitorobject.c	1970-01-01 00:00:00 +0000
+++ Objects/monitorobject.c	2008-04-09 16:13:08 +0000
@@ -0,0 +1,1712 @@
+
+#include "Python.h"
+#include "ceval.h"
+#include "branchobject.h"
+#include "cancelobject.h"
+#include "monitorobject.h"
+
+static PyObject *PyMonitorSpace_Enter(PyMonitorSpaceObject *self,
+    PyObject *func, PyObject *args, PyObject *kwds, ternaryfunc call2);
+static PyObject *PyMonitorSpace_Leave(PyMonitorSpaceObject *self,
+    PyObject *func, PyObject *args, PyObject *kwds);
+
+static int monitorspace_acquire(PyMonitorSpaceObject *self, int pushing);
+static void monitorspace_release(PyMonitorSpaceObject *self, PyState *give_to);
+
+typedef struct {
+    PyObject_HEAD
+    PyObject *cond_callable;
+} condition;
+
+typedef struct {
+    PyObject_HEAD
+    PyObject *cond;
+    PyObject *monitor;
+    PyLinkedList waiters;
+} boundcondition;
+
+static PyThread_type_lock *deadlock_lock;
+static double deadlock_delay = 1.0;
+
+
+/* MonitorMeta methods */
+static void
+MonitorMeta_dealloc(PyTypeObject *self)
+{
+    PyObject_Del(self);
+}
+
+static PyObject *
+MonitorMeta_call(PyTypeObject *self, PyObject *args, PyObject *kwds)
+{
+    PyObject *monitorspace;
+    PyObject *super;
+    PyObject *nextmethod;
+    PyObject *enter;
+    Py_ssize_t size, i;
+    PyObject *built_args;
+    PyObject *result;
+
+    assert(PyTuple_Check(args));
+
+    /* This can all be summed up as:
+       monitorspace = MonitorSpace()
+       nextmethod = super(MonitorMeta, self).__call__
+       return monitorspace.enter(nextmethod, *args, **kwargs)
+     */
+
+    monitorspace = PyObject_CallObject((PyObject *)&PyMonitorSpace_Type, NULL);
+    if (monitorspace == NULL)
+        return NULL;
+
+    super = PyEval_CallFunction((PyObject *)&PySuper_Type, "OO",
+        &PyMonitorMeta_Type, self);
+    if (super == NULL) {
+        Py_DECREF(monitorspace);
+        return NULL;
+    }
+
+    nextmethod = PyObject_GetAttrString(super, "__call__");
+    Py_DECREF(super);
+    if (nextmethod == NULL) {
+        Py_DECREF(monitorspace);
+        return NULL;
+    }
+
+    size = PyTuple_Size(args) + 1;
+    built_args = PyTuple_New(size);
+    if (built_args == NULL) {
+        Py_DECREF(monitorspace);
+        Py_DECREF(nextmethod);
+        return NULL;
+    }
+    PyTuple_SET_ITEM(built_args, 0, nextmethod); /* Steals our reference */
+    nextmethod = NULL;
+    for (i = 1; i < size; i++) {
+        PyObject *item = PyTuple_GET_ITEM(args, i-1);
+        Py_INCREF(item);
+        PyTuple_SET_ITEM(built_args, i, item);
+    }
+
+    enter = PyObject_GetAttrString(monitorspace, "enter");
+    if (enter == NULL) {
+        Py_DECREF(monitorspace);
+        Py_DECREF(built_args);
+        return NULL;
+    }
+
+    result = PyEval_CallObjectWithKeywords(enter, built_args, kwds);
+
+    Py_DECREF(monitorspace);
+    Py_DECREF(built_args);
+    Py_DECREF(enter);
+
+    return result;
+}
+
+static int
+MonitorMeta_traverse(PyTypeObject *self, visitproc visit, void *arg)
+{
+    return 0;
+}
+
+PyTypeObject PyMonitorMeta_Type = {
+    PyVarObject_HEAD_INIT(&PyType_Type, 0)
+    "_threadtoolsmodule.MonitorMeta",       /*tp_name*/
+    sizeof(PyHeapTypeObject),               /*tp_basicsize*/
+    0/*sizeof(PyMemberDef)*/,               /*tp_itemsize*/
+    (destructor)MonitorMeta_dealloc,        /*tp_dealloc*/
+    0,                                      /*tp_print*/
+    0,                                      /*tp_getattr*/
+    0,                                      /*tp_setattr*/
+    0,                                      /*tp_compare*/
+    0,                                      /*tp_repr*/
+    0,                                      /*tp_as_number*/
+    0,                                      /*tp_as_sequence*/
+    0,                                      /*tp_as_mapping*/
+    0,                                      /*tp_hash*/
+    (ternaryfunc)MonitorMeta_call,          /*tp_call*/
+    0,                                      /*tp_str*/
+    PyObject_GenericGetAttr,                /*tp_getattro*/
+    0,                                      /*tp_setattro*/
+    0,                                      /*tp_as_buffer*/
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
+            Py_TPFLAGS_BASETYPE |
+            Py_TPFLAGS_SHAREABLE,           /*tp_flags*/
+    0,                                      /*tp_doc*/
+    (traverseproc)MonitorMeta_traverse,     /*tp_traverse*/
+    0,                                      /*tp_clear*/
+    0,                                      /*tp_richcompare*/
+    0,                                      /*tp_weaklistoffset*/
+    0,                                      /*tp_iter*/
+    0,                                      /*tp_iternext*/
+    0,                                      /*tp_methods*/
+    0,                                      /*tp_members*/
+    0,                                      /*tp_getset*/
+    0,                                      /*tp_base*/
+    0,                                      /*tp_dict*/
+    0,                                      /*tp_descr_get*/
+    0,                                      /*tp_descr_set*/
+    0,                                      /*tp_dictoffset*/
+    0,                                      /*tp_init*/
+    0,                                      /*tp_new*/
+};
+/* --------------------------------------------------------------------- */
+
+
+/* Monitor methods */
+static void
+Monitor_dealloc(PyMonitorObject *self)
+{
+    PyObject *monitorspace = self->mon_monitorspace;
+    Py_DECREF(self->mon_conditions);
+    PyObject_Del(self);
+    Py_DECREF(monitorspace);
+    assert(self->mon_waking == 0);
+}
+
+/* PyErr_Occurred() should always be used after this */
+static void
+monitor_recheck_conditions(PyMonitorObject *self, boundcondition *skipped_bcond)
+{
+    Py_ssize_t i = 0;
+    PyObject *key, *value, *x;
+    int res;
+
+#warning XXX FIXME monitor_recheck_conditions should be visible in the traceback stack
+
+    if (self->mon_waking)
+        return;
+
+    while (PyDict_NextEx(self->mon_conditions, &i, &key, &value)) {
+        boundcondition *bcond = (boundcondition *)value;
+
+        if (bcond != skipped_bcond && !PyLinkedList_Empty(&bcond->waiters)) {
+            x = PyObject_CallFunction(((condition *)bcond->cond)->cond_callable,
+                "O", self);
+            res = PyObject_IsTrue(x);
+            Py_DECREF(x);
+            if (x < 0) {
+                Py_DECREF(key);
+                Py_DECREF(value);
+                return;
+            } else if (x > 0) {
+                PyState *t = PyLinkedList_First(&bcond->waiters);
+
+                PyThread_flag_set(t->condition_flag);
+                self->mon_waking = 1;
+
+                Py_DECREF(key);
+                Py_DECREF(value);
+                return;
+            }
+        }
+
+        Py_DECREF(key);
+        Py_DECREF(value);
+    }
+}
+
+static int
+Monitor_traverse(PyMonitorObject *self, visitproc visit, void *arg)
+{
+    Py_VISIT(self->mon_monitorspace);
+    Py_VISIT(self->mon_conditions);
+    return 0;
+}
+
+static PyObject *
+Monitor_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
+{
+    PyObject *self;
+
+    assert(type != NULL);
+    self = PyObject_New(type);
+    if (self != NULL) {
+        PyMonitorObject *x = (PyMonitorObject *)self;
+
+        x->mon_monitorspace = PyMonitorSpace_GetCurrent();
+        if (x->mon_monitorspace == NULL) {
+            PyObject_Del(self);
+            return NULL;
+        }
+
+        x->mon_conditions = PyDict_New();
+        if (x->mon_conditions == NULL) {
+            Py_DECREF(x->mon_monitorspace);
+            PyObject_Del(self);
+            return NULL;
+        }
+
+        x->mon_waking = 0;
+    }
+    return self;
+}
+
+static PyObject *
+Monitor_wait(PyMonitorObject *self, PyObject *args, PyObject *kwds)
+{
+    PyMonitorSpaceObject *monitorspace = PyMonitor_GetMonitorSpace(self);
+    PyObject *func;
+    PyObject *smallargs;
+    PyObject *result;
+
+    /* Monitor.wait isn't shareable, so it shouldn't be possible to call
+     * us without being the current monitorspace.  Otherwise we'd have
+     * to raise an exception here. */
+    assert(PyMonitorSpace_IsCurrent(monitorspace));
+
+    monitor_recheck_conditions(self, NULL);
+
+    if (PyTuple_Size(args) < 1) {
+        PyErr_SetString(PyExc_TypeError,
+            "Monitor.__wait__() needs a function to be called");
+        return NULL;
+    }
+
+    func = PyTuple_GetItem(args, 0);
+
+    smallargs = PyTuple_GetSlice(args, 1, PyTuple_Size(args));
+    if (smallargs == NULL) {
+        return NULL;
+    }
+
+    result = PyMonitorSpace_Leave(monitorspace, func, smallargs, kwds);
+    Py_DECREF(smallargs);
+
+    return result;
+}
+
+static int
+Monitor_isshareable (PyObject *self)
+{
+    return 1;
+}
+
+static PyObject *
+Monitor_monitorspace(PyMonitorObject *self, void *context)
+{
+    Py_INCREF(self->mon_monitorspace);
+    return self->mon_monitorspace;
+}
+
+PyDoc_STRVAR(Monitor_wait__doc__, "__wait__(func, *args, **kwargs) -> object");
+
+static PyMethodDef Monitor_methods[] = {
+    {"__wait__", (PyCFunction)Monitor_wait, METH_VARARGS | METH_KEYWORDS,
+        Monitor_wait__doc__},
+    {NULL, NULL}                /* sentinel */
+};
+
+static PyGetSetDef Monitor_getset[] = {
+    {"__monitorspace__", (getter)Monitor_monitorspace, NULL, NULL},
+    {0}
+};
+
+PyTypeObject PyMonitor_Type = {
+    PyVarObject_HEAD_INIT(&PyMonitorMeta_Type, 0)
+    "_threadtoolsmodule.Monitor",           /*tp_name*/
+    sizeof(PyMonitorObject),                /*tp_basicsize*/
+    0,                                      /*tp_itemsize*/
+    (destructor)Monitor_dealloc,            /*tp_dealloc*/
+    0,                                      /*tp_print*/
+    0,                                      /*tp_getattr*/
+    0,                                      /*tp_setattr*/
+    0,                                      /*tp_compare*/
+    0,                                      /*tp_repr*/
+    0,                                      /*tp_as_number*/
+    0,                                      /*tp_as_sequence*/
+    0,                                      /*tp_as_mapping*/
+    0,                                      /*tp_hash*/
+    0,                                      /*tp_call*/
+    0,                                      /*tp_str*/
+    PyObject_GenericGetAttr,                /*tp_getattro*/
+    0,                                      /*tp_setattro*/
+    0,                                      /*tp_as_buffer*/
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
+            Py_TPFLAGS_BASETYPE | Py_TPFLAGS_MONITOR_SUBCLASS |
+            Py_TPFLAGS_SHAREABLE,           /*tp_flags*/
+    0,                                      /*tp_doc*/
+    (traverseproc)Monitor_traverse,         /*tp_traverse*/
+    0,                                      /*tp_clear*/
+    0,                                      /*tp_richcompare*/
+    0,                                      /*tp_weaklistoffset*/
+    0,                                      /*tp_iter*/
+    0,                                      /*tp_iternext*/
+    Monitor_methods,                        /*tp_methods*/
+    0,                                      /*tp_members*/
+    Monitor_getset,                         /*tp_getset*/
+    0,                                      /*tp_base*/
+    0,                                      /*tp_dict*/
+    0,                                      /*tp_descr_get*/
+    0,                                      /*tp_descr_set*/
+    0,                                      /*tp_dictoffset*/
+    0,                                      /*tp_init*/
+    Monitor_new,                            /*tp_new*/
+    0,                                      /*tp_is_gc*/
+    0,                                      /*tp_bases*/
+    0,                                      /*tp_mro*/
+    0,                                      /*tp_cache*/
+    0,                                      /*tp_subclasses*/
+    0,                                      /*tp_weaklist*/
+    Monitor_isshareable,                    /*tp_isshareable*/
+};
+/* --------------------------------------------------------------------- */
+
+
+/* monitormethod methods */
+typedef struct {
+    PyObject_HEAD
+    PyObject *mm_callable;
+} monitormethod;
+
+static void
+mm_dealloc(monitormethod *mm)
+{
+    Py_DECREF(mm->mm_callable);
+    PyObject_Del(mm);
+}
+
+static int
+mm_traverse(monitormethod *mm, visitproc visit, void *arg)
+{
+    Py_VISIT(mm->mm_callable);
+    return 0;
+}
+
+static PyObject *
+mm_descr_get(PyObject *self, PyObject *obj, PyObject *type)
+{
+    monitormethod *mm = (monitormethod *)self;
+
+    return PyBoundMonitorMethod_New(mm->mm_callable, obj);
+}
+
+static PyObject *
+mm_new_common(PyTypeObject *type, PyObject *callable)
+{
+    monitormethod *mm;
+
+    if (!PyCallable_Check(callable)) {
+        PyErr_Format(PyExc_TypeError, "'%s' object is not callable",
+            Py_TYPE(callable)->tp_name);
+        return NULL;
+    }
+
+    mm = PyObject_New(type);
+    if (mm == NULL)
+        return NULL;
+
+    Py_INCREF(callable);
+    mm->mm_callable = callable;
+
+    return (PyObject *)mm;
+}
+
+PyObject *
+PyMonitorMethod_New(PyObject *callable)
+{
+    return mm_new_common(&PyMonitorMethod_Type, callable);
+}
+
+static PyObject *
+mm_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
+{
+    PyObject *callable;
+
+    if (!PyArg_UnpackTuple(args, "monitormethod", 1, 1, &callable))
+        return NULL;
+    if (!_PyArg_NoKeywords("monitormethod", kwds))
+        return NULL;
+
+    return mm_new_common(type, callable);
+}
+
+static int
+mm_isshareable(monitormethod *mm)
+{
+    return PyObject_IsShareable(mm->mm_callable);
+}
+
+PyDoc_STRVAR(monitormethod_doc,
+"monitormethod(function) -> method\n\
+\n\
+Convert a function to be a monitor method.\n\
+\n\
+A monitor method enters the monitor when called.");
+
+PyTypeObject PyMonitorMethod_Type = {
+    PyVarObject_HEAD_INIT(&PyType_Type, 0)
+    "monitormethod",
+    sizeof(monitormethod),
+    0,
+    (destructor)mm_dealloc,                     /* tp_dealloc */
+    0,                                          /* tp_print */
+    0,                                          /* tp_getattr */
+    0,                                          /* tp_setattr */
+    0,                                          /* tp_compare */
+    0,                                          /* tp_repr */
+    0,                                          /* tp_as_number */
+    0,                                          /* tp_as_sequence */
+    0,                                          /* tp_as_mapping */
+    0,                                          /* tp_hash */
+    0,                                          /* tp_call */
+    0,                                          /* tp_str */
+    PyObject_GenericGetAttr,                    /* tp_getattro */
+    0,                                          /* tp_setattro */
+    0,                                          /* tp_as_buffer */
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |
+            Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_SHAREABLE,
+    monitormethod_doc,                          /* tp_doc */
+    (traverseproc)mm_traverse,                  /* tp_traverse */
+    0,                                          /* tp_clear */
+    0,                                          /* tp_richcompare */
+    0,                                          /* tp_weaklistoffset */
+    0,                                          /* tp_iter */
+    0,                                          /* tp_iternext */
+    0,                                          /* tp_methods */
+    0,                                          /* tp_members */
+    0,                                          /* tp_getset */
+    0,                                          /* tp_base */
+    0,                                          /* tp_dict */
+    mm_descr_get,                               /* tp_descr_get */
+    0,                                          /* tp_descr_set */
+    0,                                          /* tp_dictoffset */
+    0,                                          /* tp_init */
+    mm_new,                                     /* tp_new */
+    0,                                          /* tp_is_gc */
+    0,                                          /* tp_bases */
+    0,                                          /* tp_mro */
+    0,                                          /* tp_cache */
+    0,                                          /* tp_subclasses */
+    0,                                          /* tp_weaklist */
+    (isshareablefunc)mm_isshareable,            /* tp_isshareable */
+};
+/* --------------------------------------------------------------------- */
+
+
+/* boundmonitormethod methods */
+typedef struct {
+    PyObject_HEAD
+    PyObject *bmm_callable;
+    PyObject *bmm_self;
+} boundmonitormethod;
+
+static void
+bmm_dealloc(boundmonitormethod *bmm)
+{
+    Py_DECREF(bmm->bmm_callable);
+    Py_DECREF(bmm->bmm_self);
+    PyObject_Del(bmm);
+}
+
+static int
+bmm_traverse(boundmonitormethod *bmm, visitproc visit, void *arg)
+{
+    Py_VISIT(bmm->bmm_callable);
+    Py_VISIT(bmm->bmm_self);
+    return 0;
+}
+
+static PyObject *
+bmm_new_common(PyTypeObject *type, PyObject *callable, PyObject *self)
+{
+    boundmonitormethod *bmm;
+
+    if (!PyCallable_Check(callable)) {
+        PyErr_Format(PyExc_TypeError, "'%s' object is not callable",
+            Py_TYPE(callable)->tp_name);
+        return NULL;
+    }
+    if (!PyMonitor_Check(self)) {
+        PyErr_Format(PyExc_TypeError, "'%s' object is not a Monitor",
+            Py_TYPE(self)->tp_name);
+        return NULL;
+    }
+
+    bmm = PyObject_New(type);
+    if (bmm == NULL)
+        return NULL;
+
+    Py_INCREF(callable);
+    bmm->bmm_callable = callable;
+    Py_INCREF(self);
+    bmm->bmm_self = self;
+
+    return (PyObject *)bmm;
+}
+
+PyObject *
+PyBoundMonitorMethod_New(PyObject *callable, PyObject *self)
+{
+    return bmm_new_common(&PyBoundMonitorMethod_Type, callable, self);
+}
+
+static PyObject *
+bmm_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
+{
+    PyObject *callable;
+    PyObject *self;
+
+    if (!PyArg_UnpackTuple(args, "boundmonitormethod", 2, 2, &callable, &self))
+        return NULL;
+    if (!_PyArg_NoKeywords("boundmonitormethod", kwds))
+        return NULL;
+
+    return bmm_new_common(type, callable, self);
+}
+
+static PyObject *
+bmm_call_inner(PyObject *result, PyObject *arg, PyObject *kw)
+{
+    PyMonitorObject *monitor;
+    assert(PyTuple_Size(arg) >= 1);
+    monitor = (PyMonitorObject *)PyTuple_GET_ITEM(arg, 0);
+    assert(PyMonitor_Check(monitor));
+
+    monitor_recheck_conditions(monitor, NULL);
+    if (PyErr_Occurred())
+        return NULL;
+    Py_XINCREF(result);
+    return result;
+}
+
+static PyObject *
+bmm_call(boundmonitormethod *bmm, PyObject *arg, PyObject *kw)
+{
+    PyObject *result;
+    Py_ssize_t argcount = PyTuple_Size(arg);
+    PyObject *newarg = PyTuple_New(argcount + 1);
+    int i;
+    PyMonitorSpaceObject *monitorspace;
+
+    if (newarg == NULL)
+        return NULL;
+    Py_INCREF(bmm->bmm_self);
+    PyTuple_SET_ITEM(newarg, 0, bmm->bmm_self);
+    for (i = 0; i < argcount; i++) {
+        PyObject *v = PyTuple_GET_ITEM(arg, i);
+        Py_XINCREF(v);
+        PyTuple_SET_ITEM(newarg, i+1, v);
+    }
+    arg = newarg;
+
+    monitorspace = PyMonitor_GetMonitorSpace(bmm->bmm_self);
+
+    if (PyMonitorSpace_IsCurrent(monitorspace))
+        result = PyEval_CallObjectWithKeywords(bmm->bmm_callable, arg,
+            kw);
+    else
+        result = PyMonitorSpace_Enter(monitorspace, bmm->bmm_callable,
+            arg, kw, bmm_call_inner);
+    Py_DECREF(arg);
+    return result;
+}
+
+static int
+bmm_isshareable(boundmonitormethod *bmm)
+{
+    return PyObject_IsShareable(bmm->bmm_callable) &&
+        PyObject_IsShareable(bmm->bmm_self);
+}
+
+PyDoc_STRVAR(boundmonitormethod_doc,
+"boundmonitormethod(function, self) -> method\n\
+\n\
+Convert a function and a monitor to be a bound monitor method.\n\
+\n\
+A bound monitor method enters the monitor when called.");
+
+PyTypeObject PyBoundMonitorMethod_Type = {
+    PyVarObject_HEAD_INIT(&PyType_Type, 0)
+    "boundmonitormethod",
+    sizeof(boundmonitormethod),
+    0,
+    (destructor)bmm_dealloc,                    /* tp_dealloc */
+    0,                                          /* tp_print */
+    0,                                          /* tp_getattr */
+    0,                                          /* tp_setattr */
+    0,                                          /* tp_compare */
+    0,                                          /* tp_repr */
+    0,                                          /* tp_as_number */
+    0,                                          /* tp_as_sequence */
+    0,                                          /* tp_as_mapping */
+    0,                                          /* tp_hash */
+    (ternaryfunc)bmm_call,                      /* tp_call */
+    0,                                          /* tp_str */
+    PyObject_GenericGetAttr,                    /* tp_getattro */
+    0,                                          /* tp_setattro */
+    0,                                          /* tp_as_buffer */
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |
+            Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_SHAREABLE,
+    boundmonitormethod_doc,                     /* tp_doc */
+    (traverseproc)bmm_traverse,                 /* tp_traverse */
+    0,                                          /* tp_clear */
+    0,                                          /* tp_richcompare */
+    0,                                          /* tp_weaklistoffset */
+    0,                                          /* tp_iter */
+    0,                                          /* tp_iternext */
+    0,                                          /* tp_methods */
+    0,                                          /* tp_members */
+    0,                                          /* tp_getset */
+    0,                                          /* tp_base */
+    0,                                          /* tp_dict */
+    0,                                          /* tp_descr_get */
+    0,                                          /* tp_descr_set */
+    0,                                          /* tp_dictoffset */
+    0,                                          /* tp_init */
+    bmm_new,                                    /* tp_new */
+    0,                                          /* tp_is_gc */
+    0,                                          /* tp_bases */
+    0,                                          /* tp_mro */
+    0,                                          /* tp_cache */
+    0,                                          /* tp_subclasses */
+    0,                                          /* tp_weaklist */
+    (isshareablefunc)bmm_isshareable,           /* tp_isshareable */
+};
+/* --------------------------------------------------------------------- */
+
+
+/* condition methods */
+static void
+cond_dealloc(condition *cond)
+{
+    Py_DECREF(cond->cond_callable);
+    PyObject_Del(cond);
+}
+
+static int
+cond_traverse(condition *cond, visitproc visit, void *arg)
+{
+    Py_VISIT(cond->cond_callable);
+    return 0;
+}
+
+static PyObject *
+cond_descr_get(PyObject *self, PyObject *obj, PyObject *type)
+{
+    PyObject *bcond;
+    PyMonitorObject *mon = (PyMonitorObject *)obj;
+
+    if (!PyMonitor_Check(obj)) {
+        PyErr_Format(PyExc_TypeError, "'%s' object is not a Monitor",
+            Py_TYPE(obj)->tp_name);
+        return NULL;
+    }
+
+    if (PyDict_GetItemEx(mon->mon_conditions, self, &bcond) < 0)
+        return NULL;
+    if (bcond != NULL)
+        return bcond;
+
+    bcond = PyBoundMonitorCondition_New(self, obj);
+    if (bcond == NULL)
+        return NULL;
+
+    if (PyDict_SetItem(mon->mon_conditions, self, bcond)) {
+        Py_DECREF(bcond);
+        return NULL;
+    }
+
+    return bcond;
+}
+
+static PyObject *
+cond_new_common(PyTypeObject *type, PyObject *callable)
+{
+    condition *cond;
+
+    if (!PyCallable_Check(callable)) {
+        PyErr_Format(PyExc_TypeError, "'%s' object is not callable",
+            Py_TYPE(callable)->tp_name);
+        return NULL;
+    }
+
+    cond = PyObject_New(type);
+    if (cond == NULL)
+        return NULL;
+
+    Py_INCREF(callable);
+    cond->cond_callable = callable;
+
+    return (PyObject *)cond;
+}
+
+PyObject *
+PyMonitorCondition_New(PyObject *callable)
+{
+    return cond_new_common(&PyMonitorCondition_Type, callable);
+}
+
+static PyObject *
+cond_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
+{
+    PyObject *callable;
+
+    if (!PyArg_UnpackTuple(args, "condition", 1, 1, &callable))
+        return NULL;
+    if (!_PyArg_NoKeywords("condition", kwds))
+        return NULL;
+
+    return cond_new_common(type, callable);
+}
+
+static int
+cond_isshareable(condition *cond)
+{
+    return PyObject_IsShareable(cond->cond_callable);
+}
+
+PyDoc_STRVAR(condition_doc,
+"condition(function) -> condition\n\
+\n\
+Convert a function to be a monitor condition.\n\
+\n\
+A monitor condition allows waiting for a property of the monitor\n\
+to become true, using wait(mon.condition).");
+
+PyTypeObject PyMonitorCondition_Type = {
+    PyVarObject_HEAD_INIT(&PyType_Type, 0)
+    "condition",
+    sizeof(condition),
+    0,
+    (destructor)cond_dealloc,                     /* tp_dealloc */
+    0,                                          /* tp_print */
+    0,                                          /* tp_getattr */
+    0,                                          /* tp_setattr */
+    0,                                          /* tp_compare */
+    0,                                          /* tp_repr */
+    0,                                          /* tp_as_number */
+    0,                                          /* tp_as_sequence */
+    0,                                          /* tp_as_mapping */
+    (hashfunc)_Py_HashPointer,                  /* tp_hash */
+    0,                                          /* tp_call */
+    0,                                          /* tp_str */
+    PyObject_GenericGetAttr,                    /* tp_getattro */
+    0,                                          /* tp_setattro */
+    0,                                          /* tp_as_buffer */
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |
+            Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_SHAREABLE,
+    condition_doc,                              /* tp_doc */
+    (traverseproc)cond_traverse,                /* tp_traverse */
+    0,                                          /* tp_clear */
+    0,                                          /* tp_richcompare */
+    0,                                          /* tp_weaklistoffset */
+    0,                                          /* tp_iter */
+    0,                                          /* tp_iternext */
+    0,                                          /* tp_methods */
+    0,                                          /* tp_members */
+    0,                                          /* tp_getset */
+    0,                                          /* tp_base */
+    0,                                          /* tp_dict */
+    cond_descr_get,                             /* tp_descr_get */
+    0,                                          /* tp_descr_set */
+    0,                                          /* tp_dictoffset */
+    0,                                          /* tp_init */
+    cond_new,                                   /* tp_new */
+    0,                                          /* tp_is_gc */
+    0,                                          /* tp_bases */
+    0,                                          /* tp_mro */
+    0,                                          /* tp_cache */
+    0,                                          /* tp_subclasses */
+    0,                                          /* tp_weaklist */
+    (isshareablefunc)cond_isshareable,          /* tp_isshareable */
+};
+/* --------------------------------------------------------------------- */
+
+
+/* boundcondition methods */
+static void
+bcond_dealloc(boundcondition *bcond)
+{
+    Py_DECREF(bcond->cond);
+    Py_DECREF(bcond->monitor);
+    assert(PyLinkedList_Empty(&bcond->waiters));
+    PyObject_Del(bcond);
+}
+
+static int
+bcond_traverse(boundcondition *bcond, visitproc visit, void *arg)
+{
+    Py_VISIT(bcond->cond);
+    Py_VISIT(bcond->monitor);
+    return 0;
+}
+
+PyObject *
+PyBoundMonitorCondition_New(PyObject *cond, PyObject *mon)
+{
+    boundcondition *bcond;
+
+    assert(PyCondition_Check(cond));
+    assert(PyMonitor_Check(mon));
+
+    bcond = PyObject_New(&PyBoundMonitorCondition_Type);
+    if (bcond == NULL)
+        return NULL;
+
+    Py_INCREF(cond);
+    bcond->cond = cond;
+    Py_INCREF(mon);
+    bcond->monitor = mon;
+    PyLinkedList_InitBase(&bcond->waiters, offsetof(PyState, condition_links));
+
+    return (PyObject *)bcond;
+}
+
+/* XXX FIXME clean up the Cancel API and delete this. */
+typedef struct {
+    PyState *pystate;
+    int cancelled;
+} blewed_up;
+
+static void
+boundcondition_wakeup(PyCancelQueue *queue, void *arg)
+{
+    blewed_up *bu = arg;
+    bu->cancelled = 1;
+    PyThread_flag_set(bu->pystate->condition_flag);
+}
+
+static PyObject *
+boundcondition_wait(boundcondition *bcond)
+{
+    PyState *pystate = PyState_Get();
+    PyMonitorSpaceObject *monitorspace =
+        PyMonitor_GetMonitorSpace(bcond->monitor);
+    PyCancelObject *cancel_scope;
+    PyObject *x, *result = NULL;
+    int res;
+    blewed_up bu;
+
+    /* boundconditions aren't shareable, so it shouldn't be possible to
+     * call us without being the current monitorspace.  Otherwise we'd
+     * have to raise an exception here. */
+    assert(PyMonitorSpace_IsCurrent(monitorspace));
+
+    bu.pystate = pystate;
+    bu.cancelled = 0;
+
+    cancel_scope = PyCancel_New(boundcondition_wakeup, &bu, pystate);
+    if (cancel_scope == NULL)
+        return NULL;
+
+    /* Push it briefly in case we're called when cancelled */
+    PyCancel_Push(cancel_scope);
+    PyCancel_Pop(cancel_scope);
+
+    while (1) {
+        if (bu.cancelled) {
+            PyErr_SetString(PyExc_Cancelled,
+                "condition.__wait__ cancelled");
+            break;
+        }
+
+        /* If the condition is already true we don't need to wait */
+        x = PyObject_CallFunction(((condition *)bcond->cond)->cond_callable,
+            "O", bcond->monitor);
+        if (x == NULL)
+            break;
+        res = PyObject_IsTrue(x);
+        Py_DECREF(x);
+        if (res < 0)
+            break;
+        if (res > 0) {
+            Py_INCREF(Py_None);
+            result = Py_None;
+            break;
+        }
+
+        /* Otherwise we put ourselves to sleep */
+        PyLinkedList_Append(&bcond->waiters, pystate);
+        monitor_recheck_conditions((PyMonitorObject *)bcond->monitor, bcond);
+
+        PyCancel_Push(cancel_scope);
+        monitorspace_release(monitorspace, NULL);
+        /* XXX FIXME be cancellable! */
+        PyState_Suspend();
+        PyThread_flag_wait(pystate->condition_flag);
+        PyState_Resume();
+        if (monitorspace_acquire(monitorspace, 0))
+            Py_FatalError("condition.__wait__ unable to reacquire MonitorSpace");
+        PyCancel_Pop(cancel_scope);
+
+        PyThread_flag_clear(pystate->condition_flag);
+        ((PyMonitorObject *)bcond->monitor)->mon_waking = 0;
+
+        PyLinkedList_Remove(&pystate->condition_links);
+
+        /* monitor_recheck_conditions and monitorspace_acquire may both
+         * set exceptions */
+        if (PyErr_Occurred())
+            break;
+    }
+
+    PyThread_flag_clear(pystate->condition_flag);
+
+    Py_DECREF(cancel_scope);
+    return result;
+}
+
+static PyMethodDef boundcondition_methods[] = {
+    {"__wait__", (PyCFunction)boundcondition_wait, METH_NOARGS,
+            NULL},
+    {NULL, NULL}                /* sentinel */
+};
+
+PyDoc_STRVAR(boundcondition_doc,
+"A monitor condition allows waiting for a property of the monitor\n\
+to become true, using wait(mon.condition).");
+
+PyTypeObject PyBoundMonitorCondition_Type = {
+    PyVarObject_HEAD_INIT(&PyType_Type, 0)
+    "boundcondition",
+    sizeof(boundcondition),
+    0,
+    (destructor)bcond_dealloc,                  /* tp_dealloc */
+    0,                                          /* tp_print */
+    0,                                          /* tp_getattr */
+    0,                                          /* tp_setattr */
+    0,                                          /* tp_compare */
+    0,                                          /* tp_repr */
+    0,                                          /* tp_as_number */
+    0,                                          /* tp_as_sequence */
+    0,                                          /* tp_as_mapping */
+    0,                                          /* tp_hash */
+    0,                                          /* tp_call */
+    0,                                          /* tp_str */
+    PyObject_GenericGetAttr,                    /* tp_getattro */
+    0,                                          /* tp_setattro */
+    0,                                          /* tp_as_buffer */
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
+        Py_TPFLAGS_SHAREABLE,
+    boundcondition_doc,                         /* tp_doc */
+    (traverseproc)bcond_traverse,               /* tp_traverse */
+    0,                                          /* tp_clear */
+    0,                                          /* tp_richcompare */
+    0,                                          /* tp_weaklistoffset */
+    0,                                          /* tp_iter */
+    0,                                          /* tp_iternext */
+    boundcondition_methods,                     /* tp_methods */
+    0,                                          /* tp_members */
+    0,                                          /* tp_getset */
+    0,                                          /* tp_base */
+    0,                                          /* tp_dict */
+    0,                                          /* tp_descr_get */
+    0,                                          /* tp_descr_set */
+    0,                                          /* tp_dictoffset */
+    0,                                          /* tp_init */
+    0,                                          /* tp_new */
+    0,                                          /* tp_is_gc */
+    0,                                          /* tp_bases */
+    0,                                          /* tp_mro */
+    0,                                          /* tp_cache */
+    0,                                          /* tp_subclasses */
+    0,                                          /* tp_weaklist */
+    0,                                          /* tp_isshareable */
+};
+/* --------------------------------------------------------------------- */
+
+
+/* MonitorSpace methods */
+void
+PyMonitorSpace_SetDeadlockDelay(double delay)
+{
+    PyState_StopTheWorld();
+    deadlock_delay = delay;
+    PyState_StartTheWorld();
+}
+
+double
+PyMonitorSpace_GetDeadlockDelay(void)
+{
+    return deadlock_delay;
+}
+
+static void
+inspect_init(PyWaitFor_Inspection *insp, int global)
+{
+    PyLinkedList_InitBase(&insp->inspecting,
+        offsetof(PyWaitFor, inspection_links));
+    insp->global = global;
+}
+
+static void
+inspect_add(PyWaitFor_Inspection *insp, PyWaitFor *node)
+{
+    PyThread_lock_acquire(node->lock);
+    PyLinkedList_Append(&insp->inspecting, node);
+    if (insp->global) {
+        assert(node->checking_deadlock == 0);
+        node->checking_deadlock = 1;
+    }
+}
+
+static int
+inspect_tryadd(PyWaitFor_Inspection *insp, PyWaitFor *node)
+{
+    assert(!insp->global);
+    if (PyThread_lock_tryacquire(node->lock)) {
+        PyLinkedList_Append(&insp->inspecting, node);
+        return 1;
+    } else
+        return 0;
+}
+
+static void
+inspect_cond_timedwait(PyWaitFor_Inspection *insp, PyWaitFor *node,
+    PyThread_type_cond *cond, PyThread_type_timeout *timeout)
+{
+    assert(!insp->global);
+
+    PyLinkedList_Remove(&node->inspection_links);
+    if (!PyLinkedList_Empty(&insp->inspecting))
+        Py_FatalError("inspect_cond_timedwait only works when inspecting a single node");
+    PyThread_cond_timedwait(cond, node->lock, timeout);
+    PyLinkedList_Append(&insp->inspecting, node);
+}
+
+static void
+inspect_clear(PyWaitFor_Inspection *insp)
+{
+    while (!PyLinkedList_Empty(&insp->inspecting)) {
+        PyWaitFor *node = PyLinkedList_First(&insp->inspecting);
+        PyLinkedList_Remove(&node->inspection_links);
+        if (insp->global) {
+            assert(node->checking_deadlock);
+            node->checking_deadlock = 0;
+        }
+        PyThread_lock_release(node->lock);
+    }
+}
+
+/* XXX FIXME rename */
+/* This returns with a and b both locked.  This lets the caller modify
+ * them knowing they *currently* don't deadlock. */
+static int
+deadlock_check_partial(PyWaitFor_Inspection *insp, PyWaitFor *a, PyWaitFor *b)
+{
+    PyWaitFor *node;
+
+    inspect_add(insp, a);
+    inspect_add(insp, b);
+
+    /* If we find a NULL blocker then we know there can't be a deadlock */
+    node = b->blocker;
+    while (1) {
+        if (node == NULL)
+            return 0;
+
+        if (!inspect_tryadd(insp, node))
+            break;
+
+        node = node->blocker;
+    }
+
+    /* Otherwise we setup for a full check */
+    inspect_clear(insp);
+    inspect_init(insp, 1);
+
+    PyThread_lock_acquire(deadlock_lock);
+
+    inspect_add(insp, a);
+    inspect_add(insp, b);
+
+    return 1;
+}
+
+/* We'll already have origin locked, as provided by deadlock_check_partial */
+static void
+deadlock_check_full(PyWaitFor_Inspection *insp, PyWaitFor *origin)
+{
+    PyWaitFor *node = origin->blocker;
+
+    /* Confirm that there really is a deadlock */
+    while (1) {
+        if (node == NULL)
+            return;
+
+        if (node->checking_deadlock)
+            break;
+
+        inspect_add(insp, node);
+        node = node->blocker;
+    }
+
+    /* Now go break it */
+    node = origin;
+    while (1) {
+        assert(node != NULL);
+
+        if (node->abortfunc != NULL) {
+            node->abortfunc(insp, node);
+            break;
+        }
+
+        node = node->blocker;
+        if (node == origin)
+            /* XXX FIXME this should eventually be be replaced with
+             * a second pass that attempts to preempt resources.
+             * That'll only be required once Monitor.wait() is added
+             * along with MonitorSpace.localenter(). */
+            Py_FatalError("Unable to break deadlock");
+    }
+}
+
+static void
+monitorspace_abortfunc(PyWaitFor_Inspection *insp, PyWaitFor *node)
+{
+    PyState *pystate = node->self;
+
+    PyLinkedList_Remove(&pystate->monitorspace_waitinglinks);
+    pystate->waitfor.blocker = NULL;
+    pystate->waitfor.abortfunc = NULL;
+    PyThread_flag_set(pystate->monitorspace_waitingflag);
+}
+
+/* 0 indicates you got the lock, 1 indicates you failed.  Note that an
+ * exception may be set even if you got the lock, if pushing is not
+ * set. */
+static int
+monitorspace_acquire(PyMonitorSpaceObject *self, int pushing)
+{
+    PyState *pystate = PyState_Get();
+    PyWaitFor *resource = &self->waitfor;
+    PyWaitFor_Inspection insp;
+    int check_deadlock = 0;
+
+    inspect_init(&insp, 0);
+
+    inspect_add(&insp, resource);
+    if (resource->blocker == NULL) {
+        /* Fast path.  If completely uncontended we won't even context
+         * switch once (assuming futexes on Linux). */
+        resource->blocker = &pystate->waitfor;
+        inspect_clear(&insp);
+        return 0;
+    }
+
+    PyThread_timeout_set(pystate->monitorspace_timeout, deadlock_delay);
+    while (resource->blocker != NULL) {
+        /* Slightly less fast path.  Deadlock detection is a bottleneck,
+         * so we putz around here first. */
+        PyState_Suspend();
+        inspect_cond_timedwait(&insp, resource, self->idle, pystate->monitorspace_timeout);
+        PyState_Resume();
+        if (PyThread_timeout_expired(pystate->monitorspace_timeout))
+            break;
+    }
+    if (resource->blocker == NULL) {
+        resource->blocker = &pystate->waitfor;
+        inspect_clear(&insp);
+        return 0;
+    }
+    inspect_clear(&insp);
+
+    /* Non-global check for deadlocks.  May give a false-positive, but
+     * never a false-negative.
+     *
+     * It also locks the two nodes given to it, giving us a safe window
+     * to mark ourselves as blocked on them. */
+    check_deadlock = deadlock_check_partial(&insp, &pystate->waitfor,
+        resource);
+
+    PyLinkedList_Append(&self->waiters, pystate);
+    pystate->waitfor.blocker = resource;
+    if (pushing)
+        pystate->waitfor.abortfunc = monitorspace_abortfunc;
+    else
+        assert(pystate->waitfor.abortfunc == NULL);
+
+    if (check_deadlock)
+        deadlock_check_full(&insp, resource);
+
+    while (resource->blocker != NULL) {
+        inspect_clear(&insp);
+        inspect_init(&insp, 0);
+        if (check_deadlock) {
+            PyThread_lock_release(deadlock_lock);
+            check_deadlock = 0;
+        }
+
+        PyState_Suspend();
+        PyThread_flag_wait(pystate->monitorspace_waitingflag);
+        PyState_Resume();
+
+        inspect_add(&insp, &pystate->waitfor);
+        inspect_add(&insp, resource);
+
+        PyThread_flag_clear(pystate->monitorspace_waitingflag);
+
+        if (pystate->waitfor.blocker == NULL) {
+            /* A deadlock was found.  We drew the short straw. */
+            assert(PyLinkedList_Detached(&pystate->monitorspace_waitinglinks));
+            inspect_clear(&insp);
+            PyErr_SetString(PyExc_SoftDeadlockError, "monitor entrance "
+                "failed due to deadlock");
+            return 1;
+        }
+    }
+
+    PyLinkedList_Remove(&pystate->monitorspace_waitinglinks);
+    pystate->waitfor.blocker = NULL;
+    assert(resource->blocker == NULL);
+    pystate->waitfor.abortfunc = NULL;
+    resource->blocker = &pystate->waitfor;
+
+    inspect_clear(&insp);
+    if (check_deadlock)
+        PyThread_lock_release(deadlock_lock);
+
+    return 0;
+}
+
+static void
+monitorspace_release(PyMonitorSpaceObject *self, PyState *give_to)
+{
+    PyWaitFor *resource = &self->waitfor;
+    PyWaitFor_Inspection insp;
+    inspect_init(&insp, 0);
+
+    if (give_to != NULL) {
+        inspect_add(&insp, &give_to->waitfor);
+        inspect_add(&insp, resource);
+        assert(resource->blocker == &PyState_Get()->waitfor);
+        assert(give_to->waitfor.blocker == resource);
+
+        resource->blocker = &give_to->waitfor;
+        PyLinkedList_Remove(&give_to->monitorspace_waitinglinks);
+        give_to->waitfor.blocker = NULL;
+        PyThread_flag_set(give_to->monitorspace_waitingflag);
+
+        inspect_clear(&insp);
+        return;
+    }
+
+    inspect_add(&insp, resource);
+    assert(resource->blocker == &PyState_Get()->waitfor);
+
+    resource->blocker = NULL;
+
+    if (!PyLinkedList_Empty(&self->waiters)) {
+        PyState *first = PyLinkedList_First(&self->waiters);
+        PyThread_flag_set(first->monitorspace_waitingflag);
+    } else
+        /* XXX This could be improved having a count of the threads
+         * waiting on self->idle as well as a flag indicating that one
+         * is waking.  That could reduce unnecessary context switches in
+         * the event that one thread is quickly acquiring/releasing the
+         * monitor, faster than other threads can wake up.
+         *
+         * Or just use another linked list with the
+         * monitorspace_waitingflag flag... */
+        PyThread_cond_wakeone(self->idle);
+
+    inspect_clear(&insp);
+}
+
+void
+_PyMonitorSpace_WaitForBranchChild(PyBranchChild *self)
+{
+    PyState *pystate = PyState_Get();
+    PyWaitFor *resource = &self->waitfor;
+    PyWaitFor_Inspection insp;
+    int check_deadlock = 0;
+
+    inspect_init(&insp, 0);
+
+    /* Fast path.  For short-lived threads we'll never need to do
+     * deadlock detection. */
+    PyState_Suspend();
+    if (PyThread_flag_timedwait(self->dead, deadlock_delay)) {
+        /* success! */
+        PyState_Resume();
+        return;
+    }
+    PyState_Resume();
+
+    /* Non-global check for deadlocks.  May give a false-positive, but
+     * never a false-negative.
+     *
+     * It also locks the two nodes given to it, giving us a safe window
+     * to mark ourselves as blocked on them. */
+    check_deadlock = deadlock_check_partial(&insp, &pystate->waitfor,
+        resource);
+
+    pystate->waitfor.blocker = resource;
+    assert(pystate->waitfor.abortfunc == NULL);
+
+    if (check_deadlock)
+        deadlock_check_full(&insp, resource);
+
+    inspect_clear(&insp);
+    inspect_init(&insp, 0);
+    if (check_deadlock) {
+        PyThread_lock_release(deadlock_lock);
+        check_deadlock = 0;
+    }
+
+    PyState_Suspend();
+    PyThread_flag_wait(self->dead);
+    PyState_Resume();
+
+    inspect_add(&insp, &pystate->waitfor);
+    inspect_add(&insp, resource);
+
+    pystate->waitfor.blocker = NULL;
+    assert(resource->blocker == NULL);
+
+    inspect_clear(&insp);
+    if (check_deadlock)
+        PyThread_lock_release(deadlock_lock);
+}
+
+/* Marks the given node as blocked on the current thread.  Requires the
+ * current thread to not be blocked on anything. */
+void
+_PyMonitorSpace_BlockOnSelf(PyWaitFor *node)
+{
+    PyWaitFor_Inspection insp;
+    PyState *pystate = PyState_Get();
+
+    inspect_init(&insp, 0);
+
+    inspect_add(&insp, node);
+    inspect_add(&insp, &pystate->waitfor);
+
+    assert(node->blocker == NULL);
+    assert(pystate->waitfor.blocker == NULL);
+
+    node->blocker = &pystate->waitfor;
+
+    inspect_clear(&insp);
+}
+
+void
+_PyMonitorSpace_UnblockOnSelf(PyWaitFor *node)
+{
+    PyWaitFor_Inspection insp;
+    PyState *pystate = PyState_Get();
+
+    inspect_init(&insp, 0);
+
+    inspect_add(&insp, node);
+    inspect_add(&insp, &pystate->waitfor);
+
+    assert(node->blocker == &pystate->waitfor);
+    assert(pystate->waitfor.blocker == NULL);
+
+    node->blocker = NULL;
+
+    inspect_clear(&insp);
+}
+
+static PyObject *
+monitorspace_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
+{
+    PyObject *self;
+
+    assert(type != NULL);
+    self = PyObject_New(type);
+    if (self != NULL) {
+        PyMonitorSpaceObject *x = (PyMonitorSpaceObject *)self;
+        x->waitfor.lock = PyThread_lock_allocate();
+        if (x->waitfor.lock == NULL) {
+            PyObject_Del(self);
+            PyErr_NoMemory();
+            return NULL;
+        }
+        //x->lock_holder = NULL;
+        //x->first_waiter = NULL;
+        //x->last_waiter = NULL;
+        x->idle = PyThread_cond_allocate();
+        if (x->idle == NULL) {
+            PyThread_lock_free(x->waitfor.lock);
+#warning XXX FIXME not safe to call PyObject_Del in *_new
+            PyObject_Del(self);
+            PyErr_NoMemory();
+            return NULL;
+        }
+        x->waitfor.self = self;
+        x->waitfor.blocker = NULL;
+        PyLinkedList_InitBase(&x->waiters, offsetof(PyState, monitorspace_waitinglinks));
+        x->waitfor.checking_deadlock = 0;
+        x->waitfor.abortfunc = NULL;
+        PyLinkedList_InitNode(&x->waitfor.inspection_links);
+    }
+    return self;
+}
+
+static void
+monitorspace_dealloc(PyMonitorSpaceObject *self)
+{
+    //assert(self->lock_holder == NULL);
+    //assert(self->first_waiter == NULL);
+    //assert(self->last_waiter == NULL);
+    assert(self->waitfor.blocker == NULL);
+    assert(PyLinkedList_Empty(&self->waiters));
+    assert(self->waitfor.checking_deadlock == 0);
+    assert(PyLinkedList_Detached(&self->waitfor.inspection_links));
+    PyThread_lock_free(self->waitfor.lock);
+    PyThread_cond_free(self->idle);
+    PyObject_Del(self);
+}
+
+static PyObject *
+monitorspace_enter(PyMonitorSpaceObject *self, PyObject *args, PyObject *kwds)
+{
+    PyObject *func;
+    PyObject *smallargs;
+    PyObject *result;
+
+    if (PyTuple_Size(args) < 1) {
+        PyErr_SetString(PyExc_TypeError,
+            "MonitorSpace.enter() needs a function to be called");
+        return NULL;
+    }
+
+    func = PyTuple_GetItem(args, 0);
+
+    smallargs = PyTuple_GetSlice(args, 1, PyTuple_Size(args));
+    if (smallargs == NULL) {
+        return NULL;
+    }
+
+    result = PyMonitorSpace_Enter(self, func, smallargs, kwds, NULL);
+    Py_DECREF(smallargs);
+
+    return result;
+}
+
+static PyObject *
+PyMonitorSpace_Enter(PyMonitorSpaceObject *self, PyObject *func,
+        PyObject *args, PyObject *kwds, ternaryfunc call2)
+{
+    PyObject *result;
+    PyMonitorSpaceFrame frame;
+    PyState *pystate = PyState_Get();
+
+    if (!PyObject_IsShareable(func)) {
+        PyErr_Format(PyExc_TypeError,
+            "Function argument must be shareable, '%s' object "
+            "is not", func->ob_type->tp_name);
+        return NULL;
+    }
+
+    if (!PyArg_RequireShareable("MonitorSpace.enter", args, kwds))
+        return NULL;
+
+    if (pystate->critical_section != NULL)
+        Py_FatalError("Cannot enter monitor while in a critical section");
+
+    if (monitorspace_acquire(self, 1))
+        return NULL;
+
+    PyLinkedList_InitNode(&frame.links);
+    PyLinkedList_Append(&pystate->monitorspaces, &frame);
+    frame.monitorspace = self;
+
+    result = PyEval_CallObjectWithKeywords(func, args, kwds);
+    if (call2 != NULL) {
+        PyObject *result2 = call2(result, args, kwds);
+        Py_XDECREF(result);
+        result = result2;
+    }
+    if (!PyArg_RequireShareableReturn("MonitorSpace.enter", func, result)) {
+        Py_XDECREF(result);
+        result = NULL;
+    }
+
+    assert(PyLinkedList_Last(&pystate->monitorspaces) == &frame);
+    assert(frame.monitorspace == self);
+
+    PyLinkedList_Remove(&frame.links);
+
+    monitorspace_release(self, NULL);
+
+    return result;
+}
+
+static PyObject *
+monitorspace_leave(PyMonitorSpaceObject *self, PyObject *args, PyObject *kwds)
+{
+    PyObject *func;
+    PyObject *smallargs;
+    PyObject *result;
+
+    if (PyTuple_Size(args) < 1) {
+        PyErr_SetString(PyExc_TypeError,
+            "MonitorSpace.leave() needs a function to be called");
+        return NULL;
+    }
+
+    func = PyTuple_GetItem(args, 0);
+
+    smallargs = PyTuple_GetSlice(args, 1, PyTuple_Size(args));
+    if (smallargs == NULL) {
+        return NULL;
+    }
+
+    result = PyMonitorSpace_Leave(self, func, smallargs, kwds);
+    Py_DECREF(smallargs);
+
+    return result;
+}
+
+static PyObject *
+PyMonitorSpace_Leave(PyMonitorSpaceObject *self, PyObject *func,
+        PyObject *args, PyObject *kwds)
+{
+    PyObject *result;
+    PyMonitorSpaceFrame frame;
+    PyState *pystate = PyState_Get();
+
+    if (!PyObject_IsShareable(func)) {
+        PyErr_Format(PyExc_TypeError,
+            "Function argument must be shareable, '%s' object "
+            "is not", func->ob_type->tp_name);
+        return NULL;
+    }
+
+    if (!PyArg_RequireShareable("MonitorSpace.leave", args, kwds))
+        return NULL;
+
+    if (pystate->critical_section != NULL)
+        Py_FatalError("Cannot leave monitor while in a critical section");
+
+    monitorspace_release(self, NULL);
+
+    PyLinkedList_InitNode(&frame.links);
+    PyLinkedList_Append(&pystate->monitorspaces, &frame);
+    frame.monitorspace = NULL;
+
+    result = PyEval_CallObjectWithKeywords(func, args, kwds);
+    if (!PyArg_RequireShareableReturn("MonitorSpace.leave", func, result)) {
+        Py_XDECREF(result);
+        result = NULL;
+    }
+
+    assert(PyLinkedList_Last(&pystate->monitorspaces) == &frame);
+#warning clearing frame.monitorspace does not release it
+    Py_CLEAR(frame.monitorspace);
+
+    PyLinkedList_Remove(&frame.links);
+
+    if (monitorspace_acquire(self, 0))
+        Py_FatalError("Non-pushing monitorspace_acquire failed");
+
+    if (PyErr_Occurred())
+        Py_CLEAR(result);
+    return result;
+}
+
+int
+PyMonitorSpace_IsCurrent(struct _PyMonitorSpaceObject *monitorspace)
+{
+    PyState *pystate = PyState_Get();
+    PyMonitorSpaceFrame *frame;
+
+    assert(monitorspace != NULL);
+    frame = PyLinkedList_Last(&pystate->monitorspaces);
+    return frame->monitorspace == monitorspace;
+}
+
+/* Returns a NEW reference */
+PyObject *
+PyMonitorSpace_GetCurrent(void)
+{
+    PyState *pystate = PyState_Get();
+    PyMonitorSpaceFrame *frame;
+
+    frame = PyLinkedList_Last(&pystate->monitorspaces);
+
+#warning PyMonitorSpace_GetCurrent should use a critical section
+    if (frame->monitorspace == NULL) {
+        PyObject *monitorspace =
+            PyObject_CallObject((PyObject *)&PyMonitorSpace_Type, NULL);
+        if (monitorspace == NULL)
+            return NULL;
+#warning PyMonitorSpace_GetCurrent should acquire new monitor space
+/* Should also make sure whoever clears frame->monitorspace releases it */
+        assert(PyLinkedList_Last(&pystate->monitorspaces) == frame);
+        assert(frame->monitorspace == NULL);
+        frame->monitorspace = (PyMonitorSpaceObject *)monitorspace;
+    }
+
+    Py_INCREF(frame->monitorspace);
+    return (PyObject *)frame->monitorspace;
+}
+
+static int
+monitorspace_isshareable (PyObject *self)
+{
+    return 1;
+}
+
+PyDoc_STRVAR(monitorspace_enter__doc__, "enter(func, *args, **kwargs) -> object");
+PyDoc_STRVAR(monitorspace_leave__doc__, "leave(func, *args, **kwargs) -> object");
+
+static PyMethodDef monitorspace_methods[] = {
+    {"enter", (PyCFunction)monitorspace_enter, METH_VARARGS | METH_KEYWORDS,
+        monitorspace_enter__doc__},
+    {"leave", (PyCFunction)monitorspace_leave, METH_VARARGS | METH_KEYWORDS,
+        monitorspace_leave__doc__},
+    {NULL, NULL}                            /* sentinel */
+};
+
+PyTypeObject PyMonitorSpace_Type = {
+    PyVarObject_HEAD_INIT(&PyType_Type, 0)
+    "_threadtoolsmodule.MonitorSpace",      /*tp_name*/
+    sizeof(PyMonitorSpaceObject),           /*tp_basicsize*/
+    0,                                      /*tp_itemsize*/
+    (destructor)monitorspace_dealloc,       /*tp_dealloc*/
+    0,                                      /*tp_print*/
+    0,                                      /*tp_getattr*/
+    0,                                      /*tp_setattr*/
+    0,                                      /*tp_compare*/
+    0,                                      /*tp_repr*/
+    0,                                      /*tp_as_number*/
+    0,                                      /*tp_as_sequence*/
+    0,                                      /*tp_as_mapping*/
+    0,                                      /*tp_hash*/
+    0,                                      /*tp_call*/
+    0,                                      /*tp_str*/
+    PyObject_GenericGetAttr,                /*tp_getattro*/
+    0,                                      /*tp_setattro*/
+    0,                                      /*tp_as_buffer*/
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |
+            Py_TPFLAGS_SHAREABLE,           /*tp_flags*/
+    0,                                      /*tp_doc*/
+    0,                                      /*tp_traverse*/
+    0,                                      /*tp_clear*/
+    0,                                      /*tp_richcompare*/
+    0,                                      /*tp_weaklistoffset*/
+    0,                                      /*tp_iter*/
+    0,                                      /*tp_iternext*/
+    monitorspace_methods,                   /*tp_methods*/
+    0,                                      /*tp_members*/
+    0,                                      /*tp_getset*/
+    0,                                      /*tp_base*/
+    0,                                      /*tp_dict*/
+    0,                                      /*tp_descr_get*/
+    0,                                      /*tp_descr_set*/
+    0,                                      /*tp_dictoffset*/
+    0,                                      /*tp_init*/
+    monitorspace_new,                       /*tp_new*/
+    0,                                      /*tp_is_gc*/
+    0,                                      /*tp_bases*/
+    0,                                      /*tp_mro*/
+    0,                                      /*tp_cache*/
+    0,                                      /*tp_subclasses*/
+    0,                                      /*tp_weaklist*/
+    monitorspace_isshareable,               /*tp_isshareable*/
+};
+
+
+void
+_PyMonitor_Init(void)
+{
+    deadlock_lock = PyThread_lock_allocate();
+    if (!deadlock_lock)
+        Py_FatalError("Failed to allocate deadlock_lock");
+}

=== modified file 'Objects/object.c'
--- Objects/object.c	2008-01-25 11:23:10 +0000
+++ Objects/object.c	2008-04-08 01:53:37 +0000
@@ -3,28 +3,31 @@
 
 #include "Python.h"
 #include "sliceobject.h" /* For PyEllipsis_Type */
+#include "monitorobject.h"
+#include "branchobject.h"
+#include "pythread.h"
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
 #ifdef Py_REF_DEBUG
-Py_ssize_t _Py_RefTotal;
+AO_t _Py_RefTotal;
 
 Py_ssize_t
 _Py_GetRefTotal(void)
 {
 	PyObject *o;
-	Py_ssize_t total = _Py_RefTotal;
+	Py_ssize_t total = AO_load_full(&_Py_RefTotal);
         /* ignore the references to the dummy object of the dicts and sets
            because they are not reliable and not useful (now that the
            hash table code is well-tested) */
 	o = _PyDict_Dummy();
 	if (o != NULL)
-		total -= o->ob_refcnt;
+		total -= Py_RefcntSnoop(o);
 	o = _PySet_Dummy();
 	if (o != NULL)
-		total -= o->ob_refcnt;
+		total -= Py_RefcntSnoop(o);
 	return total;
 }
 #endif /* Py_REF_DEBUG */
@@ -41,10 +44,11 @@
  * exist only in a Py_TRACE_REFS build.
  */
 static PyObject refchain = {&refchain, &refchain};
+static PyThread_type_lock *refchain_lock;
 
 /* Insert op at the front of the list of all objects.  If force is true,
  * op is added even if _ob_prev and _ob_next are non-NULL already.  If
- * force is false amd _ob_prev or _ob_next are non-NULL, do nothing.
+ * force is false and _ob_prev or _ob_next are non-NULL, do nothing.
  * force should be true if and only if op points to freshly allocated,
  * uninitialized memory, or you've unlinked op from the list and are
  * relinking it into the front.
@@ -56,6 +60,7 @@
 void
 _Py_AddToAllObjects(PyObject *op, int force)
 {
+	PyThread_lock_acquire(refchain_lock);
 #ifdef  Py_DEBUG
 	if (!force) {
 		/* If it's initialized memory, op must be in or out of
@@ -70,6 +75,7 @@
 		refchain._ob_next->_ob_prev = op;
 		refchain._ob_next = op;
 	}
+	PyThread_lock_release(refchain_lock);
 }
 #endif	/* Py_TRACE_REFS */
 
@@ -183,74 +189,20 @@
 #ifdef Py_REF_DEBUG
 /* Log a fatal error; doesn't return. */
 void
-_Py_NegativeRefcount(const char *fname, int lineno, PyObject *op)
+_Py_NegativeRefcount(const char *fname, int lineno, PyObject *op,
+	Py_ssize_t count)
 {
 	char buf[300];
 
 	PyOS_snprintf(buf, sizeof(buf),
 		      "%s:%i object at %p has negative ref count "
 		      "%" PY_FORMAT_SIZE_T "d",
-		      fname, lineno, op, op->ob_refcnt);
+		      fname, lineno, op, count);
 	Py_FatalError(buf);
 }
 
 #endif /* Py_REF_DEBUG */
 
-void
-Py_IncRef(PyObject *o)
-{
-    Py_XINCREF(o);
-}
-
-void
-Py_DecRef(PyObject *o)
-{
-    Py_XDECREF(o);
-}
-
-PyObject *
-PyObject_Init(PyObject *op, PyTypeObject *tp)
-{
-	if (op == NULL)
-		return PyErr_NoMemory();
-	/* Any changes should be reflected in PyObject_INIT (objimpl.h) */
-	Py_TYPE(op) = tp;
-	_Py_NewReference(op);
-	return op;
-}
-
-PyVarObject *
-PyObject_InitVar(PyVarObject *op, PyTypeObject *tp, Py_ssize_t size)
-{
-	if (op == NULL)
-		return (PyVarObject *) PyErr_NoMemory();
-	/* Any changes should be reflected in PyObject_INIT_VAR */
-	op->ob_size = size;
-	Py_TYPE(op) = tp;
-	_Py_NewReference((PyObject *)op);
-	return op;
-}
-
-PyObject *
-_PyObject_New(PyTypeObject *tp)
-{
-	PyObject *op;
-	op = (PyObject *) PyObject_MALLOC(_PyObject_SIZE(tp));
-	if (op == NULL)
-		return PyErr_NoMemory();
-	return PyObject_INIT(op, tp);
-}
-
-PyVarObject *
-_PyObject_NewVar(PyTypeObject *tp, Py_ssize_t nitems)
-{
-	PyVarObject *op;
-	const size_t size = _PyObject_VAR_SIZE(tp, nitems);
-	op = (PyVarObject *) PyObject_MALLOC(size);
-	if (op == NULL)
-		return (PyVarObject *)PyErr_NoMemory();
-	return PyObject_INIT_VAR(op, tp, nitems);
-}
 
 /* Implementation of PyObject_Print with recursion checking */
 static int
@@ -261,8 +213,6 @@
 		PyErr_SetString(PyExc_RuntimeError, "print recursion");
 		return -1;
 	}
-	if (PyErr_CheckSignals())
-		return -1;
 #ifdef USE_STACKCHECK
 	if (PyOS_CheckStack()) {
 		PyErr_SetString(PyExc_MemoryError, "stack overflow");
@@ -276,14 +226,14 @@
 		Py_END_ALLOW_THREADS
 	}
 	else {
-		if (op->ob_refcnt <= 0)
+		if (Py_RefcntSnoop(op) <= 0) {
 			/* XXX(twouters) cast refcount to long until %zd is
 			   universally available */
 			Py_BEGIN_ALLOW_THREADS
 			fprintf(fp, "<refcnt %ld at %p>",
-				(long)op->ob_refcnt, op);
+				(long)Py_RefcntSnoop(op), op);
 			Py_END_ALLOW_THREADS
-		else {
+		} else {
 			PyObject *s;
 			if (flags & Py_PRINT_RAW)
 				s = PyObject_Str(op);
@@ -345,7 +295,7 @@
 		fprintf(stderr, "NULL\n");
 	else {
 		fprintf(stderr, "object  : ");
-		(void)PyObject_Print(op, stderr, 0);
+		//(void)PyObject_Print(op, stderr, 0);
 		/* XXX(twouters) cast refcount to long until %zd is
 		   universally available */
 		fprintf(stderr, "\n"
@@ -353,7 +303,7 @@
 			"refcount: %ld\n"
 			"address : %p\n",
 			Py_TYPE(op)==NULL ? "NULL" : Py_TYPE(op)->tp_name,
-			(long)op->ob_refcnt,
+			(long)Py_RefcntSnoop(op),
 			op);
 	}
 }
@@ -362,8 +312,6 @@
 PyObject_Repr(PyObject *v)
 {
 	PyObject *res;
-	if (PyErr_CheckSignals())
-		return NULL;
 #ifdef USE_STACKCHECK
 	if (PyOS_CheckStack()) {
 		PyErr_SetString(PyExc_MemoryError, "stack overflow");
@@ -390,8 +338,6 @@
 PyObject_Str(PyObject *v)
 {
 	PyObject *res;
-	if (PyErr_CheckSignals())
-		return NULL;
 #ifdef USE_STACKCHECK
 	if (PyOS_CheckStack()) {
 		PyErr_SetString(PyExc_MemoryError, "stack overflow");
@@ -869,7 +815,7 @@
 		return err;
 	}
 	Py_DECREF(name);
-	assert(name->ob_refcnt >= 1);
+	assert(Py_RefcntSnoop(name) >= 1);
 	if (tp->tp_getattr == NULL && tp->tp_getattro == NULL)
 		PyErr_Format(PyExc_TypeError,
 			     "'%.100s' object has no attributes "
@@ -892,6 +838,17 @@
 PyObject **
 _PyObject_GetDictPtr(PyObject *obj)
 {
+	if (PyMonitor_Check(obj) &&
+			!PyMonitorSpace_IsCurrent(PyMonitor_GetMonitorSpace(obj))) {
+		return NULL;
+	}
+
+	return _PyObject_GetDictPtr_NoCheck(obj);
+}
+
+PyObject **
+_PyObject_GetDictPtr_NoCheck(PyObject *obj)
+{
 	Py_ssize_t dictoffset;
 	PyTypeObject *tp = Py_TYPE(obj);
 
@@ -926,6 +883,7 @@
 PyObject *
 PyObject_GenericGetAttr(PyObject *obj, PyObject *name)
 {
+	PyState *pystate = PyState_Get();
 	PyTypeObject *tp = Py_TYPE(obj);
 	PyObject *descr = NULL;
 	PyObject *res = NULL;
@@ -940,15 +898,15 @@
 		return NULL;
 	}
 	else
-		Py_INCREF(name);
+		Py_INCREF_PS(name);
 
 	if (tp->tp_dict == NULL) {
 		if (PyType_Ready(tp) < 0)
 			goto done;
 	}
 
-#if 0 /* XXX this is not quite _PyType_Lookup anymore */
-	/* Inline _PyType_Lookup */
+#if 0 /* XXX this is not quite _PyType_LookupEx anymore */
+	/* Inline _PyType_LookupEx */
 	{
 		Py_ssize_t i, n;
 		PyObject *mro, *base, *dict;
@@ -963,30 +921,31 @@
 			assert(PyType_Check(base));
 			dict = ((PyTypeObject *)base)->tp_dict;
 			assert(dict && PyDict_Check(dict));
-			descr = PyDict_GetItem(dict, name);
+			if (PyDict_GetItemEx(dict, name, &descr) < 0)
+				goto done;
 			if (descr != NULL)
 				break;
 		}
 	}
 #else
-	descr = _PyType_Lookup(tp, name);
+	if (_PyType_LookupEx(tp, name, &descr) < 0)
+		goto done;
 #endif
 
-	Py_XINCREF(descr);
-
 	f = NULL;
 	if (descr != NULL) {
 		f = descr->ob_type->tp_descr_get;
 		if (f != NULL && PyDescr_IsData(descr)) {
 			res = f(descr, obj, (PyObject *)obj->ob_type);
-			Py_DECREF(descr);
+			Py_DECREF_PS(descr);
 			goto done;
 		}
 	}
 
 	/* Inline _PyObject_GetDictPtr */
 	dictoffset = tp->tp_dictoffset;
-	if (dictoffset != 0) {
+	if (dictoffset != 0 && !(PyMonitor_Check(obj) &&
+			!PyMonitorSpace_IsCurrent(PyMonitor_GetMonitorSpace(obj)))) {
 		PyObject *dict;
 		if (dictoffset < 0) {
 			Py_ssize_t tsize;
@@ -1005,10 +964,8 @@
 		dict = *dictptr;
 		if (dict != NULL) {
 			Py_INCREF(dict);
-			res = PyDict_GetItem(dict, name);
-			if (res != NULL) {
-				Py_INCREF(res);
-				Py_XDECREF(descr);
+			if (PyDict_GetItemEx(dict, name, &res) <= 0) {
+				Py_XDECREF_PS(descr);
                                 Py_DECREF(dict);
 				goto done;
 			}
@@ -1018,7 +975,7 @@
 
 	if (f != NULL) {
 		res = f(descr, obj, (PyObject *)Py_TYPE(obj));
-		Py_DECREF(descr);
+		Py_DECREF_PS(descr);
 		goto done;
 	}
 
@@ -1032,7 +989,7 @@
 		     "'%.50s' object has no attribute '%.400s'",
 		     tp->tp_name, PyUnicode_AsString(name));
   done:
-	Py_DECREF(name);
+	Py_DECREF_PS(name);
 	return res;
 }
 
@@ -1040,7 +997,7 @@
 PyObject_GenericSetAttr(PyObject *obj, PyObject *name, PyObject *value)
 {
 	PyTypeObject *tp = Py_TYPE(obj);
-	PyObject *descr;
+	PyObject *descr = NULL;
 	descrsetfunc f;
 	PyObject **dictptr;
 	int res = -1;
@@ -1059,7 +1016,8 @@
 			goto done;
 	}
 
-	descr = _PyType_Lookup(tp, name);
+	if (_PyType_LookupEx(tp, name, &descr) < 0)
+		goto done;
 	f = NULL;
 	if (descr != NULL) {
 		f = descr->ob_type->tp_descr_set;
@@ -1108,6 +1066,7 @@
 		     tp->tp_name, name);
   done:
 	Py_DECREF(name);
+	Py_XDECREF(descr);
 	return res;
 }
 
@@ -1162,6 +1121,16 @@
 	return x->ob_type->tp_call != NULL;
 }
 
+/* Test whether an object is shareable */
+
+int
+PyObject_IsShareable(PyObject *x)
+{
+	if (x->ob_type->tp_isshareable != NULL)
+		return x->ob_type->tp_isshareable(x);
+	return 0;
+}
+
 /* ------------------------- PyObject_Dir() helpers ------------------------- */
 
 /* Helper for PyObject_Dir.
@@ -1429,6 +1398,12 @@
 	Py_FatalError("deallocating None");
 }
 
+static int
+none_isshareable(PyObject *ignore)
+{
+	return 1;
+}
+
 
 static PyTypeObject PyNone_Type = {
 	PyVarObject_HEAD_INIT(&PyType_Type, 0)
@@ -1444,13 +1419,46 @@
 	0,		/*tp_as_number*/
 	0,		/*tp_as_sequence*/
 	0,		/*tp_as_mapping*/
-	0,		/*tp_hash */
+	0,		/*tp_hash*/
+	0,		/*tp_call*/
+	0,		/*tp_str*/
+	0,		/*tp_getattro*/
+	0,		/*tp_setattro*/
+	0,		/*tp_as_buffer*/
+	Py_TPFLAGS_SHAREABLE,	/*tp_flags*/
+	0,		/* tp_doc */
+	0,		/* tp_traverse */
+	0,		/* tp_clear */
+	0,		/* tp_richcompare */
+	0,		/* tp_weaklistoffset */
+	0,		/* tp_iter */
+	0,		/* tp_iternext */
+	0,		/* tp_methods */
+	0,		/* tp_members */
+	0,		/* tp_getset */
+	0,		/* tp_base */
+	0,		/* tp_dict */
+	0,		/* tp_descr_get */
+	0,		/* tp_descr_set */
+	0,		/* tp_dictoffset */
+	0,		/* tp_init */
+	0,		/* tp_new */
+	0,		/* tp_is_gc */
+	0,		/* tp_bases */
+	0,		/* tp_mro */
+	0,		/* tp_cache */
+	0,		/* tp_subclasses */
+	0,		/* tp_weaklist */
+	none_isshareable,	/* tp_isshareable */
 };
 
+/*
 PyObject _Py_NoneStruct = {
   _PyObject_EXTRA_INIT
   1, &PyNone_Type
 };
+*/
+PyObject _Py_NoneStruct = PyObject_HEAD_INIT_NOCOMMA(&PyNone_Type);
 
 /* NotImplemented is an object that can be used to signal that an
    operation is not implemented for the given type combination. */
@@ -1476,12 +1484,48 @@
 	0,		/*tp_as_sequence*/
 	0,		/*tp_as_mapping*/
 	0,		/*tp_hash */
+	0,		/*tp_call*/
+	0,		/*tp_str*/
+	0,		/*tp_getattro*/
+	0,		/*tp_setattro*/
+	0,		/*tp_as_buffer*/
+	Py_TPFLAGS_SHAREABLE,	/*tp_flags*/
+	0,		/* tp_doc */
+	0,		/* tp_traverse */
+	0,		/* tp_clear */
+	0,		/* tp_richcompare */
+	0,		/* tp_weaklistoffset */
+	0,		/* tp_iter */
+	0,		/* tp_iternext */
+	0,		/* tp_methods */
+	0,		/* tp_members */
+	0,		/* tp_getset */
+	0,		/* tp_base */
+	0,		/* tp_dict */
+	0,		/* tp_descr_get */
+	0,		/* tp_descr_set */
+	0,		/* tp_dictoffset */
+	0,		/* tp_init */
+	0,		/* tp_new */
+	0,		/* tp_is_gc */
+	0,		/* tp_bases */
+	0,		/* tp_mro */
+	0,		/* tp_cache */
+	0,		/* tp_subclasses */
+	0,		/* tp_weaklist */
+	none_isshareable,	/* tp_isshareable */
 };
 
+/*
 PyObject _Py_NotImplementedStruct = {
 	_PyObject_EXTRA_INIT
 	1, &PyNotImplemented_Type
 };
+*/
+PyObject _Py_NotImplementedStruct = PyObject_HEAD_INIT_NOCOMMA(&PyNotImplemented_Type);
+
+extern PyTypeObject PyRange_Type;
+extern PyTypeObject PyCancel_Type;
 
 void
 _Py_ReadyTypes(void)
@@ -1489,9 +1533,15 @@
 	if (PyType_Ready(&PyType_Type) < 0)
 		Py_FatalError("Can't initialize 'type'");
 
-	if (PyType_Ready(&_PyWeakref_RefType) < 0)
+	if (PyType_Ready(&_PyWeakref_Type) < 0)
 		Py_FatalError("Can't initialize 'weakref'");
 
+	if (PyType_Ready(&_PyDeathQueueHandle_Type) < 0)
+		Py_FatalError("Can't initialize 'deathqueuehandle'");
+
+	if (PyType_Ready(&_PyDeathQueue_Type) < 0)
+		Py_FatalError("Can't initialize 'deathqueue'");
+
 	if (PyType_Ready(&PyBool_Type) < 0)
 		Py_FatalError("Can't initialize 'bool'");
 
@@ -1518,76 +1568,32 @@
 
 	if (PyType_Ready(&PyStdPrinter_Type) < 0)
 		Py_FatalError("Can't initialize StdPrinter");
+
+	if (PyType_Ready(&PyRange_Type) < 0)
+		Py_FatalError("Can't initialize 'range'");
+
+	PySharedDict_Type.tp_base = &PyDict_Type;
+	if (PyType_Ready(&PySharedDict_Type) < 0)
+		Py_FatalError("Can't initialize 'shareddict'");
+
+	PyMonitorMeta_Type.tp_base = &PyType_Type;
+	if (PyType_Ready(&PyMonitorMeta_Type) < 0)
+		Py_FatalError("Can't initialize 'MonitorMeta'");
+
+	if (PyType_Ready(&PyMonitor_Type) < 0)
+		Py_FatalError("Can't initialize 'Monitor'");
+
+	if (PyType_Ready(&PyMonitorSpace_Type) < 0)
+		Py_FatalError("Can't initialize 'MonitorSpace'");
+
+	if (PyType_Ready(&PyBranch_Type) < 0)
+		Py_FatalError("Can't initialize 'branch'");
+
+	if (PyType_Ready(&PyCancel_Type) < 0)
+		Py_FatalError("Can't initialize 'Cancel' type");
 }
 
-
 #ifdef Py_TRACE_REFS
-
-void
-_Py_NewReference(PyObject *op)
-{
-	_Py_INC_REFTOTAL;
-	op->ob_refcnt = 1;
-	_Py_AddToAllObjects(op, 1);
-	_Py_INC_TPALLOCS(op);
-}
-
-void
-_Py_ForgetReference(register PyObject *op)
-{
-#ifdef SLOW_UNREF_CHECK
-        register PyObject *p;
-#endif
-	if (op->ob_refcnt < 0)
-		Py_FatalError("UNREF negative refcnt");
-	if (op == &refchain ||
-	    op->_ob_prev->_ob_next != op || op->_ob_next->_ob_prev != op) {
-		fprintf(stderr, "* ob\n");
-		_PyObject_Dump(op);
-		fprintf(stderr, "* op->_ob_prev->_ob_next\n");
-		_PyObject_Dump(op->_ob_prev->_ob_next);
-		fprintf(stderr, "* op->_ob_next->_ob_prev\n");
-		_PyObject_Dump(op->_ob_next->_ob_prev);
-		Py_FatalError("UNREF invalid object");
-	}
-#ifdef SLOW_UNREF_CHECK
-	for (p = refchain._ob_next; p != &refchain; p = p->_ob_next) {
-		if (p == op)
-			break;
-	}
-	if (p == &refchain) /* Not found */
-		Py_FatalError("UNREF unknown object");
-#endif
-	op->_ob_next->_ob_prev = op->_ob_prev;
-	op->_ob_prev->_ob_next = op->_ob_next;
-	op->_ob_next = op->_ob_prev = NULL;
-	_Py_INC_TPFREES(op);
-}
-
-void
-_Py_Dealloc(PyObject *op)
-{
-	destructor dealloc = Py_TYPE(op)->tp_dealloc;
-	_Py_ForgetReference(op);
-	(*dealloc)(op);
-}
-
-/* Print all live objects.  Because PyObject_Print is called, the
- * interpreter must be in a healthy state.
- */
-void
-_Py_PrintReferences(FILE *fp)
-{
-	PyObject *op;
-	fprintf(fp, "Remaining objects:\n");
-	for (op = refchain._ob_next; op != &refchain; op = op->_ob_next) {
-		fprintf(fp, "%p [%" PY_FORMAT_SIZE_T "d] ", op, op->ob_refcnt);
-		if (PyObject_Print(op, fp, 0) != 0)
-			PyErr_Clear();
-		putc('\n', fp);
-	}
-}
-
 /* Print the addresses of all live objects.  Unlike _Py_PrintReferences, this
  * doesn't make any calls to the Python C API, so is always safe to call.
  */
@@ -1600,36 +1606,6 @@
 		fprintf(fp, "%p [%" PY_FORMAT_SIZE_T "d] %s\n", op,
 			op->ob_refcnt, Py_TYPE(op)->tp_name);
 }
-
-PyObject *
-_Py_GetObjects(PyObject *self, PyObject *args)
-{
-	int i, n;
-	PyObject *t = NULL;
-	PyObject *res, *op;
-
-	if (!PyArg_ParseTuple(args, "i|O", &n, &t))
-		return NULL;
-	op = refchain._ob_next;
-	res = PyList_New(0);
-	if (res == NULL)
-		return NULL;
-	for (i = 0; (n == 0 || i < n) && op != &refchain; i++) {
-		while (op == self || op == args || op == res || op == t ||
-		       (t != NULL && Py_TYPE(op) != (PyTypeObject *) t)) {
-			op = op->_ob_next;
-			if (op == &refchain)
-				return res;
-		}
-		if (PyList_Append(res, op) < 0) {
-			Py_DECREF(res);
-			return NULL;
-		}
-		op = op->_ob_next;
-	}
-	return res;
-}
-
 #endif
 
 
@@ -1643,6 +1619,7 @@
 
 /* Python's malloc wrappers (see pymem.h) */
 
+#if 0
 void *
 PyMem_Malloc(size_t nbytes)
 {
@@ -1660,6 +1637,7 @@
 {
 	PyMem_FREE(p);
 }
+#endif
 
 
 /* These methods are used to control infinite recursion in repr, str, print,
@@ -1683,7 +1661,7 @@
 	PyObject *list;
 	Py_ssize_t i;
 
-	dict = PyThreadState_GetDict();
+	dict = PyState_GetDict();
 	if (dict == NULL)
 		return 0;
 	list = PyDict_GetItemString(dict, KEY);
@@ -1711,7 +1689,7 @@
 	PyObject *list;
 	Py_ssize_t i;
 
-	dict = PyThreadState_GetDict();
+	dict = PyState_GetDict();
 	if (dict == NULL)
 		return;
 	list = PyDict_GetItemString(dict, KEY);
@@ -1727,56 +1705,6 @@
 	}
 }
 
-/* Trashcan support. */
-
-/* Current call-stack depth of tp_dealloc calls. */
-int _PyTrash_delete_nesting = 0;
-
-/* List of objects that still need to be cleaned up, singly linked via their
- * gc headers' gc_prev pointers.
- */
-PyObject *_PyTrash_delete_later = NULL;
-
-/* Add op to the _PyTrash_delete_later list.  Called when the current
- * call-stack depth gets large.  op must be a currently untracked gc'ed
- * object, with refcount 0.  Py_DECREF must already have been called on it.
- */
-void
-_PyTrash_deposit_object(PyObject *op)
-{
-	assert(PyObject_IS_GC(op));
-	assert(_Py_AS_GC(op)->gc.gc_refs == _PyGC_REFS_UNTRACKED);
-	assert(op->ob_refcnt == 0);
-	_Py_AS_GC(op)->gc.gc_prev = (PyGC_Head *)_PyTrash_delete_later;
-	_PyTrash_delete_later = op;
-}
-
-/* Dealloccate all the objects in the _PyTrash_delete_later list.  Called when
- * the call-stack unwinds again.
- */
-void
-_PyTrash_destroy_chain(void)
-{
-	while (_PyTrash_delete_later) {
-		PyObject *op = _PyTrash_delete_later;
-		destructor dealloc = Py_TYPE(op)->tp_dealloc;
-
-		_PyTrash_delete_later =
-			(PyObject*) _Py_AS_GC(op)->gc.gc_prev;
-
-		/* Call the deallocator directly.  This used to try to
-		 * fool Py_DECREF into calling it indirectly, but
-		 * Py_DECREF was already called on this object, and in
-		 * assorted non-release builds calling Py_DECREF again ends
-		 * up distorting allocation statistics.
-		 */
-		assert(op->ob_refcnt == 0);
-		++_PyTrash_delete_nesting;
-		(*dealloc)(op);
-		--_PyTrash_delete_nesting;
-	}
-}
-
 #ifdef __cplusplus
 }
 #endif

=== modified file 'Objects/obmalloc.c'
--- Objects/obmalloc.c	2007-07-21 17:22:18 +0000
+++ Objects/obmalloc.c	2008-03-24 04:28:03 +0000
@@ -1,6 +1,226 @@
 #include "Python.h"
 
+#include <pthread.h>
+
+
+#if 0
+#define CFPRINT(...) do {char buf[1024]; snprintf(buf, 1024, __VA_ARGS__); write(2, buf, strlen(buf)); } while(0)
+#elif 0
+#define CFPRINT(...) do {dprintf(2, __VA_ARGS__)} while (0)
+#else
+#define CFPRINT(...) do {} while (0)
+#endif
+
+PyState * (*pymalloc_pystate_hook)(void);
+
+#if 0
+static pthread_mutex_t pymemwrap_lock = PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP;
+#endif
+
+#define GET_SIZE(size_class) ((size_class) <= 0 ? size_classes[-(size_class)] : (size_class))
+
+/* XXX Must match up with PYMALLOC_CACHE_SIZECLASSES */
+static const Py_ssize_t size_classes[] = {
+	32,
+	48,
+	64,
+	96,
+	128,
+	192,
+	256,
+	384,
+	512,
+	768,
+	1024,
+	1536,
+	2048,
+};
+
+static Py_ssize_t
+find_size_class(size_t size)
+{
+	Py_ssize_t i;
+
+	assert(sizeof(size_classes) / sizeof(*size_classes) ==
+			PYMALLOC_CACHE_SIZECLASSES);
+	if (size > size_classes[PYMALLOC_CACHE_SIZECLASSES - 1])
+		return size; /* Too large to cache */
+
+	for (i = 0; ; i++) {
+		if (size <= size_classes[i])
+			return -i;
+	}
+}
+
+
+void *
+pymemcache_malloc(size_t size)
+{
+	void *mem;
+	Py_ssize_t size_class = find_size_class(size);
+
+	if (pymalloc_pystate_hook != NULL && size_class <= 0) {
+		PyState *pystate = pymalloc_pystate_hook();
+		Py_ssize_t i;
+
+		for (i = 0; i < PYMALLOC_CACHE_COUNT; i++) {
+			if (pystate->malloc_cache[-size_class][i] != NULL) {
+				mem = pystate->malloc_cache[-size_class][i];
+				pystate->malloc_cache[-size_class][i] = NULL;
+				//printf("%p Cache hit!        %8d\n", pystate, size_class);
+				return mem;
+			}
+		}
+	}
+	//printf("%p Cache miss.       %8d\n", pymalloc_pystate_hook(), size_class);
+
+	mem = malloc(GET_SIZE(size_class) + sizeof(Py_ssize_t));
+	if (mem == NULL)
+		return NULL;
+	*((Py_ssize_t *)mem) = size_class;
+	return mem + sizeof(Py_ssize_t);
+}
+
+void *
+pymemcache_realloc(void *old_inner_mem, size_t size)
+{
+	void *old_outer_mem;
+	void *new_outer_mem;
+	Py_ssize_t old_size_class;
+	Py_ssize_t new_size_class = find_size_class(size);
+
+	if (old_inner_mem == NULL)
+		old_outer_mem = NULL;
+	else {
+		old_outer_mem = old_inner_mem - sizeof(Py_ssize_t);
+		old_size_class = *((Py_ssize_t *)old_outer_mem);
+		if (old_size_class == new_size_class)
+			return old_inner_mem;  /* That was easy */
+	}
+
+	new_outer_mem = realloc(old_outer_mem, GET_SIZE(new_size_class) + sizeof(Py_ssize_t));
+	if (new_outer_mem == NULL)
+		return NULL;
+	*((Py_ssize_t *)new_outer_mem) = new_size_class;
+	return new_outer_mem + sizeof(Py_ssize_t);
+}
+
+void
+pymemcache_free(void *inner_mem)
+{
+	void *outer_mem;
+	Py_ssize_t size_class;
+
+	if (inner_mem == NULL)
+		return;
+	outer_mem = inner_mem - sizeof(Py_ssize_t);
+	size_class = *((Py_ssize_t *)outer_mem);
+
+	if (pymalloc_pystate_hook != NULL && size_class <= 0) {
+		PyState *pystate = pymalloc_pystate_hook();
+		Py_ssize_t i;
+
+		for (i = 0; i < PYMALLOC_CACHE_COUNT; i++) {
+			if (pystate->malloc_cache[-size_class][i] == NULL) {
+				pystate->malloc_cache[-size_class][i] = inner_mem;
+                //printf("%p Cached filled.    %8d\n", pystate, size_class);
+				return;
+			}
+		}
+	}
+    //printf("%p Cache not filled. %8d\n", pymalloc_pystate_hook(), size_class);
+
+	free(outer_mem);
+}
+
+
+void *
+_pymemwrap_malloc(const char *name, const char *group, size_t size)
+{
+#if 1
+	return pymemcache_malloc(size);
+#elif 1
+	if (size == 0)
+		/*Py_FatalError("No size!");*/
+		size = 1;
+	return malloc(size);
+#else
+	void *innermem;
+	void *outermem;
+	pthread_mutex_lock(&pymemwrap_lock);
+	size += sizeof(size_t) * 100;
+	if (size == 0)
+		/*Py_FatalError("No size!");*/
+		size = 1;
+	outermem = malloc(size);
+	if (outermem != NULL)
+		innermem = outermem + sizeof(size_t) * 50;
+	else
+		innermem = NULL;
+	CFPRINT("%s + %p (%d) %s\n", #group, outermem, size, #name);
+	pthread_mutex_unlock(&pymemwrap_lock);
+	return innermem;
+#endif
+}
+
+void *
+_pymemwrap_realloc(const char *name, const char *group, void *oldinnermem, size_t size)
+{
+#if 1
+	return pymemcache_realloc(oldinnermem, size);
+#elif 1
+	if (size == 0)
+		/*Py_FatalError("No size!");*/
+		size = 1;
+	return realloc(oldinnermem, size);
+#else
+	void *oldoutermem, *newinnermem, *newoutermem;
+	pthread_mutex_lock(&pymemwrap_lock);
+	CFPRINT("%s - %p %s\n", #group, oldoutermem, #name);
+	if (oldinnermem != NULL)
+		oldoutermem = oldinnermem - sizeof(size_t) * 50;
+	else
+		oldoutermem = NULL;
+	size += sizeof(size_t) * 100;
+	if (size == 0)
+		/*Py_FatalError("No size!");*/
+		size = 1;
+	newoutermem = realloc(oldoutermem, size);
+	if (newoutermem != NULL)
+		newinnermem = newoutermem + sizeof(size_t) * 50;
+	else
+		newinnermem = NULL;
+	CFPRINT("%s + %p from %p (%d) %s\n", #group, newoutermem, oldoutermem, size, #name);
+	pthread_mutex_unlock(&pymemwrap_lock);
+	return newinnermem;
+#endif
+}
+
+void
+_pymemwrap_free(const char *name, const char *group, void *innermem)
+{
+#if 1
+	pymemcache_free(innermem);
+#elif 1
+	free(innermem);
+#else
+	void *outermem;
+	pthread_mutex_lock(&pymemwrap_lock);
+	if (innermem != NULL)
+		outermem = innermem - sizeof(size_t) * 50;
+	else
+		outermem = NULL;
+	CFPRINT("%s - %p %s\n", #group, outermem, #name);
+	free(outermem);
+	pthread_mutex_unlock(&pymemwrap_lock);
+#endif
+}
+
+
 #ifdef WITH_PYMALLOC
+#ifndef WITH_GIL
+//#error "WITH_GIL is required for WITH_PYMALLOC"
+#endif
 
 /* An object allocator for Python.
 
@@ -717,10 +937,38 @@
  * Unless the optimizer reorders everything, being too smart...
  */
 
+PyState * (*pymalloc_pystate_hook)(void);
+
 #undef PyObject_Malloc
 void *
 PyObject_Malloc(size_t nbytes)
 {
+#if 1
+	unsigned char *mem;
+    Py_FatalError("MOOO");
+
+	if (nbytes < 4)
+		nbytes = 4;
+	if (nbytes >= 14 && nbytes < 16)
+		nbytes = 16;
+
+	if (pymalloc_pystate_hook != NULL) {
+		PyState *pystate = pymalloc_pystate_hook();
+		if (pystate->malloc_cache != NULL && *(size_t *)pystate->malloc_cache >= nbytes) {
+			mem = pystate->malloc_cache;
+			//printf("Using   cached mem: %p %p %d %d\n", pystate, mem, nbytes, *(size_t *)mem);
+			pystate->malloc_cache = NULL;
+			return mem + sizeof(size_t);
+		}
+	}
+
+	mem = malloc(nbytes + sizeof(size_t));
+	if (mem == NULL)
+		return NULL;
+
+	*(size_t *)mem = nbytes;
+	return mem + sizeof(size_t);
+#else
 	block *bp;
 	poolp pool;
 	poolp next;
@@ -900,6 +1148,7 @@
 	if (nbytes == 0)
 		nbytes = 1;
 	return (void *)malloc(nbytes);
+#endif
 }
 
 /* free */
@@ -908,6 +1157,28 @@
 void
 PyObject_Free(void *p)
 {
+#if 1
+	unsigned char *mem;
+	size_t nbytes;
+
+	if (p == NULL)
+		return;
+
+	mem = p - sizeof(size_t);
+	nbytes = *(size_t *)mem;
+
+	if (pymalloc_pystate_hook != NULL) {
+		PyState *pystate = pymalloc_pystate_hook();
+		if (pystate->malloc_cache == NULL && nbytes >= 14) {
+			pystate->malloc_cache = mem;
+			//printf("Storing cached mem: %p %p %d\n", pystate, mem, nbytes);
+			return;
+		}
+	}
+
+	//printf("Mooo, free of %d %p\n", nbytes, mem);
+	free(mem);
+#else
 	poolp pool;
 	block *lastfree;
 	poolp next, prev;
@@ -1112,6 +1383,7 @@
 
 	/* We didn't allocate this address. */
 	free(p);
+#endif
 }
 
 /* realloc.  If p is NULL, this acts like malloc(nbytes).  Else if nbytes==0,
@@ -1123,6 +1395,23 @@
 void *
 PyObject_Realloc(void *p, size_t nbytes)
 {
+#if 1
+	unsigned char *mem;
+
+	if (p == NULL)
+		return PyObject_Malloc(nbytes);
+
+	mem = p - sizeof(size_t);
+	if (nbytes < 4)
+		nbytes = 4;
+
+	mem = realloc(mem, nbytes + sizeof(size_t));
+	if (mem == NULL)
+		return NULL;
+
+	*(size_t *)mem = nbytes;
+	return mem + sizeof(size_t);
+#else
 	void *bp;
 	poolp pool;
 	size_t size;
@@ -1177,6 +1466,7 @@
 	 */
 	bp = realloc(p, 1);
    	return bp ? bp : p;
+#endif
 }
 
 #else	/* ! WITH_PYMALLOC */
@@ -1185,6 +1475,7 @@
 /* pymalloc not enabled:  Redirect the entry points to malloc.  These will
  * only be used by extensions that are compiled with pymalloc enabled. */
 
+#if 0
 void *
 PyObject_Malloc(size_t n)
 {
@@ -1202,6 +1493,7 @@
 {
 	PyMem_FREE(p);
 }
+#endif
 #endif /* WITH_PYMALLOC */
 
 #ifdef PYMALLOC_DEBUG

=== modified file 'Objects/rangeobject.c'
--- Objects/rangeobject.c	2008-02-09 04:13:49 +0000
+++ Objects/rangeobject.c	2008-03-24 04:28:03 +0000
@@ -54,6 +54,8 @@
     rangeobject *obj = NULL;
     PyObject *start = NULL, *stop = NULL, *step = NULL;
 
+    if (!(type->tp_flags & Py_TPFLAGS_READY))
+        Py_FatalError("range type (or subtype) isn't initialized");
     if (!_PyArg_NoKeywords("range()", kw))
         return NULL;
 
@@ -81,7 +83,7 @@
             goto Fail;
     }
 
-    obj = PyObject_New(rangeobject, &PyRange_Type);
+    obj = PyObject_New(&PyRange_Type);
     if (obj == NULL)
         goto Fail;
     obj->start = start;
@@ -292,7 +294,7 @@
 	PyObject_GenericGetAttr,  /* tp_getattro */
 	0,			/* tp_setattro */
 	0,			/* tp_as_buffer */
-	Py_TPFLAGS_DEFAULT,	/* tp_flags */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_SHAREABLE,	/* tp_flags */
 	range_doc,		/* tp_doc */
 	0,			/* tp_traverse */
 	0,			/* tp_clear */
@@ -309,7 +311,6 @@
 	0,			/* tp_descr_set */
 	0,			/* tp_dictoffset */
 	0,			/* tp_init */
-	0,			/* tp_alloc */
 	range_new,		/* tp_new */
 };
 
@@ -405,7 +406,6 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	rangeiter_new,				/* tp_new */
 };
 
@@ -441,7 +441,7 @@
 static PyObject *
 int_range_iter(long start, long stop, long step)
 {
-    rangeiterobject *it = PyObject_New(rangeiterobject, &PyRangeIter_Type);
+    rangeiterobject *it = PyObject_New(&PyRangeIter_Type);
     if (it == NULL)
         return NULL;
     it->start = start;
@@ -576,7 +576,7 @@
        and try again with a long range. */
     PyErr_Clear();
 
-    it = PyObject_New(longrangeiterobject, &PyLongRangeIter_Type);
+    it = PyObject_New(&PyLongRangeIter_Type);
     if (it == NULL)
         return NULL;
 
@@ -642,7 +642,7 @@
     }
     PyErr_Clear();
 
-    it = PyObject_New(longrangeiterobject, &PyLongRangeIter_Type);
+    it = PyObject_New(&PyLongRangeIter_Type);
     if (it == NULL)
         return NULL;
 
@@ -692,3 +692,195 @@
     PyObject_Del(it);
     return NULL;
 }
+
+
+/* DUMMY */
+PyTypeObject PyFakeRange_Type;
+
+typedef struct {
+	PyObject_HEAD
+	PyObject *start;
+	PyObject *stop;
+	PyObject *step;
+	long	x_index;
+	long	x_start;
+	long	x_step;
+	long	x_len;
+} fakerangeobject;
+
+static PyObject *
+fakerange_new(PyTypeObject *type, PyObject *args, PyObject *kw)
+{
+    fakerangeobject *obj = NULL;
+    PyObject *start = NULL, *stop = NULL, *step = NULL;
+
+    if (!_PyArg_NoKeywords("range()", kw))
+        return NULL;
+
+    if (PyTuple_Size(args) <= 1) {
+        if (!PyArg_UnpackTuple(args, "range", 1, 1, &stop))
+            goto Fail;
+        stop = PyNumber_Index(stop);
+        if (!stop)
+            goto Fail;
+        start = PyLong_FromLong(0);
+        step = PyLong_FromLong(1);
+        if (!start || !step)
+            goto Fail;
+    }
+    else {
+        if (!PyArg_UnpackTuple(args, "range", 2, 3,
+                               &start, &stop, &step))
+            goto Fail;
+
+        /* Convert borrowed refs to owned refs */
+        start = PyNumber_Index(start);
+        stop = PyNumber_Index(stop);
+        step = validate_step(step);
+        if (!start || !stop || !step)
+            goto Fail;
+    }
+
+    obj = PyObject_New(&PyFakeRange_Type);
+    if (obj == NULL)
+        goto Fail;
+    obj->start = start;
+    obj->stop = stop;
+    obj->step = step;
+    Py_INCREF(obj->start);
+    Py_INCREF(obj->stop);
+    Py_INCREF(obj->step);
+    obj->x_start = PyLong_AsLong(start);
+    //obj->x_stop = PyLong_AsLong(stop);
+    obj->x_step = PyLong_AsLong(step);
+    if (obj->x_step > 0)
+        obj->x_len = get_len_of_range(obj->x_start, PyLong_AsLong(stop), obj->x_step);
+    else
+        obj->x_len = get_len_of_range(PyLong_AsLong(stop), obj->x_start, -obj->x_step);
+    obj->x_index = 0;
+    return (PyObject *) obj;
+
+Fail:
+    //Py_XDECREF(start);
+    //Py_XDECREF(stop);
+    //Py_XDECREF(step);
+    return NULL;
+}
+
+static void
+fakerange_dealloc(rangeobject *r)
+{
+    printf("Fakerange dealloc\n");
+    Py_DECREF(r->start);
+    Py_DECREF(r->stop);
+    Py_DECREF(r->step);
+    r->start = NULL;
+    r->stop = NULL;
+    r->step = NULL;
+    PyObject_Del(r);
+}
+
+static PyObject *
+fakerange_iter(PyObject *seq)
+{
+    Py_INCREF(seq);
+    return seq;
+}
+
+#include <pthread.h>
+AO_t rocky;
+AO_t bullwinkle[16];
+AO_t bob;
+
+static PyObject *
+fakerange_next(fakerangeobject *r)
+{
+#if 1
+    int i;
+    bullwinkle[0] = 0;
+    for (i = 0; i < 1000; i++) {
+        //AO_fetch_and_add1(&rocky);
+        //AO_fetch_and_sub1(&rocky);
+        //(void)AO_load_full(&bob);
+        //(void)AO_load_full(&bob);
+        //printf("%p %p\n", &rocky, &bob);
+        //static pthread_mutex_t rocky = PTHREAD_MUTEX_INITIALIZER;
+        //pthread_mutex_lock(&rocky);
+        //pthread_mutex_unlock(&rocky);
+        //static AO_t rocky;
+        //while (1) {
+        //    AO_t prev = AO_load_full(&rocky);
+        //    if (AO_compare_and_swap(&rocky, prev, prev + 1))
+        //        break;
+        //}
+        //while (1) {
+        //    AO_t prev = AO_load_full(&rocky);
+        //    if (AO_compare_and_swap(&rocky, prev, prev - 1))
+        //        break;
+        //}
+    }
+    if (r->x_index < r->x_len) {
+        r->x_index++;
+        //Py_INCREF(Py_None);
+        //return Py_None;
+        //free(malloc(sizeof(PyVarObject)+4));
+        Py_INCREF(r->start);
+        return r->start;
+    }
+    return NULL;
+#elif 0
+    if (r->x_index < r->x_len) {
+        PyObject *foo;
+        r->x_index++;
+        foo = PyLong_FromLong(100000);
+        //printf("Foo: %p\n", foo);
+        return foo;
+    }
+    return NULL;
+#else
+    if (r->x_index < r->x_len)
+        return PyLong_FromLong(r->x_start + (r->x_index++) * r->x_step);
+    return NULL;
+#endif
+}
+
+PyTypeObject PyFakeRange_Type = {
+	PyVarObject_HEAD_INIT(&PyType_Type, 0)
+	"fakerange",		/* Name of this type */
+	sizeof(fakerangeobject),	/* Basic object size */
+	0,			/* Item size for varobject */
+	(destructor)fakerange_dealloc, /* tp_dealloc */
+	0,			/* tp_print */
+	0,			/* tp_getattr */
+	0,			/* tp_setattr */
+	0,			/* tp_compare */
+	(reprfunc)range_repr,	/* tp_repr */
+	0,			/* tp_as_number */
+	&range_as_sequence,	/* tp_as_sequence */
+	0,			/* tp_as_mapping */
+	0,			/* tp_hash */
+	0,			/* tp_call */
+	0,			/* tp_str */
+	PyObject_GenericGetAttr,  /* tp_getattro */
+	0,			/* tp_setattro */
+	0,			/* tp_as_buffer */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_SHAREABLE,	/* tp_flags */
+	range_doc,		/* tp_doc */
+	0,			/* tp_traverse */
+	0,			/* tp_clear */
+	0,			/* tp_richcompare */
+	0,			/* tp_weaklistoffset */
+	fakerange_iter,		/* tp_iter */
+	(iternextfunc)fakerange_next,		/* tp_iternext */
+	range_methods,		/* tp_methods */
+	0,			/* tp_members */
+	0,			/* tp_getset */
+	0,			/* tp_base */
+	0,			/* tp_dict */
+	0,			/* tp_descr_get */
+	0,			/* tp_descr_set */
+	0,			/* tp_dictoffset */
+	0,			/* tp_init */
+	fakerange_new,		/* tp_new */
+};
+

=== modified file 'Objects/setobject.c'
--- Objects/setobject.c	2008-02-06 14:31:34 +0000
+++ Objects/setobject.c	2008-04-11 03:01:17 +0000
@@ -51,12 +51,15 @@
 	INIT_NONZERO_SET_SLOTS(so);				\
     } while(0)
 
+#ifdef USE_SETS_FREELIST
 /* Reuse scheme to save calls to malloc, free, and memset */
 #ifndef PySet_MAXFREELIST
 #define PySet_MAXFREELIST 80
 #endif
 static PySetObject *free_list[PySet_MAXFREELIST];
 static int numfree = 0;
+static PyThread_type_lock *free_sets_lock;
+#endif
 
 
 /*
@@ -550,10 +553,6 @@
 {
 	register setentry *entry;
 	Py_ssize_t fill = so->fill;
-	PyObject_GC_UnTrack(so);
-	Py_TRASHCAN_SAFE_BEGIN(so)
-	if (so->weakreflist != NULL)
-		PyObject_ClearWeakRefs((PyObject *) so);
 
 	for (entry = so->table; fill > 0; entry++) {
 		if (entry->key) {
@@ -563,11 +562,18 @@
 	}
 	if (so->table != so->smalltable)
 		PyMem_DEL(so->table);
-	if (numfree < PySet_MAXFREELIST && PyAnySet_CheckExact(so))
+#ifdef USE_SETS_FREELIST
+	PyThread_lock_acquire(free_sets_lock);
+	if (numfree < PySet_MAXFREELIST && PyAnySet_CheckExact(so)) {
 		free_list[numfree++] = so;
-	else 
-		Py_TYPE(so)->tp_free(so);
-	Py_TRASHCAN_SAFE_END(so)
+		PyThread_lock_release(free_sets_lock);
+	} else {
+		PyThread_lock_release(free_sets_lock);
+#endif
+		PyObject_Del(so);
+#ifdef USE_SETS_FREELIST
+	}
+#endif
 }
 
 static PyObject *
@@ -890,7 +896,7 @@
 static PyObject *
 set_iter(PySetObject *so)
 {
-	setiterobject *si = PyObject_New(setiterobject, &PySetIter_Type);
+	setiterobject *si = PyObject_New(&PySetIter_Type);
 	if (si == NULL)
 		return NULL;
 	Py_INCREF(so);
@@ -977,22 +983,26 @@
 	}
 
 	/* create PySetObject structure */
+#ifdef USE_SETS_FREELIST
+	PyThread_lock_acquire(free_sets_lock);
 	if (numfree &&
 	    (type == &PySet_Type  ||  type == &PyFrozenSet_Type)) {
 		so = free_list[--numfree];
+		PyThread_lock_release(free_sets_lock);
 		assert (so != NULL && PyAnySet_CheckExact(so));
 		Py_TYPE(so) = type;
-		_Py_NewReference((PyObject *)so);
+		//_Py_NewReference((PyObject *)so);
 		EMPTY_TO_MINSIZE(so);
-		PyObject_GC_Track(so);
 	} else {
-		so = (PySetObject *)type->tp_alloc(type, 0);
+		PyThread_lock_release(free_sets_lock);
+#endif
+		so = PyObject_New(type);
 		if (so == NULL)
 			return NULL;
-		/* tp_alloc has already zeroed the structure */
-		assert(so->table == NULL && so->fill == 0 && so->used == 0);
 		INIT_NONZERO_SET_SLOTS(so);
+#ifdef USE_SETS_FREELIST
 	}
+#endif
 
 	so->lookup = set_lookkey_unicode;
 	so->weakreflist = NULL;
@@ -1043,17 +1053,34 @@
 }
 
 void
+_PySet_Init(void)
+{
+#ifdef USE_SETS_FREELIST
+	free_sets_lock = PyThread_lock_allocate();
+	if (!free_sets_lock)
+		Py_FatalError("unable to allocate lock");
+#endif
+}
+
+void
 PySet_Fini(void)
 {
+#ifdef USE_SETS_FREELIST
 	PySetObject *so;
 
 	while (numfree) {
 		numfree--;
 		so = free_list[numfree];
-		PyObject_GC_Del(so);
+		PyObject_Del(so);
 	}
+#endif
 	Py_CLEAR(dummy);
 	Py_CLEAR(emptyfrozenset);
+
+#ifdef USE_SETS_FREELIST
+	PyThread_lock_free(free_sets_lock);
+	free_sets_lock = NULL;
+#endif
 }
 
 static PyObject *
@@ -2000,7 +2027,8 @@
 	0,				/* tp_setattro */
 	0,				/* tp_as_buffer */
 	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
-		Py_TPFLAGS_BASETYPE,	/* tp_flags */
+		Py_TPFLAGS_BASETYPE | Py_TPFLAGS_SHAREABLE,
+					/* tp_flags */
 	set_doc,			/* tp_doc */
 	(traverseproc)set_traverse,	/* tp_traverse */
 	(inquiry)set_clear_internal,	/* tp_clear */
@@ -2017,9 +2045,7 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	(initproc)set_init,		/* tp_init */
-	PyType_GenericAlloc,		/* tp_alloc */
 	set_new,			/* tp_new */
-	PyObject_GC_Del,		/* tp_free */
 };
 
 /* frozenset object ********************************************************/
@@ -2095,7 +2121,8 @@
 	0,				/* tp_setattro */
 	0,				/* tp_as_buffer */
 	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
-		Py_TPFLAGS_BASETYPE,	/* tp_flags */
+		Py_TPFLAGS_BASETYPE | Py_TPFLAGS_SHAREABLE,
+					/* tp_flags */
 	frozenset_doc,			/* tp_doc */
 	(traverseproc)set_traverse,	/* tp_traverse */
 	(inquiry)set_clear_internal,	/* tp_clear */
@@ -2112,9 +2139,7 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	0,				/* tp_init */
-	PyType_GenericAlloc,		/* tp_alloc */
 	frozenset_new,			/* tp_new */
-	PyObject_GC_Del,		/* tp_free */
 };
 
 
@@ -2175,8 +2200,8 @@
 int
 PySet_Add(PyObject *anyset, PyObject *key)
 {
-	if (!PySet_Check(anyset) && 
-	    (!PyFrozenSet_Check(anyset) || Py_REFCNT(anyset) != 1)) {
+	if (!PySet_Check(anyset) &&
+	    (!PyFrozenSet_Check(anyset) || !Py_RefcntMatches(anyset, 1))) {
 		PyErr_BadInternalCall();
 		return -1;
 	}

=== modified file 'Objects/sliceobject.c'
--- Objects/sliceobject.c	2007-12-19 02:45:37 +0000
+++ Objects/sliceobject.c	2008-03-24 04:28:03 +0000
@@ -22,6 +22,12 @@
 	return PyUnicode_FromString("Ellipsis");
 }
 
+static int
+ellipsis_isshareable(PyObject *op)
+{
+	return 1;
+}
+
 static PyTypeObject PyEllipsis_Type = {
 	PyVarObject_HEAD_INIT(&PyType_Type, 0)
 	"ellipsis",			/* tp_name */
@@ -42,13 +48,41 @@
 	PyObject_GenericGetAttr,	/* tp_getattro */
 	0,				/* tp_setattro */
 	0,				/* tp_as_buffer */
-	Py_TPFLAGS_DEFAULT,		/* tp_flags */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_SHAREABLE,
+					/* tp_flags */
+	0,				/* tp_doc */
+	0,				/* tp_traverse */
+	0,				/* tp_clear */
+	0,				/* tp_richcompare */
+	0,				/* tp_weaklistoffset */
+	0,				/* tp_iter */
+	0,				/* tp_iternext */
+	0,				/* tp_methods */
+	0,				/* tp_members */
+	0,				/* tp_getset */
+	0,				/* tp_base */
+	0,				/* tp_dict */
+	0,				/* tp_descr_get */
+	0,				/* tp_descr_set */
+	0,				/* tp_dictoffset */
+	0,				/* tp_init */
+	0,				/* tp_new */
+	0,				/* tp_is_gc */
+	0,				/* tp_bases */
+	0,				/* tp_mro */
+	0,				/* tp_cache */
+	0,				/* tp_subclasses */
+	0,				/* tp_weaklist */
+	ellipsis_isshareable,		/* tp_isshareable */
 };
 
+/*
 PyObject _Py_EllipsisObject = {
 	_PyObject_EXTRA_INIT
-	1, &PyEllipsis_Type
+	1, {}, &PyEllipsis_Type
 };
+*/
+PyObject _Py_EllipsisObject = PyObject_HEAD_INIT_NOCOMMA(&PyEllipsis_Type);
 
 
 /* Slice object implementation
@@ -60,7 +94,7 @@
 PyObject *
 PySlice_New(PyObject *start, PyObject *stop, PyObject *step)
 {
-	PySliceObject *obj = PyObject_New(PySliceObject, &PySlice_Type);
+	PySliceObject *obj = PyObject_New(&PySlice_Type);
 
 	if (obj == NULL)
 		return NULL;
@@ -362,7 +396,7 @@
 	PyObject_GenericGetAttr,		/* tp_getattro */
 	0,					/* tp_setattro */
 	0,					/* tp_as_buffer */
-	Py_TPFLAGS_DEFAULT,			/* tp_flags */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_SHAREABLE,	/* tp_flags */
 	slice_doc,				/* tp_doc */
 	0,					/* tp_traverse */
 	0,					/* tp_clear */
@@ -379,6 +413,5 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	slice_new,				/* tp_new */
 };

=== modified file 'Objects/stringlib/string_format.h'
--- Objects/stringlib/string_format.h	2008-04-07 03:22:07 +0000
+++ Objects/stringlib/string_format.h	2008-04-11 02:07:14 +0000
@@ -943,7 +943,7 @@
 formatteriter_dealloc(formatteriterobject *it)
 {
     Py_XDECREF(it->str);
-    PyObject_FREE(it);
+    PyObject_Del(it);
 }
 
 /* returns a tuple:
@@ -1065,7 +1065,7 @@
 {
     formatteriterobject *it;
 
-    it = PyObject_New(formatteriterobject, &PyFormatterIter_Type);
+    it = PyObject_New(&PyFormatterIter_Type);
     if (it == NULL)
         return NULL;
 
@@ -1103,7 +1103,7 @@
 fieldnameiter_dealloc(fieldnameiterobject *it)
 {
     Py_XDECREF(it->str);
-    PyObject_FREE(it);
+    PyObject_Del(it);
 }
 
 /* returns a tuple:
@@ -1205,7 +1205,7 @@
     PyObject *first_obj = NULL;
     PyObject *result = NULL;
 
-    it = PyObject_New(fieldnameiterobject, &PyFieldNameIter_Type);
+    it = PyObject_New(&PyFieldNameIter_Type);
     if (it == NULL)
         return NULL;
 

=== modified file 'Objects/stringobject.c'
--- Objects/stringobject.c	2008-01-30 11:28:29 +0000
+++ Objects/stringobject.c	2008-03-24 04:28:03 +0000
@@ -82,11 +82,9 @@
 		return (PyObject *)op;
 	}
 
-	/* Inline PyObject_NewVar */
-	op = (PyStringObject *)PyObject_MALLOC(sizeof(PyStringObject) + size);
+	op = PyObject_NewVar(&PyString_Type, size);
 	if (op == NULL)
-		return PyErr_NoMemory();
-	PyObject_INIT_VAR(op, &PyString_Type, size);
+		return NULL;
 	op->ob_shash = -1;
 	if (str != NULL)
 		Py_MEMCPY(op->ob_sval, str, size);
@@ -130,11 +128,9 @@
 		return (PyObject *)op;
 	}
 
-	/* Inline PyObject_NewVar */
-	op = (PyStringObject *)PyObject_MALLOC(sizeof(PyStringObject) + size);
+	op = PyObject_NewVar(&PyString_Type, size);
 	if (op == NULL)
-		return PyErr_NoMemory();
-	PyObject_INIT_VAR(op, &PyString_Type, size);
+		return NULL;
 	op->ob_shash = -1;
 	Py_MEMCPY(op->ob_sval, str, size+1);
 	/* share short strings */
@@ -351,7 +347,7 @@
 static void
 string_dealloc(PyObject *op)
 {
-	Py_TYPE(op)->tp_free(op);
+	PyObject_Del(op);
 }
 
 /* Unescape a backslash-escaped string. If unicode is non-zero,
@@ -742,11 +738,9 @@
 			"repeated string is too long");
 		return NULL;
 	}
-	op = (PyStringObject *)
-		PyObject_MALLOC(sizeof(PyStringObject) + nbytes);
+	op = PyObject_NewVar(&PyString_Type, size);
 	if (op == NULL)
-		return PyErr_NoMemory();
-	PyObject_INIT_VAR(op, &PyString_Type, size);
+		return NULL;
 	op->ob_shash = -1;
 	op->ob_sval[size] = '\0';
 	if (Py_SIZE(a) == 1 && n > 0) {
@@ -3012,7 +3006,7 @@
 		return NULL;
 	assert(PyString_CheckExact(tmp));
 	n = PyString_GET_SIZE(tmp);
-	pnew = type->tp_alloc(type, n);
+	pnew = PyObject_NewVar(type, n);
 	if (pnew != NULL) {
 		Py_MEMCPY(PyString_AS_STRING(pnew),
 			  PyString_AS_STRING(tmp), n+1);
@@ -3023,6 +3017,12 @@
 	return pnew;
 }
 
+static int
+str_isshareable (PyObject *v)
+{
+    return PyString_CheckExact(v);
+}
+
 PyDoc_STRVAR(string_doc,
 "bytes(iterable_of_ints) -> bytes.\n\
 bytes(string, encoding[, errors]) -> bytes\n\
@@ -3042,7 +3042,7 @@
 	"bytes",
 	sizeof(PyStringObject),
 	sizeof(char),
- 	string_dealloc, 			/* tp_dealloc */
+	string_dealloc,				/* tp_dealloc */
 	0,			 		/* tp_print */
 	0,					/* tp_getattr */
 	0,					/* tp_setattr */
@@ -3058,7 +3058,8 @@
 	0,					/* tp_setattro */
 	&string_as_buffer,			/* tp_as_buffer */
 	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |
-		Py_TPFLAGS_STRING_SUBCLASS,	/* tp_flags */
+		Py_TPFLAGS_STRING_SUBCLASS |
+		Py_TPFLAGS_SHAREABLE,		/* tp_flags */
 	string_doc,				/* tp_doc */
 	0,					/* tp_traverse */
 	0,					/* tp_clear */
@@ -3075,9 +3076,14 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	string_new,				/* tp_new */
-	PyObject_Del,	                	/* tp_free */
+	0,					/* tp_is_gc */
+	0,					/* tp_bases */
+	0,					/* tp_mro */
+	0,					/* tp_cache */
+	0,					/* tp_subclasses */
+	0,					/* tp_weaklist */
+	str_isshareable,			/* tp_isshareable */
 };
 
 void
@@ -3125,25 +3131,19 @@
 	register PyObject *v;
 	register PyStringObject *sv;
 	v = *pv;
-	if (!PyString_Check(v) || Py_REFCNT(v) != 1 || newsize < 0) {
+	if (!PyString_Check(v) || !Py_RefcntMatches(v, 1) || newsize < 0) {
 		*pv = 0;
 		Py_DECREF(v);
 		PyErr_BadInternalCall();
 		return -1;
 	}
-	/* XXX UNREF/NEWREF interface should be more symmetrical */
-	_Py_DEC_REFTOTAL;
-	_Py_ForgetReference(v);
-	*pv = (PyObject *)
-		PyObject_REALLOC((char *)v, sizeof(PyStringObject) + newsize);
+	*pv = PyObject_Resize(v, newsize);
 	if (*pv == NULL) {
-		PyObject_Del(v);
-		PyErr_NoMemory();
+		Py_DECREF(v);
 		return -1;
 	}
-	_Py_NewReference(*pv);
 	sv = (PyStringObject *) *pv;
-	Py_SIZE(sv) = newsize;
+	assert(Py_SIZE(sv) == newsize);
 	sv->ob_sval[newsize] = '\0';
 	sv->ob_shash = -1;	/* invalidate cached hash value */
 	return 0;
@@ -3221,7 +3221,7 @@
 	}
 
 	/* To modify the string in-place, there can only be one reference. */
-	if (Py_REFCNT(result) != 1) {
+	if (!Py_RefcntMatches(result, 1)) {
 		PyErr_BadInternalCall();
 		return NULL;
 	}
@@ -3315,9 +3315,8 @@
 static void
 striter_dealloc(striterobject *it)
 {
-	_PyObject_GC_UNTRACK(it);
 	Py_XDECREF(it->it_seq);
-	PyObject_GC_Del(it);
+	PyObject_Del(it);
 }
 
 static int
@@ -3412,12 +3411,11 @@
 		PyErr_BadInternalCall();
 		return NULL;
 	}
-	it = PyObject_GC_New(striterobject, &PyStringIter_Type);
+	it = PyObject_New(&PyStringIter_Type);
 	if (it == NULL)
 		return NULL;
 	it->it_index = 0;
 	Py_INCREF(seq);
 	it->it_seq = (PyStringObject *)seq;
-	_PyObject_GC_TRACK(it);
 	return (PyObject *)it;
 }

=== modified file 'Objects/structseq.c'
--- Objects/structseq.c	2008-01-14 18:49:24 +0000
+++ Objects/structseq.c	2008-03-24 04:28:03 +0000
@@ -31,7 +31,7 @@
 {
 	PyStructSequence *obj;
 
-	obj = PyObject_New(PyStructSequence, type);
+	obj = PyObject_New(type);
 	Py_SIZE(obj) = VISIBLE_SIZE_TP(type);
 
 	return (PyObject*) obj;
@@ -466,7 +466,6 @@
 	0,					/* tp_descr_set */
 	0,	                                /* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	structseq_new,				/* tp_new */
 };
 
@@ -480,6 +479,10 @@
 #ifdef Py_TRACE_REFS
 	/* if the type object was chained, unchain it first
 	   before overwriting its storage */
+	/* This is "probably" safe.  _ob_next should only be manipulated
+	   during object creation/deletion, so it should have passed
+	   through some memory barriers before we see it.  Then again,
+	   why are we manipulating it here? */
 	if (type->ob_base.ob_base._ob_next) {
 		_Py_ForgetReference((PyObject*)type);
 	}

=== modified file 'Objects/tupleobject.c'
--- Objects/tupleobject.c	2008-02-16 07:38:31 +0000
+++ Objects/tupleobject.c	2008-03-24 04:28:03 +0000
@@ -3,6 +3,10 @@
 
 #include "Python.h"
 
+#ifndef WITH_GIL
+#define PyTuple_MAXSAVESIZE 1  /* Disabled to remove lock contention */
+#endif
+
 /* Speed optimization to avoid frequent malloc/free of small tuples */
 #ifndef PyTuple_MAXSAVESIZE
 #define PyTuple_MAXSAVESIZE	20  /* Largest tuple to save on free list */
@@ -47,12 +51,6 @@
 #ifdef COUNT_ALLOCS
 		fast_tuple_allocs++;
 #endif
-		/* Inline PyObject_InitVar */
-#ifdef Py_TRACE_REFS
-		Py_SIZE(op) = size;
-		Py_TYPE(op) = &PyTuple_Type;
-#endif
-		_Py_NewReference((PyObject *)op);
 	}
 	else
 #endif
@@ -65,20 +63,20 @@
 		{
 			return PyErr_NoMemory();
 		}
-		op = PyObject_GC_NewVar(PyTupleObject, &PyTuple_Type, size);
+		op = PyObject_NewVar(&PyTuple_Type, size);
 		if (op == NULL)
 			return NULL;
 	}
 	for (i=0; i < size; i++)
 		op->ob_item[i] = NULL;
 #if PyTuple_MAXSAVESIZE > 0
+	/* XXX FIXME this isn't threadsafe and should probably be done elsewhere */
 	if (size == 0) {
 		free_list[0] = op;
 		++numfree[0];
 		Py_INCREF(op);	/* extra INCREF so that this is never freed */
 	}
 #endif
-	_PyObject_GC_TRACK(op);
 	return (PyObject *) op;
 }
 
@@ -112,7 +110,7 @@
 {
 	register PyObject *olditem;
 	register PyObject **p;
-	if (!PyTuple_Check(op) || op->ob_refcnt != 1) {
+	if (!PyTuple_Check(op) || !Py_RefcntMatches(op, 1)) {
 		Py_XDECREF(newitem);
 		PyErr_BadInternalCall();
 		return -1;
@@ -161,8 +159,6 @@
 {
 	register Py_ssize_t i;
 	register Py_ssize_t len =  Py_SIZE(op);
-	PyObject_GC_UnTrack(op);
-	Py_TRASHCAN_SAFE_BEGIN(op)
 	if (len > 0) {
 		i = len;
 		while (--i >= 0)
@@ -175,13 +171,11 @@
 			op->ob_item[0] = (PyObject *) free_list[len];
 			numfree[len]++;
 			free_list[len] = op;
-			goto done; /* return */
+			return;
 		}
 #endif
 	}
-	Py_TYPE(op)->tp_free((PyObject *)op);
-done:
-	Py_TRASHCAN_SAFE_END(op)
+	PyObject_Del(op);
 }
 
 static PyObject *
@@ -591,7 +585,7 @@
 	if (tmp == NULL)
 		return NULL;
 	assert(PyTuple_Check(tmp));
-	newobj = type->tp_alloc(type, n = PyTuple_GET_SIZE(tmp));
+	newobj = PyObject_NewVar(type, n = PyTuple_GET_SIZE(tmp));
 	if (newobj == NULL)
 		return NULL;
 	for (i = 0; i < n; i++) {
@@ -701,6 +695,23 @@
 	0
 };
 
+static int
+tuple_isshareable (PyTupleObject *v)
+{
+    Py_ssize_t i;
+
+    if (AO_load_full(&v->shareable))
+        return 1;
+
+    for (i = 0; i < Py_SIZE(v); i++) {
+        if (!PyObject_IsShareable(PyTuple_GET_ITEM(v, i)))
+            return 0;
+    }
+
+    AO_store_full(&v->shareable, 1);
+    return 1;
+}
+
 static PyObject *tuple_iter(PyObject *seq);
 
 PyTypeObject PyTuple_Type = {
@@ -724,7 +735,8 @@
 	0,					/* tp_setattro */
 	0,					/* tp_as_buffer */
 	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
-		Py_TPFLAGS_BASETYPE | Py_TPFLAGS_TUPLE_SUBCLASS, /* tp_flags */
+		Py_TPFLAGS_BASETYPE | Py_TPFLAGS_TUPLE_SUBCLASS |
+		Py_TPFLAGS_SHAREABLE,		/* tp_flags */
 	tuple_doc,				/* tp_doc */
  	(traverseproc)tupletraverse,		/* tp_traverse */
 	0,					/* tp_clear */
@@ -741,9 +753,14 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	tuple_new,				/* tp_new */
-	PyObject_GC_Del,        		/* tp_free */
+	0,					/* tp_is_gc */
+	0,					/* tp_bases */
+	0,					/* tp_mro */
+	0,					/* tp_cache */
+	0,					/* tp_subclasses */
+	0,					/* tp_weaklist */
+	(isshareablefunc)tuple_isshareable,	/* tp_isshareable */
 };
 
 /* The following function breaks the notion that tuples are immutable:
@@ -763,7 +780,8 @@
 
 	v = (PyTupleObject *) *pv;
 	if (v == NULL || Py_TYPE(v) != &PyTuple_Type ||
-	    (Py_SIZE(v) != 0 && Py_REFCNT(v) != 1)) {
+	    (Py_SIZE(v) != 0 && !Py_RefcntMatches(v, 1)) ||
+	    v == free_list[0]) {
 		*pv = 0;
 		Py_XDECREF(v);
 		PyErr_BadInternalCall();
@@ -782,28 +800,19 @@
 		return *pv == NULL ? -1 : 0;
 	}
 
-	/* XXX UNREF/NEWREF interface should be more symmetrical */
-	_Py_DEC_REFTOTAL;
-	_PyObject_GC_UNTRACK(v);
-	_Py_ForgetReference((PyObject *) v);
 	/* DECREF items deleted by shrinkage */
-	for (i = newsize; i < oldsize; i++) {
-		Py_XDECREF(v->ob_item[i]);
-		v->ob_item[i] = NULL;
-	}
-	sv = PyObject_GC_Resize(PyTupleObject, v, newsize);
+	for (i = newsize; i < oldsize; i++)
+		Py_CLEAR(v->ob_item[i]);
+
+	sv = PyObject_Resize(v, newsize);
 	if (sv == NULL) {
 		*pv = NULL;
-		PyObject_GC_Del(v);
+#warning XXX FIXME Failed resize of tuple leaks contents
+		PyObject_Del(v);
 		return -1;
 	}
-	_Py_NewReference((PyObject *) sv);
-	/* Zero out items added by growing */
-	if (newsize > oldsize)
-		memset(&sv->ob_item[oldsize], 0,
-		       sizeof(*sv->ob_item) * (newsize - oldsize));
+
 	*pv = (PyObject *) sv;
-	_PyObject_GC_TRACK(sv);
 	return 0;
 }
 
@@ -822,7 +831,7 @@
 		while (p) {
 			q = p;
 			p = (PyTupleObject *)(p->ob_item[0]);
-			PyObject_GC_Del(q);
+			PyObject_Del(q);
 		}
 	}
 #endif
@@ -853,9 +862,8 @@
 static void
 tupleiter_dealloc(tupleiterobject *it)
 {
-	_PyObject_GC_UNTRACK(it);
 	Py_XDECREF(it->it_seq);
-	PyObject_GC_Del(it);
+	PyObject_Del(it);
 }
 
 static int
@@ -947,12 +955,11 @@
 		PyErr_BadInternalCall();
 		return NULL;
 	}
-	it = PyObject_GC_New(tupleiterobject, &PyTupleIter_Type);
+	it = PyObject_New(&PyTupleIter_Type);
 	if (it == NULL)
 		return NULL;
 	it->it_index = 0;
 	Py_INCREF(seq);
 	it->it_seq = (PyTupleObject *)seq;
-	_PyObject_GC_TRACK(it);
 	return (PyObject *)it;
 }

=== modified file 'Objects/typeobject.c'
--- Objects/typeobject.c	2008-04-07 05:43:42 +0000
+++ Objects/typeobject.c	2008-04-11 02:07:14 +0000
@@ -3,6 +3,7 @@
 #include "Python.h"
 #include "frameobject.h"
 #include "structmember.h"
+#include "monitorobject.h"
 
 #include <ctype.h>
 
@@ -74,7 +75,7 @@
 	   We don't assign new version tags eagerly, but only as
 	   needed.
 	 */
-	PyObject *raw, *ref;
+	PyObject *raw, *subcls;
 	Py_ssize_t i, n;
 
 	if (!PyType_HasFeature(type, Py_TPFLAGS_VALID_VERSION_TAG))
@@ -84,11 +85,10 @@
 	if (raw != NULL) {
 		n = PyList_GET_SIZE(raw);
 		for (i = 0; i < n; i++) {
-			ref = PyList_GET_ITEM(raw, i);
-			ref = PyWeakref_GET_OBJECT(ref);
-			if (ref != Py_None) {
-				type_modified((PyTypeObject *)ref);
-			}
+			subcls = PyWeakref_GetObjectEx(PyList_GET_ITEM(raw, i));
+			if (subcls != Py_None)
+				type_modified((PyTypeObject *)subcls);
+			Py_DECREF(subcls);
 		}
 	}
 	type->tp_flags &= ~Py_TPFLAGS_VALID_VERSION_TAG;
@@ -282,15 +282,14 @@
 	char *s;
 
 	if (type->tp_flags & Py_TPFLAGS_HEAPTYPE) {
-		mod = PyDict_GetItemString(type->tp_dict, "__module__");
-		if (!mod) { 
+		if (PyDict_GetItemStringEx(type->tp_dict, "__module__", &mod) < 0)
+			return NULL;
+		if (mod == NULL) {
 			PyErr_Format(PyExc_AttributeError, "__module__");
-			return 0;
+			return NULL;
 		}
-		Py_XINCREF(mod);
 		return mod;
-	}
-	else {
+	} else {
 		s = strrchr(type->tp_name, '.');
 		if (s != NULL)
 			return PyUnicode_FromStringAndSize(
@@ -375,10 +374,10 @@
 static int
 mro_subclasses(PyTypeObject *type, PyObject* temp)
 {
+#if 0
 	PyTypeObject *subclass;
 	PyObject *ref, *subclasses, *old_mro;
 	Py_ssize_t i, n;
-
 	subclasses = type->tp_subclasses;
 	if (subclasses == NULL)
 		return 0;
@@ -410,6 +409,7 @@
 		if (mro_subclasses(subclass, temp) < 0)
 			return -1;
 	}
+#endif
 	return 0;
 }
 
@@ -570,17 +570,18 @@
 	PyObject *result;
 	if (!(type->tp_flags & Py_TPFLAGS_HEAPTYPE) && type->tp_doc != NULL)
 		return PyUnicode_FromString(type->tp_doc);
-	result = PyDict_GetItemString(type->tp_dict, "__doc__");
+	if (PyDict_GetItemStringEx(type->tp_dict, "__doc--", &result) < 0)
+		return NULL;
 	if (result == NULL) {
-		result = Py_None;
-		Py_INCREF(result);
-	}
-	else if (Py_TYPE(result)->tp_descr_get) {
-		result = Py_TYPE(result)->tp_descr_get(result, NULL,
-						       (PyObject *)type);
-	}
-	else {
-		Py_INCREF(result);
+		Py_INCREF(Py_None);
+		return Py_None;
+	}
+	
+	if (Py_TYPE(result)->tp_descr_get) {
+		PyObject *tmp = Py_TYPE(result)->tp_descr_get(result,
+			NULL, (PyObject *)type);
+		Py_DECREF(result);
+		result = tmp;
 	}
 	return result;
 }
@@ -643,10 +644,49 @@
 		    (kwds == NULL ||
 		     (PyDict_Check(kwds) && PyDict_Size(kwds) == 0)))
 			return obj;
+
 		/* If the returned object is not an instance of type,
 		   it won't be initialized. */
 		if (!PyType_IsSubtype(Py_TYPE(obj), type))
 			return obj;
+
+		if (PyType_HasFeature(type, Py_TPFLAGS_HAVE_FINALIZE)) {
+			PyObject *queue, *handle;
+			PyObject *core = type->tp_new(type, args, kwds);
+			if (core == NULL) {
+				Py_DECREF(obj);
+				return NULL;
+			}
+			if (PyObject_SetAttrString(obj, "__finalizecore__", core) == -1) {
+				Py_DECREF(obj);
+				Py_DECREF(core);
+				return NULL;
+			}
+
+			queue = PySys_GetObject("finalizequeue");
+			if (queue == NULL) {
+				PyErr_SetString(PyExc_RuntimeError, "lost sys.finalizequeue");
+				Py_DECREF(obj);
+				Py_DECREF(core);
+				return NULL;
+			}
+			handle = PyObject_CallMethod(queue, "watch", "OO", obj, core);
+			//Py_DECREF(queue); // PySys_GetObject returns a borrowed reference
+			if (handle == NULL) {
+				Py_DECREF(obj);
+				Py_DECREF(core);
+				return NULL;
+			}
+			if (PyObject_SetAttrString(obj, "__finalizehandle__", handle) == -1) {
+				Py_DECREF(handle);
+				Py_DECREF(obj);
+				Py_DECREF(core);
+				return NULL;
+			}
+			Py_DECREF(handle);
+			Py_DECREF(core);
+		}
+
 		type = Py_TYPE(obj);
 		if (type->tp_init != NULL &&
 		    type->tp_init(obj, args, kwds) < 0) {
@@ -658,39 +698,9 @@
 }
 
 PyObject *
-PyType_GenericAlloc(PyTypeObject *type, Py_ssize_t nitems)
-{
-	PyObject *obj;
-	const size_t size = _PyObject_VAR_SIZE(type, nitems+1);
-	/* note that we need to add one, for the sentinel */
-
-	if (PyType_IS_GC(type))
-		obj = _PyObject_GC_Malloc(size);
-	else
-		obj = (PyObject *)PyObject_MALLOC(size);
-
-	if (obj == NULL)
-		return PyErr_NoMemory();
-
-	memset(obj, '\0', size);
-
-	if (type->tp_flags & Py_TPFLAGS_HEAPTYPE)
-		Py_INCREF(type);
-
-	if (type->tp_itemsize == 0)
-		PyObject_INIT(obj, type);
-	else
-		(void) PyObject_INIT_VAR((PyVarObject *)obj, type, nitems);
-
-	if (PyType_IS_GC(type))
-		_PyObject_GC_TRACK(obj);
-	return obj;
-}
-
-PyObject *
 PyType_GenericNew(PyTypeObject *type, PyObject *args, PyObject *kwds)
 {
-	return type->tp_alloc(type, 0);
+	return PyObject_New(type);
 }
 
 /* Helpers for subtyping */
@@ -738,16 +748,19 @@
 	}
 
 	if (type->tp_dictoffset != base->tp_dictoffset) {
-		PyObject **dictptr = _PyObject_GetDictPtr(self);
+		PyObject **dictptr = _PyObject_GetDictPtr_NoCheck(self);
 		if (dictptr && *dictptr)
 			Py_VISIT(*dictptr);
 	}
 
+#if 0
+	/* XXX gc_traverse does this directly now */
 	if (type->tp_flags & Py_TPFLAGS_HEAPTYPE)
 		/* For a heaptype, the instances count as references
-		   to the type.	 Traverse the type so the collector
+		   to the type.  Traverse the type so the collector
 		   can find cycles involving this link. */
 		Py_VISIT(type);
+#endif
 
 	if (basetraverse)
 		return basetraverse(self, visit, arg);
@@ -809,91 +822,9 @@
 	type = Py_TYPE(self);
 	assert(type->tp_flags & Py_TPFLAGS_HEAPTYPE);
 
-	/* Test whether the type has GC exactly once */
-
-	if (!PyType_IS_GC(type)) {
-		/* It's really rare to find a dynamic type that doesn't have
-		   GC; it can only happen when deriving from 'object' and not
-		   adding any slots or instance variables.  This allows
-		   certain simplifications: there's no need to call
-		   clear_slots(), or DECREF the dict, or clear weakrefs. */
-
-		/* Maybe call finalizer; exit early if resurrected */
-		if (type->tp_del) {
-			type->tp_del(self);
-			if (self->ob_refcnt > 0)
-				return;
-		}
-
-		/* Find the nearest base with a different tp_dealloc */
-		base = type;
-		while ((basedealloc = base->tp_dealloc) == subtype_dealloc) {
-			assert(Py_SIZE(base) == 0);
-			base = base->tp_base;
-			assert(base);
-		}
-
-		/* Call the base tp_dealloc() */
-		assert(basedealloc);
-		basedealloc(self);
-
-		/* Can't reference self beyond this point */
-		Py_DECREF(type);
-
-		/* Done */
-		return;
-	}
-
-	/* We get here only if the type has GC */
-
-	/* UnTrack and re-Track around the trashcan macro, alas */
-	/* See explanation at end of function for full disclosure */
-	PyObject_GC_UnTrack(self);
-	++_PyTrash_delete_nesting;
-	Py_TRASHCAN_SAFE_BEGIN(self);
-	--_PyTrash_delete_nesting;
-	/* DO NOT restore GC tracking at this point.  weakref callbacks
-	 * (if any, and whether directly here or indirectly in something we
-	 * call) may trigger GC, and if self is tracked at that point, it
-	 * will look like trash to GC and GC will try to delete self again.
+	/* Find the nearest base with a different tp_dealloc
+	 * Clear slots up to the nearest base with a different tp_dealloc
 	 */
-
-	/* Find the nearest base with a different tp_dealloc */
-	base = type;
-	while ((basedealloc = base->tp_dealloc) == subtype_dealloc) {
-		base = base->tp_base;
-		assert(base);
-	}
-
-	/* If we added a weaklist, we clear it.	 Do this *before* calling
-	   the finalizer (__del__), clearing slots, or clearing the instance
-	   dict. */
-
-	if (type->tp_weaklistoffset && !base->tp_weaklistoffset)
-		PyObject_ClearWeakRefs(self);
-
-	/* Maybe call finalizer; exit early if resurrected */
-	if (type->tp_del) {
-		_PyObject_GC_TRACK(self);
-		type->tp_del(self);
-		if (self->ob_refcnt > 0)
-			goto endlabel;	/* resurrected */
-		else
-			_PyObject_GC_UNTRACK(self);
-		/* New weakrefs could be created during the finalizer call.
-		    If this occurs, clear them out without calling their
-		    finalizers since they might rely on part of the object
-		    being finalized that has already been destroyed. */
-		if (type->tp_weaklistoffset && !base->tp_weaklistoffset) {
-			/* Modeled after GET_WEAKREFS_LISTPTR() */
-			PyWeakReference **list = (PyWeakReference **) \
-				PyObject_GET_WEAKREFS_LISTPTR(self);
-			while (*list)
-				_PyWeakref_ClearRef(*list);
-		}
-	}
-
-	/*  Clear slots up to the nearest base with a different tp_dealloc */
 	base = type;
 	while ((basedealloc = base->tp_dealloc) == subtype_dealloc) {
 		if (Py_SIZE(base))
@@ -904,7 +835,7 @@
 
 	/* If we added a dict, DECREF it */
 	if (type->tp_dictoffset && !base->tp_dictoffset) {
-		PyObject **dictptr = _PyObject_GetDictPtr(self);
+		PyObject **dictptr = _PyObject_GetDictPtr_NoCheck(self);
 		if (dictptr != NULL) {
 			PyObject *dict = *dictptr;
 			if (dict != NULL) {
@@ -914,119 +845,9 @@
 		}
 	}
 
-	/* Call the base tp_dealloc(); first retrack self if
-	 * basedealloc knows about gc.
-	 */
-	if (PyType_IS_GC(base))
-		_PyObject_GC_TRACK(self);
+	/* Call the base tp_dealloc() */
 	assert(basedealloc);
 	basedealloc(self);
-
-	/* Can't reference self beyond this point */
-	Py_DECREF(type);
-
-  endlabel:
-	++_PyTrash_delete_nesting;
-	Py_TRASHCAN_SAFE_END(self);
-	--_PyTrash_delete_nesting;
-
-	/* Explanation of the weirdness around the trashcan macros:
-
-	   Q. What do the trashcan macros do?
-
-	   A. Read the comment titled "Trashcan mechanism" in object.h.
-	      For one, this explains why there must be a call to GC-untrack
-	      before the trashcan begin macro.	Without understanding the
-	      trashcan code, the answers to the following questions don't make
-	      sense.
-
-	   Q. Why do we GC-untrack before the trashcan and then immediately
-	      GC-track again afterward?
-
-	   A. In the case that the base class is GC-aware, the base class
-	      probably GC-untracks the object.	If it does that using the
-	      UNTRACK macro, this will crash when the object is already
-	      untracked.  Because we don't know what the base class does, the
-	      only safe thing is to make sure the object is tracked when we
-	      call the base class dealloc.  But...  The trashcan begin macro
-	      requires that the object is *untracked* before it is called.  So
-	      the dance becomes:
-
-		 GC untrack
-		 trashcan begin
-		 GC track
-
-	   Q. Why did the last question say "immediately GC-track again"?
-	      It's nowhere near immediately.
-
-	   A. Because the code *used* to re-track immediately.	Bad Idea.
-	      self has a refcount of 0, and if gc ever gets its hands on it
-	      (which can happen if any weakref callback gets invoked), it
-	      looks like trash to gc too, and gc also tries to delete self
-	      then.  But we're already deleting self.  Double dealloction is
-	      a subtle disaster.
-
-	   Q. Why the bizarre (net-zero) manipulation of
-	      _PyTrash_delete_nesting around the trashcan macros?
-
-	   A. Some base classes (e.g. list) also use the trashcan mechanism.
-	      The following scenario used to be possible:
-
-	      - suppose the trashcan level is one below the trashcan limit
-
-	      - subtype_dealloc() is called
-
-	      - the trashcan limit is not yet reached, so the trashcan level
-		is incremented and the code between trashcan begin and end is
-		executed
-
-	      - this destroys much of the object's contents, including its
-		slots and __dict__
-
-	      - basedealloc() is called; this is really list_dealloc(), or
-		some other type which also uses the trashcan macros
-
-	      - the trashcan limit is now reached, so the object is put on the
-		trashcan's to-be-deleted-later list
-
-	      - basedealloc() returns
-
-	      - subtype_dealloc() decrefs the object's type
-
-	      - subtype_dealloc() returns
-
-	      - later, the trashcan code starts deleting the objects from its
-		to-be-deleted-later list
-
-	      - subtype_dealloc() is called *AGAIN* for the same object
-
-	      - at the very least (if the destroyed slots and __dict__ don't
-		cause problems) the object's type gets decref'ed a second
-		time, which is *BAD*!!!
-
-	      The remedy is to make sure that if the code between trashcan
-	      begin and end in subtype_dealloc() is called, the code between
-	      trashcan begin and end in basedealloc() will also be called.
-	      This is done by decrementing the level after passing into the
-	      trashcan block, and incrementing it just before leaving the
-	      block.
-
-	      But now it's possible that a chain of objects consisting solely
-	      of objects whose deallocator is subtype_dealloc() will defeat
-	      the trashcan mechanism completely: the decremented level means
-	      that the effective level never reaches the limit.	 Therefore, we
-	      *increment* the level *before* entering the trashcan block, and
-	      matchingly decrement it after leaving.  This means the trashcan
-	      code will trigger a little early, but that's no big deal.
-
-	   Q. Are there any live examples of code in need of all this
-	      complexity?
-
-	   A. Yes.  See SF bug 668433 for code that crashed (when Python was
-	      compiled in debug mode) before the trashcan level manipulations
-	      were added.  For more discussion, see SF patches 581742, 575073
-	      and bug 574207.
-	*/
 }
 
 static PyTypeObject *solid_base(PyTypeObject *type);
@@ -1065,14 +886,14 @@
 /* Internal routines to do a method lookup in the type
    without looking in the instance dictionary
    (so we can't use PyObject_GetAttr) but still binding
-   it to the instance.	The arguments are the object,
+   it to the instance.  The arguments are the object,
    the method name as a C string, and the address of a
    static variable used to cache the interned Python string.
 
    Two variants:
 
    - lookup_maybe() returns NULL without raising an exception
-     when the _PyType_Lookup() call fails;
+     when the _PyType_LookupEx() call fails;
 
    - lookup_method() always raises an exception upon errors.
 */
@@ -1087,13 +908,15 @@
 		if (*attrobj == NULL)
 			return NULL;
 	}
-	res = _PyType_Lookup(Py_TYPE(self), *attrobj);
+	if (_PyType_LookupEx(Py_TYPE(self), *attrobj, &res) < 0)
+		return NULL;
 	if (res != NULL) {
 		descrgetfunc f;
-		if ((f = Py_TYPE(res)->tp_descr_get) == NULL)
-			Py_INCREF(res);
-		else
-			res = f(res, self, (PyObject *)(Py_TYPE(self)));
+		if ((f = Py_TYPE(res)->tp_descr_get) != NULL) {
+			PyObject *tmp = f(res, self, (PyObject *)(Py_TYPE(self)));
+			Py_DECREF(res);
+			res = tmp;
+		}
 	}
 	return res;
 }
@@ -1651,9 +1474,15 @@
 		if (dict_str == NULL)
 			return NULL;
 	}
-	descr = _PyType_Lookup(type, dict_str);
-	if (descr == NULL || !PyDescr_IsData(descr))
-		return NULL;
+
+	if (_PyType_LookupEx(type, dict_str, &descr) < 0)
+		return NULL;
+	if (descr == NULL)
+		return NULL;
+	if (!PyDescr_IsData(descr)) {
+		Py_DECREF(descr);
+		return NULL;
+	}
 
 	return descr;
 }
@@ -1791,17 +1620,17 @@
 };
 
 static int
-valid_identifier(PyObject *s)
+valid_identifier(PyObject *s, const char *name)
 {
 	if (!PyUnicode_Check(s)) {
 		PyErr_Format(PyExc_TypeError,
-			     "__slots__ items must be strings, not '%.200s'",
-			     Py_TYPE(s)->tp_name);
+			     "%s items must be strings, not '%.200s'",
+			     name, Py_TYPE(s)->tp_name);
 		return 0;
 	}
 	if (!PyUnicode_IsIdentifier(s)) {
-		PyErr_SetString(PyExc_TypeError,
-				"__slots__ must be identifiers");
+		PyErr_Format(PyExc_TypeError,
+				"%s must be identifiers", name);
 		return 0;
 	}
 	return 1;
@@ -1845,12 +1674,13 @@
 {
 	PyObject *name, *bases, *dict;
 	static char *kwlist[] = {"name", "bases", "dict", 0};
-	PyObject *slots, *tmp, *newslots;
+	PyObject *slots, *tmp, *newslots, *finalizeattrs;
 	PyTypeObject *type, *base, *tmptype, *winner;
 	PyHeapTypeObject *et;
 	PyMemberDef *mp;
 	Py_ssize_t i, nbases, nslots, slotoffset, add_dict, add_weak;
 	int j, may_add_dict, may_add_weak;
+	int shared, status;
 
 	assert(args != NULL && PyTuple_Check(args));
 	assert(kwds == NULL || PyDict_Check(kwds));
@@ -1937,8 +1767,29 @@
 		return NULL;
 	}
 
+	/* Check for a __shared__ attribute */
+	shared = 0;
+	if (PyDict_GetItemStringEx(dict, "__shared__", &tmp) < 0) {
+		Py_DECREF(bases);
+		return NULL;
+	}
+	if (tmp != NULL) {
+		shared = PyObject_IsTrue(tmp);
+		Py_DECREF(tmp);
+		if (shared == -1) {
+			Py_DECREF(bases);
+			return NULL;
+		}
+	}
+	/* XXX FIXME do an audit, ensure all possible attributes are
+	 * checked for shareability.  For now I'm going to be lazy and
+	 * just check the most obvious ones. */
+
 	/* Check for a __slots__ sequence variable in dict, and count it */
-	slots = PyDict_GetItemString(dict, "__slots__");
+	if (PyDict_GetItemStringEx(dict, "__slots__", &slots) < 0) {
+		Py_DECREF(bases);
+		return NULL;
+	}
 	nslots = 0;
 	add_dict = 0;
 	add_weak = 0;
@@ -1957,9 +1808,11 @@
 
 		/* Make it into a tuple */
 		if (PyUnicode_Check(slots))
-			slots = PyTuple_Pack(1, slots);
+			tmp = PyTuple_Pack(1, slots);
 		else
-			slots = PySequence_Tuple(slots);
+			tmp = PySequence_Tuple(slots);
+		Py_DECREF(slots);
+		slots = tmp;
 		if (slots == NULL) {
 			Py_DECREF(bases);
 			return NULL;
@@ -1982,7 +1835,7 @@
 		/* Check for valid slot names and two special cases */
 		for (i = 0; i < nslots; i++) {
 			PyObject *tmp = PyTuple_GET_ITEM(slots, i);
-			if (!valid_identifier(tmp))
+			if (!valid_identifier(tmp, "__slots__"))
 				goto bad_slots;
 			assert(PyUnicode_Check(tmp));
 			if (PyUnicode_CompareWithASCIIString(tmp, "__dict__") == 0) {
@@ -2071,7 +1924,9 @@
 	   "return NULL" may leak slots! */
 
 	/* Allocate the type object */
-	type = (PyTypeObject *)metatype->tp_alloc(metatype, nslots);
+	/* XXX This assumes the allocator will allocate one extra slot
+	 * for the sentinal. */
+	type = PyObject_NewVar(metatype, nslots);
 	if (type == NULL) {
 		Py_XDECREF(slots);
 		Py_DECREF(bases);
@@ -2107,62 +1962,87 @@
 	type->tp_base = base;
 
 	/* Initialize tp_dict from passed-in dict */
-	type->tp_dict = dict = PyDict_Copy(dict);
+	if (shared)
+		type->tp_dict = dict = PyObject_CallFunction(
+			(PyObject *)&PySharedDict_Type, "(O)", dict);
+	else
+		type->tp_dict = dict = PyDict_Copy(dict);
 	if (dict == NULL) {
 		Py_DECREF(type);
 		return NULL;
 	}
 
 	/* Set __module__ in the dict */
-	if (PyDict_GetItemString(dict, "__module__") == NULL) {
-		tmp = PyEval_GetGlobals();
-		if (tmp != NULL) {
-			tmp = PyDict_GetItemString(tmp, "__name__");
+	if (PyDict_GetItemStringEx(dict, "__module__", &tmp) < 0) {
+		Py_DECREF(type);
+		return NULL;
+	}
+	if (tmp == NULL) {
+		PyObject *globals = PyEval_GetGlobals();
+		if (globals != NULL) {
+			if (PyDict_GetItemStringEx(globals, "__name__", &tmp) < 0)
+				return NULL;
 			if (tmp != NULL) {
 				if (PyDict_SetItemString(dict, "__module__",
-							 tmp) < 0)
+							 tmp) < 0) {
+					Py_DECREF(tmp);
 					return NULL;
+				}
+				Py_DECREF(tmp);
 			}
 		}
-	}
+	} else
+		Py_DECREF(tmp);
 
 	/* Set tp_doc to a copy of dict['__doc__'], if the latter is there
 	   and is a string.  The __doc__ accessor will first look for tp_doc;
 	   if that fails, it will still look into __dict__.
 	*/
 	{
-		PyObject *doc = PyDict_GetItemString(dict, "__doc__");
+		PyObject *doc;
+		if (PyDict_GetItemStringEx(dict, "__doc__", &doc) < 0) {
+			Py_DECREF(type);
+			return NULL;
+		}
 		if (doc != NULL && PyUnicode_Check(doc)) {
 			size_t n;
 			char *tp_doc;
 			const char *str = PyUnicode_AsString(doc);
 			if (str == NULL) {
 				Py_DECREF(type);
+				Py_DECREF(doc);
 				return NULL;
 			}
 			n = strlen(str);
 			tp_doc = (char *)PyObject_MALLOC(n+1);
 			if (tp_doc == NULL) {
 				Py_DECREF(type);
+				Py_DECREF(doc);
 				return NULL;
 			}
 			memcpy(tp_doc, str, n+1);
 			type->tp_doc = tp_doc;
 		}
+		Py_XDECREF(doc);
 	}
 
 	/* Special-case __new__: if it's a plain function,
 	   make it a static function */
-	tmp = PyDict_GetItemString(dict, "__new__");
+	if (PyDict_GetItemStringEx(dict, "__new__", &tmp) < 0) {
+		Py_DECREF(type);
+		return NULL;
+	}
 	if (tmp != NULL && PyFunction_Check(tmp)) {
-		tmp = PyStaticMethod_New(tmp);
-		if (tmp == NULL) {
+		PyObject *tmp2 = PyStaticMethod_New(tmp);
+		Py_DECREF(tmp);
+		if (tmp2 == NULL) {
 			Py_DECREF(type);
 			return NULL;
 		}
-		PyDict_SetItemString(dict, "__new__", tmp);
-		Py_DECREF(tmp);
-	}
+		PyDict_SetItemString(dict, "__new__", tmp2);
+		Py_DECREF(tmp2);
+	} else
+		Py_XDECREF(tmp);
 
 	/* Add descriptors for custom slots from __slots__, or for __dict__ */
 	mp = PyHeapType_GET_MEMBERS(et);
@@ -2221,14 +2101,42 @@
 		type->tp_flags |= Py_TPFLAGS_HAVE_GC;
 
 	/* Always override allocation strategy to use regular heap */
-	type->tp_alloc = PyType_GenericAlloc;
+	/* XXX This comment needs updating */
 	if (type->tp_flags & Py_TPFLAGS_HAVE_GC) {
-		type->tp_free = PyObject_GC_Del;
 		type->tp_traverse = subtype_traverse;
 		type->tp_clear = subtype_clear;
 	}
-	else
-		type->tp_free = PyObject_Del;
+
+	/* Activate sharing, check that the contents are shareable too */
+	if (shared) {
+		type->tp_flags |= Py_TPFLAGS_SHAREABLE;
+
+		for (i = 0; i < nbases; i++) {
+			tmp = PyTuple_GET_ITEM(bases, i);
+			if (!PyObject_IsShareable(tmp)) {
+				PyErr_SetString(PyExc_TypeError,
+					"Shared type given unshareable base");
+				Py_DECREF(type);
+				return NULL;
+			}
+		}
+	}
+
+	status = PyDict_ContainsString(dict, "__finalize__");
+	if (status < 0) {
+		Py_DECREF(type);
+		return NULL;
+	} else if (status > 0)
+		type->tp_flags |= Py_TPFLAGS_HAVE_FINALIZE;
+	else {
+		for (i = 0; i < nbases; i++) {
+			tmp = PyTuple_GET_ITEM(bases, i);
+			if (((PyTypeObject *)tmp)->tp_flags & Py_TPFLAGS_HAVE_FINALIZE) {
+				type->tp_flags |= Py_TPFLAGS_HAVE_FINALIZE;
+				break;
+			}
+		}
+	}
 
 	/* Initialize the rest */
 	if (PyType_Ready(type) < 0) {
@@ -2239,18 +2147,68 @@
 	/* Put the proper slots in place */
 	fixup_slot_dispatchers(type);
 
+	/* Add __finalizeattrs__ */
+	if (PyDict_GetItemStringEx(dict, "__finalizeattrs__", &finalizeattrs) < 0) {
+		Py_DECREF(type);
+		return NULL;
+	}
+	if (finalizeattrs != NULL) {
+		/* Make it into a tuple */
+		if (PyUnicode_Check(finalizeattrs))
+			tmp = PyTuple_Pack(1, finalizeattrs);
+		else
+			tmp = PySequence_Tuple(finalizeattrs);
+		Py_DECREF(finalizeattrs);
+		finalizeattrs = tmp;
+		if (finalizeattrs == NULL) {
+			Py_DECREF(type);
+			return NULL;
+		}
+		assert(PyTuple_Check(finalizeattrs));
+
+		for (i = 0; i < PyTuple_GET_SIZE(finalizeattrs); i++) {
+			PyObject *descr;
+			PyObject *tmp = PyTuple_GET_ITEM(finalizeattrs, i);
+
+			if (!valid_identifier(tmp, "__finalizeattrs__")) {
+				Py_DECREF(type);
+				return NULL;
+			}
+
+			descr = PyDescr_NewFinalizeAttr(type, tmp);
+			if (descr == NULL) {
+				Py_DECREF(type);
+				return NULL;
+			}
+
+			if (PyDict_SetItem(type->tp_dict, tmp, descr) < 0) {
+				Py_DECREF(finalizeattrs);
+				Py_DECREF(descr);
+				Py_DECREF(type);
+				return NULL;
+			}
+		}
+		Py_DECREF(finalizeattrs);
+	}
+
 	return (PyObject *)type;
 }
 
-/* Internal API to look for a name through the MRO.
-   This returns a borrowed reference, and doesn't set an exception! */
-PyObject *
-_PyType_Lookup(PyTypeObject *type, PyObject *name)
+/* Internal API to look for a name through the MRO.  Return values:
+ * -1 Error, exception set (result set to NULL)
+ *  0 Success (result filled in with *NEW* reference)
+ * +1 Not found, no exception set (result set to NULL)
+ */
+int
+_PyType_LookupEx(PyTypeObject *type, PyObject *name, PyObject **result)
 {
 	Py_ssize_t i, n;
-	PyObject *mro, *res, *base, *dict;
+	PyObject *mro, *base, *dict;
 	unsigned int h;
 
+	*result = NULL;
+
+#if 0
 	if (MCACHE_CACHEABLE_NAME(name) &&
 	    PyType_HasFeature(type, Py_TPFLAGS_VALID_VERSION_TAG)) {
 		/* fast path */
@@ -2259,6 +2217,7 @@
 		    method_cache[h].name == name)
 		    return method_cache[h].value;
 	}
+#endif
 
 	/* Look in tp_dict of types in MRO */
 	mro = type->tp_mro;
@@ -2267,21 +2226,27 @@
 	   by PyType_Ready(), or already cleared by type_clear().
 	   Either way the safest thing to do is to return NULL. */
 	if (mro == NULL)
-		return NULL;
+		return 1;  /* XXX should this be -1 with an exception instead? */
 
-	res = NULL;
 	assert(PyTuple_Check(mro));
 	n = PyTuple_GET_SIZE(mro);
 	for (i = 0; i < n; i++) {
 		base = PyTuple_GET_ITEM(mro, i);
 		assert(PyType_Check(base));
+
 		dict = ((PyTypeObject *)base)->tp_dict;
 		assert(dict && PyDict_Check(dict));
-		res = PyDict_GetItem(dict, name);
-		if (res != NULL)
-			break;
+
+		if (PyDict_GetItemEx(dict, name, result) < 0)
+			return -1;
+		if (*result != NULL)
+			return 0;
 	}
 
+#if 1
+	return 1;
+#else
+#error needs fixing and sanity-checking
 	if (MCACHE_CACHEABLE_NAME(name) && assign_version_tag(type)) {
 		h = MCACHE_HASH_METHOD(type, name);
 		method_cache[h].version = type->tp_version_tag;
@@ -2290,11 +2255,13 @@
 		Py_DECREF(method_cache[h].name);
 		method_cache[h].name = name;
 	}
-	return res;
+        *result = res;
+        return 0;
+#endif
 }
 
 /* This is similar to PyObject_GenericGetAttr(),
-   but uses _PyType_Lookup() instead of just looking in type->tp_dict. */
+   but uses _PyType_LookupEx() instead of just looking in type->tp_dict. */
 static PyObject *
 type_getattro(PyTypeObject *type, PyObject *name)
 {
@@ -2312,7 +2279,8 @@
 	meta_get = NULL;
 
 	/* Look for the attribute in the metatype */
-	meta_attribute = _PyType_Lookup(metatype, name);
+	if (_PyType_LookupEx(metatype, name, &meta_attribute) < 0)
+		return NULL;
 
 	if (meta_attribute != NULL) {
 		meta_get = Py_TYPE(meta_attribute)->tp_descr_get;
@@ -2322,15 +2290,19 @@
 			 * writes. Assume the attribute is not overridden in
 			 * type's tp_dict (and bases): call the descriptor now.
 			 */
-			return meta_get(meta_attribute, (PyObject *)type,
-					(PyObject *)metatype);
+			attribute = meta_get(meta_attribute, (PyObject *)type,
+				(PyObject *)metatype);
+			Py_DECREF(meta_attribute);
+			return attribute;
 		}
-		Py_INCREF(meta_attribute);
 	}
 
 	/* No data descriptor found on metatype. Look in tp_dict of this
 	 * type and its bases */
-	attribute = _PyType_Lookup(type, name);
+	if (_PyType_LookupEx(type, name, &attribute) < 0) {
+		Py_XDECREF(meta_attribute);
+		return NULL;
+	}
 	if (attribute != NULL) {
 		/* Implement descriptor functionality, if any */
 		descrgetfunc local_get = Py_TYPE(attribute)->tp_descr_get;
@@ -2338,13 +2310,15 @@
 		Py_XDECREF(meta_attribute);
 
 		if (local_get != NULL) {
+			PyObject *tmp;
 			/* NULL 2nd argument indicates the descriptor was
 			 * found on the target object itself (or a base)  */
-			return local_get(attribute, (PyObject *)NULL,
-					 (PyObject *)type);
+			tmp = local_get(attribute, (PyObject *)NULL,
+				(PyObject *)type);
+			Py_DECREF(attribute);
+			return tmp;
 		}
 
-		Py_INCREF(attribute);
 		return attribute;
 	}
 
@@ -2392,8 +2366,6 @@
 
 	/* Assert this is a heap-allocated type object */
 	assert(type->tp_flags & Py_TPFLAGS_HEAPTYPE);
-	_PyObject_GC_UNTRACK(type);
-	PyObject_ClearWeakRefs((PyObject *)type);
 	et = (PyHeapTypeObject *)type;
 	Py_XDECREF(type->tp_base);
 	Py_XDECREF(type->tp_dict);
@@ -2404,10 +2376,10 @@
 	/* A type's tp_doc is heap allocated, unlike the tp_doc slots
 	 * of most other objects.  It's okay to cast it to char *.
 	 */
-	PyObject_Free((char *)type->tp_doc);
+	PyObject_FREE((char *)type->tp_doc);
 	Py_XDECREF(et->ht_name);
 	Py_XDECREF(et->ht_slots);
-	Py_TYPE(type)->tp_free((PyObject *)type);
+	PyObject_Del(type);
 }
 
 static PyObject *
@@ -2419,6 +2391,7 @@
 	list = PyList_New(0);
 	if (list == NULL)
 		return NULL;
+#if 0
 	raw = type->tp_subclasses;
 	if (raw == NULL)
 		return list;
@@ -2435,6 +2408,7 @@
 			}
 		}
 	}
+#endif
 	return list;
 }
 
@@ -2488,6 +2462,7 @@
 	   for heaptypes. */
 	assert(type->tp_flags & Py_TPFLAGS_HEAPTYPE);
 
+#warning XXX FIXME this should check for subtypes of type and change ob_type to a known-safe value for HEAPTYPEs
 	/* The only field we need to clear is tp_mro, which is part of a
 	   hard cycle (its first element is the class itself) that won't
 	   be broken otherwise (it's a tuple and tuples don't have a
@@ -2524,6 +2499,17 @@
 	return type->tp_flags & Py_TPFLAGS_HEAPTYPE;
 }
 
+static int
+type_isshareable (PyTypeObject *type)
+{
+#warning XXX FIXME HACK pretending io.OpenWrapper and collections.MutableMapping are shareable
+    if (strcmp(type->tp_name, "OpenWrapper") == 0 ||
+            strcmp(type->tp_name, "MutableMapping") == 0)
+        return 1;
+
+    return PyType_HasFeature(type, Py_TPFLAGS_SHAREABLE);
+}
+
 PyTypeObject PyType_Type = {
 	PyVarObject_HEAD_INIT(&PyType_Type, 0)
 	"type",					/* tp_name */
@@ -2545,7 +2531,8 @@
 	(setattrofunc)type_setattro,		/* tp_setattro */
 	0,					/* tp_as_buffer */
 	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
-		Py_TPFLAGS_BASETYPE | Py_TPFLAGS_TYPE_SUBCLASS,	/* tp_flags */
+		Py_TPFLAGS_BASETYPE | Py_TPFLAGS_TYPE_SUBCLASS |
+		Py_TPFLAGS_SHAREABLE,		/* tp_flags */
 	type_doc,				/* tp_doc */
 	(traverseproc)type_traverse,		/* tp_traverse */
 	(inquiry)type_clear,			/* tp_clear */
@@ -2562,10 +2549,14 @@
 	0,					/* tp_descr_set */
 	offsetof(PyTypeObject, tp_dict),	/* tp_dictoffset */
 	type_init,				/* tp_init */
-	0,					/* tp_alloc */
 	type_new,				/* tp_new */
-	PyObject_GC_Del,			/* tp_free */
 	(inquiry)type_is_gc,			/* tp_is_gc */
+	0,					/* tp_bases */
+	0,					/* tp_mro */
+	0,					/* tp_cache */
+	0,					/* tp_subclasses */
+	0,					/* tp_weaklist */
+	(isshareablefunc)type_isshareable,	/* tp_isshareable */
 };
 
 
@@ -2604,6 +2595,13 @@
    __init__() is overridden and __new__() is not overridden
    (IOW, if __new__() is overridden or __init__() is not overridden).
 
+       __new__     __init__    __new__     __init__
+      overridden  overridden  complains   complains
+   a.     no          no         yes         yes
+   b.     no         yes          no         yes
+   c.    yes          no         yes          no
+   d.    yes         yes         yes         yes
+
    However, for backwards compatibility, this breaks too much code.
    Therefore, in 2.6, we'll *warn* about excess arguments when both
    methods are overridden; for all other cases we'll use the above
@@ -2629,14 +2627,14 @@
 	if (excess_args(args, kwds)) {
 		PyTypeObject *type = Py_TYPE(self);
 		if (type->tp_init != object_init &&
-		    type->tp_new != object_new)
+		    type->tp_new != object_new) /* Condition d */
 		{
 			err = PyErr_WarnEx(PyExc_DeprecationWarning,
 				   "object.__init__() takes no parameters",
 				   1);
 		}
-		else if (type->tp_init != object_init ||
-			 type->tp_new == object_new)
+		else if (type->tp_init != object_init || /* Conditions b, d */
+			 type->tp_new == object_new) /* Conditions a, b */
 		{
 			PyErr_SetString(PyExc_TypeError,
 				"object.__init__() takes no parameters");
@@ -2652,14 +2650,14 @@
 	int err = 0;
 	if (excess_args(args, kwds)) {
 		if (type->tp_new != object_new &&
-		    type->tp_init != object_init)
+		    type->tp_init != object_init) /* Condition d */
 		{
 			err = PyErr_WarnEx(PyExc_DeprecationWarning,
 				   "object.__new__() takes no parameters",
 				   1);
 		}
-		else if (type->tp_new != object_new ||
-			 type->tp_init == object_init)
+		else if (type->tp_new != object_new || /* Conditions c, d */
+			 type->tp_init == object_init) /* Conditions a, c */
 		{
 			PyErr_SetString(PyExc_TypeError,
 				"object.__new__() takes no parameters");
@@ -2714,13 +2712,13 @@
 		Py_XDECREF(abstract_methods);
 		return NULL;
 	}
-	return type->tp_alloc(type, 0);
+	return PyObject_New(type);
 }
 
 static void
 object_dealloc(PyObject *self)
 {
-	Py_TYPE(self)->tp_free(self);
+	PyObject_Del(self);
 }
 
 static PyObject *
@@ -2858,9 +2856,7 @@
 {
 	PyTypeObject *newbase, *oldbase;
 
-	if (newto->tp_dealloc != oldto->tp_dealloc ||
-	    newto->tp_free != oldto->tp_free)
-	{
+	if (newto->tp_dealloc != oldto->tp_dealloc) {
 		PyErr_Format(PyExc_TypeError,
 			     "%s assignment: "
 			     "'%s' deallocator differs from '%s'",
@@ -2967,10 +2963,12 @@
 	}
 
 	clsdict = ((PyTypeObject *)cls)->tp_dict;
-	slotnames = PyDict_GetItemString(clsdict, "__slotnames__");
-	if (slotnames != NULL && PyList_Check(slotnames)) {
-		Py_INCREF(slotnames);
-		return slotnames;
+	if (PyDict_GetItemStringEx(clsdict, "__slotnames__", &slotnames) < 0)
+		return NULL;
+	if (slotnames != NULL) {
+		if (PyList_Check(slotnames))
+			return slotnames;
+		Py_DECREF(slotnames);
 	}
 
 	copy_reg = import_copy_reg();
@@ -3203,10 +3201,14 @@
 			Py_DECREF(reduce);
 			return NULL;
 		}
-		objreduce = PyDict_GetItemString(PyBaseObject_Type.tp_dict,
-						 "__reduce__");
+		if (PyDict_GetItemStringEx(PyBaseObject_Type.tp_dict,
+				"__reduce__", &objreduce) < 0) {
+			Py_DECREF(reduce);
+			return NULL;
+		}
 		override = (clsreduce != objreduce);
 		Py_DECREF(clsreduce);
+		Py_XDECREF(objreduce);
 		if (override) {
 			res = PyObject_CallObject(reduce, NULL);
 			Py_DECREF(reduce);
@@ -3268,6 +3270,31 @@
         return result;
 }
 
+static PyObject *
+object_finalize(PyObject *self, PyObject *args)
+{
+    PyObject *handle, *queue, *res;
+
+    handle = PyObject_GetAttrString(self, "__finalizehandle__");
+    if (handle == NULL && PyErr_ExceptionMatches(PyExc_AttributeError)) {
+        PyErr_Clear();
+        Py_INCREF(Py_None);
+        return Py_None;
+    } else if (handle == NULL)
+        return NULL;
+
+    queue = PySys_GetObject("finalizequeue");
+    if (queue == NULL) {
+        PyErr_SetString(PyExc_RuntimeError, "lost sys.finalizequeue");
+        Py_DECREF(handle);
+        return NULL;
+    }
+
+    res = PyObject_CallMethod(queue, "cancel", "O", handle);
+    //Py_DECREF(queue); // PySys_GetObject returns a borrowed reference
+    return res;
+}
+
 static PyMethodDef object_methods[] = {
 	{"__reduce_ex__", object_reduce_ex, METH_VARARGS,
 	 PyDoc_STR("helper for pickle")},
@@ -3277,6 +3304,8 @@
 	 object_subclasshook_doc},
         {"__format__", object_format, METH_VARARGS,
          PyDoc_STR("default object formatter")},
+        {"__finalize__", object_finalize, METH_NOARGS,
+         PyDoc_STR("base finalize method")},
 	{0}
 };
 
@@ -3301,7 +3330,8 @@
 	PyObject_GenericGetAttr,		/* tp_getattro */
 	PyObject_GenericSetAttr,		/* tp_setattro */
 	0,					/* tp_as_buffer */
-	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |
+		Py_TPFLAGS_SHAREABLE,		/* tp_flags */
 	PyDoc_STR("The most base type"),	/* tp_doc */
 	0,					/* tp_traverse */
 	0,					/* tp_clear */
@@ -3318,9 +3348,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	object_init,				/* tp_init */
-	PyType_GenericAlloc,			/* tp_alloc */
 	object_new,				/* tp_new */
-	PyObject_Del,				/* tp_free */
 };
 
 
@@ -3333,9 +3361,14 @@
 
 	for (; meth->ml_name != NULL; meth++) {
 		PyObject *descr;
-		if (PyDict_GetItemString(dict, meth->ml_name) &&
-			!(meth->ml_flags & METH_COEXIST))
+		int status;
+
+		if ((status = PyDict_ContainsString(dict, meth->ml_name))) {
+			if (status < 0)
+				return -1;
+			if (!(meth->ml_flags & METH_COEXIST))
 				continue;
+		}
 		if (meth->ml_flags & METH_CLASS) {
 			if (meth->ml_flags & METH_STATIC) {
 				PyErr_SetString(PyExc_ValueError,
@@ -3370,8 +3403,12 @@
 
 	for (; memb->name != NULL; memb++) {
 		PyObject *descr;
-		if (PyDict_GetItemString(dict, memb->name))
+		if (PyDict_GetItemStringEx(dict, memb->name, &descr) < 0)
+			return -1;
+		if (descr != NULL) {
+			Py_DECREF(descr);
 			continue;
+		}
 		descr = PyDescr_NewMember(type, memb);
 		if (descr == NULL)
 			return -1;
@@ -3389,8 +3426,12 @@
 
 	for (; gsp->name != NULL; gsp++) {
 		PyObject *descr;
-		if (PyDict_GetItemString(dict, gsp->name))
+		if (PyDict_GetItemStringEx(dict, gsp->name, &descr) < 0)
+			return -1;
+		if (descr != NULL) {
+			Py_DECREF(descr);
 			continue;
+		}
 		descr = PyDescr_NewGetSet(type, gsp);
 
 		if (descr == NULL)
@@ -3465,6 +3506,8 @@
 		type->tp_flags |= Py_TPFLAGS_LIST_SUBCLASS;
 	else if (PyType_IsSubtype(base, &PyDict_Type))
 		type->tp_flags |= Py_TPFLAGS_DICT_SUBCLASS;
+	else if (PyType_IsSubtype(base, &PyMonitor_Type))
+		type->tp_flags |= Py_TPFLAGS_MONITOR_SUBCLASS;
 }
 
 static char *hash_name_op[] = {
@@ -3474,21 +3517,24 @@
 	NULL
 };
 
+/* 1 is returned if a method is found, 0 if none are found, and -1 on error */
 static int
 overrides_hash(PyTypeObject *type)
 {
 	char **p;
 	PyObject *dict = type->tp_dict;
+	int result;
 
 	assert(dict != NULL);
 	for (p = hash_name_op; *p; p++) {
-		if (PyDict_GetItemString(dict, *p) != NULL)
-			return 1;
+		result = PyDict_ContainsString(dict, *p);
+		if (result)
+			return result;
 	}
 	return 0;
 }
 
-static void
+static int
 inherit_slots(PyTypeObject *type, PyTypeObject *base)
 {
 	PyTypeObject *basebase;
@@ -3602,19 +3648,21 @@
 	/* tp_hash see tp_richcompare */
 	COPYSLOT(tp_call);
 	COPYSLOT(tp_str);
-	{
-		/* Copy comparison-related slots only when
-		   not overriding them anywhere */
-		if (type->tp_compare == NULL &&
-		    type->tp_richcompare == NULL &&
-		    type->tp_hash == NULL &&
-		    !overrides_hash(type))
-		{
+
+	/* Copy comparison-related slots only when
+	   not overriding them anywhere */
+	if (type->tp_compare == NULL && type->tp_richcompare == NULL &&
+			type->tp_hash == NULL) {
+		int status = overrides_hash(type);
+		if (status < 0)
+			return -1;
+		else if (status == 0) {
 			type->tp_compare = base->tp_compare;
 			type->tp_richcompare = base->tp_richcompare;
 			type->tp_hash = base->tp_hash;
 		}
 	}
+
 	{
 		COPYSLOT(tp_iter);
 		COPYSLOT(tp_iternext);
@@ -3623,28 +3671,12 @@
 		COPYSLOT(tp_descr_get);
 		COPYSLOT(tp_descr_set);
 		COPYSLOT(tp_dictoffset);
+		COPYSLOT(tp_isshareable);
 		COPYSLOT(tp_init);
-		COPYSLOT(tp_alloc);
 		COPYSLOT(tp_is_gc);
-		if ((type->tp_flags & Py_TPFLAGS_HAVE_GC) ==
-		    (base->tp_flags & Py_TPFLAGS_HAVE_GC)) {
-			/* They agree about gc. */
-			COPYSLOT(tp_free);
-		}
-		else if ((type->tp_flags & Py_TPFLAGS_HAVE_GC) &&
-			 type->tp_free == NULL &&
-			 base->tp_free == PyObject_Free) {
-			/* A bit of magic to plug in the correct default
-			 * tp_free function when a derived class adds gc,
-			 * didn't define tp_free, and the base uses the
-			 * default non-gc tp_free.
-			 */
-			type->tp_free = PyObject_GC_Del;
-		}
-		/* else they didn't agree about gc, and there isn't something
-		 * obvious to be done -- the type is on its own.
-		 */
 	}
+
+	return 0;
 }
 
 static int add_operators(PyTypeObject *);
@@ -3652,7 +3684,7 @@
 int
 PyType_Ready(PyTypeObject *type)
 {
-	PyObject *dict, *bases;
+	PyObject *dict, *bases, *doc;
 	PyTypeObject *base;
 	Py_ssize_t i, n;
 
@@ -3663,6 +3695,7 @@
 	assert((type->tp_flags & Py_TPFLAGS_READYING) == 0);
 
 	type->tp_flags |= Py_TPFLAGS_READYING;
+//	printf("Readying %s\n", type->tp_name);
 
 #ifdef Py_TRACE_REFS
 	/* PyType_Ready is the closest thing we have to a choke point
@@ -3690,12 +3723,12 @@
 			goto error;
 	}
 
-	/* Initialize ob_type if NULL.	This means extensions that want to be
+	/* Initialize ob_type if NULL.  This means extensions that want to be
 	   compilable separately on Windows can call PyType_Ready() instead of
 	   initializing the ob_type field of their type objects. */
 	/* The test for base != NULL is really unnecessary, since base is only
 	   NULL when type is &PyBaseObject_Type, and we know its ob_type is
-	   not NULL (it's initialized to &PyType_Type).	 But coverity doesn't
+	   not NULL (it's initialized to &PyType_Type).  But coverity doesn't
 	   know that. */
 	if (Py_TYPE(type) == NULL && base != NULL)
 		Py_TYPE(type) = Py_TYPE(base);
@@ -3753,29 +3786,20 @@
 	n = PyTuple_GET_SIZE(bases);
 	for (i = 1; i < n; i++) {
 		PyObject *b = PyTuple_GET_ITEM(bases, i);
-		if (PyType_Check(b))
-			inherit_slots(type, (PyTypeObject *)b);
-	}
-
-	/* Sanity check for tp_free. */
-	if (PyType_IS_GC(type) && (type->tp_flags & Py_TPFLAGS_BASETYPE) &&
-	    (type->tp_free == NULL || type->tp_free == PyObject_Del)) {
-		/* This base class needs to call tp_free, but doesn't have
-		 * one, or its tp_free is for non-gc'ed objects.
-		 */
-		PyErr_Format(PyExc_TypeError, "type '%.100s' participates in "
-			     "gc and is a base type but has inappropriate "
-			     "tp_free slot",
-			     type->tp_name);
-		goto error;
+		if (PyType_Check(b)) {
+			if (inherit_slots(type, (PyTypeObject *)b))
+				goto error;
+		}
 	}
 
 	/* if the type dictionary doesn't contain a __doc__, set it from
 	   the tp_doc slot.
 	 */
-	if (PyDict_GetItemString(type->tp_dict, "__doc__") == NULL) {
+	if (PyDict_GetItemStringEx(type->tp_dict, "__doc__", &doc) < 0)
+		goto error;
+	if (doc == NULL) {
 		if (type->tp_doc != NULL) {
-			PyObject *doc = PyUnicode_FromString(type->tp_doc);
+			doc = PyUnicode_FromString(type->tp_doc);
 			if (doc == NULL)
 				goto error;
 			PyDict_SetItemString(type->tp_dict, "__doc__", doc);
@@ -3784,7 +3808,8 @@
 			PyDict_SetItemString(type->tp_dict,
 					     "__doc__", Py_None);
 		}
-	}
+	} else
+		Py_DECREF(doc);
 
 	/* Hack for tp_hash and __hash__.
 	   If after all that, tp_hash is still NULL, and __hash__ is not in
@@ -3792,10 +3817,14 @@
 	   This signals that __hash__ is not inherited.
 	 */
 	if (type->tp_hash == NULL) {
-		if (PyDict_GetItemString(type->tp_dict, "__hash__") == NULL) {
+		PyObject *hash;
+		if (PyDict_GetItemStringEx(type->tp_dict, "__hash__", &hash) < 0)
+			goto error;
+		if (hash == NULL) {
 			if (PyDict_SetItemString(type->tp_dict, "__hash__", Py_None) < 0)
 				goto error;
-		}
+		} else
+			Py_DECREF(hash);
 	}
 
 	/* Some more special stuff */
@@ -3835,6 +3864,9 @@
 static int
 add_subclass(PyTypeObject *base, PyTypeObject *type)
 {
+        return 0; /* XXX FIXME brutal hack! */
+
+#if 0
 	Py_ssize_t i;
 	int result;
 	PyObject *list, *ref, *newobj;
@@ -3857,11 +3889,15 @@
 	result = PyList_Append(list, newobj);
 	Py_DECREF(newobj);
 	return result;
+#endif
 }
 
 static void
 remove_subclass(PyTypeObject *base, PyTypeObject *type)
 {
+        return; /* XXX FIXME brutal hack! */
+
+#if 0
 	Py_ssize_t i;
 	PyObject *list, *ref;
 
@@ -3880,6 +3916,7 @@
 			return;
 		}
 	}
+#endif
 }
 
 static int
@@ -4439,8 +4476,12 @@
 add_tp_new_wrapper(PyTypeObject *type)
 {
 	PyObject *func;
+	int status;
 
-	if (PyDict_GetItemString(type->tp_dict, "__new__") != NULL)
+	status = PyDict_ContainsString(type->tp_dict, "__new__");
+	if (status < 0)
+		return -1;
+	if (status > 0)
 		return 0;
 	func = PyCFunction_New(tp_new_methoddef, (PyObject *)type);
 	if (func == NULL)
@@ -4589,12 +4630,14 @@
 		if (getitem_str == NULL)
 			return NULL;
 	}
-	func = _PyType_Lookup(Py_TYPE(self), getitem_str);
+
+	if (_PyType_LookupEx(Py_TYPE(self), getitem_str, &func) < 0)
+		return NULL;
 	if (func != NULL) {
-		if ((f = Py_TYPE(func)->tp_descr_get) == NULL)
-			Py_INCREF(func);
-		else {
-			func = f(func, self, (PyObject *)(Py_TYPE(self)));
+		if ((f = Py_TYPE(func)->tp_descr_get) != NULL) {
+			PyObject *tmp = f(func, self, (PyObject *)(Py_TYPE(self)));
+			Py_DECREF(func);
+			func = tmp;
 			if (func == NULL) {
 				return NULL;
 			}
@@ -4610,10 +4653,9 @@
 				return retval;
 			}
 		}
-	}
-	else {
+	} else
 		PyErr_SetObject(PyExc_AttributeError, getitem_str);
-	}
+
 	Py_XDECREF(args);
 	Py_XDECREF(ival);
 	Py_XDECREF(func);
@@ -4994,13 +5036,19 @@
 		if (getattribute_str == NULL)
 			return NULL;
 	}
-	getattr = _PyType_Lookup(tp, getattr_str);
+
+	if (_PyType_LookupEx(tp, getattr_str, &getattr) < 0)
+		return NULL;
 	if (getattr == NULL) {
 		/* No __getattr__ hook: use a simpler dispatcher */
 		tp->tp_getattro = slot_tp_getattro;
 		return slot_tp_getattro(self, name);
 	}
-	getattribute = _PyType_Lookup(tp, getattribute_str);
+
+	if (_PyType_LookupEx(tp, getattribute_str, &getattribute) < 0) {
+		Py_DECREF(getattr);
+		return NULL;
+	}
 	if (getattribute == NULL ||
 	    (Py_TYPE(getattribute) == &PyWrapperDescr_Type &&
 	     ((PyWrapperDescrObject *)getattribute)->d_wrapped ==
@@ -5008,10 +5056,14 @@
 		res = PyObject_GenericGetAttr(self, name);
 	else
 		res = PyObject_CallFunctionObjArgs(getattribute, self, name, NULL);
+	Py_XDECREF(getattribute);
+
 	if (res == NULL && PyErr_ExceptionMatches(PyExc_AttributeError)) {
 		PyErr_Clear();
 		res = PyObject_CallFunctionObjArgs(getattr, self, name, NULL);
 	}
+
+	Py_DECREF(getattr);
 	return res;
 }
 
@@ -5127,7 +5179,7 @@
 slot_tp_descr_get(PyObject *self, PyObject *obj, PyObject *type)
 {
 	PyTypeObject *tp = Py_TYPE(self);
-	PyObject *get;
+	PyObject *get, *res;
 	static PyObject *get_str = NULL;
 
 	if (get_str == NULL) {
@@ -5135,7 +5187,9 @@
 		if (get_str == NULL)
 			return NULL;
 	}
-	get = _PyType_Lookup(tp, get_str);
+
+	if (_PyType_LookupEx(tp, get_str, &get) < 0)
+		return NULL;
 	if (get == NULL) {
 		/* Avoid further slowdowns */
 		if (tp->tp_descr_get == slot_tp_descr_get)
@@ -5143,11 +5197,15 @@
 		Py_INCREF(self);
 		return self;
 	}
+
 	if (obj == NULL)
 		obj = Py_None;
 	if (type == NULL)
 		type = Py_None;
-	return PyObject_CallFunctionObjArgs(get, self, obj, type, NULL);
+
+	res = PyObject_CallFunctionObjArgs(get, self, obj, type, NULL);
+	Py_DECREF(get);
+	return res;
 }
 
 static int
@@ -5226,66 +5284,6 @@
 	return x;
 }
 
-static void
-slot_tp_del(PyObject *self)
-{
-	static PyObject *del_str = NULL;
-	PyObject *del, *res;
-	PyObject *error_type, *error_value, *error_traceback;
-
-	/* Temporarily resurrect the object. */
-	assert(self->ob_refcnt == 0);
-	self->ob_refcnt = 1;
-
-	/* Save the current exception, if any. */
-	PyErr_Fetch(&error_type, &error_value, &error_traceback);
-
-	/* Execute __del__ method, if any. */
-	del = lookup_maybe(self, "__del__", &del_str);
-	if (del != NULL) {
-		res = PyEval_CallObject(del, NULL);
-		if (res == NULL)
-			PyErr_WriteUnraisable(del);
-		else
-			Py_DECREF(res);
-		Py_DECREF(del);
-	}
-
-	/* Restore the saved exception. */
-	PyErr_Restore(error_type, error_value, error_traceback);
-
-	/* Undo the temporary resurrection; can't use DECREF here, it would
-	 * cause a recursive call.
-	 */
-	assert(self->ob_refcnt > 0);
-	if (--self->ob_refcnt == 0)
-		return;	/* this is the normal path out */
-
-	/* __del__ resurrected it!  Make it look like the original Py_DECREF
-	 * never happened.
-	 */
-	{
-		Py_ssize_t refcnt = self->ob_refcnt;
-		_Py_NewReference(self);
-		self->ob_refcnt = refcnt;
-	}
-	assert(!PyType_IS_GC(Py_TYPE(self)) ||
-	       _Py_AS_GC(self)->gc.gc_refs != _PyGC_REFS_UNTRACKED);
-	/* If Py_REF_DEBUG, _Py_NewReference bumped _Py_RefTotal, so
-	 * we need to undo that. */
-	_Py_DEC_REFTOTAL;
-	/* If Py_TRACE_REFS, _Py_NewReference re-added self to the object
-	 * chain, so no more to do there.
-	 * If COUNT_ALLOCS, the original decref bumped tp_frees, and
-	 * _Py_NewReference bumped tp_allocs:  both of those need to be
-	 * undone.
-	 */
-#ifdef COUNT_ALLOCS
-	--Py_TYPE(self)->tp_frees;
-	--Py_TYPE(self)->tp_allocs;
-#endif
-}
-
 
 /* Table mapping __foo__ names to tp_foo offsets and slot_tp_foo wrapper
    functions.  The offsets here are relative to the 'PyHeapTypeObject'
@@ -5509,7 +5507,6 @@
 	       "see x.__class__.__doc__ for signature",
 	       PyWrapperFlag_KEYWORDS),
 	TPSLOT("__new__", tp_new, slot_tp_new, NULL, ""),
-	TPSLOT("__del__", tp_del, slot_tp_del, NULL, ""),
 	{NULL}
 };
 
@@ -5614,29 +5611,29 @@
 		return p;
 	}
 	do {
-		descr = _PyType_Lookup(type, p->name_strobj);
+		if (_PyType_LookupEx(type, p->name_strobj, &descr) < 0)
+			Py_FatalError("Lookup failed in update_one_slot.  FIXME: propagate error");
 		if (descr == NULL)
 			continue;
 		if (Py_TYPE(descr) == &PyWrapperDescr_Type) {
 			void **tptr = resolve_slotdups(type, p->name_strobj);
+
 			if (tptr == NULL || tptr == ptr)
 				generic = p->function;
 			d = (PyWrapperDescrObject *)descr;
+
 			if (d->d_base->wrapper == p->wrapper &&
-			    PyType_IsSubtype(type, d->d_type))
-			{
+			    PyType_IsSubtype(type, d->d_type)) {
 				if (specific == NULL ||
 				    specific == d->d_wrapped)
 					specific = d->d_wrapped;
 				else
 					use_generic = 1;
 			}
-		}
-		else if (Py_TYPE(descr) == &PyCFunction_Type &&
+		} else if (Py_TYPE(descr) == &PyCFunction_Type &&
 			 PyCFunction_GET_FUNCTION(descr) ==
 			 (PyCFunction)tp_new_wrapper &&
-			 strcmp(p->name, "__new__") == 0)
-		{
+			 strcmp(p->name, "__new__") == 0) {
 			/* The __new__ wrapper is not a wrapper descriptor,
 			   so must be special-cased differently.
 			   If we don't do this, creating an instance will
@@ -5653,11 +5650,12 @@
 			   in this reasoning that requires additional
 			   sanity checks.  I'll buy the first person to
 			   point out a bug in this reasoning a beer. */
-		}
-		else {
+		} else {
 			use_generic = 1;
 			generic = p->function;
 		}
+
+		Py_DECREF(descr);
 	} while ((++p)->offset == offset);
 	if (specific && !use_generic)
 		*ptr = specific;
@@ -5792,6 +5790,7 @@
 recurse_down_subclasses(PyTypeObject *type, PyObject *name,
 			update_callback callback, void *data)
 {
+#if 0
 	PyTypeObject *subclass;
 	PyObject *ref, *subclasses, *dict;
 	Py_ssize_t i, n;
@@ -5811,12 +5810,17 @@
 		assert(PyType_Check(subclass));
 		/* Avoid recursing down into unaffected classes */
 		dict = subclass->tp_dict;
-		if (dict != NULL && PyDict_Check(dict) &&
-		    PyDict_GetItem(dict, name) != NULL)
-			continue;
+		if (dict != NULL && PyDict_Check(dict)) {
+			int status = PyDict_Contains(dict, name);
+			if (status < 0)
+				return -1;
+			if (status > 0)
+				continue;
+		}
 		if (update_subclasses(subclass, name, callback, data) < 0)
 			return -1;
 	}
+#endif
 	return 0;
 }
 
@@ -5824,13 +5828,13 @@
    dictionary with method descriptors for function slots.  For each
    function slot (like tp_repr) that's defined in the type, one or more
    corresponding descriptors are added in the type's tp_dict dictionary
-   under the appropriate name (like __repr__).	Some function slots
+   under the appropriate name (like __repr__).  Some function slots
    cause more than one descriptor to be added (for example, the nb_add
    slot adds both __add__ and __radd__ descriptors) and some function
    slots compete for the same descriptor (for example both sq_item and
    mp_subscript generate a __getitem__ descriptor).
 
-   In the latter case, the first slotdef entry encoutered wins.	 Since
+   In the latter case, the first slotdef entry encoutered wins.  Since
    slotdef entries are sorted by the offset of the slot in the
    PyHeapTypeObject, this gives us some control over disambiguating
    between competing slots: the members of PyHeapTypeObject are listed
@@ -5855,6 +5859,7 @@
 {
 	PyObject *dict = type->tp_dict;
 	slotdef *p;
+	int status;
 	PyObject *descr;
 	void **ptr;
 
@@ -5865,7 +5870,10 @@
 		ptr = slotptr(type, p->offset);
 		if (!ptr || !*ptr)
 			continue;
-		if (PyDict_GetItem(dict, p->name_strobj))
+		status = PyDict_Contains(dict, p->name_strobj);
+		if (status < 0)
+			return -1;
+		if (status > 0)
 			continue;
 		descr = PyDescr_NewWrapper(type, p, *ptr);
 		if (descr == NULL)
@@ -5906,11 +5914,10 @@
 {
 	superobject *su = (superobject *)self;
 
-	_PyObject_GC_UNTRACK(self);
 	Py_XDECREF(su->obj);
 	Py_XDECREF(su->type);
 	Py_XDECREF(su->obj_type);
-	Py_TYPE(self)->tp_free(self);
+	PyObject_Del(self);
 }
 
 static PyObject *
@@ -5970,9 +5977,9 @@
 				dict = ((PyTypeObject *)tmp)->tp_dict;
 			else
 				continue;
-			res = PyDict_GetItem(dict, name);
+			if (PyDict_GetItemEx(dict, name, &res) < 0)
+				return NULL;
 			if (res != NULL) {
-				Py_INCREF(res);
 				f = Py_TYPE(res)->tp_descr_get;
 				if (f != NULL) {
 					tmp = f(res,
@@ -6109,7 +6116,7 @@
         if (type == NULL) {
 		/* Call super(), without args -- fill in from __class__
 		   and first local variable on the stack. */
-		PyFrameObject *f = PyThreadState_GET()->frame;
+		PyFrameObject *f = PyState_Get()->frame;
 		PyCodeObject *co = f->f_code;
 		int i, n;
 		if (co == NULL) {
@@ -6232,7 +6239,7 @@
 	0,					/* tp_setattro */
 	0,					/* tp_as_buffer */
 	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
-		Py_TPFLAGS_BASETYPE,		/* tp_flags */
+		Py_TPFLAGS_BASETYPE | Py_TPFLAGS_SHAREABLE,	/* tp_flags */
 	super_doc,				/* tp_doc */
 	super_traverse,				/* tp_traverse */
 	0,					/* tp_clear */
@@ -6249,7 +6256,5 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	super_init,				/* tp_init */
-	PyType_GenericAlloc,			/* tp_alloc */
 	PyType_GenericNew,			/* tp_new */
-	PyObject_GC_Del,			/* tp_free */
 };

=== modified file 'Objects/unicodeobject.c'
--- Objects/unicodeobject.c	2008-04-07 03:22:07 +0000
+++ Objects/unicodeobject.c	2008-04-11 05:45:00 +0000
@@ -41,6 +41,7 @@
 
 #define PY_SSIZE_T_CLEAN
 #include "Python.h"
+#include "pythread.h"
 #include "bytes_methods.h"
 
 #include "unicodeobject.h"
@@ -52,6 +53,8 @@
 #include <windows.h>
 #endif
 
+//#define USE_UNICODE_FREELIST
+
 /* Limit for the Unicode object free list */
 
 #define PyUnicode_MAXFREELIST       1024
@@ -95,6 +98,21 @@
 extern "C" {
 #endif
 
+/* Use only if you know it's a string */
+int
+_PyUnicode_SnoopState(PyUnicodeObject *op)
+{
+    /* XXX Just what is required here?  This all needs to be audited/fixed anyway.. */
+    //return (int)AO_load_full(&op->state);
+    return (int)AO_load_acquire(&op->state);
+}
+
+static inline void
+PyUnicode_SetState(PyUnicodeObject *op, int state)
+{
+    AO_store_full(&op->state, state);
+}
+
 /* This dictionary holds all interned unicode strings.  Note that references
    to strings in this dictionary are *not* counted in the string's ob_refcnt.
    When the interned string reaches a refcnt of 0 the string deallocation
@@ -104,10 +122,16 @@
    count of a string is:  s->ob_refcnt + (s->state ? 2 : 0)
 */
 static PyObject *interned;
+/* Some dict and list operations will be called while holding
+ * interned_critical.  This is dangerous, but presumably unavoidable. */
+static PyCritical *interned_critical;
 
+#ifdef USE_UNICODE_FREELIST
 /* Free list for Unicode objects */
 static PyUnicodeObject *free_list;
 static int numfree;
+static PyCritical *free_list_critical;
+#endif
 
 /* The empty Unicode object is shared to improve performance. */
 static PyUnicodeObject *unicode_empty;
@@ -313,38 +337,46 @@
         return unicode_empty;
     }
 
+#ifdef USE_UNICODE_FREELIST
     /* Unicode freelist & memory allocation */
+    PyCritical_Enter(free_list_critical);
     if (free_list) {
         unicode = free_list;
         free_list = *(PyUnicodeObject **)unicode;
         numfree--;
-	if (unicode->str) {
-	    /* Keep-Alive optimization: we only upsize the buffer,
-	       never downsize it. */
-	    if ((unicode->length < length) &&
+        PyCritical_Exit(free_list_critical);
+        if (unicode->str) {
+            /* Keep-Alive optimization: we only upsize the buffer,
+               never downsize it. */
+            if ((unicode->length < length) &&
                 unicode_resize(unicode, length) < 0) {
-		PyObject_DEL(unicode->str);
-		goto onError;
-	    }
-	}
+                PyMem_DEL(unicode->str);
+                goto onError;
+            }
+        }
         else {
-	    size_t new_size = sizeof(Py_UNICODE) * ((size_t)length + 1);
-	    unicode->str = (Py_UNICODE*) PyObject_MALLOC(new_size);
+            size_t new_size = sizeof(Py_UNICODE) * ((size_t)length + 1);
+            unicode->str = (Py_UNICODE*) PyObject_MALLOC(new_size);
         }
         PyObject_INIT(unicode, &PyUnicode_Type);
     }
     else {
-	size_t new_size;
-        unicode = PyObject_New(PyUnicodeObject, &PyUnicode_Type);
+        PyCritical_Exit(free_list_critical);
+#endif
+        unicode = PyObject_New(&PyUnicode_Type);
         if (unicode == NULL)
             return NULL;
-	new_size = sizeof(Py_UNICODE) * ((size_t)length + 1);
-	unicode->str = (Py_UNICODE*) PyObject_MALLOC(new_size);
+        {
+            size_t new_size = sizeof(Py_UNICODE) * ((size_t)length + 1);
+            unicode->str = (Py_UNICODE*) PyObject_MALLOC(new_size);
+        }
+#ifdef USE_UNICODE_FREELIST
     }
+#endif
 
     if (!unicode->str) {
-	PyErr_NoMemory();
-	goto onError;
+        PyErr_NoMemory();
+        goto onError;
     }
     /* Initialize the first element to guard against cases where
      * the caller fails before initializing str -- unicode_resize()
@@ -362,55 +394,80 @@
     return unicode;
 
  onError:
-    _Py_ForgetReference((PyObject *)unicode);
     PyObject_Del(unicode);
     return NULL;
 }
 
+/* There's many assumptions built in here about what we can do safely. */
 static
 void unicode_dealloc(register PyUnicodeObject *unicode)
 {
-    switch (PyUnicode_CHECK_INTERNED(unicode)) {
-        case SSTATE_NOT_INTERNED:
-            break;
-
-        case SSTATE_INTERNED_MORTAL:
-            /* revive dead object temporarily for DelItem */
-            Py_REFCNT(unicode) = 3;
-            if (PyDict_DelItem(interned, (PyObject *)unicode) != 0)
-                Py_FatalError(
-                    "deletion of interned unicode string failed");
-            break;
-
-        case SSTATE_INTERNED_IMMORTAL:
-            Py_FatalError("Immortal interned unicode string died.");
-
-        default:
-            Py_FatalError("Inconsistent interned unicode string state.");
+    int state = _PyUnicode_SnoopState(unicode);
+    assert(Py_RefcntSnoop(unicode) == 1);
+    assert(unicode->state == SSTATE_NOT_INTERNED ||
+        unicode->state == SSTATE_INTERNED);
+
+    if (state == SSTATE_INTERNED) {
+        PyCritical_Enter(interned_critical);
+        if (Py_RefcntSnoop(unicode) > 1) {
+            PyCritical_Exit(interned_critical);
+            /* An asynchronous DECREF is used to ensure we
+             * don't become recursive and risk blowing our
+             * stack. */
+            PyObject_Revive(unicode);
+            Py_DECREF_ASYNC(unicode);
+            return;
+        }
+
+        /* We got a refcnt of 0 then we must be the owner of it, and the
+         * only remaining reference is this interned, which we hold the
+         * lock to.  Thus, we can safely alter the refcnt. */
+        /* We're assuming PyDict_DelItem won't do anything that might
+         * release the PyState */
+        //((PyObject *)unicode)->ob_refowner = (AO_t)PyState_Get();
+        //((PyObject *)unicode)->ob_refcnt = 3;
+        Py_INCREF(unicode);
+        Py_INCREF(unicode);
+        if (PyDict_DelItem(interned, (PyObject *)unicode) != 0)
+            Py_FatalError("deletion of interned unicode string failed");
+
+        assert(Py_RefcntSnoop(unicode) == 1);
+
+        //((PyObject *)unicode)->ob_refcnt = 0;
+
+        PyCritical_Exit(interned_critical);
     }
 
+#ifdef USE_UNICODE_FREELIST
+    PyCritical_Enter(free_list_critical);
     if (PyUnicode_CheckExact(unicode) &&
 	numfree < PyUnicode_MAXFREELIST) {
+	PyObject *defenc;
         /* Keep-Alive optimization */
 	if (unicode->length >= KEEPALIVE_SIZE_LIMIT) {
-	    PyObject_DEL(unicode->str);
+	    PyObject_FREE(unicode->str);
 	    unicode->str = NULL;
 	    unicode->length = 0;
 	}
-	if (unicode->defenc) {
-	    Py_DECREF(unicode->defenc);
-	    unicode->defenc = NULL;
-	}
+	defenc = unicode->defenc;
+	unicode->defenc = NULL;
 	/* Add to free list */
         *(PyUnicodeObject **)unicode = free_list;
         free_list = unicode;
         numfree++;
+	PyCritical_Exit(free_list_critical);
+	Py_XDECREF(defenc);
     }
     else {
-	PyObject_DEL(unicode->str);
+	PyCritical_Exit(free_list_critical);
+#endif
+	PyObject_FREE(unicode->str);
 	Py_XDECREF(unicode->defenc);
-	Py_TYPE(unicode)->tp_free((PyObject *)unicode);
+	assert(Py_RefcntSnoop(unicode) == 1);
+        PyObject_Del(unicode);
+#ifdef USE_UNICODE_FREELIST
     }
+#endif
 }
 
 int PyUnicode_Resize(PyObject **unicode, Py_ssize_t length)
@@ -423,7 +480,7 @@
 	return -1;
     }
     v = (PyUnicodeObject *)*unicode;
-    if (v == NULL || !PyUnicode_Check(v) || Py_REFCNT(v) != 1 || length < 0) {
+    if (v == NULL || !PyUnicode_Check(v) || !Py_RefcntMatches(v, 1) || length < 0) {
 	PyErr_BadInternalCall();
 	return -1;
     }
@@ -1301,6 +1358,7 @@
 PyObject *_PyUnicode_AsDefaultEncodedString(PyObject *unicode,
 					    const char *errors)
 {
+#warning defenc field is not thread-safe
     PyObject *v = ((PyUnicodeObject *)unicode)->defenc;
     if (v)
         return v;
@@ -4188,7 +4246,7 @@
 /* Charmap encoding: the lookup table */
 
 struct encoding_map{
-  PyObject_HEAD
+  PyObject_VAR_HEAD
   unsigned char level1[32];
   int count2, count3;
   unsigned char level23[1];
@@ -4211,14 +4269,14 @@
 static void
 encoding_map_dealloc(PyObject* o)
 {
-	PyObject_FREE(o);
+	PyObject_Del(o);
 }
 
 static PyTypeObject EncodingMapType = {
 	PyVarObject_HEAD_INIT(NULL, 0)
         "EncodingMap",          /*tp_name*/
         sizeof(struct encoding_map),   /*tp_basicsize*/
-        0,                      /*tp_itemsize*/
+        sizeof(char),           /*tp_itemsize*/
         /* methods */
         encoding_map_dealloc,   /*tp_dealloc*/
         0,                      /*tp_print*/
@@ -4252,9 +4310,7 @@
         0,                      /*tp_descr_set*/
         0,                      /*tp_dictoffset*/
         0,                      /*tp_init*/
-        0,                      /*tp_alloc*/
         0,                      /*tp_new*/
-        0,                      /*tp_free*/
         0,                      /*tp_is_gc*/
 };
 
@@ -4333,11 +4389,14 @@
     }
 
     /* Create a three-level trie */
-    result = PyObject_MALLOC(sizeof(struct encoding_map) +
-                             16*count2 + 128*count3 - 1);
-    if (!result)
-        return PyErr_NoMemory();
-    PyObject_Init(result, &EncodingMapType);
+    //result = PyObject_MALLOC(sizeof(struct encoding_map) +
+    //                         16*count2 + 128*count3 - 1);
+    //if (!result)
+    //    return PyErr_NoMemory();
+    //PyObject_Init(result, &EncodingMapType);
+    result = PyObject_NewVar(&EncodingMapType, 16*count2 + 128*count3 - 1);
+    if (result == NULL)
+        return NULL;
     mresult = (struct encoding_map*)result;
     mresult->count2 = count2;
     mresult->count3 = count3;
@@ -8089,7 +8148,11 @@
 static PyObject*
 unicode_freelistsize(PyUnicodeObject *self)
 {
-    return PyLong_FromLong(numfree);
+    int size;
+    PyCritical_Enter(free_list_critical);
+    size = numfree;
+    PyCritical_Exit(free_list_critical);
+    return PyLong_FromLong(size);
 }
 #endif
 
@@ -8259,7 +8322,7 @@
 
 #if 0
     /* This one is just used for debugging the implementation. */
-    {"freelistsize", (PyCFunction) unicode_freelistsize, METH_NOARGS},
+    {"freelistsize", (PyCFunction) free_listsize, METH_NOARGS},
 #endif
 
     {"__getnewargs__",	(PyCFunction)unicode_getnewargs, METH_NOARGS},
@@ -9077,14 +9140,14 @@
 	if (tmp == NULL)
 		return NULL;
 	assert(PyUnicode_Check(tmp));
-	pnew = (PyUnicodeObject *) type->tp_alloc(type, n = tmp->length);
+	n = tmp->length;
+	pnew = PyObject_New(type);
 	if (pnew == NULL) {
 		Py_DECREF(tmp);
 		return NULL;
 	}
 	pnew->str = (Py_UNICODE*) PyObject_MALLOC(sizeof(Py_UNICODE) * (n+1));
 	if (pnew->str == NULL) {
-		_Py_ForgetReference((PyObject *)pnew);
 		PyObject_Del(pnew);
 		Py_DECREF(tmp);
 		return PyErr_NoMemory();
@@ -9096,6 +9159,12 @@
 	return (PyObject *)pnew;
 }
 
+static int
+unicode_isshareable (PyObject *v)
+{
+	return PyUnicode_CheckExact(v);
+}
+
 PyDoc_STRVAR(unicode_doc,
 "str(string [, encoding[, errors]]) -> object\n\
 \n\
@@ -9127,7 +9196,8 @@
     0,			 		/* tp_setattro */
     0, 					/* tp_as_buffer */
     Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | 
-        Py_TPFLAGS_UNICODE_SUBCLASS,	/* tp_flags */
+        Py_TPFLAGS_UNICODE_SUBCLASS |
+        Py_TPFLAGS_SHAREABLE,		/* tp_flags */
     unicode_doc,			/* tp_doc */
     0,					/* tp_traverse */
     0,					/* tp_clear */
@@ -9144,14 +9214,36 @@
     0,					/* tp_descr_set */
     0,					/* tp_dictoffset */
     0,					/* tp_init */
-    0,					/* tp_alloc */
     unicode_new,			/* tp_new */
-    PyObject_Del,      		/* tp_free */
+    0,					/* tp_is_gc */
+    0,					/* tp_bases */
+    0,					/* tp_mro */
+    0,					/* tp_cache */
+    0,					/* tp_subclasses */
+    0,					/* tp_weaklist */
+    unicode_isshareable,		/* tp_isshareable */
 };
 
 /* Initialize the Unicode implementation */
 
-void _PyUnicode_Init(void)
+/* Even type and object's initialization calls us, so we need a bare
+ * minimum of functionality to be ready even before them. */
+void
+_PyUnicode_PreInit(void)
+{
+    interned_critical = PyCritical_Allocate(PyCRITICAL_NORMAL);
+    if (!interned_critical)
+        Py_FatalError("unable to allocate lock");
+
+#ifdef USE_UNICODE_FREELIST
+    free_list_critical = PyCritical_Allocate(PyCRITICAL_NORMAL);
+    if (!free_list_critical)
+        Py_FatalError("unable to allocate lock");
+#endif
+}
+
+void
+_PyUnicode_Init(void)
 {
     int i;
 
@@ -9168,8 +9260,10 @@
     };
 
     /* Init the implementation */
-    free_list = NULL;
-    numfree = 0;
+#ifdef USE_UNICODE_FREELIST
+    assert(free_list == NULL && numfree == 0 &&
+	unicode_empty == NULL);
+#endif
     unicode_empty = _PyUnicode_New(0);
     if (!unicode_empty)
 	return;
@@ -9192,6 +9286,7 @@
 int
 PyUnicode_ClearFreeList(void)
 {
+#ifdef USE_UNICODE_FREELIST
     int freelist_size = numfree;
     PyUnicodeObject *u;
 
@@ -9199,7 +9294,7 @@
 	PyUnicodeObject *v = u;
 	u = *(PyUnicodeObject **)u;
 	if (v->str)
-	    PyObject_DEL(v->str);
+	    PyObject_FREE(v->str);
 	Py_XDECREF(v->defenc);
 	PyObject_Del(v);
 	numfree--;
@@ -9207,6 +9302,9 @@
     free_list = NULL;
     assert(numfree == 0);
     return freelist_size;
+#else
+    return 0;
+#endif
 }
 
 void
@@ -9223,65 +9321,83 @@
 	    unicode_latin1[i] = NULL;
 	}
     }
+
+#ifdef USE_UNICODE_FREELIST
     (void)PyUnicode_ClearFreeList();
+#endif
+}
+
+void
+_PyUnicode_PostFini(void)
+{
+    PyCritical_Free(interned_critical);
+    interned_critical = NULL;
+
+#ifdef USE_UNICODE_FREELIST
+    PyCritical_Free(free_list_critical);
+    free_list_critical = NULL;
+#endif
 }
 
 void
 PyUnicode_InternInPlace(PyObject **p)
 {
-	register PyUnicodeObject *s = (PyUnicodeObject *)(*p);
-	PyObject *t;
-	if (s == NULL || !PyUnicode_Check(s))
-		Py_FatalError(
-		    "PyUnicode_InternInPlace: unicode strings only please!");
-	/* If it's a subclass, we don't really know what putting
-	   it in the interned dict might do. */
-	if (!PyUnicode_CheckExact(s))
-		return;
-	if (PyUnicode_CHECK_INTERNED(s))
-		return;
-	if (interned == NULL) {
-		interned = PyDict_New();
-		if (interned == NULL) {
-			PyErr_Clear(); /* Don't leave an exception */
-			return;
-		}
-	}
-	/* It might be that the GetItem call fails even
-	   though the key is present in the dictionary,
-	   namely when this happens during a stack overflow. */
-	Py_ALLOW_RECURSION
-	t = PyDict_GetItem(interned, (PyObject *)s);
-	Py_END_ALLOW_RECURSION
-
-	if (t) {
-		Py_INCREF(t);
-		Py_DECREF(*p);
-		*p = t;
-		return;
-	}
-
-	PyThreadState_GET()->recursion_critical = 1;
-	if (PyDict_SetItem(interned, (PyObject *)s, (PyObject *)s) < 0) {
-		PyErr_Clear();
-		PyThreadState_GET()->recursion_critical = 0;
-		return;
-	}
-	PyThreadState_GET()->recursion_critical = 0;
-	/* The two references in interned are not counted by refcnt.
-	   The deallocator will take care of this */
-	Py_REFCNT(s) -= 2;
-	PyUnicode_CHECK_INTERNED(s) = SSTATE_INTERNED_MORTAL;
-}
-
-void
-PyUnicode_InternImmortal(PyObject **p)
-{
-	PyUnicode_InternInPlace(p);
-	if (PyUnicode_CHECK_INTERNED(*p) != SSTATE_INTERNED_IMMORTAL) {
-		PyUnicode_CHECK_INTERNED(*p) = SSTATE_INTERNED_IMMORTAL;
-		Py_INCREF(*p);
-	}
+    register PyUnicodeObject *s = (PyUnicodeObject *)(*p);
+    PyObject *t;
+    if (s == NULL || !PyUnicode_Check(s))
+        Py_FatalError(
+            "PyUnicode_InternInPlace: unicode strings only please!");
+    /* If it's a subclass, we don't really know what putting
+       it in the interned dict might do. */
+    if (!PyUnicode_CheckExact(s))
+        return;
+    if (_PyUnicode_SnoopState(s))
+        return;
+
+    PyCritical_Enter(interned_critical);
+    if (interned == NULL) {
+        interned = PyDict_New();
+        if (interned == NULL) {
+            PyCritical_Exit(interned_critical);
+            PyErr_Clear(); /* Don't leave an exception */
+            return;
+        }
+    }
+
+    /* It might be that the GetItem call fails even
+       though the key is present in the dictionary,
+       namely when this happens during a stack overflow. */
+    Py_ALLOW_RECURSION
+    t = PyDict_GetItem(interned, (PyObject *)s);
+    Py_END_ALLOW_RECURSION
+
+    if (t) {
+        assert(PyUnicode_CheckExact(t));
+        Py_INCREF(t);
+        PyCritical_Exit(interned_critical);
+        Py_DECREF(*p);
+        *p = t;
+        return;
+    }
+
+    PyState_Get()->recursion_critical = 1;
+    if (PyDict_SetItem(interned, (PyObject *)s, (PyObject *)s) < 0) {
+        PyCritical_Exit(interned_critical);
+        PyErr_Clear();
+        PyState_Get()->recursion_critical = 0;
+        return;
+    }
+    PyState_Get()->recursion_critical = 0;
+    /* The two references in interned are not counted by refcnt.
+       The deallocator will take care of this */
+    /* Note, this only works because Py_TPFLAGS_HAVE_GC isn't set.  Not
+     * only does that mean we don't have a tp_traverse function, but
+     * other tp_traverse functions will ignore us when they find us.
+     * That prevents the GC from finding 0 or even -1 references to us. */
+    Py_DECREF(s);
+    Py_DECREF(s);
+    PyUnicode_SetState(s, SSTATE_INTERNED);
+    PyCritical_Exit(interned_critical);
 }
 
 PyObject *
@@ -9296,15 +9412,23 @@
 
 void _Py_ReleaseInternedUnicodeStrings(void)
 {
-	PyObject *keys;
-	PyUnicodeObject *s;
+	PyObject *keys, *temp;
 	Py_ssize_t i, n;
-	Py_ssize_t immortal_size = 0, mortal_size = 0;
-
-	if (interned == NULL || !PyDict_Check(interned))
+	Py_ssize_t mortal_size = 0;
+	PyState *pystate = PyState_Get();
+
+	PyCritical_Enter(interned_critical);
+	if (!_PyState_SingleThreaded())
+		Py_FatalError("Attempting to release interned strings while "
+			"multiple threads exist");
+
+	if (interned == NULL || !PyDict_Check(interned)) {
+		PyCritical_Exit(interned_critical);
 		return;
+	}
 	keys = PyDict_Keys(interned);
 	if (keys == NULL || !PyList_Check(keys)) {
+		PyCritical_Exit(interned_critical);
 		PyErr_Clear();
 		return;
 	}
@@ -9318,31 +9442,30 @@
 	fprintf(stderr, "releasing %" PY_FORMAT_SIZE_T "d interned strings\n",
 		n);
 	for (i = 0; i < n; i++) {
-		s = (PyUnicodeObject *) PyList_GET_ITEM(keys, i);
-		switch (s->state) {
-		case SSTATE_NOT_INTERNED:
-			/* XXX Shouldn't happen */
-			break;
-		case SSTATE_INTERNED_IMMORTAL:
-			Py_REFCNT(s) += 1;
-			immortal_size += s->length;
-			break;
-		case SSTATE_INTERNED_MORTAL:
-			Py_REFCNT(s) += 2;
-			mortal_size += s->length;
-			break;
-		default:
+		PyUnicodeObject *s = (PyUnicodeObject *) PyList_GET_ITEM(keys, i);
+		void *owner = (void *)AO_load_full(&((PyObject *)s)->ob_refowner);
+		if (_PyUnicode_SnoopState(s) != SSTATE_INTERNED)
 			Py_FatalError("Inconsistent interned string state.");
-		}
+
+		if (owner == (void *)Py_REFOWNER_STATICINIT) {
+			/* Inline _PyGC_RefMode_Promote */
+			((PyObject *)s)->ob_refowner = (AO_t)pystate;
+		} else if (owner != pystate)
+			Py_FatalError("Interned string has wrong owner");
+
+		Py_INCREF(s);
+		Py_INCREF(s);
+		mortal_size += s->length;
 		s->state = SSTATE_NOT_INTERNED;
 	}
 	fprintf(stderr, "total size of all interned strings: "
-			"%" PY_FORMAT_SIZE_T "d/%" PY_FORMAT_SIZE_T "d "
-			"mortal/immortal\n", mortal_size, immortal_size);
+			"%" PY_FORMAT_SIZE_T "d\n", mortal_size);
+	temp = interned;
+	interned = NULL;
+	PyCritical_Exit(interned_critical);
 	Py_DECREF(keys);
-	PyDict_Clear(interned);
-	Py_DECREF(interned);
-	interned = NULL;
+	PyDict_Clear(temp);
+	Py_DECREF(temp);
 }
 
 
@@ -9357,9 +9480,8 @@
 static void
 unicodeiter_dealloc(unicodeiterobject *it)
 {
-	_PyObject_GC_UNTRACK(it);
 	Py_XDECREF(it->it_seq);
-	PyObject_GC_Del(it);
+	PyObject_Del(it);
 }
 
 static int
@@ -9453,13 +9575,12 @@
 		PyErr_BadInternalCall();
 		return NULL;
 	}
-	it = PyObject_GC_New(unicodeiterobject, &PyUnicodeIter_Type);
+	it = PyObject_New(&PyUnicodeIter_Type);
 	if (it == NULL)
 		return NULL;
 	it->it_index = 0;
 	Py_INCREF(seq);
 	it->it_seq = (PyUnicodeObject *)seq;
-	_PyObject_GC_TRACK(it);
 	return (PyObject *)it;
 }
 

=== modified file 'Objects/weakrefobject.c'
--- Objects/weakrefobject.c	2007-12-19 02:45:37 +0000
+++ Objects/weakrefobject.c	2008-04-10 21:12:04 +0000
@@ -2,181 +2,69 @@
 #include "structmember.h"
 
 
-#define GET_WEAKREFS_LISTPTR(o) \
-        ((PyWeakReference **) PyObject_GET_WEAKREFS_LISTPTR(o))
-
-
-Py_ssize_t
-_PyWeakref_GetWeakrefCount(PyWeakReference *head)
-{
-    Py_ssize_t count = 0;
-
-    while (head != NULL) {
-        ++count;
-        head = head->wr_next;
-    }
-    return count;
-}
-
-
-static void
-init_weakref(PyWeakReference *self, PyObject *ob, PyObject *callback)
-{
-    self->hash = -1;
-    self->wr_object = ob;
-    Py_XINCREF(callback);
-    self->wr_callback = callback;
-}
-
-static PyWeakReference *
-new_weakref(PyObject *ob, PyObject *callback)
-{
-    PyWeakReference *result;
-
-    result = PyObject_GC_New(PyWeakReference, &_PyWeakref_RefType);
-    if (result) {
-        init_weakref(result, ob, callback);
-        PyObject_GC_Track(result);
-    }
-    return result;
-}
-
-
-/* This function clears the passed-in reference and removes it from the
- * list of weak references for the referent.  This is the only code that
- * removes an item from the doubly-linked list of weak references for an
- * object; it is also responsible for clearing the callback slot.
- */
-static void
-clear_weakref(PyWeakReference *self)
-{
-    PyObject *callback = self->wr_callback;
-
-    if (PyWeakref_GET_OBJECT(self) != Py_None) {
-        PyWeakReference **list = GET_WEAKREFS_LISTPTR(
-            PyWeakref_GET_OBJECT(self));
-
-        if (*list == self)
-	    /* If 'self' is the end of the list (and thus self->wr_next == NULL)
-	       then the weakref list itself (and thus the value of *list) will
-	       end up being set to NULL. */
-            *list = self->wr_next;
-        self->wr_object = Py_None;
-        if (self->wr_prev != NULL)
-            self->wr_prev->wr_next = self->wr_next;
-        if (self->wr_next != NULL)
-            self->wr_next->wr_prev = self->wr_prev;
-        self->wr_prev = NULL;
-        self->wr_next = NULL;
-    }
-    if (callback != NULL) {
-        Py_DECREF(callback);
-        self->wr_callback = NULL;
-    }
-}
-
-/* Cyclic gc uses this to *just* clear the passed-in reference, leaving
- * the callback intact and uncalled.  It must be possible to call self's
- * tp_dealloc() after calling this, so self has to be left in a sane enough
- * state for that to work.  We expect tp_dealloc to decref the callback
- * then.  The reason for not letting clear_weakref() decref the callback
- * right now is that if the callback goes away, that may in turn trigger
- * another callback (if a weak reference to the callback exists) -- running
- * arbitrary Python code in the middle of gc is a disaster.  The convolution
- * here allows gc to delay triggering such callbacks until the world is in
- * a sane state again.
- */
-void
-_PyWeakref_ClearRef(PyWeakReference *self)
-{
-    PyObject *callback;
-
-    assert(self != NULL);
-    assert(PyWeakref_Check(self));
-    /* Preserve and restore the callback around clear_weakref. */
-    callback = self->wr_callback;
-    self->wr_callback = NULL;
-    clear_weakref(self);
-    self->wr_callback = callback;
-}
-
-static void
-weakref_dealloc(PyObject *self)
-{
-    PyObject_GC_UnTrack(self);
-    clear_weakref((PyWeakReference *) self);
-    Py_TYPE(self)->tp_free(self);
-}
-
-
-static int
-gc_traverse(PyWeakReference *self, visitproc visit, void *arg)
-{
-    Py_VISIT(self->wr_callback);
-    return 0;
-}
-
-
-static int
-gc_clear(PyWeakReference *self)
-{
-    clear_weakref(self);
-    return 0;
-}
-
+static int deathqueue_clear(PyDeathQueue *self);
+static int PyDeathQueue_Cancel(PyDeathQueue *queue, PyDeathQueueHandle *handle);
+static PyObject *deathqueue_wait(PyDeathQueue *queue);
+
+
+static void
+weakref_dealloc(PyWeakReference *self)
+{
+    if (self->wr_object != NULL)
+        Py_FatalError("Still-valid weakref deleted!");
+    PyCritical_Free(self->crit);
+    PyObject_Del(self);
+}
+
+static int
+weakref_traverse(PyWeakReference *self, visitproc visit, void *arg)
+{
+    return 0;
+}
 
 static PyObject *
-weakref_call(PyWeakReference *self, PyObject *args, PyObject *kw)
+weakref_call(PyObject *self, PyObject *args, PyObject *kw)
 {
     static char *kwlist[] = {NULL};
-
-    if (PyArg_ParseTupleAndKeywords(args, kw, ":__call__", kwlist)) {
-        PyObject *object = PyWeakref_GET_OBJECT(self);
-        Py_INCREF(object);
-        return (object);
-    }
-    return NULL;
-}
-
-
-static long
-weakref_hash(PyWeakReference *self)
-{
-    if (self->hash != -1)
-        return self->hash;
-    if (PyWeakref_GET_OBJECT(self) == Py_None) {
-        PyErr_SetString(PyExc_TypeError, "weak object has gone away");
-        return -1;
-    }
-    self->hash = PyObject_Hash(PyWeakref_GET_OBJECT(self));
-    return self->hash;
-}
-
+    PyObject *ob;
+
+    if (!PyArg_ParseTupleAndKeywords(args, kw, ":__call__", kwlist))
+        return NULL;
+
+    ob = PyWeakref_GetObjectEx(self);
+    if (ob == NULL) {
+        Py_INCREF(Py_None);
+        ob = Py_None;
+    }
+
+    return ob;
+}
 
 static PyObject *
 weakref_repr(PyWeakReference *self)
 {
     char buffer[256];
-    if (PyWeakref_GET_OBJECT(self) == Py_None) {
+    PyObject *ob = PyWeakref_GetObjectEx((PyObject *)self);
+
+    if (ob == NULL)
         PyOS_snprintf(buffer, sizeof(buffer), "<weakref at %p; dead>", self);
-    }
     else {
-	char *name = NULL;
-	PyObject *nameobj = PyObject_GetAttrString(PyWeakref_GET_OBJECT(self),
-						   "__name__");
-	if (nameobj == NULL)
-		PyErr_Clear();
-	else if (PyUnicode_Check(nameobj))
-		name = PyUnicode_AsString(nameobj);
+        char *name = NULL;
+        PyObject *nameobj = PyObject_GetAttrString(ob, "__name__");
+
+        if (nameobj == NULL)
+            PyErr_Clear();
+        else if (PyUnicode_Check(nameobj))
+            name = PyUnicode_AsString(nameobj);
+
         PyOS_snprintf(buffer, sizeof(buffer),
-		      name ? "<weakref at %p; to '%.50s' at %p (%s)>"
-		           : "<weakref at %p; to '%.50s' at %p>",
-		      self,
-		      Py_TYPE(PyWeakref_GET_OBJECT(self))->tp_name,
-		      PyWeakref_GET_OBJECT(self),
-		      name);
-	Py_XDECREF(nameobj);
+                      name ? "<weakref at %p; to '%.50s' at %p (%s)>"
+                           : "<weakref at %p; to '%.50s' at %p>",
+                      self, Py_TYPE(ob)->tp_name, ob, name);
+        Py_XDECREF(nameobj);
+        Py_DECREF(ob);
     }
+
     return PyUnicode_FromString(buffer);
 }
 
@@ -185,147 +73,63 @@
    gone away, they are equal if they are identical. */
 
 static PyObject *
-weakref_richcompare(PyWeakReference* self, PyWeakReference* other, int op)
+weakref_richcompare(PyWeakReference *self, PyWeakReference *other, int op)
 {
+    PyObject *self_ob, *other_ob;
+    PyObject *res;
+
     if ((op != Py_EQ && op != Py_NE) ||
-	!PyWeakref_Check(self) ||
-	!PyWeakref_Check(other)) {
+            !PyWeakref_Check(self) ||
+            !PyWeakref_Check(other)) {
         Py_INCREF(Py_NotImplemented);
         return Py_NotImplemented;
     }
-    if (PyWeakref_GET_OBJECT(self) == Py_None
-        || PyWeakref_GET_OBJECT(other) == Py_None) {
-        PyObject *res = self==other ? Py_True : Py_False;
+
+    if (self == other) {
+        Py_INCREF(Py_True);
+        return Py_True;
+    }
+
+#warning XXX FIXME weakref comparisons should probably just use identity
+    self_ob = PyWeakref_GetObjectEx((PyObject *)self);
+    other_ob = PyWeakref_GetObjectEx((PyObject *)other);
+
+    if (self_ob == NULL || other_ob == NULL) {
+        res = Py_False;
         Py_INCREF(res);
-        return res;
-    }
-    return PyObject_RichCompare(PyWeakref_GET_OBJECT(self),
-                                PyWeakref_GET_OBJECT(other), op);
-}
-
-/* Given the head of an object's list of weak references, extract the
- * two callback-less refs (ref and proxy).  Used to determine if the
- * shared references exist and to determine the back link for newly
- * inserted references.
- */
-static void
-get_basic_refs(PyWeakReference *head,
-               PyWeakReference **refp, PyWeakReference **proxyp)
-{
-    *refp = NULL;
-    *proxyp = NULL;
-
-    if (head != NULL && head->wr_callback == NULL) {
-        /* We need to be careful that the "basic refs" aren't
-           subclasses of the main types.  That complicates this a
-           little. */
-        if (PyWeakref_CheckRefExact(head)) {
-            *refp = head;
-            head = head->wr_next;
-        }
-        if (head != NULL
-            && head->wr_callback == NULL
-            && PyWeakref_CheckProxy(head)) {
-            *proxyp = head;
-            /* head = head->wr_next; */
-        }
-    }
-}
-
-/* Insert 'newref' in the list after 'prev'.  Both must be non-NULL. */
-static void
-insert_after(PyWeakReference *newref, PyWeakReference *prev)
-{
-    newref->wr_prev = prev;
-    newref->wr_next = prev->wr_next;
-    if (prev->wr_next != NULL)
-        prev->wr_next->wr_prev = newref;
-    prev->wr_next = newref;
-}
-
-/* Insert 'newref' at the head of the list; 'list' points to the variable
- * that stores the head.
- */
-static void
-insert_head(PyWeakReference *newref, PyWeakReference **list)
-{
-    PyWeakReference *next = *list;
-
-    newref->wr_prev = NULL;
-    newref->wr_next = next;
-    if (next != NULL)
-        next->wr_prev = newref;
-    *list = newref;
+    } else
+        res = PyObject_RichCompare(self_ob, other_ob, op);
+
+    Py_XDECREF(self_ob);
+    Py_XDECREF(other_ob);
+    return res;
 }
 
 static int
 parse_weakref_init_args(char *funcname, PyObject *args, PyObject *kwargs,
-                        PyObject **obp, PyObject **callbackp)
+                        PyObject **obp)
 {
     /* XXX Should check that kwargs == NULL or is empty. */
-    return PyArg_UnpackTuple(args, funcname, 1, 2, obp, callbackp);
+    return PyArg_UnpackTuple(args, funcname, 1, 1, obp);
 }
 
 static PyObject *
 weakref___new__(PyTypeObject *type, PyObject *args, PyObject *kwargs)
 {
-    PyWeakReference *self = NULL;
-    PyObject *ob, *callback = NULL;
-
-    if (parse_weakref_init_args("__new__", args, kwargs, &ob, &callback)) {
-        PyWeakReference *ref, *proxy;
-        PyWeakReference **list;
-
-        if (!PyType_SUPPORTS_WEAKREFS(Py_TYPE(ob))) {
-            PyErr_Format(PyExc_TypeError,
-                         "cannot create weak reference to '%s' object",
-                         Py_TYPE(ob)->tp_name);
-            return NULL;
-        }
-        if (callback == Py_None)
-            callback = NULL;
-        list = GET_WEAKREFS_LISTPTR(ob);
-        get_basic_refs(*list, &ref, &proxy);
-        if (callback == NULL && type == &_PyWeakref_RefType) {
-            if (ref != NULL) {
-                /* We can re-use an existing reference. */
-                Py_INCREF(ref);
-                return (PyObject *)ref;
-            }
-        }
-        /* We have to create a new reference. */
-        /* Note: the tp_alloc() can trigger cyclic GC, so the weakref
-           list on ob can be mutated.  This means that the ref and
-           proxy pointers we got back earlier may have been collected,
-           so we need to compute these values again before we use
-           them. */
-        self = (PyWeakReference *) (type->tp_alloc(type, 0));
-        if (self != NULL) {
-            init_weakref(self, ob, callback);
-            if (callback == NULL && type == &_PyWeakref_RefType) {
-                insert_head(self, list);
-            }
-            else {
-                PyWeakReference *prev;
-
-                get_basic_refs(*list, &ref, &proxy);
-                prev = (proxy == NULL) ? ref : proxy;
-                if (prev == NULL)
-                    insert_head(self, list);
-                else
-                    insert_after(self, prev);
-            }
-        }
-    }
-    return (PyObject *)self;
+    PyObject *ob;
+
+    if (!parse_weakref_init_args("__new__", args, kwargs, &ob))
+        return NULL;
+
+    return PyWeakref_NewRef(ob, NULL);
 }
 
 static int
 weakref___init__(PyObject *self, PyObject *args, PyObject *kwargs)
 {
-    PyObject *tmp;
+    PyObject *ob;
 
-    if (parse_weakref_init_args("__init__", args, kwargs, &tmp, &tmp))
+    if (parse_weakref_init_args("__init__", args, kwargs, &ob))
         return 0;
     else
         return 1;
@@ -333,31 +137,33 @@
 
 
 PyTypeObject
-_PyWeakref_RefType = {
+_PyWeakref_Type = {
     PyVarObject_HEAD_INIT(&PyType_Type, 0)
     "weakref",
     sizeof(PyWeakReference),
     0,
-    weakref_dealloc,            /*tp_dealloc*/
-    0,	                        /*tp_print*/
+    (destructor)weakref_dealloc,  /*tp_dealloc*/
+    0,                          /*tp_print*/
     0,                          /*tp_getattr*/
     0,                          /*tp_setattr*/
-    0,	                        /*tp_compare*/
+    0,                          /*tp_compare*/
     (reprfunc)weakref_repr,     /*tp_repr*/
     0,                          /*tp_as_number*/
     0,                          /*tp_as_sequence*/
     0,                          /*tp_as_mapping*/
-    (hashfunc)weakref_hash,     /*tp_hash*/
-    (ternaryfunc)weakref_call,  /*tp_call*/
+    0,                          /*tp_hash*/
+    weakref_call,               /*tp_call*/
     0,                          /*tp_str*/
     0,                          /*tp_getattro*/
     0,                          /*tp_setattro*/
     0,                          /*tp_as_buffer*/
-    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC
-        | Py_TPFLAGS_BASETYPE,  /*tp_flags*/
+    /* There is only ever one weakref per object, so subclassing is
+     * unsupported. */
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
+        Py_TPFLAGS_SHAREABLE,  /*tp_flags*/
     0,                          /*tp_doc*/
-    (traverseproc)gc_traverse,  /*tp_traverse*/
-    (inquiry)gc_clear,          /*tp_clear*/
+    (traverseproc)weakref_traverse,  /*tp_traverse*/
+    0,                          /*tp_clear*/
     (richcmpfunc)weakref_richcompare,	/*tp_richcompare*/
     0,                          /*tp_weaklistoffset*/
     0,                          /*tp_iter*/
@@ -371,548 +177,1011 @@
     0,                          /*tp_descr_set*/
     0,                          /*tp_dictoffset*/
     weakref___init__,           /*tp_init*/
-    PyType_GenericAlloc,        /*tp_alloc*/
     weakref___new__,            /*tp_new*/
-    PyObject_GC_Del,            /*tp_free*/
-};
-
-
-static int
-proxy_checkref(PyWeakReference *proxy)
-{
-    if (PyWeakref_GET_OBJECT(proxy) == Py_None) {
-        PyErr_SetString(PyExc_ReferenceError,
-                        "weakly-referenced object no longer exists");
+};
+
+
+static void
+deathqueuehandle_dealloc(PyDeathQueueHandle *self)
+{
+    /* queue holds a reference to us, so we should never get deleted
+     * without clearing us first. */
+    assert(self->payload == NULL);
+    assert(self->weakref == NULL);
+    assert(self->queue == NULL);
+    assert(PyLinkedList_Detached(&self->weakref_links));
+    assert(PyLinkedList_Detached(&self->queue_links));
+    PyCritical_Free(self->crit);
+    PyObject_Del(self);
+}
+
+static PyObject *
+deathqueuehandle_repr(PyDeathQueueHandle *self)
+{
+    char buffer[256];
+    PyObject *payload;
+    PyWeakReference *weakref;
+
+    PyCritical_Enter(self->crit);
+    payload = self->payload;
+    weakref = self->weakref;
+    Py_XINCREF(payload);
+    Py_XINCREF(weakref);
+    PyCritical_Exit(self->crit);
+
+    if (payload == NULL)
+        PyOS_snprintf(buffer, sizeof(buffer),
+            "<deathqueuehandle at %p; cancelled/processed>", self);
+    else {
+        char *name = NULL;
+        char *state = (weakref != NULL) ? "live" : "dead";
+        PyObject *nameobj = PyObject_GetAttrString(payload, "__name__");
+
+        if (nameobj == NULL)
+            PyErr_Clear();
+        else if (PyUnicode_Check(nameobj))
+            name = PyUnicode_AsString(nameobj);
+
+        if (name != NULL)
+            PyOS_snprintf(buffer, sizeof(buffer),
+                "<deathqueuehandle at %p; payload '%.50s' at %p (%s); %s>",
+                self, Py_TYPE(payload)->tp_name, payload, name, state);
+        else
+            PyOS_snprintf(buffer, sizeof(buffer),
+                "<deathqueuehandle at %p; payload '%.50s' at %p; %s>",
+                self, Py_TYPE(payload)->tp_name, payload, state);
+        Py_XDECREF(nameobj);
+    }
+
+    Py_XDECREF(payload);
+    Py_XDECREF(weakref);
+
+    return PyUnicode_FromString(buffer);
+}
+
+static int
+deathqueuehandle_traverse(PyDeathQueueHandle *self, visitproc visit, void *arg)
+{
+    Py_VISIT(self->payload);
+    Py_VISIT(self->weakref);
+    return 0;
+}
+
+
+PyTypeObject
+_PyDeathQueueHandle_Type = {
+    PyVarObject_HEAD_INIT(&PyType_Type, 0)
+    "deathqueuehandle",
+    sizeof(PyDeathQueueHandle),
+    0,
+    (destructor)deathqueuehandle_dealloc,  /*tp_dealloc*/
+    0,                          /*tp_print*/
+    0,                          /*tp_getattr*/
+    0,                          /*tp_setattr*/
+    0,                          /*tp_compare*/
+    (reprfunc)deathqueuehandle_repr,  /*tp_repr*/
+    0,                          /*tp_as_number*/
+    0,                          /*tp_as_sequence*/
+    0,                          /*tp_as_mapping*/
+    0,                          /*tp_hash*/
+    0,                          /*tp_call*/
+    0,                          /*tp_str*/
+    0,                          /*tp_getattro*/
+    0,                          /*tp_setattro*/
+    0,                          /*tp_as_buffer*/
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
+        Py_TPFLAGS_SHAREABLE,  /*tp_flags*/
+    0,                          /*tp_doc*/
+    (traverseproc)deathqueuehandle_traverse,  /*tp_traverse*/
+    0,                          /*tp_clear*/
+    0,                          /*tp_richcompare*/
+    0,                          /*tp_weaklistoffset*/
+    0,                          /*tp_iter*/
+    0,                          /*tp_iternext*/
+    0,                          /*tp_methods*/
+    0,                          /*tp_members*/
+    0,                          /*tp_getset*/
+    0,                          /*tp_base*/
+    0,                          /*tp_dict*/
+    0,                          /*tp_descr_get*/
+    0,                          /*tp_descr_set*/
+    0,                          /*tp_dictoffset*/
+    0,                          /*tp_init*/
+    0,                          /*tp_new*/
+};
+
+
+static void
+deathqueue_dealloc(PyDeathQueue *self)
+{
+    deathqueue_clear(self);
+
+    if (Py_RefcntSnoop(self) != 1) {
+        /* Another thread is trying to manipulate us.  Probably a
+         * handle getting set to dead.  We can finish deleting later. */
+        PyObject_Revive(self);
+        Py_DECREF_ASYNC(self);
+    } else {
+        assert(PyLinkedList_Empty(&self->live_links));
+        assert(PyLinkedList_Empty(&self->dead_links));
+        PyCritical_Free(self->crit);
+        PyThread_cond_free(self->cond);
+        PyObject_Del(self);
+    }
+}
+
+static int
+deathqueue_traverse(PyDeathQueue *queue, visitproc visit, void *arg)
+{
+    PyDeathQueueHandle *handle = NULL;
+
+    while (PyLinkedList_Next(&queue->live_links, &handle))
+        Py_VISIT(handle);
+
+    assert(handle == NULL);
+    while (PyLinkedList_Next(&queue->dead_links, &handle))
+        Py_VISIT(handle);
+
+    return 0;
+}
+
+static int
+deathqueue_clear(PyDeathQueue *queue)
+{
+    /* When called by the tracing GC (not deathqueue_dealloc), we don't
+     * need to deal with the critical sections, as the tracing GC won't
+     * run while a thread is in one.  It won't hurt either though. */
+    while (1) {
+        PyDeathQueueHandle *handle;
+
+        PyCritical_Enter(queue->crit);
+        handle = PyLinkedList_First(&queue->live_links);
+        Py_XINCREF(handle);
+        PyCritical_Exit(queue->crit);
+
+        if (handle != NULL) {
+            if (PyDeathQueue_Cancel(queue, handle))
+                Py_FatalError("deathqueue_clear failed when calling "
+                    "PyDeathQueue_Cancel");
+            Py_DECREF(handle);
+        } else
+            break;
+    }
+
+    while (1) {
+        PyDeathQueueHandle *handle;
+
+        PyCritical_Enter(queue->crit);
+        handle = PyLinkedList_First(&queue->dead_links);
+        Py_XINCREF(handle);
+        PyCritical_Exit(queue->crit);
+
+        if (handle != NULL) {
+            if (PyDeathQueue_Cancel(queue, handle))
+                Py_FatalError("deathqueue_clear failed when calling "
+                    "PyDeathQueue_Cancel");
+            Py_DECREF(handle);
+        } else
+            break;
+    }
+
+    return 0;
+}
+
+static PyObject *
+deathqueue___new__(PyTypeObject *type, PyObject *args, PyObject *kwargs)
+{
+    PyDeathQueue *queue;
+
+    static char *kwlist[] = {NULL};
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "", kwlist))
+        return NULL;
+
+    queue = PyObject_New(&_PyDeathQueue_Type);
+    if (queue == NULL)
+        return NULL;
+
+    queue->crit = PyCritical_Allocate(PyCRITICAL_WEAKREF_QUEUE);
+    if (queue->crit == NULL) {
+        PyObject_Del(queue);
+        PyErr_NoMemory();
+        return NULL;
+    }
+
+    queue->cond = PyThread_cond_allocate();
+    if (queue->cond == NULL) {
+        PyCritical_Free(queue->crit);
+        PyObject_Del(queue);
+        PyErr_NoMemory();
+        return NULL;
+    }
+
+    PyLinkedList_InitBase(&queue->live_links,
+        offsetof(PyDeathQueueHandle, queue_links));
+    PyLinkedList_InitBase(&queue->dead_links,
+        offsetof(PyDeathQueueHandle, queue_links));
+
+    return (PyObject *)queue;
+}
+
+static int
+deathqueue___init__(PyObject *self, PyObject *args, PyObject *kwargs)
+{
+    static char *kwlist[] = {NULL};
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "", kwlist))
+        return 1;
+
+    return 0;
+}
+
+static PyObject *
+deathqueue_watch(PyDeathQueue *queue, PyObject *args)
+{
+    PyObject *obj, *payload;
+    PyWeakReference *ref;
+    PyDeathQueueHandle *handle;
+
+    if (!PyArg_UnpackTuple(args, "watch", 2, 2, &obj, &payload))
+        return NULL;
+
+    if (!PyObject_IsShareable(payload)) {
+        PyErr_Format(PyExc_TypeError,
+            "deathqueue.watch()'s payload argument must be shareable, '%s' object "
+            "is not", payload->ob_type->tp_name);
+        return NULL;
+    }
+
+    ref = (PyWeakReference *)PyWeakref_NewRef(obj, NULL);
+    if (ref == NULL)
+        return NULL;
+
+    handle = PyObject_New(&_PyDeathQueueHandle_Type);
+    if (handle == NULL) {
+        Py_DECREF(ref);
+        return NULL;
+    }
+
+    handle->crit = PyCritical_Allocate(PyCRITICAL_WEAKREF_HANDLE);
+    if (handle->crit == NULL) {
+        PyObject_Del(handle);
+        Py_DECREF(ref);
+        return NULL;
+    }
+
+    PyCritical_Enter(ref->crit);
+    /* We skip handle->crit as nobody else has a reference to handle yet. */
+    PyCritical_Enter(queue->crit);
+
+    assert(ref->wr_object != NULL);
+
+    /* The underlying ownership order is queue -> handle -> weakref.
+     * queue needs a reference to us, but handle doesn't INCREF them
+     * (they clear our pointer if they get deleted), and we already have
+     * a reference to weakref. */
+    Py_INCREF(handle);
+
+    Py_INCREF(payload);
+    handle->payload = payload;
+    handle->queue = queue;
+    handle->weakref = ref;
+    PyLinkedList_InitNode(&handle->weakref_links);
+    PyLinkedList_InitNode(&handle->queue_links);
+
+    PyLinkedList_Append(&ref->handle_links, handle);
+    PyLinkedList_Append(&queue->live_links, handle);
+
+    PyCritical_Exit(queue->crit);
+    PyCritical_Exit(ref->crit);
+
+    return (PyObject *)handle;
+}
+
+PyObject *
+deathqueue_cancel(PyDeathQueue *queue, PyObject *args)
+{
+    PyDeathQueueHandle *handle;
+
+    if (!PyArg_UnpackTuple(args, "cancel", 1, 1, &handle))
+        return NULL;
+
+    if (!PyDeathQueueHandle_Check(handle)) {
+        PyErr_Format(PyExc_TypeError, "cancel expected deathqueuehandle "
+            "(not \"%.200s\")", Py_TYPE(handle)->tp_name);
+        return NULL;
+    }
+
+    if (PyDeathQueue_Cancel(queue, handle))
+        return NULL;
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+/* Warning: this function deletes queue's reference to handle.  If the
+ * caller doesn't have their own reference to handle, it may be gone by
+ * the time this function returns. */
+static int
+PyDeathQueue_Cancel(PyDeathQueue *queue, PyDeathQueueHandle *handle)
+{
+    PyWeakReference *ref;
+    int decref_weakref = 0;
+    PyObject *payload;
+
+    /* "climb" up the ordered critical sections */
+    PyCritical_Enter(handle->crit);
+    ref = handle->weakref;
+    Py_XINCREF(ref);
+    PyCritical_Exit(handle->crit);
+
+    /* Begin entering all 3 critical sections (weakref, handle, queue) */
+    if (ref != NULL)
+        PyCritical_Enter(ref->crit);
+    PyCritical_Enter(handle->crit);
+
+    /* Early out if we've got nothing to do */
+    if (handle->queue != queue) {
+        PyDeathQueue *badqueue = handle->queue;
+        PyCritical_Exit(handle->crit);
+        if (ref != NULL)
+            PyCritical_Exit(ref->crit);
+        Py_XDECREF(ref);
+
+        if (handle->queue == NULL) {
+            /* Already cleared */
+            return 0;
+        } else {
+            /* Wrong queue! */
+            PyErr_Format(PyExc_ValueError, "cancel called on %p queue "
+                "but handle %p is for %p queue", queue, handle, badqueue);
+            return 1;
+        }
+    }
+
+    PyCritical_Enter(queue->crit);
+
+    /* The real work of this function */
+    if (handle->weakref != NULL) {
+        PyLinkedList_Remove(&handle->weakref_links);
+        handle->weakref = NULL;
+        decref_weakref = 1;
+    }
+    payload = handle->payload;
+    handle->payload = NULL;
+
+    PyLinkedList_Remove(&handle->queue_links);
+    handle->queue = NULL;
+
+    /* Exit the critical sections */
+    PyCritical_Exit(queue->crit);
+    PyCritical_Exit(handle->crit);
+    if (ref != NULL)
+        PyCritical_Exit(ref->crit);
+
+    /* Finally, cleanup */
+    Py_DECREF(handle);  /* queue -> handle reference */
+    Py_XDECREF(ref);  /* our reference */
+    if (decref_weakref)
+        Py_DECREF(ref);  /* handle -> weakref reference */
+    Py_XDECREF(payload);
+
+    return 0;
+}
+
+/* Returns 0 for success and 1 for empty */
+static int
+pop_common(PyDeathQueue *queue, PyObject **payload)
+{
+    PyDeathQueueHandle *handle;
+
+    while (1) {
+        PyCritical_Enter(queue->crit);
+        handle = PyLinkedList_First(&queue->dead_links);
+        Py_XINCREF(handle);
+        PyCritical_Exit(queue->crit);
+
+        if (handle == NULL)
+            return 1;
+
+        PyCritical_Enter(handle->crit);
+        PyCritical_Enter(queue->crit);
+
+        if (handle->queue == NULL) {
+            /* Another thread popped the handle on us, or cancelled it */
+            PyCritical_Exit(queue->crit);
+            PyCritical_Exit(handle->crit);
+            Py_DECREF(handle);
+            continue;
+        }
+
+        assert(handle->weakref == NULL);
+        PyLinkedList_Remove(&handle->queue_links);
+        *payload = handle->payload;
+        handle->payload = NULL;  /* We steal their reference */
+        handle->queue = NULL;
+
+        PyCritical_Exit(queue->crit);
+        PyCritical_Exit(handle->crit);
+
+        Py_DECREF(handle);
         return 0;
     }
+}
+
+static PyObject *
+deathqueue_pop(PyDeathQueue *queue)
+{
+    PyObject *payload, *x;
+
+    while (1) {
+        x = deathqueue_wait(queue);
+        if (x == NULL)
+            return NULL;
+        Py_DECREF(x);
+        if (!pop_common(queue, &payload))
+            return payload;
+    }
+}
+
+static PyObject *
+deathqueue_trypop(PyDeathQueue *queue)
+{
+    PyObject *payload;
+
+    if (pop_common(queue, &payload)) {
+        PyErr_SetString(PyExc_ValueError, "trypop from empty deathqueue");
+        return NULL;
+    } else
+        return payload;
+}
+
+static int
+deathqueue_bool(PyDeathQueue *queue)
+{
+    int result;
+
+    PyCritical_Enter(queue->crit);
+    result = !PyLinkedList_Empty(&queue->dead_links);
+    PyCritical_Exit(queue->crit);
+
+    return result;
+}
+
+static PyObject *
+deathqueue_wait(PyDeathQueue *queue)
+{
+    /* Using this method is racey, giving you extra wakeups and forcing
+     * you to have retry loops, so we don't bother to add another retry
+     * loop inside it. */
+    PyCritical_Enter(queue->crit);
+
+    if (PyLinkedList_Empty(&queue->dead_links))
+        _PyCritical_CondWait(queue->crit, queue->cond);
+
+    PyCritical_Exit(queue->crit);
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+
+PyDoc_STRVAR(watch_doc,
+"deathqueue.watch(obj, payload) -> handle.  payload is returned from\n\
+deathqueue.pop() once obj dies, unless canceled first.");
+
+PyDoc_STRVAR(cancel_doc,
+"deathqueue.cancel(handle) -> None.  Cancels watching of associated obj.");
+
+PyDoc_STRVAR(pop_doc,
+"deathqueue.pop() -> payload.  Returns the payload passed to\n\
+deathqueue.watch().  Blocks if no watched objects have died yet.");
+
+PyDoc_STRVAR(trypop_doc,
+"deathqueue.trypop() -> payload.  Used once bool(deathqueue) or\n\
+deathqueue.wait() indicate a watched obj has died; returns the payload\n\
+passed to deathqueue.watch().");
+
+PyDoc_STRVAR(wait_doc,
+"deathqueue.wait() -> None.  Does not return until a watched obj has\n\
+died.  This function is cancellable.");
+
+static PyNumberMethods deathqueue_as_number = {
+    0,                              /*nb_add*/
+    0,                              /*nb_subtract*/
+    0,                              /*nb_multiply*/
+    0,                              /*nb_remainder*/
+    0,                              /*nb_divmod*/
+    0,                              /*nb_power*/
+    0,                              /*nb_negative*/
+    0,                              /*nb_positive*/
+    0,                              /*nb_absolute*/
+    (inquiry)deathqueue_bool,       /*nb_bool*/
+};
+
+static PyMethodDef deathqueue_methods[] = {
+    {"watch",       (PyCFunction)deathqueue_watch,      METH_VARARGS, watch_doc},
+    {"cancel",      (PyCFunction)deathqueue_cancel,     METH_VARARGS, cancel_doc},
+    {"pop",         (PyCFunction)deathqueue_pop,        METH_NOARGS, pop_doc},
+    {"trypop",      (PyCFunction)deathqueue_trypop,     METH_NOARGS, trypop_doc},
+    {"wait",        (PyCFunction)deathqueue_wait,       METH_NOARGS, wait_doc},
+    {NULL}
+};
+
+static int
+deathqueue_isshareable (PyDeathQueue *queue)
+{
     return 1;
 }
 
-
-/* If a parameter is a proxy, check that it is still "live" and wrap it,
- * replacing the original value with the raw object.  Raises ReferenceError
- * if the param is a dead proxy.
- */
-#define UNWRAP(o) \
-        if (PyWeakref_CheckProxy(o)) { \
-            if (!proxy_checkref((PyWeakReference *)o)) \
-                return NULL; \
-            o = PyWeakref_GET_OBJECT(o); \
-        }
-
-#define UNWRAP_I(o) \
-        if (PyWeakref_CheckProxy(o)) { \
-            if (!proxy_checkref((PyWeakReference *)o)) \
-                return -1; \
-            o = PyWeakref_GET_OBJECT(o); \
-        }
-
-#define WRAP_UNARY(method, generic) \
-    static PyObject * \
-    method(PyObject *proxy) { \
-        UNWRAP(proxy); \
-        return generic(proxy); \
-    }
-
-#define WRAP_BINARY(method, generic) \
-    static PyObject * \
-    method(PyObject *x, PyObject *y) { \
-        UNWRAP(x); \
-        UNWRAP(y); \
-        return generic(x, y); \
-    }
-
-/* Note that the third arg needs to be checked for NULL since the tp_call
- * slot can receive NULL for this arg.
- */
-#define WRAP_TERNARY(method, generic) \
-    static PyObject * \
-    method(PyObject *proxy, PyObject *v, PyObject *w) { \
-        UNWRAP(proxy); \
-        UNWRAP(v); \
-        if (w != NULL) \
-            UNWRAP(w); \
-        return generic(proxy, v, w); \
-    }
-
-
-/* direct slots */
-
-WRAP_BINARY(proxy_getattr, PyObject_GetAttr)
-WRAP_UNARY(proxy_str, PyObject_Str)
-WRAP_TERNARY(proxy_call, PyEval_CallObjectWithKeywords)
-
-static PyObject *
-proxy_repr(PyWeakReference *proxy)
-{
-    char buf[160];
-    PyOS_snprintf(buf, sizeof(buf),
-		  "<weakproxy at %p to %.100s at %p>", proxy,
-		  Py_TYPE(PyWeakref_GET_OBJECT(proxy))->tp_name,
-		  PyWeakref_GET_OBJECT(proxy));
-    return PyUnicode_FromString(buf);
-}
-
-
-static int
-proxy_setattr(PyWeakReference *proxy, PyObject *name, PyObject *value)
-{
-    if (!proxy_checkref(proxy))
-        return -1;
-    return PyObject_SetAttr(PyWeakref_GET_OBJECT(proxy), name, value);
-}
-
-static PyObject *
-proxy_richcompare(PyObject *proxy, PyObject *v, int op)
-{
-    UNWRAP(proxy);
-    UNWRAP(v);
-    return PyObject_RichCompare(proxy, v, op);
-}
-
-/* number slots */
-WRAP_BINARY(proxy_add, PyNumber_Add)
-WRAP_BINARY(proxy_sub, PyNumber_Subtract)
-WRAP_BINARY(proxy_mul, PyNumber_Multiply)
-WRAP_BINARY(proxy_mod, PyNumber_Remainder)
-WRAP_BINARY(proxy_divmod, PyNumber_Divmod)
-WRAP_TERNARY(proxy_pow, PyNumber_Power)
-WRAP_UNARY(proxy_neg, PyNumber_Negative)
-WRAP_UNARY(proxy_pos, PyNumber_Positive)
-WRAP_UNARY(proxy_abs, PyNumber_Absolute)
-WRAP_UNARY(proxy_invert, PyNumber_Invert)
-WRAP_BINARY(proxy_lshift, PyNumber_Lshift)
-WRAP_BINARY(proxy_rshift, PyNumber_Rshift)
-WRAP_BINARY(proxy_and, PyNumber_And)
-WRAP_BINARY(proxy_xor, PyNumber_Xor)
-WRAP_BINARY(proxy_or, PyNumber_Or)
-WRAP_UNARY(proxy_int, PyNumber_Int)
-WRAP_UNARY(proxy_long, PyNumber_Long)
-WRAP_UNARY(proxy_float, PyNumber_Float)
-WRAP_BINARY(proxy_iadd, PyNumber_InPlaceAdd)
-WRAP_BINARY(proxy_isub, PyNumber_InPlaceSubtract)
-WRAP_BINARY(proxy_imul, PyNumber_InPlaceMultiply)
-WRAP_BINARY(proxy_imod, PyNumber_InPlaceRemainder)
-WRAP_TERNARY(proxy_ipow, PyNumber_InPlacePower)
-WRAP_BINARY(proxy_ilshift, PyNumber_InPlaceLshift)
-WRAP_BINARY(proxy_irshift, PyNumber_InPlaceRshift)
-WRAP_BINARY(proxy_iand, PyNumber_InPlaceAnd)
-WRAP_BINARY(proxy_ixor, PyNumber_InPlaceXor)
-WRAP_BINARY(proxy_ior, PyNumber_InPlaceOr)
-
-static int
-proxy_bool(PyWeakReference *proxy)
-{
-    PyObject *o = PyWeakref_GET_OBJECT(proxy);
-    if (!proxy_checkref(proxy))
-        return -1;
-    return PyObject_IsTrue(o);
-}
-
-static void
-proxy_dealloc(PyWeakReference *self)
-{
-    if (self->wr_callback != NULL)
-        PyObject_GC_UnTrack((PyObject *)self);
-    clear_weakref(self);
-    PyObject_GC_Del(self);
-}
-
-/* sequence slots */
-
-static int
-proxy_contains(PyWeakReference *proxy, PyObject *value)
-{
-    if (!proxy_checkref(proxy))
-        return -1;
-    return PySequence_Contains(PyWeakref_GET_OBJECT(proxy), value);
-}
-
-
-/* mapping slots */
-
-static Py_ssize_t
-proxy_length(PyWeakReference *proxy)
-{
-    if (!proxy_checkref(proxy))
-        return -1;
-    return PyObject_Length(PyWeakref_GET_OBJECT(proxy));
-}
-
-WRAP_BINARY(proxy_getitem, PyObject_GetItem)
-
-static int
-proxy_setitem(PyWeakReference *proxy, PyObject *key, PyObject *value)
-{
-    if (!proxy_checkref(proxy))
-        return -1;
-
-    if (value == NULL)
-        return PyObject_DelItem(PyWeakref_GET_OBJECT(proxy), key);
-    else
-        return PyObject_SetItem(PyWeakref_GET_OBJECT(proxy), key, value);
-}
-
-/* iterator slots */
-
-static PyObject *
-proxy_iter(PyWeakReference *proxy)
-{
-    if (!proxy_checkref(proxy))
-        return NULL;
-    return PyObject_GetIter(PyWeakref_GET_OBJECT(proxy));
-}
-
-static PyObject *
-proxy_iternext(PyWeakReference *proxy)
-{
-    if (!proxy_checkref(proxy))
-        return NULL;
-    return PyIter_Next(PyWeakref_GET_OBJECT(proxy));
-}
-
-
-static PyNumberMethods proxy_as_number = {
-    proxy_add,              /*nb_add*/
-    proxy_sub,              /*nb_subtract*/
-    proxy_mul,              /*nb_multiply*/
-    proxy_mod,              /*nb_remainder*/
-    proxy_divmod,           /*nb_divmod*/
-    proxy_pow,              /*nb_power*/
-    proxy_neg,              /*nb_negative*/
-    proxy_pos,              /*nb_positive*/
-    proxy_abs,              /*nb_absolute*/
-    (inquiry)proxy_bool,    /*nb_bool*/
-    proxy_invert,           /*nb_invert*/
-    proxy_lshift,           /*nb_lshift*/
-    proxy_rshift,           /*nb_rshift*/
-    proxy_and,              /*nb_and*/
-    proxy_xor,              /*nb_xor*/
-    proxy_or,               /*nb_or*/
-    0,                      /*nb_reserved*/
-    proxy_int,              /*nb_int*/
-    proxy_long,             /*nb_long*/
-    proxy_float,            /*nb_float*/
-    0,                      /*nb_oct*/
-    0,                      /*nb_hex*/
-    proxy_iadd,             /*nb_inplace_add*/
-    proxy_isub,             /*nb_inplace_subtract*/
-    proxy_imul,             /*nb_inplace_multiply*/
-    proxy_imod,             /*nb_inplace_remainder*/
-    proxy_ipow,             /*nb_inplace_power*/
-    proxy_ilshift,          /*nb_inplace_lshift*/
-    proxy_irshift,          /*nb_inplace_rshift*/
-    proxy_iand,             /*nb_inplace_and*/
-    proxy_ixor,             /*nb_inplace_xor*/
-    proxy_ior,              /*nb_inplace_or*/
-};
-
-static PySequenceMethods proxy_as_sequence = {
-    (lenfunc)proxy_length,      /*sq_length*/
-    0,                          /*sq_concat*/
-    0,                          /*sq_repeat*/
-    0,                          /*sq_item*/
-    0,                          /*sq_slice*/
-    0,                          /*sq_ass_item*/
-    0,				 /*sq_ass_slice*/
-    (objobjproc)proxy_contains, /* sq_contains */
-};
-
-static PyMappingMethods proxy_as_mapping = {
-    (lenfunc)proxy_length,        /*mp_length*/
-    proxy_getitem,                /*mp_subscript*/
-    (objobjargproc)proxy_setitem, /*mp_ass_subscript*/
-};
-
-
-PyTypeObject
-_PyWeakref_ProxyType = {
-    PyVarObject_HEAD_INIT(&PyType_Type, 0)
-    "weakproxy",
-    sizeof(PyWeakReference),
-    0,
-    /* methods */
-    (destructor)proxy_dealloc,          /* tp_dealloc */
-    0,				        /* tp_print */
-    0,				        /* tp_getattr */
-    0, 				        /* tp_setattr */
-    0,				        /* tp_compare */
-    (reprfunc)proxy_repr,	        /* tp_repr */
-    &proxy_as_number,		        /* tp_as_number */
-    &proxy_as_sequence,		        /* tp_as_sequence */
-    &proxy_as_mapping,		        /* tp_as_mapping */
-    0,	                                /* tp_hash */
-    0,	                                /* tp_call */
-    proxy_str,                          /* tp_str */
-    proxy_getattr,                      /* tp_getattro */
-    (setattrofunc)proxy_setattr,        /* tp_setattro */
-    0,				        /* tp_as_buffer */
-    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC, /* tp_flags */
-    0,                                  /* tp_doc */
-    (traverseproc)gc_traverse,          /* tp_traverse */
-    (inquiry)gc_clear,                  /* tp_clear */
-    proxy_richcompare,                  /* tp_richcompare */
-    0,                                  /* tp_weaklistoffset */
-    (getiterfunc)proxy_iter,            /* tp_iter */
-    (iternextfunc)proxy_iternext,       /* tp_iternext */
-};
-
-
-PyTypeObject
-_PyWeakref_CallableProxyType = {
-    PyVarObject_HEAD_INIT(&PyType_Type, 0)
-    "weakcallableproxy",
-    sizeof(PyWeakReference),
-    0,
-    /* methods */
-    (destructor)proxy_dealloc,          /* tp_dealloc */
-    0,				        /* tp_print */
-    0,				        /* tp_getattr */
-    0, 				        /* tp_setattr */
-    0,				        /* tp_compare */
-    (unaryfunc)proxy_repr,	        /* tp_repr */
-    &proxy_as_number,		        /* tp_as_number */
-    &proxy_as_sequence,		        /* tp_as_sequence */
-    &proxy_as_mapping,		        /* tp_as_mapping */
-    0,	                                /* tp_hash */
-    proxy_call,	                        /* tp_call */
-    proxy_str,	                        /* tp_str */
-    proxy_getattr,                      /* tp_getattro */
-    (setattrofunc)proxy_setattr,        /* tp_setattro */
-    0,				        /* tp_as_buffer */
-    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC, /* tp_flags */
-    0,                                  /* tp_doc */
-    (traverseproc)gc_traverse,          /* tp_traverse */
-    (inquiry)gc_clear,                  /* tp_clear */
-    proxy_richcompare,                  /* tp_richcompare */
-    0,                                  /* tp_weaklistoffset */
-    (getiterfunc)proxy_iter,            /* tp_iter */
-    (iternextfunc)proxy_iternext,       /* tp_iternext */
-};
-
+PyTypeObject
+_PyDeathQueue_Type = {
+    PyVarObject_HEAD_INIT(&PyType_Type, 0)
+    "deathqueue",
+    sizeof(PyDeathQueue),
+    0,
+    (destructor)deathqueue_dealloc,  /*tp_dealloc*/
+    0,                          /*tp_print*/
+    0,                          /*tp_getattr*/
+    0,                          /*tp_setattr*/
+    0,                          /*tp_compare*/
+    0,                          /*tp_repr*/
+    &deathqueue_as_number,      /*tp_as_number*/
+    0,                          /*tp_as_sequence*/
+    0,                          /*tp_as_mapping*/
+    0,                          /*tp_hash*/
+    0,                          /*tp_call*/
+    0,                          /*tp_str*/
+    0,                          /*tp_getattro*/
+    0,                          /*tp_setattro*/
+    0,                          /*tp_as_buffer*/
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
+        Py_TPFLAGS_SHAREABLE,  /*tp_flags*/
+    0,                          /*tp_doc*/
+    (traverseproc)deathqueue_traverse,  /*tp_traverse*/
+    0,                          /*tp_clear*/
+    0,                          /*tp_richcompare*/
+    0,                          /*tp_weaklistoffset*/
+    0,                          /*tp_iter*/
+    0,                          /*tp_iternext*/
+    deathqueue_methods,         /*tp_methods*/
+    0,                          /*tp_members*/
+    0,                          /*tp_getset*/
+    0,                          /*tp_base*/
+    0,                          /*tp_dict*/
+    0,                          /*tp_descr_get*/
+    0,                          /*tp_descr_set*/
+    0,                          /*tp_dictoffset*/
+    deathqueue___init__,        /*tp_init*/
+    deathqueue___new__,         /*tp_new*/
+    0,                          /*tp_is_gc*/
+    0,                          /*tp_bases*/
+    0,                          /*tp_mro*/
+    0,                          /*tp_cache*/
+    0,                          /*tp_subclasses*/
+    0,                          /*tp_weaklist*/
+    (isshareablefunc)deathqueue_isshareable,    /*tp_isshareable*/
+};
 
 
 PyObject *
 PyWeakref_NewRef(PyObject *ob, PyObject *callback)
 {
-    PyWeakReference *result = NULL;
-    PyWeakReference **list;
-    PyWeakReference *ref, *proxy;
-
-    if (!PyType_SUPPORTS_WEAKREFS(Py_TYPE(ob))) {
-        PyErr_Format(PyExc_TypeError,
-		     "cannot create weak reference to '%s' object",
-                     Py_TYPE(ob)->tp_name);
-        return NULL;
-    }
-    list = GET_WEAKREFS_LISTPTR(ob);
-    get_basic_refs(*list, &ref, &proxy);
-    if (callback == Py_None)
-        callback = NULL;
-    if (callback == NULL)
-        /* return existing weak reference if it exists */
-        result = ref;
-    if (result != NULL)
-        Py_INCREF(result);
-    else {
-        /* Note: new_weakref() can trigger cyclic GC, so the weakref
-           list on ob can be mutated.  This means that the ref and
-           proxy pointers we got back earlier may have been collected,
-           so we need to compute these values again before we use
-           them. */
-        result = new_weakref(ob, callback);
-        if (result != NULL) {
-            get_basic_refs(*list, &ref, &proxy);
-            if (callback == NULL) {
-                if (ref == NULL)
-                    insert_head(result, list);
-                else {
-                    /* Someone else added a ref without a callback
-                       during GC.  Return that one instead of this one
-                       to avoid violating the invariants of the list
-                       of weakrefs for ob. */
-                    Py_DECREF(result);
-                    Py_INCREF(ref);
-                    result = ref;
-                }
-            }
-            else {
-                PyWeakReference *prev;
-
-                prev = (proxy == NULL) ? ref : proxy;
-                if (prev == NULL)
-                    insert_head(result, list);
-                else
-                    insert_after(result, prev);
-            }
-        }
-    }
-    return (PyObject *) result;
-}
-
-
-PyObject *
-PyWeakref_NewProxy(PyObject *ob, PyObject *callback)
-{
-    PyWeakReference *result = NULL;
-    PyWeakReference **list;
-    PyWeakReference *ref, *proxy;
-
-    if (!PyType_SUPPORTS_WEAKREFS(Py_TYPE(ob))) {
-        PyErr_Format(PyExc_TypeError,
-		     "cannot create weak reference to '%s' object",
-                     Py_TYPE(ob)->tp_name);
-        return NULL;
-    }
-    list = GET_WEAKREFS_LISTPTR(ob);
-    get_basic_refs(*list, &ref, &proxy);
-    if (callback == Py_None)
-        callback = NULL;
-    if (callback == NULL)
-        /* attempt to return an existing weak reference if it exists */
-        result = proxy;
-    if (result != NULL)
-        Py_INCREF(result);
-    else {
-        /* Note: new_weakref() can trigger cyclic GC, so the weakref
-           list on ob can be mutated.  This means that the ref and
-           proxy pointers we got back earlier may have been collected,
-           so we need to compute these values again before we use
-           them. */
-        result = new_weakref(ob, callback);
-        if (result != NULL) {
-            PyWeakReference *prev;
-
-            if (PyCallable_Check(ob))
-                Py_TYPE(result) = &_PyWeakref_CallableProxyType;
-            else
-                Py_TYPE(result) = &_PyWeakref_ProxyType;
-            get_basic_refs(*list, &ref, &proxy);
-            if (callback == NULL) {
-                if (proxy != NULL) {
-                    /* Someone else added a proxy without a callback
-                       during GC.  Return that one instead of this one
-                       to avoid violating the invariants of the list
-                       of weakrefs for ob. */
-                    Py_DECREF(result);
-                    Py_INCREF(result = proxy);
-                    goto skip_insert;
-                }
-                prev = ref;
-            }
-            else
-                prev = (proxy == NULL) ? ref : proxy;
-
-            if (prev == NULL)
-                insert_head(result, list);
-            else
-                insert_after(result, prev);
-        skip_insert:
-            ;
-        }
-    }
-    return (PyObject *) result;
-}
-
-
-PyObject *
-PyWeakref_GetObject(PyObject *ref)
-{
+    PyWeakReference **ptr;
+    PyWeakReference *ref;
+
+    if (!PyType_SUPPORTS_WEAKREFS(Py_TYPE(ob))) {
+        PyErr_Format(PyExc_TypeError,
+                     "cannot create weak reference to '%s' object",
+                     Py_TYPE(ob)->tp_name);
+        return NULL;
+    }
+    if (callback != NULL) {
+        PyErr_Format(PyExc_TypeError,
+            "weakrefs no longer support callbacks");
+        return NULL;
+    }
+
+    ptr = _PY_GETWEAKREFPTR(ob);
+
+    /* XXX FIXME We should have some sort of fake critical section to
+     * ensure the tracing GC doesn't activate and delete the weakref */
+
+    /* Use the existing ref if there is one */
+    ref = (PyWeakReference *)AO_load_full((AO_t *)ptr);
+    if (ref != NULL) {
+        Py_INCREF(ref);
+        return (PyObject *)ref;
+    }
+
+    /* If there isn't a ref we start creating one */
+    ref = PyObject_New(&_PyWeakref_Type);
+    ref->crit = PyCritical_Allocate(PyCRITICAL_WEAKREF_REF);
+    if (ref->crit == NULL) {
+        PyObject_Del(ref);
+        PyErr_NoMemory();
+        return NULL;
+    }
+    ref->hash = (AO_t)-1;
+    ref->wr_object = ob;
+    PyLinkedList_InitBase(&ref->handle_links,
+        offsetof(PyDeathQueueHandle, weakref_links));
+    PyLinkedList_InitBase(&ref->binding_links,
+        offsetof(PyWeakBinding, weakref_links));
+
+    if (!AO_compare_and_swap_full((AO_t *)ptr, (AO_t)NULL, (AO_t)ref)) {
+        /* Another thread beat us to it.  Use theirs instead. */
+        Py_DECREF(ref);
+        ref = (PyWeakReference *)AO_load_full((AO_t *)ptr);
+        assert(ref != NULL);
+    }
+
+    /* ob has the original reference, so we need another one to return
+     * to our caller */
+    Py_INCREF(ref);
+    return (PyObject *)ref;
+}
+
+
+/* Unlike the old function, this DOES include an INCREF */
+PyObject *
+PyWeakref_GetObjectEx(PyObject *ref_)
+{
+    PyObject *ob;
+    PyWeakReference *ref = (PyWeakReference *)ref_;
+
     if (ref == NULL || !PyWeakref_Check(ref)) {
         PyErr_BadInternalCall();
         return NULL;
     }
-    return PyWeakref_GET_OBJECT(ref);
-}
-
-/* Note that there's an inlined copy-paste of handle_callback() in gcmodule.c's
- * handle_weakrefs().
- */
-static void
-handle_callback(PyWeakReference *ref, PyObject *callback)
-{
-    PyObject *cbresult = PyObject_CallFunctionObjArgs(callback, ref, NULL);
-
-    if (cbresult == NULL)
-        PyErr_WriteUnraisable(callback);
-    else
-        Py_DECREF(cbresult);
-}
-
-/* This function is called by the tp_dealloc handler to clear weak references.
- *
- * This iterates through the weak references for 'object' and calls callbacks
- * for those references which have one.  It returns when all callbacks have
- * been attempted.
- */
-void
-PyObject_ClearWeakRefs(PyObject *object)
-{
-    PyWeakReference **list;
-
-    if (object == NULL
-        || !PyType_SUPPORTS_WEAKREFS(Py_TYPE(object))
-        || object->ob_refcnt != 0) {
-        PyErr_BadInternalCall();
-        return;
-    }
-    list = GET_WEAKREFS_LISTPTR(object);
-    /* Remove the callback-less basic and proxy references */
-    if (*list != NULL && (*list)->wr_callback == NULL) {
-        clear_weakref(*list);
-        if (*list != NULL && (*list)->wr_callback == NULL)
-            clear_weakref(*list);
-    }
-    if (*list != NULL) {
-        PyWeakReference *current = *list;
-        Py_ssize_t count = _PyWeakref_GetWeakrefCount(current);
-        int restore_error = PyErr_Occurred() ? 1 : 0;
-        PyObject *err_type, *err_value, *err_tb;
-
-        if (restore_error)
-            PyErr_Fetch(&err_type, &err_value, &err_tb);
-        if (count == 1) {
-            PyObject *callback = current->wr_callback;
-
-            current->wr_callback = NULL;
-            clear_weakref(current);
-            if (callback != NULL) {
-                handle_callback(current, callback);
-                Py_DECREF(callback);
-            }
-        }
-        else {
-            PyObject *tuple;
-            Py_ssize_t i = 0;
-    
-            tuple = PyTuple_New(count * 2);
-            if (tuple == NULL) {
-                if (restore_error)
-                    PyErr_Fetch(&err_type, &err_value, &err_tb);
-                return;
-            }
-
-            for (i = 0; i < count; ++i) {
-                PyWeakReference *next = current->wr_next;
-
-                Py_INCREF(current);
-                PyTuple_SET_ITEM(tuple, i * 2, (PyObject *) current);
-                PyTuple_SET_ITEM(tuple, i * 2 + 1, current->wr_callback);
-                current->wr_callback = NULL;
-                clear_weakref(current);
-                current = next;
-            }
-            for (i = 0; i < count; ++i) {
-                PyObject *callback = PyTuple_GET_ITEM(tuple, i * 2 + 1);
-
-                if (callback != NULL) {
-                    PyObject *item = PyTuple_GET_ITEM(tuple, i * 2);
-                    handle_callback((PyWeakReference *)item, callback);
-                }
-            }
-            Py_DECREF(tuple);
-        }
-        if (restore_error)
-            PyErr_Restore(err_type, err_value, err_tb);
-    }
-}
+
+    PyCritical_Enter(ref->crit);
+    ob = ref->wr_object;
+    Py_XINCREF(ob);
+    PyCritical_Exit(ref->crit);
+
+    return ob;
+}
+
+
+static void
+_PyWeakref_delete_common(PyObject *object, PyWeakReference *ref)
+{
+    PyWeakReference **ptr = _PY_GETWEAKREFPTR(object);
+    ref->wr_object = NULL;
+    *ptr = NULL;
+    Py_DECREF(ref);
+
+    while (!PyLinkedList_Empty(&ref->handle_links)) {
+        PyDeathQueueHandle *handle = PyLinkedList_First(&ref->handle_links);
+
+        PyCritical_Enter(handle->crit);
+        assert(handle->queue != NULL);
+        PyCritical_Enter(handle->queue->crit);
+
+        PyLinkedList_Remove(&handle->weakref_links);
+        handle->weakref = NULL;
+        /* There should always be one reference remaining, borrowed
+         * from the caller. */
+        Py_DECREF(ref);
+
+        PyLinkedList_Remove(&handle->queue_links);
+        PyLinkedList_Append(&handle->queue->dead_links, handle);
+        PyThread_cond_wakeall(handle->queue->cond);
+
+        PyCritical_Exit(handle->queue->crit);
+        PyCritical_Exit(handle->crit);
+    }
+}
+
+static int
+_PyWeakref_TryDelete(PyObject *object, PyWeakReference *ref)
+{
+    PyCritical_Enter(ref->crit);
+    if (ref->wr_object == NULL) {
+        PyCritical_Exit(ref->crit);
+        return 0;
+    }
+    assert(ref->wr_object == object);
+
+    if (Py_RefcntSnoop(object) != 1) {
+        /* Brought back from the brink of death! */
+        PyCritical_Exit(ref->crit);
+        return 1;
+    } else {
+        _PyWeakref_delete_common(object, ref);
+
+        PyCritical_Exit(ref->crit);
+
+        _PyWeakref_ClearBindings(object, ref);
+
+        return 0;
+    }
+}
+
+/* XXX This version will actually be called by Py_Dealloc and may
+ * indicate the object is not to be deleted after all. */
+/* XXX FIXME this whole function should get moved into gcmodule.c */
+int
+_PyObject_TryClearWeakref(PyObject *object)
+{
+    PyWeakReference **ptr;
+    PyWeakReference *ref;
+    int result;
+
+    if (object == NULL ||
+            !PyType_SUPPORTS_WEAKREFS(Py_TYPE(object)) ||
+            !Py_RefcntMatches(object, 1)) {
+        PyErr_BadInternalCall();
+        return 0;
+    }
+    ptr = _PY_GETWEAKREFPTR(object);
+
+    ref = (PyWeakReference *)AO_load_full((AO_t *)ptr);
+    if (ref == NULL)
+        return 0;
+    Py_INCREF(ref);
+
+    result = _PyWeakref_TryDelete(object, ref);
+
+    Py_DECREF(ref);
+    return result;
+}
+
+void
+_PyObject_ForceClearWeakref(PyObject *object)
+{
+    PyWeakReference *ref;
+    PyWeakReference **ptr = _PY_GETWEAKREFPTR(object);
+
+    ref = (PyWeakReference *)AO_load_full((AO_t *)ptr);
+    if (ref == NULL)
+        return;
+
+    Py_INCREF(ref);
+
+    PyCritical_Enter(ref->crit);
+    assert(ref->wr_object == object);
+    _PyWeakref_delete_common(object, ref);
+    PyCritical_Exit(ref->crit);
+
+    _PyWeakref_ClearBindings(object, ref);
+
+    Py_DECREF(ref);
+}
+
+PyObject *
+PyWeakref_NewBinding(PyObject *ob, PyObject *value)
+{
+    PyWeakReference *ref;
+    PyWeakBinding *bind;
+
+    ref = (PyWeakReference *)PyWeakref_NewRef(ob, NULL);
+    if (ref == NULL)
+        return NULL;
+
+    bind = PyObject_New(&_PyWeakBinding_Type);
+    if (bind == NULL) {
+        Py_DECREF(ref);
+        return NULL;
+    }
+
+    PyCritical_Enter(ref->crit);
+    assert(ref->wr_object != NULL);
+    bind->weakref = ref;
+    Py_INCREF(value); /* This is actually owned by ob */
+    bind->value = value;
+    PyLinkedList_InitNode(&bind->weakref_links);
+    PyLinkedList_Append(&ref->binding_links, bind);
+    PyCritical_Exit(ref->crit);
+
+    return (PyObject *)bind;
+}
+
+PyObject *
+PyWeakref_GetBindingObject(PyObject *bind_, PyObject **value)
+{
+    PyObject *ob;
+    PyWeakBinding *bind = (PyWeakBinding *)bind_;
+
+    if (bind == NULL || !PyWeakBinding_Check(bind) || value == NULL) {
+        PyErr_BadInternalCall();
+        return NULL;
+    }
+
+    PyCritical_Enter(bind->weakref->crit);
+    if (!PyLinkedList_Detached(&bind->weakref_links) &&
+            bind->weakref->wr_object != NULL) {
+        ob = bind->weakref->wr_object;
+        Py_INCREF(ob);
+        *value = bind->value;
+        Py_INCREF(*value);
+        PyCritical_Exit(bind->weakref->crit);
+        return ob;
+    } else {
+        PyCritical_Exit(bind->weakref->crit);
+        *value = NULL;
+        return NULL;
+    }
+}
+
+void
+_PyWeakref_ClearBindings(PyObject *ob, PyWeakReference *ref)
+{
+    /* Deleting the values may cause another binding to be deleted,
+     * reentering the critical section.  Thus the hoops about making
+     * sure all the bindings we want stay alive long enough, and exiting
+     * the critical section while calling DECREF */
+    PyWeakBinding *bind = NULL;
+    PyObject *value;
+
+    PyCritical_Enter(ref->crit);
+    assert(ref->wr_object == NULL);
+
+    while (PyLinkedList_Next(&ref->binding_links, &bind))
+        Py_INCREF(bind);
+
+    while (!PyLinkedList_Empty(&ref->binding_links)) {
+        bind = PyLinkedList_First(&ref->binding_links);
+
+        PyLinkedList_Remove(&bind->weakref_links);
+        value = bind->value;
+        bind->value = NULL;
+
+        PyCritical_Exit(ref->crit);
+        Py_DECREF(bind);
+        Py_DECREF(value);
+        PyCritical_Enter(ref->crit);
+    }
+
+    PyCritical_Exit(ref->crit);
+}
+
+static void
+weakbind_dealloc(PyWeakBinding *bind)
+{
+    PyCritical_Enter(bind->weakref->crit);
+    if (!PyLinkedList_Detached(&bind->weakref_links)) {
+        PyObject *value;
+        assert(bind->value);
+        PyLinkedList_Remove(&bind->weakref_links);
+        value = bind->value;
+        bind->value = NULL;
+        /* At this point we've taken ob's reference to value and now
+         * own it directly. */
+        PyCritical_Exit(bind->weakref->crit);
+        Py_DECREF(value);
+    } else
+        PyCritical_Exit(bind->weakref->crit);
+
+    if (Py_RefcntSnoop(bind) != 1) {
+        /* Another thread is trying to manipulate us.  Probably a
+         * clearing all the bindings for a weakref.  We can finish
+         * deleting later. */
+        PyObject_Revive(bind);
+        Py_DECREF_ASYNC(bind);
+        return;
+    }
+
+    Py_DECREF(bind->weakref);
+
+    PyObject_Del(bind);
+}
+
+static int
+weakbind_traverse(PyWeakBinding *bind, visitproc visit, void *arg)
+{
+    Py_VISIT(bind->weakref);
+    return 0;
+}
+
+static PyObject *
+weakbind_call(PyObject *bind, PyObject *args, PyObject *kw)
+{
+    static char *kwlist[] = {NULL};
+    PyObject *ob, *value;
+
+    if (!PyArg_ParseTupleAndKeywords(args, kw, ":__call__", kwlist))
+        return NULL;
+
+    ob = PyWeakref_GetBindingObject(bind, &value);
+
+    if (ob == NULL)
+        return Py_BuildValue("OO", Py_None, Py_None);
+    else
+        return Py_BuildValue("NN", ob, value);
+}
+
+static PyObject *
+weakbind_repr(PyWeakBinding *bind)
+{
+    char buffer[256];
+    PyObject *ob, *value;
+
+    ob = PyWeakref_GetBindingObject((PyObject *)bind, &value);
+
+    if (ob == NULL)
+        PyOS_snprintf(buffer, sizeof(buffer), "<weakbinding at %p; dead>", bind);
+    else {
+        PyOS_snprintf(buffer, sizeof(buffer),
+            "<weakbinding at %p; from '%.50s' at %p to '%.50s' at %p>",
+            bind, Py_TYPE(ob)->tp_name, ob, Py_TYPE(value)->tp_name, value);
+        Py_DECREF(ob);
+        Py_DECREF(value);
+    }
+
+    return PyUnicode_FromString(buffer);
+}
+
+static int
+parse_weakbind_init_args(char *funcname, PyObject *args, PyObject *kwargs,
+                        PyObject **obp, PyObject **valuep)
+{
+    /* XXX Should check that kwargs == NULL or is empty. */
+    return PyArg_UnpackTuple(args, funcname, 2, 2, obp, valuep);
+}
+
+static PyObject *
+weakbind___new__(PyTypeObject *type, PyObject *args, PyObject *kwargs)
+{
+    PyObject *ob, *value;
+
+    if (!parse_weakbind_init_args("__new__", args, kwargs, &ob, &value))
+        return NULL;
+
+    return PyWeakref_NewBinding(ob, value);
+}
+
+static int
+weakbind___init__(PyObject *self, PyObject *args, PyObject *kwargs)
+{
+    PyObject *ob, *value;
+
+    if (parse_weakbind_init_args("__init__", args, kwargs, &ob, &value))
+        return 0;
+    else
+        return 1;
+}
+
+
+PyTypeObject
+_PyWeakBinding_Type = {
+    PyVarObject_HEAD_INIT(&PyType_Type, 0)
+    "weakbinding",
+    sizeof(PyWeakBinding),
+    0,
+    (destructor)weakbind_dealloc,  /*tp_dealloc*/
+    0,                          /*tp_print*/
+    0,                          /*tp_getattr*/
+    0,                          /*tp_setattr*/
+    0,                          /*tp_compare*/
+    (reprfunc)weakbind_repr,    /*tp_repr*/
+    0,                          /*tp_as_number*/
+    0,                          /*tp_as_sequence*/
+    0,                          /*tp_as_mapping*/
+    0,                          /*tp_hash*/
+    weakbind_call,              /*tp_call*/
+    0,                          /*tp_str*/
+    0,                          /*tp_getattro*/
+    0,                          /*tp_setattro*/
+    0,                          /*tp_as_buffer*/
+    /* subclassing is unsupported */
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
+        Py_TPFLAGS_SHAREABLE,  /*tp_flags*/
+    0,                          /*tp_doc*/
+    (traverseproc)weakbind_traverse,  /*tp_traverse*/
+    0,                          /*tp_clear*/
+    0,                          /*tp_richcompare*/
+    0,                          /*tp_weaklistoffset*/
+    0,                          /*tp_iter*/
+    0,                          /*tp_iternext*/
+    0,                          /*tp_methods*/
+    0,                          /*tp_members*/
+    0,                          /*tp_getset*/
+    0,                          /*tp_base*/
+    0,                          /*tp_dict*/
+    0,                          /*tp_descr_get*/
+    0,                          /*tp_descr_set*/
+    0,                          /*tp_dictoffset*/
+    weakbind___init__,          /*tp_init*/
+    weakbind___new__,           /*tp_new*/
+};

=== modified file 'PC/_msi.c'
--- PC/_msi.c	2008-02-12 22:59:25 +0000
+++ PC/_msi.c	2008-03-24 04:28:03 +0000
@@ -454,9 +454,7 @@
         0,                      /*tp_descr_set*/
         0,                      /*tp_dictoffset*/
         0,                      /*tp_init*/
-        0,                      /*tp_alloc*/
         0,                      /*tp_new*/
-        0,                      /*tp_free*/
         0,                      /*tp_is_gc*/
 };
 
@@ -624,9 +622,7 @@
         0,                      /*tp_descr_set*/
         0,                      /*tp_dictoffset*/
         0,                      /*tp_init*/
-        0,                      /*tp_alloc*/
         0,                      /*tp_new*/
-        0,                      /*tp_free*/
         0,                      /*tp_is_gc*/
 };
 
@@ -772,9 +768,7 @@
         0,                      /*tp_descr_set*/
         0,                      /*tp_dictoffset*/
         0,                      /*tp_init*/
-        0,                      /*tp_alloc*/
         0,                      /*tp_new*/
-        0,                      /*tp_free*/
         0,                      /*tp_is_gc*/
 };
 
@@ -889,9 +883,7 @@
         0,                      /*tp_descr_set*/
         0,                      /*tp_dictoffset*/
         0,                      /*tp_init*/
-        0,                      /*tp_alloc*/
         0,                      /*tp_new*/
-        0,                      /*tp_free*/
         0,                      /*tp_is_gc*/
 };
 

=== modified file 'PC/_subprocess.c'
--- PC/_subprocess.c	2007-12-19 02:45:37 +0000
+++ PC/_subprocess.c	2008-03-24 04:28:03 +0000
@@ -101,7 +101,7 @@
 {
 	if (self->handle != INVALID_HANDLE_VALUE)
 		CloseHandle(self->handle);
-	PyObject_FREE(self);
+	PyObject_DEL(self);
 }
 
 static PyMethodDef sp_handle_methods[] = {

=== modified file 'Parser/intrcheck.c'
--- Parser/intrcheck.c	2007-08-16 14:35:24 +0000
+++ Parser/intrcheck.c	2008-03-24 04:28:03 +0000
@@ -1,172 +0,0 @@
-
-/* Check for interrupts */
-
-#include "Python.h"
-
-#ifdef QUICKWIN
-
-#include <io.h>
-
-void
-PyOS_InitInterrupts(void)
-{
-}
-
-void
-PyOS_FiniInterrupts(void)
-{
-}
-
-int
-PyOS_InterruptOccurred(void)
-{
-	_wyield();
-}
-
-#define OK
-
-#endif /* QUICKWIN */
-
-#if defined(_M_IX86) && !defined(__QNX__)
-#include <io.h>
-#endif
-
-#if defined(MSDOS) && !defined(QUICKWIN)
-
-#ifdef __GNUC__
-
-/* This is for DJGPP's GO32 extender.  I don't know how to trap
- * control-C  (There's no API for ctrl-C, and I don't want to mess with
- * the interrupt vectors.)  However, this DOES catch control-break.
- * --Amrit
- */
-
-#include <go32.h>
-
-void
-PyOS_InitInterrupts(void)
-{
-	_go32_want_ctrl_break(1 /* TRUE */);
-}
-
-void
-PyOS_FiniInterrupts(void)
-{
-}
-
-int
-PyOS_InterruptOccurred(void)
-{
-	return _go32_was_ctrl_break_hit();
-}
-
-#else /* !__GNUC__ */
-
-/* This might work for MS-DOS (untested though): */
-
-void
-PyOS_InitInterrupts(void)
-{
-}
-
-void
-PyOS_FiniInterrupts(void)
-{
-}
-
-int
-PyOS_InterruptOccurred(void)
-{
-	int interrupted = 0;
-	while (kbhit()) {
-		if (getch() == '\003')
-			interrupted = 1;
-	}
-	return interrupted;
-}
-
-#endif /* __GNUC__ */
-
-#define OK
-
-#endif /* MSDOS && !QUICKWIN */
-
-
-#ifndef OK
-
-/* Default version -- for real operating systems and for Standard C */
-
-#include <stdio.h>
-#include <string.h>
-#include <signal.h>
-
-static int interrupted;
-
-void
-PyErr_SetInterrupt(void)
-{
-	interrupted = 1;
-}
-
-extern int PyErr_CheckSignals(void);
-
-static int
-checksignals_witharg(void * arg)
-{
-	return PyErr_CheckSignals();
-}
-
-static void
-intcatcher(int sig)
-{
-	extern void Py_Exit(int);
-	static char message[] =
-"python: to interrupt a truly hanging Python program, interrupt once more.\n";
-	switch (interrupted++) {
-	case 0:
-		break;
-	case 1:
-		write(2, message, strlen(message));
-		break;
-	case 2:
-		interrupted = 0;
-		Py_Exit(1);
-		break;
-	}
-	PyOS_setsig(SIGINT, intcatcher);
-	Py_AddPendingCall(checksignals_witharg, NULL);
-}
-
-static void (*old_siginthandler)(int) = SIG_DFL;
-
-void
-PyOS_InitInterrupts(void)
-{
-	if ((old_siginthandler = PyOS_setsig(SIGINT, SIG_IGN)) != SIG_IGN)
-		PyOS_setsig(SIGINT, intcatcher);
-}
-
-void
-PyOS_FiniInterrupts(void)
-{
-	PyOS_setsig(SIGINT, old_siginthandler);
-}
-
-int
-PyOS_InterruptOccurred(void)
-{
-	if (!interrupted)
-		return 0;
-	interrupted = 0;
-	return 1;
-}
-
-#endif /* !OK */
-
-void
-PyOS_AfterFork(void)
-{
-#ifdef WITH_THREAD
-	PyEval_ReInitThreads();
-#endif
-}

=== modified file 'Parser/myreadline.c'
--- Parser/myreadline.c	2007-08-16 14:35:24 +0000
+++ Parser/myreadline.c	2008-03-24 04:28:03 +0000
@@ -20,11 +20,11 @@
 #endif
 
 
-PyThreadState* _PyOS_ReadlineTState;
+PyState* _PyOS_ReadlinePyState;
 
 #ifdef WITH_THREAD
 #include "pythread.h"
-static PyThread_type_lock _PyOS_ReadlineLock = NULL;
+static PyThread_type_lock *_PyOS_ReadlineLock = NULL;
 #endif
 
 int (*PyOS_InputHook)(void) = NULL;
@@ -77,22 +77,29 @@
 		}
 #ifdef EINTR
 		if (errno == EINTR) {
-			int s;
 #ifdef WITH_THREAD
-			PyEval_RestoreThread(_PyOS_ReadlineTState);
+			//PyEval_RestoreThread(_PyOS_ReadlinePyState);
+			PyState_Resume();
 #endif
+#if 0
 			s = PyErr_CheckSignals();
+#endif
 #ifdef WITH_THREAD
-			PyEval_SaveThread();
+			//PyEval_SaveThread();
+			PyState_Suspend();
 #endif
+#if 0
 			if (s < 0) {
 				return 1;
 			}
+#endif
 		}
 #endif
+#if 0
 		if (PyOS_InterruptOccurred()) {
 			return 1; /* Interrupt */
 		}
+#endif
 		return -2; /* Error */
 	}
 	/* NOTREACHED */
@@ -157,7 +164,7 @@
 {
 	char *rv;
 
-	if (_PyOS_ReadlineTState == PyThreadState_GET()) {
+	if (_PyOS_ReadlinePyState == PyState_Get()) {
 		PyErr_SetString(PyExc_RuntimeError,
 				"can't re-enter readline");
 		return NULL;
@@ -174,14 +181,14 @@
 	
 #ifdef WITH_THREAD
 	if (_PyOS_ReadlineLock == NULL) {
-		_PyOS_ReadlineLock = PyThread_allocate_lock();		
+		_PyOS_ReadlineLock = PyThread_lock_allocate();		
 	}
 #endif
 
-	_PyOS_ReadlineTState = PyThreadState_GET();
+	_PyOS_ReadlinePyState = PyState_Get();
 	Py_BEGIN_ALLOW_THREADS
 #ifdef WITH_THREAD
-	PyThread_acquire_lock(_PyOS_ReadlineLock, 1);
+	PyThread_lock_acquire(_PyOS_ReadlineLock);
 #endif
 
         /* This is needed to handle the unlikely case that the
@@ -197,10 +204,10 @@
 	Py_END_ALLOW_THREADS
 
 #ifdef WITH_THREAD
-	PyThread_release_lock(_PyOS_ReadlineLock);
+	PyThread_lock_release(_PyOS_ReadlineLock);
 #endif
 
-	_PyOS_ReadlineTState = NULL;
+	_PyOS_ReadlinePyState = NULL;
 
 	return rv;
 }

=== modified file 'Parser/node.c'
--- Parser/node.c	2006-06-08 15:35:45 +0000
+++ Parser/node.c	2008-03-24 04:28:03 +0000
@@ -13,6 +13,7 @@
 	n->n_type = type;
 	n->n_str = NULL;
 	n->n_lineno = 0;
+    n->n_col_offset = 42424242;
 	n->n_nchildren = 0;
 	n->n_child = NULL;
 	return n;
@@ -102,6 +103,8 @@
 	n = &n1->n_child[n1->n_nchildren++];
 	n->n_type = type;
 	n->n_str = str;
+    //if (str != NULL)
+        //printf("New %p '%s'\n", str, str);
 	n->n_lineno = lineno;
 	n->n_col_offset = col_offset;
 	n->n_nchildren = 0;
@@ -130,6 +133,8 @@
 		freechildren(CHILD(n, i));
 	if (n->n_child != NULL)
 		PyObject_FREE(n->n_child);
-	if (STR(n) != NULL)
+	if (STR(n) != NULL) {
+        //printf("Delete %p '%s'\n", STR(n), STR(n));
 		PyObject_FREE(STR(n));
+    }
 }

=== modified file 'Python/Python-ast.c'
--- Python/Python-ast.c	2008-03-31 05:29:39 +0000
+++ Python/Python-ast.c	2008-04-11 03:06:12 +0000
@@ -507,9 +507,7 @@
     0,                       /* tp_descr_set */
     0,                       /* tp_dictoffset */
     (initproc)ast_type_init, /* tp_init */
-    PyType_GenericAlloc,     /* tp_alloc */
     PyType_GenericNew,       /* tp_new */
-    PyObject_Del,            /* tp_free */
 };
 
 

=== modified file 'Python/ast.c'
--- Python/ast.c	2008-04-05 14:49:54 +0000
+++ Python/ast.c	2008-04-11 02:07:14 +0000
@@ -3145,6 +3145,8 @@
         p = buf = PyString_AsString(u);
         end = s + len;
         while (s < end) {
+            if (*s == '\0')
+                Py_FatalError("Meh");
             if (*s == '\\') {
                 *p++ = *s++;
                 if (*s & 0x80) {
@@ -3175,6 +3177,7 @@
                 *p++ = *s++;
             }
         }
+        *p = '\0';
         len = p - buf;
         s = buf;
     }

=== modified file 'Python/bltinmodule.c'
--- Python/bltinmodule.c	2008-03-31 04:20:05 +0000
+++ Python/bltinmodule.c	2008-04-11 03:18:17 +0000
@@ -9,6 +9,9 @@
 
 #include <ctype.h>
 
+#include "monitorobject.h"
+#include "branchobject.h"
+
 /* The default encoding used by the platform file system APIs
    Can remain NULL for all platforms that don't have such a concept
 
@@ -147,12 +150,16 @@
 	PyObject *locals = NULL;
 	PyObject *fromlist = NULL;
 	int level = -1;
+	PyObject *r;
 
 	if (!PyArg_ParseTupleAndKeywords(args, kwds, "s|OOOi:__import__",
 			kwlist, &name, &globals, &locals, &fromlist, &level))
 		return NULL;
-	return PyImport_ImportModuleLevel(name, globals, locals,
+	PyState_EnterImport();
+	r = PyImport_ImportModuleLevel(name, globals, locals,
 					  fromlist, level);
+	PyState_ExitImport();
+	return r;
 }
 
 PyDoc_STRVAR(import_doc,
@@ -305,7 +312,7 @@
 		return NULL;
 
 	/* create filterobject structure */
-	lz = (filterobject *)type->tp_alloc(type, 0);
+	lz = PyObject_New(type);
 	if (lz == NULL) {
 		Py_DECREF(it);
 		return NULL;
@@ -320,10 +327,9 @@
 static void
 filter_dealloc(filterobject *lz)
 {
-	PyObject_GC_UnTrack(lz);
 	Py_XDECREF(lz->func);
 	Py_XDECREF(lz->it);
-	Py_TYPE(lz)->tp_free(lz);
+	PyObject_Del(lz);
 }
 
 static int
@@ -396,7 +402,8 @@
 	0,				/* tp_setattro */
 	0,				/* tp_as_buffer */
 	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
-		Py_TPFLAGS_BASETYPE,	/* tp_flags */
+		Py_TPFLAGS_BASETYPE |
+		Py_TPFLAGS_SHAREABLE,	/* tp_flags */
 	filter_doc,			/* tp_doc */
 	(traverseproc)filter_traverse,	/* tp_traverse */
 	0,				/* tp_clear */
@@ -413,9 +420,7 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	0,				/* tp_init */
-	PyType_GenericAlloc,		/* tp_alloc */
 	filter_new,			/* tp_new */
-	PyObject_GC_Del,		/* tp_free */
 };
 
 
@@ -932,7 +937,7 @@
 	}
 
 	/* create mapobject structure */
-	lz = (mapobject *)type->tp_alloc(type, 0);
+	lz = PyObject_New(type);
 	if (lz == NULL) {
 		Py_DECREF(iters);
 		return NULL;
@@ -948,10 +953,9 @@
 static void
 map_dealloc(mapobject *lz)
 {
-	PyObject_GC_UnTrack(lz);
 	Py_XDECREF(lz->iters);
 	Py_XDECREF(lz->func);
-	Py_TYPE(lz)->tp_free(lz);
+	PyObject_Del(lz);
 }
 
 static int
@@ -1016,7 +1020,8 @@
 	0,				/* tp_setattro */
 	0,				/* tp_as_buffer */
 	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
-		Py_TPFLAGS_BASETYPE,	/* tp_flags */
+		Py_TPFLAGS_BASETYPE |
+		Py_TPFLAGS_SHAREABLE,	/* tp_flags */
 	map_doc,			/* tp_doc */
 	(traverseproc)map_traverse,	/* tp_traverse */
 	0,				/* tp_clear */
@@ -1033,9 +1038,7 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	0,				/* tp_init */
-	PyType_GenericAlloc,		/* tp_alloc */
 	map_new,			/* tp_new */
-	PyObject_GC_Del,		/* tp_free */
 };
 
 static PyObject *
@@ -1672,6 +1675,7 @@
 	int ndigits = UNDEF_NDIGITS;
 	static char *kwlist[] = {"number", "ndigits", 0};
 	PyObject *number, *round;
+	PyObject *result;
 
 	if (!PyArg_ParseTupleAndKeywords(args, kwds, "O|i:round",
                 kwlist, &number, &ndigits))
@@ -1688,7 +1692,8 @@
 			return NULL;
 	}
 
-	round = _PyType_Lookup(Py_TYPE(number), round_str);
+	if (_PyType_LookupEx(Py_TYPE(number), round_str, &round) < 0)
+		return NULL;
 	if (round == NULL) {
 		PyErr_Format(PyExc_TypeError,
 			     "type %.100s doesn't define __round__ method",
@@ -1697,9 +1702,11 @@
 	}
 
 	if (ndigits == UNDEF_NDIGITS)
-                return PyObject_CallFunction(round, "O", number);
+		result = PyObject_CallFunction(round, "O", number);
 	else
-                return PyObject_CallFunction(round, "Oi", number, ndigits);
+                result = PyObject_CallFunction(round, "Oi", number, ndigits);
+	Py_DECREF(round);
+	return result;
 #undef UNDEF_NDIGITS
 }
 
@@ -2047,7 +2054,7 @@
 	}
 
 	/* create zipobject structure */
-	lz = (zipobject *)type->tp_alloc(type, 0);
+	lz = PyObject_New(type);
 	if (lz == NULL) {
 		Py_DECREF(ittuple);
 		Py_DECREF(result);
@@ -2063,10 +2070,9 @@
 static void
 zip_dealloc(zipobject *lz)
 {
-	PyObject_GC_UnTrack(lz);
 	Py_XDECREF(lz->ittuple);
 	Py_XDECREF(lz->result);
-	Py_TYPE(lz)->tp_free(lz);
+	PyObject_Del(lz);
 }
 
 static int
@@ -2089,7 +2095,7 @@
 
 	if (tuplesize == 0)
 		return NULL;
-	if (Py_REFCNT(result) == 1) {
+	if (Py_RefcntMatches(result, 1)) {
 		Py_INCREF(result);
 		for (i=0 ; i < tuplesize ; i++) {
 			it = PyTuple_GET_ITEM(lz->ittuple, i);
@@ -2153,7 +2159,8 @@
 	0,				/* tp_setattro */
 	0,				/* tp_as_buffer */
 	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
-		Py_TPFLAGS_BASETYPE,	/* tp_flags */
+		Py_TPFLAGS_BASETYPE |
+		Py_TPFLAGS_SHAREABLE,	/* tp_flags */
 	zip_doc,			/* tp_doc */
 	(traverseproc)zip_traverse,    /* tp_traverse */
 	0,				/* tp_clear */
@@ -2170,54 +2177,52 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	0,				/* tp_init */
-	PyType_GenericAlloc,		/* tp_alloc */
 	zip_new,			/* tp_new */
-	PyObject_GC_Del,		/* tp_free */
 };
 
 
 static PyMethodDef builtin_methods[] = {
  	{"__build_class__", (PyCFunction)builtin___build_class__,
-         METH_VARARGS | METH_KEYWORDS, build_class_doc},
- 	{"__import__",	(PyCFunction)builtin___import__, METH_VARARGS | METH_KEYWORDS, import_doc},
- 	{"abs",		builtin_abs,        METH_O, abs_doc},
- 	{"all",		builtin_all,        METH_O, all_doc},
- 	{"any",		builtin_any,        METH_O, any_doc},
-	{"bin",		builtin_bin,	    METH_O, bin_doc},
- 	{"chr",		builtin_chr,        METH_VARARGS, chr_doc},
- 	{"cmp",		builtin_cmp,        METH_VARARGS, cmp_doc},
- 	{"compile",	(PyCFunction)builtin_compile,    METH_VARARGS | METH_KEYWORDS, compile_doc},
- 	{"delattr",	builtin_delattr,    METH_VARARGS, delattr_doc},
- 	{"dir",		builtin_dir,        METH_VARARGS, dir_doc},
- 	{"divmod",	builtin_divmod,     METH_VARARGS, divmod_doc},
- 	{"eval",	builtin_eval,       METH_VARARGS, eval_doc},
-	{"exec",        builtin_exec,       METH_VARARGS, exec_doc},
- 	{"format",	builtin_format,     METH_VARARGS, format_doc},
- 	{"getattr",	builtin_getattr,    METH_VARARGS, getattr_doc},
- 	{"globals",	(PyCFunction)builtin_globals,    METH_NOARGS, globals_doc},
- 	{"hasattr",	builtin_hasattr,    METH_VARARGS, hasattr_doc},
- 	{"hash",	builtin_hash,       METH_O, hash_doc},
- 	{"hex",		builtin_hex,        METH_O, hex_doc},
- 	{"id",		builtin_id,         METH_O, id_doc},
- 	{"input",	builtin_input,      METH_VARARGS, input_doc},
- 	{"isinstance",  builtin_isinstance, METH_VARARGS, isinstance_doc},
- 	{"issubclass",  builtin_issubclass, METH_VARARGS, issubclass_doc},
- 	{"iter",	builtin_iter,       METH_VARARGS, iter_doc},
- 	{"len",		builtin_len,        METH_O, len_doc},
- 	{"locals",	(PyCFunction)builtin_locals,     METH_NOARGS, locals_doc},
- 	{"max",		(PyCFunction)builtin_max,        METH_VARARGS | METH_KEYWORDS, max_doc},
- 	{"min",		(PyCFunction)builtin_min,        METH_VARARGS | METH_KEYWORDS, min_doc},
-	{"next",	(PyCFunction)builtin_next,       METH_VARARGS, next_doc},
- 	{"oct",		builtin_oct,        METH_O, oct_doc},
- 	{"ord",		builtin_ord,        METH_O, ord_doc},
- 	{"pow",		builtin_pow,        METH_VARARGS, pow_doc},
- 	{"print",	(PyCFunction)builtin_print,      METH_VARARGS | METH_KEYWORDS, print_doc},
- 	{"repr",	builtin_repr,       METH_O, repr_doc},
- 	{"round",	(PyCFunction)builtin_round,      METH_VARARGS | METH_KEYWORDS, round_doc},
- 	{"setattr",	builtin_setattr,    METH_VARARGS, setattr_doc},
- 	{"sorted",	(PyCFunction)builtin_sorted,     METH_VARARGS | METH_KEYWORDS, sorted_doc},
- 	{"sum",		builtin_sum,        METH_VARARGS, sum_doc},
- 	{"vars",	builtin_vars,       METH_VARARGS, vars_doc},
+         METH_SHARED | METH_VARARGS | METH_KEYWORDS, build_class_doc},
+ 	{"__import__",	(PyCFunction)builtin___import__, METH_SHARED | METH_VARARGS | METH_KEYWORDS, import_doc},
+ 	{"abs",		builtin_abs,        METH_SHARED | METH_O, abs_doc},
+ 	{"all",		builtin_all,        METH_SHARED | METH_O, all_doc},
+ 	{"any",		builtin_any,        METH_SHARED | METH_O, any_doc},
+	{"bin",		builtin_bin,	    METH_SHARED | METH_O, bin_doc},
+ 	{"chr",		builtin_chr,        METH_SHARED | METH_VARARGS, chr_doc},
+ 	{"cmp",		builtin_cmp,        METH_SHARED | METH_VARARGS, cmp_doc},
+ 	{"compile",	(PyCFunction)builtin_compile,    METH_SHARED | METH_VARARGS | METH_KEYWORDS, compile_doc},
+ 	{"delattr",	builtin_delattr,    METH_SHARED | METH_VARARGS, delattr_doc},
+ 	{"dir",		builtin_dir,        METH_SHARED | METH_VARARGS, dir_doc},
+ 	{"divmod",	builtin_divmod,     METH_SHARED | METH_VARARGS, divmod_doc},
+ 	{"eval",	builtin_eval,       METH_SHARED | METH_VARARGS, eval_doc},
+	{"exec",        builtin_exec,       METH_SHARED | METH_VARARGS, exec_doc},
+ 	{"format",	builtin_format,     METH_SHARED | METH_VARARGS, format_doc},
+ 	{"getattr",	builtin_getattr,    METH_SHARED | METH_VARARGS, getattr_doc},
+ 	{"globals",	(PyCFunction)builtin_globals,    METH_SHARED | METH_NOARGS, globals_doc},
+ 	{"hasattr",	builtin_hasattr,    METH_SHARED | METH_VARARGS, hasattr_doc},
+ 	{"hash",	builtin_hash,       METH_SHARED | METH_O, hash_doc},
+ 	{"hex",		builtin_hex,        METH_SHARED | METH_O, hex_doc},
+ 	{"id",		builtin_id,         METH_SHARED | METH_O, id_doc},
+ 	{"input",	builtin_input,      METH_SHARED | METH_VARARGS, input_doc},
+ 	{"isinstance",  builtin_isinstance, METH_SHARED | METH_VARARGS, isinstance_doc},
+ 	{"issubclass",  builtin_issubclass, METH_SHARED | METH_VARARGS, issubclass_doc},
+ 	{"iter",	builtin_iter,       METH_SHARED | METH_VARARGS, iter_doc},
+ 	{"len",		builtin_len,        METH_SHARED | METH_O, len_doc},
+ 	{"locals",	(PyCFunction)builtin_locals,     METH_SHARED | METH_NOARGS, locals_doc},
+ 	{"max",		(PyCFunction)builtin_max,        METH_SHARED | METH_VARARGS | METH_KEYWORDS, max_doc},
+ 	{"min",		(PyCFunction)builtin_min,        METH_SHARED | METH_VARARGS | METH_KEYWORDS, min_doc},
+	{"next",	(PyCFunction)builtin_next,       METH_SHARED | METH_VARARGS, next_doc},
+ 	{"oct",		builtin_oct,        METH_SHARED | METH_O, oct_doc},
+ 	{"ord",		builtin_ord,        METH_SHARED | METH_O, ord_doc},
+ 	{"pow",		builtin_pow,        METH_SHARED | METH_VARARGS, pow_doc},
+ 	{"print",	(PyCFunction)builtin_print,      METH_SHARED | METH_VARARGS | METH_KEYWORDS, print_doc},
+ 	{"repr",	builtin_repr,       METH_SHARED | METH_O, repr_doc},
+ 	{"round",	(PyCFunction)builtin_round,      METH_SHARED | METH_VARARGS | METH_KEYWORDS, round_doc},
+ 	{"setattr",	builtin_setattr,    METH_SHARED | METH_VARARGS, setattr_doc},
+ 	{"sorted",	(PyCFunction)builtin_sorted,     METH_SHARED | METH_VARARGS | METH_KEYWORDS, sorted_doc},
+ 	{"sum",		builtin_sum,        METH_SHARED | METH_VARARGS, sum_doc},
+ 	{"vars",	builtin_vars,       METH_SHARED | METH_VARARGS, vars_doc},
 	{NULL,		NULL},
 };
 
@@ -2226,16 +2231,26 @@
 \n\
 Noteworthy: None is the `nil' object; Ellipsis represents `...' in slices.");
 
-PyObject *
+
+PyObject *_PyBuiltin_Dict;
+
+extern PyTypeObject PyFakeRange_Type;
+int
 _PyBuiltin_Init(void)
 {
-	PyObject *mod, *dict, *debug;
-	mod = Py_InitModule4("builtins", builtin_methods,
+	PyObject *mod, *debug;
+
+	PyState_EnterImport();
+
+	mod = Py_InitModule5("builtins", builtin_methods,
 			     builtin_doc, (PyObject *)NULL,
-			     PYTHON_API_VERSION);
+			     PYTHON_API_VERSION, 1);
 	if (mod == NULL)
-		return NULL;
-	dict = PyModule_GetDict(mod);
+		goto error;
+	_PyBuiltin_Dict = PyModule_GetDict(mod);
+	if (_PyBuiltin_Dict == NULL)
+		Py_FatalError("_PyBuiltin_Init: can't retrieve dict");
+	Py_INCREF(_PyBuiltin_Dict);
 
 #ifdef Py_TRACE_REFS
 	/* "builtins" exposes a number of statically allocated objects
@@ -2250,8 +2265,8 @@
 #endif
 
 #define SETBUILTIN(NAME, OBJECT) \
-	if (PyDict_SetItemString(dict, NAME, (PyObject *)OBJECT) < 0)	\
-		return NULL;						\
+	if (PyDict_SetItemString(_PyBuiltin_Dict, NAME, (PyObject *)OBJECT) < 0)	\
+		goto error;						\
 	ADD_TO_ALL(OBJECT)
 
 	SETBUILTIN("None",		Py_None);
@@ -2268,6 +2283,7 @@
 	SETBUILTIN("complex",		&PyComplex_Type);
 #endif
 	SETBUILTIN("dict",		&PyDict_Type);
+	SETBUILTIN("shareddict",	&PySharedDict_Type);
  	SETBUILTIN("enumerate",		&PyEnum_Type);
  	SETBUILTIN("filter",		&PyFilter_Type);
 	SETBUILTIN("float",		&PyFloat_Type);
@@ -2278,6 +2294,7 @@
 	SETBUILTIN("map",		&PyMap_Type);
 	SETBUILTIN("object",		&PyBaseObject_Type);
 	SETBUILTIN("range",		&PyRange_Type);
+	SETBUILTIN("fakerange",		&PyFakeRange_Type);
 	SETBUILTIN("reversed",		&PyReversed_Type);
 	SETBUILTIN("set",		&PySet_Type);
 	SETBUILTIN("slice",		&PySlice_Type);
@@ -2288,13 +2305,102 @@
 	SETBUILTIN("type",		&PyType_Type);
 	SETBUILTIN("zip",		&PyZip_Type);
 	debug = PyBool_FromLong(Py_OptimizeFlag == 0);
-	if (PyDict_SetItemString(dict, "__debug__", debug) < 0) {
+	if (PyDict_SetItemString(_PyBuiltin_Dict, "__debug__", debug) < 0) {
 		Py_XDECREF(debug);
-		return NULL;
+		goto error;
 	}
 	Py_XDECREF(debug);
 
-	return mod;
+	/* initialize builtin exceptions */
+	_PyExc_Init();
+
+	PyState_ExitImport();
+	return 0;
+
+error:
+	PyState_ExitImport();
+	return 1;
+#undef ADD_TO_ALL
+#undef SETBUILTIN
+}
+
+
+/* Doesn't really belong here, but oh well */
+static PyObject *
+threadtools_wait(PyObject *unused, PyObject *args, PyObject *kwds)
+{
+    PyObject *self, *rest, *method, *result;
+
+    if (PyTuple_GET_SIZE(args) < 1) {
+        PyErr_SetString(PyExc_TypeError, "wait() requires at least 1 "
+            "argument");
+        return NULL;
+    }
+
+    self = PyTuple_GET_ITEM(args, 0);
+    rest = PyTuple_GetSlice(args, 1, PyTuple_GET_SIZE(args));
+    if (rest == NULL)
+        return NULL;
+
+    method = PyObject_GetAttrString(self, "__wait__");
+    if (method == NULL) {
+        Py_DECREF(rest);
+        return NULL;
+    }
+
+    result = PyObject_Call(method, rest, kwds);
+    Py_DECREF(rest);
+    Py_DECREF(method);
+    return result;
+}
+
+PyDoc_STRVAR(wait_doc,
+"wait(monitor, func, *args, **kwargs) -> result\n\
+wait(monitor.condition) -> None\n\
+\n\
+Relinquishes monitor until func returns or condition is true.");
+
+
+static PyMethodDef threadtools_methods[] = {
+    {"wait", (PyCFunction)threadtools_wait,
+        METH_SHARED | METH_VARARGS | METH_KEYWORDS, wait_doc},
+    {NULL, NULL},
+};
+
+PyDoc_STRVAR(module_doc,
+"This is a template module just for instruction.");
+
+PyMODINIT_FUNC
+_Py_ThreadTools_Init(void)
+{
+	PyObject *mod, *dict;
+
+	mod = Py_InitModule3("_threadtools", threadtools_methods, module_doc);
+	if (mod == NULL)
+		return;
+
+	dict = PyModule_GetDict(mod);
+
+#ifdef Py_TRACE_REFS
+#define ADD_TO_ALL(OBJECT) _Py_AddToAllObjects((PyObject *)(OBJECT), 0)
+#else
+#define ADD_TO_ALL(OBJECT) (void)0
+#endif
+
+#define SETBUILTIN(NAME, OBJECT) \
+	if (PyDict_SetItemString(dict, NAME, (PyObject *)OBJECT) < 0)	\
+		goto error;						\
+	ADD_TO_ALL(OBJECT)
+
+	SETBUILTIN("MonitorMeta",	&PyMonitorMeta_Type);
+	SETBUILTIN("Monitor",		&PyMonitor_Type);
+	SETBUILTIN("monitormethod",	&PyMonitorMethod_Type);
+	SETBUILTIN("condition",		&PyMonitorCondition_Type);
+	SETBUILTIN("MonitorSpace",	&PyMonitorSpace_Type);
+	SETBUILTIN("branch",		&PyBranch_Type);
+
+error:
+	;
 #undef ADD_TO_ALL
 #undef SETBUILTIN
 }

=== modified file 'Python/ceval.c'
--- Python/ceval.c	2008-03-16 00:07:10 +0000
+++ Python/ceval.c	2008-04-11 02:48:44 +0000
@@ -62,8 +62,8 @@
 	      uint64 loop0, uint64 loop1, uint64 intr0, uint64 intr1)
 {
 	uint64 intr, inst, loop;
-	PyThreadState *tstate = PyThreadState_Get();
-	if (!tstate->interp->tscdump)
+	extern int _PySys_TSCDump;
+	if (!_PySys_TSCDump)
 		return;
 	intr = intr1 - intr0;
 	inst = inst1 - inst0 - intr;
@@ -79,7 +79,7 @@
 
 #ifdef Py_DEBUG
 /* For debugging the interpreter: */
-#define LLTRACE  1	/* Low-level trace feature */
+//#define LLTRACE  1	/* Low-level trace feature */
 #define CHECKEXC 1	/* Double-check exception checking */
 #endif
 
@@ -87,11 +87,11 @@
 
 /* Forward declarations */
 #ifdef WITH_TSC
-static PyObject * call_function(PyObject ***, int, uint64*, uint64*);
+static PyObject * call_function(PyState *, PyObject ***, int, uint64*, uint64*);
 #else
-static PyObject * call_function(PyObject ***, int);
+static PyObject * call_function(PyState *, PyObject ***, int);
 #endif
-static PyObject * fast_function(PyObject *, PyObject ***, int, int, int);
+static PyObject * fast_function(PyState *, PyObject *, PyObject ***, int, int, int);
 static PyObject * do_call(PyObject *, PyObject ***, int, int);
 static PyObject * ext_do_call(PyObject *, PyObject ***, int, int, int);
 static PyObject * update_keyword_args(PyObject *, int, PyObject ***,
@@ -116,8 +116,8 @@
 static PyObject * cmp_outcome(int, PyObject *, PyObject *);
 static PyObject * import_from(PyObject *, PyObject *);
 static int import_all_from(PyObject *, PyObject *);
-static void set_exc_info(PyThreadState *, PyObject *, PyObject *, PyObject *);
-static void reset_exc_info(PyThreadState *);
+static void set_exc_info(PyState *, PyObject *, PyObject *, PyObject *);
+static void reset_exc_info(PyState *);
 static void format_exc_check_arg(PyObject *, const char *, PyObject *);
 static PyObject * unicode_concatenate(PyObject *, PyObject *,
                                       PyFrameObject *, unsigned char *);
@@ -199,221 +199,11 @@
 #endif
 
 
-#ifdef WITH_THREAD
-
 #ifdef HAVE_ERRNO_H
 #include <errno.h>
 #endif
 #include "pythread.h"
 
-static PyThread_type_lock interpreter_lock = 0; /* This is the GIL */
-static long main_thread = 0;
-
-int
-PyEval_ThreadsInitialized(void)
-{
-	return interpreter_lock != 0;
-}
-
-void
-PyEval_InitThreads(void)
-{
-	if (interpreter_lock)
-		return;
-	interpreter_lock = PyThread_allocate_lock();
-	PyThread_acquire_lock(interpreter_lock, 1);
-	main_thread = PyThread_get_thread_ident();
-}
-
-void
-PyEval_AcquireLock(void)
-{
-	PyThread_acquire_lock(interpreter_lock, 1);
-}
-
-void
-PyEval_ReleaseLock(void)
-{
-	PyThread_release_lock(interpreter_lock);
-}
-
-void
-PyEval_AcquireThread(PyThreadState *tstate)
-{
-	if (tstate == NULL)
-		Py_FatalError("PyEval_AcquireThread: NULL new thread state");
-	/* Check someone has called PyEval_InitThreads() to create the lock */
-	assert(interpreter_lock);
-	PyThread_acquire_lock(interpreter_lock, 1);
-	if (PyThreadState_Swap(tstate) != NULL)
-		Py_FatalError(
-			"PyEval_AcquireThread: non-NULL old thread state");
-}
-
-void
-PyEval_ReleaseThread(PyThreadState *tstate)
-{
-	if (tstate == NULL)
-		Py_FatalError("PyEval_ReleaseThread: NULL thread state");
-	if (PyThreadState_Swap(NULL) != tstate)
-		Py_FatalError("PyEval_ReleaseThread: wrong thread state");
-	PyThread_release_lock(interpreter_lock);
-}
-
-/* This function is called from PyOS_AfterFork to ensure that newly
-   created child processes don't hold locks referring to threads which
-   are not running in the child process.  (This could also be done using
-   pthread_atfork mechanism, at least for the pthreads implementation.) */
-
-void
-PyEval_ReInitThreads(void)
-{
-	if (!interpreter_lock)
-		return;
-	/*XXX Can't use PyThread_free_lock here because it does too
-	  much error-checking.  Doing this cleanly would require
-	  adding a new function to each thread_*.h.  Instead, just
-	  create a new lock and waste a little bit of memory */
-	interpreter_lock = PyThread_allocate_lock();
-	PyThread_acquire_lock(interpreter_lock, 1);
-	main_thread = PyThread_get_thread_ident();
-}
-#endif
-
-/* Functions save_thread and restore_thread are always defined so
-   dynamically loaded modules needn't be compiled separately for use
-   with and without threads: */
-
-PyThreadState *
-PyEval_SaveThread(void)
-{
-	PyThreadState *tstate = PyThreadState_Swap(NULL);
-	if (tstate == NULL)
-		Py_FatalError("PyEval_SaveThread: NULL tstate");
-#ifdef WITH_THREAD
-	if (interpreter_lock)
-		PyThread_release_lock(interpreter_lock);
-#endif
-	return tstate;
-}
-
-void
-PyEval_RestoreThread(PyThreadState *tstate)
-{
-	if (tstate == NULL)
-		Py_FatalError("PyEval_RestoreThread: NULL tstate");
-#ifdef WITH_THREAD
-	if (interpreter_lock) {
-		int err = errno;
-		PyThread_acquire_lock(interpreter_lock, 1);
-		errno = err;
-	}
-#endif
-	PyThreadState_Swap(tstate);
-}
-
-
-/* Mechanism whereby asynchronously executing callbacks (e.g. UNIX
-   signal handlers or Mac I/O completion routines) can schedule calls
-   to a function to be called synchronously.
-   The synchronous function is called with one void* argument.
-   It should return 0 for success or -1 for failure -- failure should
-   be accompanied by an exception.
-
-   If registry succeeds, the registry function returns 0; if it fails
-   (e.g. due to too many pending calls) it returns -1 (without setting
-   an exception condition).
-
-   Note that because registry may occur from within signal handlers,
-   or other asynchronous events, calling malloc() is unsafe!
-
-#ifdef WITH_THREAD
-   Any thread can schedule pending calls, but only the main thread
-   will execute them.
-#endif
-
-   XXX WARNING!  ASYNCHRONOUSLY EXECUTING CODE!
-   There are two possible race conditions:
-   (1) nested asynchronous registry calls;
-   (2) registry calls made while pending calls are being processed.
-   While (1) is very unlikely, (2) is a real possibility.
-   The current code is safe against (2), but not against (1).
-   The safety against (2) is derived from the fact that only one
-   thread (the main thread) ever takes things out of the queue.
-
-   XXX Darn!  With the advent of thread state, we should have an array
-   of pending calls per thread in the thread state!  Later...
-*/
-
-#define NPENDINGCALLS 32
-static struct {
-	int (*func)(void *);
-	void *arg;
-} pendingcalls[NPENDINGCALLS];
-static volatile int pendingfirst = 0;
-static volatile int pendinglast = 0;
-static volatile int things_to_do = 0;
-
-int
-Py_AddPendingCall(int (*func)(void *), void *arg)
-{
-	static volatile int busy = 0;
-	int i, j;
-	/* XXX Begin critical section */
-	/* XXX If you want this to be safe against nested
-	   XXX asynchronous calls, you'll have to work harder! */
-	if (busy)
-		return -1;
-	busy = 1;
-	i = pendinglast;
-	j = (i + 1) % NPENDINGCALLS;
-	if (j == pendingfirst) {
-		busy = 0;
-		return -1; /* Queue full */
-	}
-	pendingcalls[i].func = func;
-	pendingcalls[i].arg = arg;
-	pendinglast = j;
-
-	_Py_Ticker = 0;
-	things_to_do = 1; /* Signal main loop */
-	busy = 0;
-	/* XXX End critical section */
-	return 0;
-}
-
-int
-Py_MakePendingCalls(void)
-{
-	static int busy = 0;
-#ifdef WITH_THREAD
-	if (main_thread && PyThread_get_thread_ident() != main_thread)
-		return 0;
-#endif
-	if (busy)
-		return 0;
-	busy = 1;
-	things_to_do = 0;
-	for (;;) {
-		int i;
-		int (*func)(void *);
-		void *arg;
-		i = pendingfirst;
-		if (i == pendinglast)
-			break; /* Queue empty */
-		func = pendingcalls[i].func;
-		arg = pendingcalls[i].arg;
-		pendingfirst = (i + 1) % NPENDINGCALLS;
-		if (func(arg) < 0) {
-			busy = 0;
-			things_to_do = 1; /* We're not done yet */
-			return -1;
-		}
-	}
-	busy = 0;
-	return 0;
-}
-
 
 /* The interpreter's recursion limit */
 
@@ -444,28 +234,28 @@
 int
 _Py_CheckRecursiveCall(char *where)
 {
-	PyThreadState *tstate = PyThreadState_GET();
+	PyState *pystate = PyState_Get();
 
 #ifdef USE_STACKCHECK
 	if (PyOS_CheckStack()) {
-		--tstate->recursion_depth;
+		--pystate->recursion_depth;
 		PyErr_SetString(PyExc_MemoryError, "Stack overflow");
 		return -1;
 	}
 #endif
-	if (tstate->recursion_critical)
+	if (pystate->recursion_critical)
 		/* Somebody asked that we don't check for recursion. */
 		return 0;
-	if (tstate->overflowed) {
-		if (tstate->recursion_depth > recursion_limit + 50) {
+	if (pystate->overflowed) {
+		if (pystate->recursion_depth > recursion_limit + 50) {
 			/* Overflowing while handling an overflow. Give up. */
 			Py_FatalError("Cannot recover from stack overflow.");
 		}
 		return 0;
 	}
-	if (tstate->recursion_depth > recursion_limit) {
-		--tstate->recursion_depth;
-		tstate->overflowed = 1;
+	if (pystate->recursion_depth > recursion_limit) {
+		--pystate->recursion_depth;
+		pystate->overflowed = 1;
 		PyErr_Format(PyExc_RuntimeError,
 			     "maximum recursion depth exceeded%s",
 			     where);
@@ -491,8 +281,8 @@
 
 /* for manipulating the thread switch and periodic "stuff" - used to be
    per thread, now just a pair o' globals */
-int _Py_CheckInterval = 100;
-volatile int _Py_Ticker = 100;
+int _Py_CheckInterval = 10000;
+//volatile int _Py_Ticker = 100;
 
 PyObject *
 PyEval_EvalCode(PyCodeObject *co, PyObject *globals, PyObject *locals)
@@ -528,14 +318,14 @@
 	register int oparg;	/* Current opcode argument, if any */
 	register enum why_code why; /* Reason for block stack unwind */
 	register int err;	/* Error status -- nonzero if error */
-	register PyObject *x;	/* Result object -- NULL if error */
+	PyObject *x;	/* Result object -- NULL if error */
 	register PyObject *v;	/* Temporary objects popped off stack */
 	register PyObject *w;
 	register PyObject *u;
 	register PyObject *t;
 	register PyObject **fastlocals, **freevars;
 	PyObject *retval = NULL;	/* Return value */
-	PyThreadState *tstate = PyThreadState_GET();
+	PyState *pystate = PyState_Get();
 	PyCodeObject *co;
 
 	/* when tracing we set things up so that
@@ -690,7 +480,7 @@
    variable would be pointing to already-freed memory. */
 #define SETLOCAL(i, value)	do { PyObject *tmp = GETLOCAL(i); \
 				     GETLOCAL(i) = value; \
-                                     Py_XDECREF(tmp); } while (0)
+                                     Py_XDECREF_PS(tmp); } while (0)
 
 /* Start of code */
 
@@ -701,11 +491,12 @@
 	if (Py_EnterRecursiveCall(""))
 		return NULL;
 
-	tstate->frame = f;
+	//printf("%p's old %p replaced with f %p\n", pystate, pystate->frame, f);
+	pystate->frame = f;
 
-	if (tstate->use_tracing) {
-		if (tstate->c_tracefunc != NULL) {
-			/* tstate->c_tracefunc, if defined, is a
+	if (pystate->use_tracing) {
+		if (pystate->c_tracefunc != NULL) {
+			/* pystate->c_tracefunc, if defined, is a
 			   function that will be called on *every* entry
 			   to a code block.  Its return value, if not
 			   None, is a function that will be called at
@@ -718,18 +509,18 @@
 			   an argument which depends on the situation.
 			   The global trace function is also called
 			   whenever an exception is detected. */
-			if (call_trace_protected(tstate->c_tracefunc, 
-						 tstate->c_traceobj,
+			if (call_trace_protected(pystate->c_tracefunc,
+						 pystate->c_traceobj,
 						 f, PyTrace_CALL, Py_None)) {
 				/* Trace function raised an error */
 				goto exit_eval_frame;
 			}
 		}
-		if (tstate->c_profilefunc != NULL) {
+		if (pystate->c_profilefunc != NULL) {
 			/* Similar for c_profilefunc, except it needn't
 			   return itself and isn't called for "line" events */
-			if (call_trace_protected(tstate->c_profilefunc,
-						 tstate->c_profileobj,
+			if (call_trace_protected(pystate->c_profilefunc,
+						 pystate->c_profileobj,
 						 f, PyTrace_CALL, Py_None)) {
 				/* Profile function raised an error */
 				goto exit_eval_frame;
@@ -803,63 +594,12 @@
 		assert(stack_pointer >= f->f_valuestack); /* else underflow */
 		assert(STACK_LEVEL() <= co->co_stacksize);  /* else overflow */
 
-		/* Do periodic things.  Doing this every time through
-		   the loop would add too much overhead, so we do it
-		   only every Nth instruction.  We also do it if
-		   ``things_to_do'' is set, i.e. when an asynchronous
-		   event needs attention (e.g. a signal handler or
-		   async I/O handler); see Py_AddPendingCall() and
-		   Py_MakePendingCalls() above. */
-
-		if (--_Py_Ticker < 0) {
-			if (*next_instr == SETUP_FINALLY) {
-				/* Make the last opcode before
-				   a try: finally: block uninterruptable. */
-				goto fast_next_opcode;
-			}
-			_Py_Ticker = _Py_CheckInterval;
-			tstate->tick_counter++;
-#ifdef WITH_TSC
-			ticked = 1;
-#endif
-			if (things_to_do) {
-				if (Py_MakePendingCalls() < 0) {
-					why = WHY_EXCEPTION;
-					goto on_error;
-				}
-				if (things_to_do)
-					/* MakePendingCalls() didn't succeed.
-					   Force early re-execution of this
-					   "periodic" code, possibly after
-					   a thread switch */
-					_Py_Ticker = 0;
-			}
-#ifdef WITH_THREAD
-			if (interpreter_lock) {
-				/* Give another thread a chance */
-
-				if (PyThreadState_Swap(NULL) != tstate)
-					Py_FatalError("ceval: tstate mix-up");
-				PyThread_release_lock(interpreter_lock);
-
-				/* Other threads may run now */
-
-				PyThread_acquire_lock(interpreter_lock, 1);
-				if (PyThreadState_Swap(tstate) != NULL)
-					Py_FatalError("ceval: orphan tstate");
-
-				/* Check for thread interrupts */
-
-				if (tstate->async_exc != NULL) {
-					x = tstate->async_exc;
-					tstate->async_exc = NULL;
-					PyErr_SetNone(x);
-					Py_DECREF(x);
-					why = WHY_EXCEPTION;
-					goto on_error;
-				}
-			}
-#endif
+		/* Check for asynchronous events, unless we're at the
+		 * last opcode before a try-finally block. */
+		if (*next_instr != SETUP_FINALLY && PyState_Tick()) {
+			assert(PyErr_Occurred());
+			why = WHY_EXCEPTION;
+			goto on_error;
 		}
 
 	fast_next_opcode:
@@ -867,13 +607,13 @@
 
 		/* line-by-line tracing support */
 
-		if (tstate->c_tracefunc != NULL && !tstate->tracing) {
+		if (pystate->c_tracefunc != NULL && !pystate->tracing) {
 			/* see maybe_call_line_trace
 			   for expository comments */
 			f->f_stacktop = stack_pointer;
 
-			err = maybe_call_line_trace(tstate->c_tracefunc,
-						    tstate->c_traceobj,
+			err = maybe_call_line_trace(pystate->c_tracefunc,
+						    pystate->c_traceobj,
 						    f, &instr_lb, &instr_ub,
 						    &instr_prev);
 			/* Reload possibly changed frame fields */
@@ -897,6 +637,7 @@
 			oparg = NEXTARG();
 	  dispatch_opcode:
 #ifdef DYNAMIC_EXECUTION_PROFILE
+#error bleh
 #ifdef DXPAIRS
 		dxpairs[lastopcode][opcode]++;
 		lastopcode = opcode;
@@ -905,6 +646,7 @@
 #endif
 
 #ifdef LLTRACE
+#error bleh lltrace
 		/* Instruction tracing */
 
 		if (lltrace) {
@@ -937,7 +679,7 @@
 		case LOAD_FAST:
 			x = GETLOCAL(oparg);
 			if (x != NULL) {
-				Py_INCREF(x);
+				Py_INCREF_PS(x);
 				PUSH(x);
 				goto fast_next_opcode;
 			}
@@ -948,7 +690,7 @@
 
 		case LOAD_CONST:
 			x = GETITEM(consts, oparg);
-			Py_INCREF(x);
+			Py_INCREF_PS(x);
 			PUSH(x);
 			goto fast_next_opcode;
 
@@ -961,7 +703,7 @@
 		PREDICTED(POP_TOP);
 		case POP_TOP:
 			v = POP();
-			Py_DECREF(v);
+			Py_DECREF_PS(v);
 			goto fast_next_opcode;
 
 		case ROT_TWO:
@@ -993,27 +735,27 @@
 
 		case DUP_TOP:
 			v = TOP();
-			Py_INCREF(v);
+			Py_INCREF_PS(v);
 			PUSH(v);
 			goto fast_next_opcode;
 
 		case DUP_TOPX:
 			if (oparg == 2) {
 				x = TOP();
-				Py_INCREF(x);
+				Py_INCREF_PS(x);
 				w = SECOND();
-				Py_INCREF(w);
+				Py_INCREF_PS(w);
 				STACKADJ(2);
 				SET_TOP(x);
 				SET_SECOND(w);
 				goto fast_next_opcode;
 			} else if (oparg == 3) {
 				x = TOP();
-				Py_INCREF(x);
+				Py_INCREF_PS(x);
 				w = SECOND();
-				Py_INCREF(w);
+				Py_INCREF_PS(w);
 				v = THIRD();
-				Py_INCREF(v);
+				Py_INCREF_PS(v);
 				STACKADJ(3);
 				SET_TOP(x);
 				SET_SECOND(w);
@@ -1027,7 +769,7 @@
 		case UNARY_POSITIVE:
 			v = TOP();
 			x = PyNumber_Positive(v);
-			Py_DECREF(v);
+			Py_DECREF_PS(v);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1035,7 +777,7 @@
 		case UNARY_NEGATIVE:
 			v = TOP();
 			x = PyNumber_Negative(v);
-			Py_DECREF(v);
+			Py_DECREF_PS(v);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1043,14 +785,14 @@
 		case UNARY_NOT:
 			v = TOP();
 			err = PyObject_IsTrue(v);
-			Py_DECREF(v);
+			Py_DECREF_PS(v);
 			if (err == 0) {
-				Py_INCREF(Py_True);
+				Py_INCREF_PS(Py_True);
 				SET_TOP(Py_True);
 				continue;
 			}
 			else if (err > 0) {
-				Py_INCREF(Py_False);
+				Py_INCREF_PS(Py_False);
 				SET_TOP(Py_False);
 				err = 0;
 				continue;
@@ -1061,7 +803,7 @@
 		case UNARY_INVERT:
 			v = TOP();
 			x = PyNumber_Invert(v);
-			Py_DECREF(v);
+			Py_DECREF_PS(v);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1070,8 +812,8 @@
 			w = POP();
 			v = TOP();
 			x = PyNumber_Power(v, w, Py_None);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREF_PS(v);
+			Py_DECREF_PS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1080,8 +822,8 @@
 			w = POP();
 			v = TOP();
 			x = PyNumber_Multiply(v, w);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREF_PS(v);
+			Py_DECREF_PS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1090,8 +832,8 @@
 			w = POP();
 			v = TOP();
 			x = PyNumber_TrueDivide(v, w);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREF_PS(v);
+			Py_DECREF_PS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1100,8 +842,8 @@
 			w = POP();
 			v = TOP();
 			x = PyNumber_FloorDivide(v, w);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREF_PS(v);
+			Py_DECREF_PS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1110,8 +852,8 @@
 			w = POP();
 			v = TOP();
 			x = PyNumber_Remainder(v, w);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREF_PS(v);
+			Py_DECREF_PS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1128,9 +870,9 @@
 			else {
 				x = PyNumber_Add(v, w);
 			}
-			Py_DECREF(v);
+			Py_DECREF_PS(v);
 		  skip_decref_vx:
-			Py_DECREF(w);
+			Py_DECREF_PS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1139,8 +881,8 @@
 			w = POP();
 			v = TOP();
 			x = PyNumber_Subtract(v, w);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREF_PS(v);
+			Py_DECREF_PS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1149,8 +891,8 @@
 			w = POP();
 			v = TOP();
 			x = PyObject_GetItem(v, w);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREF_PS(v);
+			Py_DECREF_PS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1159,8 +901,8 @@
 			w = POP();
 			v = TOP();
 			x = PyNumber_Lshift(v, w);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREF_PS(v);
+			Py_DECREF_PS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1169,8 +911,8 @@
 			w = POP();
 			v = TOP();
 			x = PyNumber_Rshift(v, w);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREF_PS(v);
+			Py_DECREF_PS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1179,8 +921,8 @@
 			w = POP();
 			v = TOP();
 			x = PyNumber_And(v, w);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREF_PS(v);
+			Py_DECREF_PS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1189,8 +931,8 @@
 			w = POP();
 			v = TOP();
 			x = PyNumber_Xor(v, w);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREF_PS(v);
+			Py_DECREF_PS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1199,8 +941,8 @@
 			w = POP();
 			v = TOP();
 			x = PyNumber_Or(v, w);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREF_PS(v);
+			Py_DECREF_PS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1209,8 +951,8 @@
 			w = POP();
 			v = POP();
 			err = PyList_Append(v, w);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREF_PS(v);
+			Py_DECREF_PS(w);
 			if (err == 0) {
 				PREDICT(JUMP_ABSOLUTE);
 				continue;
@@ -1221,8 +963,8 @@
 			w = POP();
 			v = POP();
 			err = PySet_Add(v, w);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREF_PS(v);
+			Py_DECREF_PS(w);
 			if (err == 0) {
 				PREDICT(JUMP_ABSOLUTE);
 				continue;
@@ -1233,8 +975,8 @@
 			w = POP();
 			v = TOP();
 			x = PyNumber_InPlacePower(v, w, Py_None);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREF_PS(v);
+			Py_DECREF_PS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1243,8 +985,8 @@
 			w = POP();
 			v = TOP();
 			x = PyNumber_InPlaceMultiply(v, w);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREF_PS(v);
+			Py_DECREF_PS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1253,8 +995,8 @@
 			w = POP();
 			v = TOP();
 			x = PyNumber_InPlaceTrueDivide(v, w);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREF_PS(v);
+			Py_DECREF_PS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1263,8 +1005,8 @@
 			w = POP();
 			v = TOP();
 			x = PyNumber_InPlaceFloorDivide(v, w);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREF_PS(v);
+			Py_DECREF_PS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1273,8 +1015,8 @@
 			w = POP();
 			v = TOP();
 			x = PyNumber_InPlaceRemainder(v, w);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREF_PS(v);
+			Py_DECREF_PS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1291,9 +1033,9 @@
 			else {
 				x = PyNumber_InPlaceAdd(v, w);
 			}
-			Py_DECREF(v);
+			Py_DECREF_PS(v);
 		  skip_decref_v:
-			Py_DECREF(w);
+			Py_DECREF_PS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1302,8 +1044,8 @@
 			w = POP();
 			v = TOP();
 			x = PyNumber_InPlaceSubtract(v, w);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREF_PS(v);
+			Py_DECREF_PS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1312,8 +1054,8 @@
 			w = POP();
 			v = TOP();
 			x = PyNumber_InPlaceLshift(v, w);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREF_PS(v);
+			Py_DECREF_PS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1322,8 +1064,8 @@
 			w = POP();
 			v = TOP();
 			x = PyNumber_InPlaceRshift(v, w);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREF_PS(v);
+			Py_DECREF_PS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1332,8 +1074,8 @@
 			w = POP();
 			v = TOP();
 			x = PyNumber_InPlaceAnd(v, w);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREF_PS(v);
+			Py_DECREF_PS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1342,8 +1084,8 @@
 			w = POP();
 			v = TOP();
 			x = PyNumber_InPlaceXor(v, w);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREF_PS(v);
+			Py_DECREF_PS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1352,8 +1094,8 @@
 			w = POP();
 			v = TOP();
 			x = PyNumber_InPlaceOr(v, w);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREF_PS(v);
+			Py_DECREF_PS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1365,9 +1107,9 @@
 			STACKADJ(-3);
 			/* v[w] = u */
 			err = PyObject_SetItem(v, w, u);
-			Py_DECREF(u);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREF_PS(u);
+			Py_DECREF_PS(v);
+			Py_DECREF_PS(w);
 			if (err == 0) continue;
 			break;
 
@@ -1377,8 +1119,8 @@
 			STACKADJ(-2);
 			/* del v[w] */
 			err = PyObject_DelItem(v, w);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREF_PS(v);
+			Py_DECREF_PS(w);
 			if (err == 0) continue;
 			break;
 
@@ -1398,12 +1140,12 @@
 			}
 			if (err == 0) {
 				w = PyEval_CallObject(w, x);
-				Py_XDECREF(w);
+				Py_XDECREF_PS(w);
 				if (w == NULL)
 					err = -1;
 			}
-			Py_DECREF(v);
-			Py_XDECREF(x);
+			Py_DECREF_PS(v);
+			Py_XDECREF_PS(x);
 			break;
 
 #ifdef CASE_TOO_BIG
@@ -1430,7 +1172,7 @@
 		case STORE_LOCALS:
 			x = POP();
 			v = f->f_locals;
-			Py_XDECREF(v);
+			Py_XDECREF_PS(v);
 			f->f_locals = x;
 			continue;
 
@@ -1450,7 +1192,7 @@
 				PyTryBlock *b = PyFrame_BlockPop(f);
 				while (STACK_LEVEL() > b->b_level) {
 					v = POP();
-					Py_DECREF(v);
+					Py_DECREF_PS(v);
 				}
 			}
 			continue;
@@ -1477,18 +1219,19 @@
 					"'finally' pops bad exception");
 				why = WHY_EXCEPTION;
 			}
-			Py_DECREF(v);
+			Py_DECREF_PS(v);
 			break;
 
 		case LOAD_BUILD_CLASS:
-			x = PyDict_GetItemString(f->f_builtins,
-						 "__build_class__");
+			if (PyDict_GetItemStringEx(f->f_builtins,
+					"__build_class__", &x) < 0)
+				break;
 			if (x == NULL) {
 				PyErr_SetString(PyExc_ImportError,
 						"__build_class__ not found");
 				break;
 			}
-			Py_INCREF(x);
+			/*Py_INCREF_PS(x);*/
 			PUSH(x);
 			break;
 
@@ -1500,7 +1243,7 @@
 					err = PyDict_SetItem(x, w, v);
 				else
 					err = PyObject_SetItem(x, w, v);
-				Py_DECREF(v);
+				Py_DECREF_PS(v);
 				if (err == 0) continue;
 				break;
 			}
@@ -1530,10 +1273,10 @@
 					((PyTupleObject *)v)->ob_item;
 				while (oparg--) {
 					w = items[oparg];
-					Py_INCREF(w);
+					Py_INCREF_PS(w);
 					PUSH(w);
 				}
-				Py_DECREF(v);
+				Py_DECREF_PS(v);
 				continue;
 			} else if (PyList_CheckExact(v) &&
 				   PyList_GET_SIZE(v) == oparg) {
@@ -1541,7 +1284,7 @@
 					((PyListObject *)v)->ob_item;
 				while (oparg--) {
 					w = items[oparg];
-					Py_INCREF(w);
+					Py_INCREF_PS(w);
 					PUSH(w);
 				}
 			} else if (unpack_iterable(v, oparg, -1,
@@ -1551,7 +1294,7 @@
 				/* unpack_iterable() raised an exception */
 				why = WHY_EXCEPTION;
 			}
-			Py_DECREF(v);
+			Py_DECREF_PS(v);
 			break;
 
 		case UNPACK_EX:
@@ -1565,7 +1308,7 @@
 			} else {
 				why = WHY_EXCEPTION;
 			}
-			Py_DECREF(v);
+			Py_DECREF_PS(v);
 			break;
 		}
 
@@ -1575,8 +1318,8 @@
 			u = SECOND();
 			STACKADJ(-2);
 			err = PyObject_SetAttr(v, w, u); /* v.w = u */
-			Py_DECREF(v);
-			Py_DECREF(u);
+			Py_DECREF_PS(v);
+			Py_DECREF_PS(u);
 			if (err == 0) continue;
 			break;
 
@@ -1585,14 +1328,14 @@
 			v = POP();
 			err = PyObject_SetAttr(v, w, (PyObject *)NULL);
 							/* del v.w */
-			Py_DECREF(v);
+			Py_DECREF_PS(v);
 			break;
 
 		case STORE_GLOBAL:
 			w = GETITEM(names, oparg);
 			v = POP();
 			err = PyDict_SetItem(f->f_globals, w, v);
-			Py_DECREF(v);
+			Py_DECREF_PS(v);
 			if (err == 0) continue;
 			break;
 
@@ -1612,9 +1355,8 @@
 			}
 			if (PyDict_CheckExact(v)) {
 				x = PyDict_GetItem(v, w);
-				Py_XINCREF(x);
-			}
-			else {
+				Py_XINCREF_PS(x);
+			} else {
 				x = PyObject_GetItem(v, w);
 				if (x == NULL && PyErr_Occurred()) {
 					if (!PyErr_ExceptionMatches(
@@ -1624,9 +1366,11 @@
 				}
 			}
 			if (x == NULL) {
-				x = PyDict_GetItem(f->f_globals, w);
+				if (PyDict_GetItemEx(f->f_globals, w, &x) < 0)
+					break;
 				if (x == NULL) {
-					x = PyDict_GetItem(f->f_builtins, w);
+					if (PyDict_GetItemEx(f->f_builtins, w, &x) < 0)
+						break;
 					if (x == NULL) {
 						format_exc_check_arg(
 							    PyExc_NameError,
@@ -1634,7 +1378,6 @@
 						break;
 					}
 				}
-				Py_INCREF(x);
 			}
 			PUSH(x);
 			continue;
@@ -1649,37 +1392,52 @@
 				if (hash != -1) {
 					PyDictObject *d;
 					PyDictEntry *e;
+					PyDict_LockState lockstate;
+
 					d = (PyDictObject *)(f->f_globals);
-					e = d->ma_lookup(d, w, hash);
+					_pydictlock_initstate_read(&lockstate);
+					_pydictlock_acquire(d, &lockstate);
+					e = d->ma_lookup(d, w, hash, &lockstate);
 					if (e == NULL) {
+						_pydictlock_release(d, &lockstate);
 						x = NULL;
 						break;
 					}
 					x = e->me_value;
 					if (x != NULL) {
-						Py_INCREF(x);
+						Py_INCREF_PS(x);
+						_pydictlock_release(d, &lockstate);
 						PUSH(x);
 						continue;
 					}
+					_pydictlock_release(d, &lockstate);
+
 					d = (PyDictObject *)(f->f_builtins);
-					e = d->ma_lookup(d, w, hash);
+					_pydictlock_initstate_read(&lockstate);
+					_pydictlock_acquire(d, &lockstate);
+					e = d->ma_lookup(d, w, hash, &lockstate);
 					if (e == NULL) {
+						_pydictlock_release(d, &lockstate);
 						x = NULL;
 						break;
 					}
 					x = e->me_value;
 					if (x != NULL) {
-						Py_INCREF(x);
+						Py_INCREF_PS(x);
+						_pydictlock_release(d, &lockstate);
 						PUSH(x);
 						continue;
 					}
+					_pydictlock_release(d, &lockstate);
 					goto load_global_error;
 				}
 			}
 			/* This is the un-inlined version of the code above */
-			x = PyDict_GetItem(f->f_globals, w);
+			if (PyDict_GetItemEx(f->f_builtins, w, &x) < 0)
+				break;
 			if (x == NULL) {
-				x = PyDict_GetItem(f->f_builtins, w);
+				if (PyDict_GetItemEx(f->f_builtins, w, &x) < 0)
+					break;
 				if (x == NULL) {
 				  load_global_error:
 					format_exc_check_arg(
@@ -1688,7 +1446,6 @@
 					break;
 				}
 			}
-			Py_INCREF(x);
 			PUSH(x);
 			continue;
 
@@ -1707,7 +1464,7 @@
 
 		case LOAD_CLOSURE:
 			x = freevars[oparg];
-			Py_INCREF(x);
+			Py_INCREF_PS(x);
 			PUSH(x);
 			if (x != NULL) continue;
 			break;
@@ -1742,7 +1499,7 @@
 			w = POP();
 			x = freevars[oparg];
 			PyCell_Set(x, w);
-			Py_DECREF(w);
+			Py_DECREF_PS(w);
 			continue;
 
 		case BUILD_TUPLE:
@@ -1776,10 +1533,10 @@
 					w = POP();
 					if (err == 0)
 						err = PySet_Add(x, w);
-					Py_DECREF(w);
+					Py_DECREF_PS(w);
 				}
 				if (err != 0) {
-					Py_DECREF(x);
+					Py_DECREF_PS(x);
 					break;
 				}
 				PUSH(x);
@@ -1800,8 +1557,8 @@
 			STACKADJ(-2);
 			assert (PyDict_CheckExact(v));
 			err = PyDict_SetItem(v, w, u);  /* v[w] = u */
-			Py_DECREF(u);
-			Py_DECREF(w);
+			Py_DECREF_PS(u);
+			Py_DECREF_PS(w);
 			if (err == 0) continue;
 			break;
 
@@ -1809,7 +1566,7 @@
 			w = GETITEM(names, oparg);
 			v = TOP();
 			x = PyObject_GetAttr(v, w);
-			Py_DECREF(v);
+			Py_DECREF_PS(v);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1818,8 +1575,8 @@
 			w = POP();
 			v = TOP();
 			x = cmp_outcome(oparg, v, w);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREF_PS(v);
+			Py_DECREF_PS(w);
 			SET_TOP(x);
 			if (x == NULL) break;
 			PREDICT(JUMP_IF_FALSE);
@@ -1828,13 +1585,15 @@
 
 		case IMPORT_NAME:
 			w = GETITEM(names, oparg);
-			x = PyDict_GetItemString(f->f_builtins, "__import__");
+			if (PyDict_GetItemStringEx(f->f_builtins,
+					"__import__", &x) < 0)
+				break;
 			if (x == NULL) {
 				PyErr_SetString(PyExc_ImportError,
 						"__import__ not found");
 				break;
 			}
-			Py_INCREF(x);
+			Py_INCREF_PS(x);
 			v = POP();
 			u = TOP();
 			if (PyLong_AsLong(u) != -1 || PyErr_Occurred())
@@ -1852,20 +1611,19 @@
 					    f->f_locals == NULL ?
 						  Py_None : f->f_locals,
 					    v);
-			Py_DECREF(v);
-			Py_DECREF(u);
+			Py_DECREF_PS(v);
+			Py_DECREF_PS(u);
 			if (w == NULL) {
 				u = POP();
-				Py_DECREF(x);
-				x = NULL;
+				Py_CLEAR_PS(x);
 				break;
 			}
 			READ_TIMESTAMP(intr0);
 			v = x;
 			x = PyEval_CallObject(v, w);
-			Py_DECREF(v);
+			Py_DECREF_PS(v);
 			READ_TIMESTAMP(intr1);
-			Py_DECREF(w);
+			Py_DECREF_PS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1882,7 +1640,7 @@
 			err = import_all_from(x, v);
 			READ_TIMESTAMP(intr1);
 			PyFrame_LocalsToFast(f, 0);
-			Py_DECREF(v);
+			Py_DECREF_PS(v);
 			if (err == 0) continue;
 			break;
 
@@ -1962,7 +1720,7 @@
 			/* before: [obj]; after [getiter(obj)] */
 			v = TOP();
 			x = PyObject_GetIter(v);
-			Py_DECREF(v);
+			Py_DECREF_PS(v);
 			if (x != NULL) {
 				SET_TOP(x);
 				PREDICT(FOR_ITER);
@@ -1975,6 +1733,10 @@
 		case FOR_ITER:
 			/* before: [iter]; after: [iter, iter()] *or* [] */
 			v = TOP();
+			extern PyTypeObject PyFakeRange_Type;
+			if (v->ob_type == &PyFakeRange_Type) {
+				//printf("Moo %p %s %p %p %p %p\n", v, v->ob_type->tp_name, stack_pointer, next_instr, freevars, fastlocals);
+			}
 			x = (*v->ob_type->tp_iternext)(v);
 			if (x != NULL) {
 				PUSH(x);
@@ -1990,7 +1752,7 @@
 			}
 			/* iterator ended normally */
  			x = v = POP();
-			Py_DECREF(v);
+			Py_DECREF_PS(v);
 			JUMPBY(oparg);
 			continue;
 
@@ -2085,11 +1847,11 @@
 			if (u != Py_None && PyObject_IsTrue(x)) {
 				/* There was an exception and a true return */
 				STACKADJ(-2);
-				Py_INCREF(Py_None);
+				Py_INCREF_PS(Py_None);
 				SET_TOP(Py_None);
-				Py_DECREF(u);
-				Py_DECREF(v);
-				Py_DECREF(w);
+				Py_DECREF_PS(u);
+				Py_DECREF_PS(v);
+				Py_DECREF_PS(w);
 			} else {
 				/* The stack was rearranged to remove EXIT
 				   above. Let END_FINALLY do its thing */
@@ -2106,9 +1868,9 @@
 			PCALL(PCALL_ALL);
 			sp = stack_pointer;
 #ifdef WITH_TSC
-			x = call_function(&sp, oparg, &intr0, &intr1);
+			x = call_function(pystate, &sp, oparg, &intr0, &intr1);
 #else
-			x = call_function(&sp, oparg);
+			x = call_function(pystate, &sp, oparg);
 #endif
 			stack_pointer = sp;
 			PUSH(x);
@@ -2137,25 +1899,25 @@
 		    if (PyMethod_Check(func)
 			&& PyMethod_GET_SELF(func) != NULL) {
 			    PyObject *self = PyMethod_GET_SELF(func);
-			    Py_INCREF(self);
+			    Py_INCREF_PS(self);
 			    func = PyMethod_GET_FUNCTION(func);
-			    Py_INCREF(func);
-			    Py_DECREF(*pfunc);
+			    Py_INCREF_PS(func);
+			    Py_DECREF_PS(*pfunc);
 			    *pfunc = self;
 			    na++;
 			    n++;
 		    } else
-			    Py_INCREF(func);
+			    Py_INCREF_PS(func);
 		    sp = stack_pointer;
 		    READ_TIMESTAMP(intr0);
 		    x = ext_do_call(func, &sp, flags, na, nk);
 		    READ_TIMESTAMP(intr1);
 		    stack_pointer = sp;
-		    Py_DECREF(func);
+		    Py_DECREF_PS(func);
 
 		    while (stack_pointer > pfunc) {
 			    w = POP();
-			    Py_DECREF(w);
+			    Py_DECREF_PS(w);
 		    }
 		    PUSH(x);
 		    if (x != NULL)
@@ -2172,12 +1934,12 @@
 
 			v = POP(); /* code object */
 			x = PyFunction_New(v, f->f_globals);
-			Py_DECREF(v);
+			Py_DECREF_PS(v);
 			
 			if (x != NULL && opcode == MAKE_CLOSURE) {
 				v = POP();
 				err = PyFunction_SetClosure(x, v);
-				Py_DECREF(v);
+				Py_DECREF_PS(v);
 			}
 
 			if (x != NULL && num_annotations > 0) {
@@ -2185,7 +1947,7 @@
 				u = POP(); /* names of args with annotations */
 				v = PyDict_New();
 				if (v == NULL) {
-					Py_DECREF(x);
+					Py_DECREF_PS(x);
 					x = NULL;
 					break;
 				}
@@ -2197,19 +1959,19 @@
 					w = POP();
 					/* XXX(nnorwitz): check for errors */
 					PyDict_SetItem(v, t, w);
-					Py_DECREF(w);
+					Py_DECREF_PS(w);
 				}
 
 				err = PyFunction_SetAnnotations(x, v);
-				Py_DECREF(v);
-				Py_DECREF(u);
+				Py_DECREF_PS(v);
+				Py_DECREF_PS(u);
 			}
 
 			/* XXX Maybe this should be a separate opcode? */
 			if (x != NULL && posdefaults > 0) {
 				v = PyTuple_New(posdefaults);
 				if (v == NULL) {
-					Py_DECREF(x);
+					Py_DECREF_PS(x);
 					x = NULL;
 					break;
 				}
@@ -2218,12 +1980,12 @@
 					PyTuple_SET_ITEM(v, posdefaults, w);
 				}
 				err = PyFunction_SetDefaults(x, v);
-				Py_DECREF(v);
+				Py_DECREF_PS(v);
 			}
 			if (x != NULL && kwdefaults > 0) {
 				v = PyDict_New();
 				if (v == NULL) {
-					Py_DECREF(x);
+					Py_DECREF_PS(x);
 					x = NULL;
 					break;
 				}
@@ -2232,11 +1994,11 @@
 					u = POP(); /* kw only arg name */
 					/* XXX(nnorwitz): check for errors */
 					PyDict_SetItem(v, u, w);
-					Py_DECREF(w);
-					Py_DECREF(u);
+					Py_DECREF_PS(w);
+					Py_DECREF_PS(u);
 				}
 				err = PyFunction_SetKwDefaults(x, v);
-				Py_DECREF(v);
+				Py_DECREF_PS(v);
 			}
 			PUSH(x);
 			break;
@@ -2250,9 +2012,9 @@
 			v = POP();
 			u = TOP();
 			x = PySlice_New(u, v, w);
-			Py_DECREF(u);
-			Py_DECREF(v);
-			Py_XDECREF(w);
+			Py_DECREF_PS(u);
+			Py_DECREF_PS(v);
+			Py_XDECREF_PS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -2329,9 +2091,9 @@
 		if (why == WHY_EXCEPTION) {
 			PyTraceBack_Here(f);
 
-			if (tstate->c_tracefunc != NULL)
-				call_exc_trace(tstate->c_tracefunc,
-					       tstate->c_traceobj, f);
+			if (pystate->c_tracefunc != NULL)
+				call_exc_trace(pystate->c_tracefunc,
+					       pystate->c_traceobj, f);
 		}
 
 		/* For the rest, treat WHY_RERAISE as WHY_EXCEPTION */
@@ -2353,13 +2115,13 @@
 						   b->b_level);
 				why = WHY_NOT;
 				JUMPTO(PyLong_AS_LONG(retval));
-				Py_DECREF(retval);
+				Py_DECREF_PS(retval);
 				break;
 			}
 
 			while (STACK_LEVEL() > b->b_level) {
 				v = POP();
-				Py_XDECREF(v);
+				Py_XDECREF_PS(v);
 			}
 			if (b->b_type == SETUP_LOOP && why == WHY_BREAK) {
 				why = WHY_NOT;
@@ -2374,7 +2136,7 @@
 					PyErr_Fetch(&exc, &val, &tb);
 					if (val == NULL) {
 						val = Py_None;
-						Py_INCREF(val);
+						Py_INCREF_PS(val);
 					}
 					/* Make the raw exception data
 					   available to the handler,
@@ -2384,11 +2146,11 @@
 					if (b->b_type == SETUP_EXCEPT) {
 						PyErr_NormalizeException(
 							&exc, &val, &tb);
-						set_exc_info(tstate,
+						set_exc_info(pystate,
 							     exc, val, tb);
 					}
 					if (tb == NULL) {
-						Py_INCREF(Py_None);
+						Py_INCREF_PS(Py_None);
 						PUSH(Py_None);
 					} else
 						PUSH(tb);
@@ -2419,56 +2181,57 @@
 	/* Pop remaining stack entries. */
 	while (!EMPTY()) {
 		v = POP();
-		Py_XDECREF(v);
+		Py_XDECREF_PS(v);
 	}
 
 	if (why != WHY_RETURN)
 		retval = NULL;
 
 fast_yield:
-	if (tstate->use_tracing) {
-		if (tstate->c_tracefunc) {
+	if (pystate->use_tracing) {
+		if (pystate->c_tracefunc) {
 			if (why == WHY_RETURN || why == WHY_YIELD) {
-				if (call_trace(tstate->c_tracefunc,
-					       tstate->c_traceobj, f,
+				if (call_trace(pystate->c_tracefunc,
+					       pystate->c_traceobj, f,
 					       PyTrace_RETURN, retval)) {
-					Py_XDECREF(retval);
+					Py_XDECREF_PS(retval);
 					retval = NULL;
 					why = WHY_EXCEPTION;
 				}
 			}
 			else if (why == WHY_EXCEPTION) {
-				call_trace_protected(tstate->c_tracefunc,
-						     tstate->c_traceobj, f,
+				call_trace_protected(pystate->c_tracefunc,
+						     pystate->c_traceobj, f,
 						     PyTrace_RETURN, NULL);
 			}
 		}
-		if (tstate->c_profilefunc) {
+		if (pystate->c_profilefunc) {
 			if (why == WHY_EXCEPTION)
-				call_trace_protected(tstate->c_profilefunc,
-						     tstate->c_profileobj, f,
+				call_trace_protected(pystate->c_profilefunc,
+						     pystate->c_profileobj, f,
 						     PyTrace_RETURN, NULL);
-			else if (call_trace(tstate->c_profilefunc,
-					    tstate->c_profileobj, f,
+			else if (call_trace(pystate->c_profilefunc,
+					    pystate->c_profileobj, f,
 					    PyTrace_RETURN, retval)) {
-				Py_XDECREF(retval);
+				Py_XDECREF_PS(retval);
 				retval = NULL;
 				why = WHY_EXCEPTION;
 			}
 		}
 	}
 
-	if (tstate->frame->f_exc_type != NULL)
-		reset_exc_info(tstate);
+	if (pystate->frame->f_exc_type != NULL)
+		reset_exc_info(pystate);
 	else {
-		assert(tstate->frame->f_exc_value == NULL);
-		assert(tstate->frame->f_exc_traceback == NULL);
+		assert(pystate->frame->f_exc_value == NULL);
+		assert(pystate->frame->f_exc_traceback == NULL);
 	}
 
 	/* pop frame */
 exit_eval_frame:
 	Py_LeaveRecursiveCall();
-	tstate->frame = f->f_back;
+	//printf("%p's old %p replaced with f->f_back %p\n", pystate, pystate->frame, f->f_back);
+	pystate->frame = f->f_back;
 
 	return retval;
 }
@@ -2485,7 +2248,7 @@
 	register PyFrameObject *f;
 	register PyObject *retval = NULL;
 	register PyObject **fastlocals, **freevars;
-	PyThreadState *tstate = PyThreadState_GET();
+	PyState *pystate = PyState_Get();
 	PyObject *x, *u;
 
 	if (globals == NULL) {
@@ -2494,9 +2257,9 @@
 		return NULL;
 	}
 
-	assert(tstate != NULL);
+	assert(pystate != NULL);
 	assert(globals != NULL);
-	f = PyFrame_New(tstate, co, globals, locals);
+	f = PyFrame_New(pystate, co, globals, locals);
 	if (f == NULL)
 		return NULL;
 
@@ -2535,7 +2298,7 @@
 		}
 		for (i = 0; i < n; i++) {
 			x = args[i];
-			Py_INCREF(x);
+			Py_INCREF_PS(x);
 			SETLOCAL(i, x);
 		}
 		if (co->co_flags & CO_VARARGS) {
@@ -2545,7 +2308,7 @@
 			SETLOCAL(co->co_argcount + co->co_kwonlyargcount, u);
 			for (i = n; i < argcount; i++) {
 				x = args[i];
-				Py_INCREF(x);
+				Py_INCREF_PS(x);
 				PyTuple_SET_ITEM(u, i-n, x);
 			}
 		}
@@ -2596,7 +2359,7 @@
 					     keyword);
 					goto fail;
 				}
-				Py_INCREF(value);
+				Py_INCREF_PS(value);
 				SETLOCAL(j, value);
 			}
 		}
@@ -2612,7 +2375,7 @@
 				if (kwdefs != NULL)
 					def = PyDict_GetItem(kwdefs, name);
 				if (def != NULL) {
-					Py_INCREF(def);
+					Py_INCREF_PS(def);
 					SETLOCAL(i, def);
 					continue;
 				}
@@ -2646,7 +2409,7 @@
 			for (; i < defcount; i++) {
 				if (GETLOCAL(m+i) == NULL) {
 					PyObject *def = defs[i];
-					Py_INCREF(def);
+					Py_INCREF_PS(def);
 					SETLOCAL(m+i, def);
 				}
 			}
@@ -2709,7 +2472,7 @@
 		int i;
 		for (i = 0; i < PyTuple_GET_SIZE(co->co_freevars); ++i) {
 			PyObject *o = PyTuple_GET_ITEM(closure, i);
-			Py_INCREF(o);
+			Py_INCREF_PS(o);
 			freevars[PyTuple_GET_SIZE(co->co_cellvars) + i] = o;
 		}
 	}
@@ -2717,7 +2480,7 @@
 	if (co->co_flags & CO_GENERATOR) {
 		/* Don't need to keep the reference to f_back, it will be set
 		 * when the generator is resumed. */
-		Py_XDECREF(f->f_back);
+		Py_XDECREF_PS(f->f_back);
 		f->f_back = NULL;
 
 		PCALL(PCALL_GENERATOR);
@@ -2736,10 +2499,10 @@
 	   current Python frame (f), the associated C stack is still in use,
 	   so recursion_depth must be boosted for the duration.
 	*/
-	assert(tstate != NULL);
-	++tstate->recursion_depth;
-	Py_DECREF(f);
-	--tstate->recursion_depth;
+	assert(pystate != NULL);
+	++pystate->recursion_depth;
+	Py_DECREF_PS(f);
+	--pystate->recursion_depth;
 	return retval;
 }
 
@@ -2749,13 +2512,13 @@
 - Below, 'exc_ZZZ' stands for 'exc_type', 'exc_value' and
   'exc_traceback'.  These always travel together.
 
-- tstate->curexc_ZZZ is the "hot" exception that is set by
+- pystate->curexc_ZZZ is the "hot" exception that is set by
   PyErr_SetString(), cleared by PyErr_Clear(), and so on.
 
 - Once an exception is caught by an except clause, it is transferred
-  from tstate->curexc_ZZZ to tstate->exc_ZZZ, from which sys.exc_info()
+  from pystate->curexc_ZZZ to pystate->exc_ZZZ, from which sys.exc_info()
   can pick it up.  This is the primary task of set_exc_info().
-  XXX That can't be right:  set_exc_info() doesn't look at tstate->curexc_ZZZ.
+  XXX That can't be right:  set_exc_info() doesn't look at pystate->curexc_ZZZ.
 
 - Now let me explain the complicated dance with frame->f_exc_ZZZ.
 
@@ -2791,26 +2554,26 @@
   (Example: traceback.print_exc()).
 
   At the same time I fixed the problem that sys.exc_ZZZ weren't
-  thread-safe, by introducing sys.exc_info() which gets it from tstate;
+  thread-safe, by introducing sys.exc_info() which gets it from pystate;
   but that's really a separate improvement.
 
-  The reset_exc_info() function in ceval.c restores the tstate->exc_ZZZ
+  The reset_exc_info() function in ceval.c restores the pystate->exc_ZZZ
   variables to what they were before the current frame was called.  The
   set_exc_info() function saves them on the frame so that
   reset_exc_info() can restore them.  The invariant is that
   frame->f_exc_ZZZ is NULL iff the current frame never caught an
   exception (where "catching" an exception applies only to successful
   except clauses); and if the current frame ever caught an exception,
-  frame->f_exc_ZZZ is the exception that was stored in tstate->exc_ZZZ
+  frame->f_exc_ZZZ is the exception that was stored in pystate->exc_ZZZ
   at the start of the current frame.
 
 */
 
 static void
-set_exc_info(PyThreadState *tstate,
+set_exc_info(PyState *pystate,
 	     PyObject *type, PyObject *value, PyObject *tb)
 {
-	PyFrameObject *frame = tstate->frame;
+	PyFrameObject *frame = pystate->frame;
 	PyObject *tmp_type, *tmp_value, *tmp_tb;
 
 	assert(type != NULL);
@@ -2820,36 +2583,36 @@
 		assert(frame->f_exc_traceback == NULL);
 		/* This frame didn't catch an exception before. */
 		/* Save previous exception of this thread in this frame. */
-		if (tstate->exc_type == NULL) {
+		if (pystate->exc_type == NULL) {
 			/* XXX Why is this set to Py_None? */
-			Py_INCREF(Py_None);
-			tstate->exc_type = Py_None;
+			Py_INCREF_PS(Py_None);
+			pystate->exc_type = Py_None;
 		}
-		Py_INCREF(tstate->exc_type);
-		Py_XINCREF(tstate->exc_value);
-		Py_XINCREF(tstate->exc_traceback);
-		frame->f_exc_type = tstate->exc_type;
-		frame->f_exc_value = tstate->exc_value;
-		frame->f_exc_traceback = tstate->exc_traceback;
+		Py_INCREF_PS(pystate->exc_type);
+		Py_XINCREF_PS(pystate->exc_value);
+		Py_XINCREF_PS(pystate->exc_traceback);
+		frame->f_exc_type = pystate->exc_type;
+		frame->f_exc_value = pystate->exc_value;
+		frame->f_exc_traceback = pystate->exc_traceback;
 	}
 	/* Set new exception for this thread. */
-	tmp_type = tstate->exc_type;
-	tmp_value = tstate->exc_value;
-	tmp_tb = tstate->exc_traceback;
-	Py_INCREF(type);
-	Py_XINCREF(value);
-	Py_XINCREF(tb);
-	tstate->exc_type = type;
-	tstate->exc_value = value;
-	tstate->exc_traceback = tb;
+	tmp_type = pystate->exc_type;
+	tmp_value = pystate->exc_value;
+	tmp_tb = pystate->exc_traceback;
+	Py_INCREF_PS(type);
+	Py_XINCREF_PS(value);
+	Py_XINCREF_PS(tb);
+	pystate->exc_type = type;
+	pystate->exc_value = value;
+	pystate->exc_traceback = tb;
 	PyException_SetTraceback(value, tb);
-	Py_XDECREF(tmp_type);
-	Py_XDECREF(tmp_value);
-	Py_XDECREF(tmp_tb);
+	Py_XDECREF_PS(tmp_type);
+	Py_XDECREF_PS(tmp_value);
+	Py_XDECREF_PS(tmp_tb);
 }
 
 static void
-reset_exc_info(PyThreadState *tstate)
+reset_exc_info(PyState *pystate)
 {
 	PyFrameObject *frame;
 	PyObject *tmp_type, *tmp_value, *tmp_tb;
@@ -2857,24 +2620,24 @@
 	/* It's a precondition that the thread state's frame caught an
 	 * exception -- verify in a debug build.
 	 */
-	assert(tstate != NULL);
-	frame = tstate->frame;
+	assert(pystate != NULL);
+	frame = pystate->frame;
 	assert(frame != NULL);
 	assert(frame->f_exc_type != NULL);
 
 	/* Copy the frame's exception info back to the thread state. */
-	tmp_type = tstate->exc_type;
-	tmp_value = tstate->exc_value;
-	tmp_tb = tstate->exc_traceback;
-	Py_INCREF(frame->f_exc_type);
-	Py_XINCREF(frame->f_exc_value);
-	Py_XINCREF(frame->f_exc_traceback);
-	tstate->exc_type = frame->f_exc_type;
-	tstate->exc_value = frame->f_exc_value;
-	tstate->exc_traceback = frame->f_exc_traceback;
-	Py_XDECREF(tmp_type);
-	Py_XDECREF(tmp_value);
-	Py_XDECREF(tmp_tb);
+	tmp_type = pystate->exc_type;
+	tmp_value = pystate->exc_value;
+	tmp_tb = pystate->exc_traceback;
+	Py_INCREF_PS(frame->f_exc_type);
+	Py_XINCREF_PS(frame->f_exc_value);
+	Py_XINCREF_PS(frame->f_exc_traceback);
+	pystate->exc_type = frame->f_exc_type;
+	pystate->exc_value = frame->f_exc_value;
+	pystate->exc_traceback = frame->f_exc_traceback;
+	Py_XDECREF_PS(tmp_type);
+	Py_XDECREF_PS(tmp_value);
+	Py_XDECREF_PS(tmp_tb);
 
 	/* Clear the frame's exception info. */
 	tmp_type = frame->f_exc_type;
@@ -2883,9 +2646,9 @@
 	frame->f_exc_type = NULL;
 	frame->f_exc_value = NULL;
 	frame->f_exc_traceback = NULL;
-	Py_DECREF(tmp_type);
-	Py_XDECREF(tmp_value);
-	Py_XDECREF(tmp_tb);
+	Py_DECREF_PS(tmp_type);
+	Py_XDECREF_PS(tmp_value);
+	Py_XDECREF_PS(tmp_tb);
 }
 
 /* Logic for the raise statement (too complicated for inlining).
@@ -2897,10 +2660,10 @@
 
 	if (exc == NULL) {
 		/* Reraise */
-		PyThreadState *tstate = PyThreadState_GET();
-		type = tstate->exc_type;
-		value = tstate->exc_value;
-		tb = tstate->exc_traceback;
+		PyState *pystate = PyState_Get();
+		type = pystate->exc_type;
+		value = pystate->exc_value;
+		tb = pystate->exc_traceback;
 		if (type == Py_None) {
 			PyErr_SetString(PyExc_RuntimeError,
 					"No active exception to reraise");
@@ -2941,16 +2704,26 @@
 	tb = PyException_GetTraceback(value);
 	if (cause) {
 		PyObject *fixed_cause;
+		int i;
 		if (PyExceptionClass_Check(cause)) {
 			fixed_cause = PyObject_CallObject(cause, NULL);
 			if (fixed_cause == NULL)
 				goto raise_error;
 			Py_DECREF(cause);
-		}
-		else if (PyExceptionInstance_Check(cause)) {
-			fixed_cause = cause;
-		}
-		else {
+		} else if (PyExceptionInstance_Check(cause)) {
+			fixed_cause = cause;
+		} else if (PyTuple_Check(cause)) {
+			for (i = 0; i < PyTuple_GET_SIZE(cause); i++) {
+				PyObject *ob = PyTuple_GET_ITEM(cause, i);
+				if (!PyExceptionInstance_Check(ob)) {
+					PyErr_SetString(PyExc_TypeError,
+						"exception causes must "
+						"derive from BaseException");
+					goto raise_error;
+				}
+			}
+			fixed_cause = cause;
+		} else {
 			PyErr_SetString(PyExc_TypeError,
 					"exception causes must derive from "
 					"BaseException");
@@ -3113,16 +2886,16 @@
 call_trace(Py_tracefunc func, PyObject *obj, PyFrameObject *frame,
 	   int what, PyObject *arg)
 {
-	register PyThreadState *tstate = frame->f_tstate;
+	register PyState *pystate = frame->f_pystate;
 	int result;
-	if (tstate->tracing)
+	if (pystate->tracing)
 		return 0;
-	tstate->tracing++;
-	tstate->use_tracing = 0;
+	pystate->tracing++;
+	pystate->use_tracing = 0;
 	result = func(obj, frame, what, arg);
-	tstate->use_tracing = ((tstate->c_tracefunc != NULL)
-			       || (tstate->c_profilefunc != NULL));
-	tstate->tracing--;
+	pystate->use_tracing = ((pystate->c_tracefunc != NULL)
+			       || (pystate->c_profilefunc != NULL));
+	pystate->tracing--;
 	return result;
 }
 
@@ -3130,17 +2903,17 @@
 _PyEval_CallTracing(PyObject *func, PyObject *args)
 {
 	PyFrameObject *frame = PyEval_GetFrame();
-	PyThreadState *tstate = frame->f_tstate;
-	int save_tracing = tstate->tracing;
-	int save_use_tracing = tstate->use_tracing;
+	PyState *pystate = frame->f_pystate;
+	int save_tracing = pystate->tracing;
+	int save_use_tracing = pystate->use_tracing;
 	PyObject *result;
 
-	tstate->tracing = 0;
-	tstate->use_tracing = ((tstate->c_tracefunc != NULL)
-			       || (tstate->c_profilefunc != NULL));
+	pystate->tracing = 0;
+	pystate->use_tracing = ((pystate->c_tracefunc != NULL)
+			       || (pystate->c_profilefunc != NULL));
 	result = PyObject_Call(func, args, NULL);
-	tstate->tracing = save_tracing;
-	tstate->use_tracing = save_use_tracing;
+	pystate->tracing = save_tracing;
+	pystate->use_tracing = save_use_tracing;
 	return result;
 }
 
@@ -3180,45 +2953,46 @@
 void
 PyEval_SetProfile(Py_tracefunc func, PyObject *arg)
 {
-	PyThreadState *tstate = PyThreadState_GET();
-	PyObject *temp = tstate->c_profileobj;
-	Py_XINCREF(arg);
-	tstate->c_profilefunc = NULL;
-	tstate->c_profileobj = NULL;
+	PyState *pystate = PyState_Get();
+	PyObject *temp = pystate->c_profileobj;
+	Py_XINCREF_PS(arg);
+	pystate->c_profilefunc = NULL;
+	pystate->c_profileobj = NULL;
 	/* Must make sure that tracing is not ignored if 'temp' is freed */
-	tstate->use_tracing = tstate->c_tracefunc != NULL;
-	Py_XDECREF(temp);
-	tstate->c_profilefunc = func;
-	tstate->c_profileobj = arg;
+	pystate->use_tracing = pystate->c_tracefunc != NULL;
+	Py_XDECREF_PS(temp);
+	pystate->c_profilefunc = func;
+	pystate->c_profileobj = arg;
 	/* Flag that tracing or profiling is turned on */
-	tstate->use_tracing = (func != NULL) || (tstate->c_tracefunc != NULL);
+	pystate->use_tracing = (func != NULL) || (pystate->c_tracefunc != NULL);
 }
 
 void
 PyEval_SetTrace(Py_tracefunc func, PyObject *arg)
 {
-	PyThreadState *tstate = PyThreadState_GET();
-	PyObject *temp = tstate->c_traceobj;
-	Py_XINCREF(arg);
-	tstate->c_tracefunc = NULL;
-	tstate->c_traceobj = NULL;
+	PyState *pystate = PyState_Get();
+	PyObject *temp = pystate->c_traceobj;
+	Py_XINCREF_PS(arg);
+	pystate->c_tracefunc = NULL;
+	pystate->c_traceobj = NULL;
 	/* Must make sure that profiling is not ignored if 'temp' is freed */
-	tstate->use_tracing = tstate->c_profilefunc != NULL;
-	Py_XDECREF(temp);
-	tstate->c_tracefunc = func;
-	tstate->c_traceobj = arg;
+	pystate->use_tracing = pystate->c_profilefunc != NULL;
+	Py_XDECREF_PS(temp);
+	pystate->c_tracefunc = func;
+	pystate->c_traceobj = arg;
 	/* Flag that tracing or profiling is turned on */
-	tstate->use_tracing = ((func != NULL)
-			       || (tstate->c_profilefunc != NULL));
+	pystate->use_tracing = ((func != NULL)
+			       || (pystate->c_profilefunc != NULL));
 }
 
 PyObject *
 PyEval_GetBuiltins(void)
 {
 	PyFrameObject *current_frame = PyEval_GetFrame();
-	if (current_frame == NULL)
-		return PyThreadState_GET()->interp->builtins;
-	else
+	if (current_frame == NULL) {
+		extern PyObject *_PyBuiltin_Dict;
+		return _PyBuiltin_Dict;
+	} else
 		return current_frame->f_builtins;
 }
 
@@ -3245,8 +3019,8 @@
 PyFrameObject *
 PyEval_GetFrame(void)
 {
-	PyThreadState *tstate = PyThreadState_GET();
-	return _PyThreadState_GetFrame(tstate);
+	PyState *pystate = PyState_Get();
+	return _PyState_GetFrame(pystate);
 }
 
 int
@@ -3359,26 +3133,26 @@
 }
 
 #define C_TRACE(x, call) \
-if (tstate->use_tracing && tstate->c_profilefunc) { \
-	if (call_trace(tstate->c_profilefunc, \
-		tstate->c_profileobj, \
-		tstate->frame, PyTrace_C_CALL, \
+if (pystate->use_tracing && pystate->c_profilefunc) { \
+	if (call_trace(pystate->c_profilefunc, \
+		pystate->c_profileobj, \
+		pystate->frame, PyTrace_C_CALL, \
 		func)) { \
 		x = NULL; \
 	} \
 	else { \
 		x = call; \
-		if (tstate->c_profilefunc != NULL) { \
+		if (pystate->c_profilefunc != NULL) { \
 			if (x == NULL) { \
-				call_trace_protected(tstate->c_profilefunc, \
-					tstate->c_profileobj, \
-					tstate->frame, PyTrace_C_EXCEPTION, \
+				call_trace_protected(pystate->c_profilefunc, \
+					pystate->c_profileobj, \
+					pystate->frame, PyTrace_C_EXCEPTION, \
 					func); \
 				/* XXX should pass (type, value, tb) */ \
 			} else { \
-				if (call_trace(tstate->c_profilefunc, \
-					tstate->c_profileobj, \
-					tstate->frame, PyTrace_C_RETURN, \
+				if (call_trace(pystate->c_profilefunc, \
+					pystate->c_profileobj, \
+					pystate->frame, PyTrace_C_RETURN, \
 					func)) { \
 					Py_DECREF(x); \
 					x = NULL; \
@@ -3391,7 +3165,7 @@
 	}
 
 static PyObject *
-call_function(PyObject ***pp_stack, int oparg
+call_function(PyState *pystate, PyObject ***pp_stack, int oparg
 #ifdef WITH_TSC
 		, uint64* pintr0, uint64* pintr1
 #endif
@@ -3409,7 +3183,6 @@
 	*/
 	if (PyCFunction_Check(func) && nk == 0) {
 		int flags = PyCFunction_GET_FLAGS(func);
-		PyThreadState *tstate = PyThreadState_GET();
 
 		PCALL(PCALL_CFUNCTION);
 		if (flags & (METH_NOARGS | METH_O)) {
@@ -3421,7 +3194,7 @@
 			else if (flags & METH_O && na == 1) {
 				PyObject *arg = EXT_POP(*pp_stack);
 				C_TRACE(x, (*meth)(self,arg));
-				Py_DECREF(arg);
+				Py_DECREF_PS(arg);
 			}
 			else {
 				err_args(func, flags, na);
@@ -3434,7 +3207,7 @@
 			READ_TIMESTAMP(*pintr0);
 			C_TRACE(x, PyCFunction_Call(func,callargs,NULL));
 			READ_TIMESTAMP(*pintr1);
-			Py_XDECREF(callargs);
+			Py_XDECREF_PS(callargs);
 		}
 	} else {
 		if (PyMethod_Check(func) && PyMethod_GET_SELF(func) != NULL) {
@@ -3442,22 +3215,22 @@
 			PyObject *self = PyMethod_GET_SELF(func);
 			PCALL(PCALL_METHOD);
 			PCALL(PCALL_BOUND_METHOD);
-			Py_INCREF(self);
+			Py_INCREF_PS(self);
 			func = PyMethod_GET_FUNCTION(func);
-			Py_INCREF(func);
-			Py_DECREF(*pfunc);
+			Py_INCREF_PS(func);
+			Py_DECREF_PS(*pfunc);
 			*pfunc = self;
 			na++;
 			n++;
 		} else
-			Py_INCREF(func);
+			Py_INCREF_PS(func);
 		READ_TIMESTAMP(*pintr0);
 		if (PyFunction_Check(func))
-			x = fast_function(func, pp_stack, n, na, nk);
+			x = fast_function(pystate, func, pp_stack, n, na, nk);
 		else
 			x = do_call(func, pp_stack, na, nk);
 		READ_TIMESTAMP(*pintr1);
-		Py_DECREF(func);
+		Py_DECREF_PS(func);
 	}
 
 	/* Clear the stack of the function object.  Also removes
@@ -3466,7 +3239,7 @@
 	 */
 	while ((*pp_stack) > pfunc) {
 		w = EXT_POP(*pp_stack);
-		Py_DECREF(w);
+		Py_DECREF_PS(w);
 		PCALL(PCALL_POP);
 	}
 	return x;
@@ -3482,7 +3255,7 @@
 */
 
 static PyObject *
-fast_function(PyObject *func, PyObject ***pp_stack, int n, int na, int nk)
+fast_function(PyState *pystate, PyObject *func, PyObject ***pp_stack, int n, int na, int nk)
 {
 	PyCodeObject *co = (PyCodeObject *)PyFunction_GET_CODE(func);
 	PyObject *globals = PyFunction_GET_GLOBALS(func);
@@ -3498,7 +3271,6 @@
 	    co->co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)) {
 		PyFrameObject *f;
 		PyObject *retval = NULL;
-		PyThreadState *tstate = PyThreadState_GET();
 		PyObject **fastlocals, **stack;
 		int i;
 
@@ -3508,8 +3280,8 @@
 		   PyFrame_New() that doesn't take locals, but does
 		   take builtins without sanity checking them.
 		*/
-		assert(tstate != NULL);
-		f = PyFrame_New(tstate, co, globals, NULL);
+		assert(pystate != NULL);
+		f = PyFrame_New(pystate, co, globals, NULL);
 		if (f == NULL)
 			return NULL;
 
@@ -3517,13 +3289,13 @@
 		stack = (*pp_stack) - n;
 
 		for (i = 0; i < n; i++) {
-			Py_INCREF(*stack);
+			Py_INCREF_PS(*stack);
 			fastlocals[i] = *stack++;
 		}
 		retval = PyEval_EvalFrameEx(f,0);
-		++tstate->recursion_depth;
-		Py_DECREF(f);
-		--tstate->recursion_depth;
+		++pystate->recursion_depth;
+		Py_DECREF_PS(f);
+		--pystate->recursion_depth;
 		return retval;
 	}
 	if (argdefs != NULL) {
@@ -3919,6 +3691,7 @@
 {
 	/* This function implements 'variable += expr' when both arguments
 	   are (Unicode) strings. */
+	PyState *pystate = PyState_Get();
 	Py_ssize_t v_len = PyUnicode_GET_SIZE(v);
 	Py_ssize_t w_len = PyUnicode_GET_SIZE(w);
 	Py_ssize_t new_len = v_len + w_len;
@@ -3928,7 +3701,7 @@
 		return NULL;
 	}
 
-	if (v->ob_refcnt == 2) {
+	if (Py_RefcntMatches(v, 2)) {
 		/* In the common case, there are 2 references to the value
 		 * stored in 'variable' when the += is performed: one on the
 		 * value stack (in 'v') and one still stored in the
@@ -3969,7 +3742,7 @@
 		}
 	}
 
-	if (v->ob_refcnt == 1 && !PyUnicode_CHECK_INTERNED(v)) {
+	if (Py_RefcntMatches(v, 1) && !_PyUnicode_SnoopState((PyUnicodeObject *)v)) {
 		/* Now we own the last reference to 'v', so we can resize it
 		 * in-place.
 		 */

=== modified file 'Python/codecs.c'
--- Python/codecs.c	2008-01-03 23:05:47 +0000
+++ Python/codecs.c	2008-03-24 04:28:03 +0000
@@ -26,10 +26,13 @@
 
 static int _PyCodecRegistry_Init(void); /* Forward */
 
+static PyObject *codec_search_path;
+static PyObject *codec_search_cache;
+static PyObject *codec_error_registry;
+
 int PyCodec_Register(PyObject *search_function)
 {
-    PyInterpreterState *interp = PyThreadState_GET()->interp;
-    if (interp->codec_search_path == NULL && _PyCodecRegistry_Init())
+    if (codec_search_path == NULL && _PyCodecRegistry_Init())
 	goto onError;
     if (search_function == NULL) {
 	PyErr_BadArgument();
@@ -39,7 +42,7 @@
 	PyErr_SetString(PyExc_TypeError, "argument must be callable");
 	goto onError;
     }
-    return PyList_Append(interp->codec_search_path, search_function);
+    return PyList_Append(codec_search_path, search_function);
 
  onError:
     return -1;
@@ -97,7 +100,6 @@
 
 PyObject *_PyCodec_Lookup(const char *encoding)
 {
-    PyInterpreterState *interp;
     PyObject *result, *args = NULL, *v;
     Py_ssize_t i, len;
 
@@ -106,8 +108,7 @@
 	goto onError;
     }
 
-    interp = PyThreadState_GET()->interp;
-    if (interp->codec_search_path == NULL && _PyCodecRegistry_Init())
+    if (codec_search_path == NULL && _PyCodecRegistry_Init())
 	goto onError;
 
     /* Convert the encoding to a normalized Python string: all
@@ -119,7 +120,7 @@
     PyUnicode_InternInPlace(&v);
 
     /* First, try to lookup the name in the registry dictionary */
-    result = PyDict_GetItem(interp->codec_search_cache, v);
+    result = PyDict_GetItem(codec_search_cache, v);
     if (result != NULL) {
 	Py_INCREF(result);
 	Py_DECREF(v);
@@ -132,7 +133,7 @@
 	goto onError;
     PyTuple_SET_ITEM(args,0,v);
 
-    len = PyList_Size(interp->codec_search_path);
+    len = PyList_Size(codec_search_path);
     if (len < 0)
 	goto onError;
     if (len == 0) {
@@ -145,7 +146,7 @@
     for (i = 0; i < len; i++) {
 	PyObject *func;
 
-	func = PyList_GetItem(interp->codec_search_path, i);
+	func = PyList_GetItem(codec_search_path, i);
 	if (func == NULL)
 	    goto onError;
 	result = PyEval_CallObject(func, args);
@@ -171,7 +172,7 @@
     }
 
     /* Cache and return the result */
-    if (PyDict_SetItem(interp->codec_search_cache, v, result) < 0) {
+    if (PyDict_SetItem(codec_search_cache, v, result) < 0) {
 	Py_DECREF(result);
 	goto onError;
     }
@@ -426,14 +427,13 @@
    Return 0 on success, -1 on error */
 int PyCodec_RegisterError(const char *name, PyObject *error)
 {
-    PyInterpreterState *interp = PyThreadState_GET()->interp;
-    if (interp->codec_search_path == NULL && _PyCodecRegistry_Init())
+    if (codec_search_path == NULL && _PyCodecRegistry_Init())
 	return -1;
     if (!PyCallable_Check(error)) {
 	PyErr_SetString(PyExc_TypeError, "handler must be callable");
 	return -1;
     }
-    return PyDict_SetItemString(interp->codec_error_registry,
+    return PyDict_SetItemString(codec_error_registry,
 	    			(char *)name, error);
 }
 
@@ -444,13 +444,12 @@
 {
     PyObject *handler = NULL;
 
-    PyInterpreterState *interp = PyThreadState_GET()->interp;
-    if (interp->codec_search_path == NULL && _PyCodecRegistry_Init())
+    if (codec_search_path == NULL && _PyCodecRegistry_Init())
 	return NULL;
 
     if (name==NULL)
 	name = "strict";
-    handler = PyDict_GetItemString(interp->codec_error_registry, (char *)name);
+    handler = PyDict_GetItemString(codec_error_registry, (char *)name);
     if (!handler)
 	PyErr_Format(PyExc_LookupError, "unknown error handler name '%.400s'", name);
     else
@@ -821,18 +820,17 @@
 	}
     };
 
-    PyInterpreterState *interp = PyThreadState_GET()->interp;
     PyObject *mod;
     unsigned i;
 
-    if (interp->codec_search_path != NULL)
+    if (codec_search_path != NULL)
 	return 0;
 
-    interp->codec_search_path = PyList_New(0);
-    interp->codec_search_cache = PyDict_New();
-    interp->codec_error_registry = PyDict_New();
+    codec_search_path = PyList_New(0);
+    codec_search_cache = PyDict_New();
+    codec_error_registry = PyDict_New();
 
-    if (interp->codec_error_registry) {
+    if (codec_error_registry) {
 	for (i = 0; i < sizeof(methods)/sizeof(methods[0]); ++i) {
 	    PyObject *func = PyCFunction_New(&methods[i].def, NULL);
 	    int res;
@@ -845,9 +843,9 @@
 	}
     }
 
-    if (interp->codec_search_path == NULL ||
-	interp->codec_search_cache == NULL ||
-	interp->codec_error_registry == NULL)
+    if (codec_search_path == NULL ||
+	codec_search_cache == NULL ||
+	codec_error_registry == NULL)
 	Py_FatalError("can't initialize codec registry");
 
     mod = PyImport_ImportModuleNoBlock("encodings");

=== modified file 'Python/dynload_shlib.c'
--- Python/dynload_shlib.c	2006-01-04 01:30:17 +0000
+++ Python/dynload_shlib.c	2008-03-24 04:28:03 +0000
@@ -109,7 +109,8 @@
 	}
 
 #if !(defined(PYOS_OS2) && defined(PYCC_GCC))
-        dlopenflags = PyThreadState_GET()->interp->dlopenflags;
+        extern int _PySys_DLOpenFlags;
+        dlopenflags = _PySys_DLOpenFlags;
 #endif
 
 	if (Py_VerboseFlag)

=== modified file 'Python/errors.c'
--- Python/errors.c	2008-01-03 23:01:04 +0000
+++ Python/errors.c	2008-03-24 04:28:03 +0000
@@ -24,7 +24,7 @@
 void
 PyErr_Restore(PyObject *type, PyObject *value, PyObject *traceback)
 {
-	PyThreadState *tstate = PyThreadState_GET();
+	PyState *pystate = PyState_Get();
 	PyObject *oldtype, *oldvalue, *oldtraceback;
 
 	if (traceback != NULL && !PyTraceBack_Check(traceback)) {
@@ -36,13 +36,13 @@
 
 	/* Save these in locals to safeguard against recursive
 	   invocation through Py_XDECREF */
-	oldtype = tstate->curexc_type;
-	oldvalue = tstate->curexc_value;
-	oldtraceback = tstate->curexc_traceback;
+	oldtype = pystate->curexc_type;
+	oldvalue = pystate->curexc_value;
+	oldtraceback = pystate->curexc_traceback;
 
-	tstate->curexc_type = type;
-	tstate->curexc_value = value;
-	tstate->curexc_traceback = traceback;
+	pystate->curexc_type = type;
+	pystate->curexc_value = value;
+	pystate->curexc_traceback = traceback;
 
 	Py_XDECREF(oldtype);
 	Py_XDECREF(oldvalue);
@@ -52,6 +52,8 @@
 void
 PyErr_SetObject(PyObject *exception, PyObject *value)
 {
+	if (exception != NULL && exception->ob_type == NULL)
+		Py_FatalError("Unitialized exception type passed to PyErr_SetObject");
 	if (exception != NULL &&
 	    !PyExceptionClass_Check(exception)) {
 		PyErr_Format(PyExc_SystemError,
@@ -82,9 +84,9 @@
 PyObject *
 PyErr_Occurred(void)
 {
-	PyThreadState *tstate = PyThreadState_GET();
+	PyState *pystate = PyState_Get();
 
-	return tstate->curexc_type;
+	return pystate->curexc_type;
 }
 
 
@@ -115,7 +117,9 @@
 	if (PyExceptionClass_Check(err) && PyExceptionClass_Check(exc)) {
 		/* problems here!?  not sure PyObject_IsSubclass expects to
 		   be called with an exception pending... */
-		return PyObject_IsSubclass(err, exc);
+		/* Worse, we may be called when it's not safe to call
+		 * arbitrary code.  Thus, I switch to a safer check */
+		return _PyObject_IsSubclassSimple(err, exc);
 	}
 
 	return err == exc;
@@ -139,7 +143,7 @@
 	PyObject *value = *val;
 	PyObject *inclass = NULL;
 	PyObject *initial_tb = NULL;
-	PyThreadState *tstate = NULL;
+	PyState *pystate = NULL;
 
 	if (type == NULL) {
 		/* There was no exception, so nothing to do. */
@@ -215,29 +219,38 @@
 			Py_DECREF(initial_tb);
 	}
 	/* normalize recursively */
-	tstate = PyThreadState_GET();
-	if (++tstate->recursion_depth > Py_GetRecursionLimit()) {
-	    --tstate->recursion_depth;
+	pystate = PyState_Get();
+	if (++pystate->recursion_depth > Py_GetRecursionLimit()) {
+	    --pystate->recursion_depth;
 	    PyErr_SetObject(PyExc_RuntimeError, PyExc_RecursionErrorInst);
 	    return;
 	}
 	PyErr_NormalizeException(exc, val, tb);
-	--tstate->recursion_depth;
+	--pystate->recursion_depth;
+}
+
+PyObject *
+PyErr_SimplifyException(PyObject *exc, PyObject *val, PyObject *tb)
+{
+    PyErr_NormalizeException(&exc, &val, &tb);
+    Py_DECREF(exc);
+    Py_XDECREF(tb);
+    return val;
 }
 
 
 void
 PyErr_Fetch(PyObject **p_type, PyObject **p_value, PyObject **p_traceback)
 {
-	PyThreadState *tstate = PyThreadState_GET();
-
-	*p_type = tstate->curexc_type;
-	*p_value = tstate->curexc_value;
-	*p_traceback = tstate->curexc_traceback;
-
-	tstate->curexc_type = NULL;
-	tstate->curexc_value = NULL;
-	tstate->curexc_traceback = NULL;
+	PyState *pystate = PyState_Get();
+
+	*p_type = pystate->curexc_type;
+	*p_value = pystate->curexc_value;
+	*p_traceback = pystate->curexc_traceback;
+
+	pystate->curexc_type = NULL;
+	pystate->curexc_value = NULL;
+	pystate->curexc_traceback = NULL;
 }
 
 void
@@ -291,11 +304,6 @@
 #endif /* Unix/Windows */
 #endif /* PLAN 9*/
 
-#ifdef EINTR
-	if (i == EINTR && PyErr_CheckSignals())
-		return NULL;
-#endif
-
 #ifdef PLAN9
 	rerrstr(errbuf, sizeof errbuf);
 	message = PyUnicode_DecodeUTF8(errbuf, strlen(errbuf), "ignore");

=== modified file 'Python/future.c'
--- Python/future.c	2008-03-26 22:34:47 +0000
+++ Python/future.c	2008-04-11 02:54:37 +0000
@@ -37,6 +37,8 @@
 			continue;
 		} else if (strcmp(feature, FUTURE_UNICODE_LITERALS) == 0) {
 			continue;
+		} else if (strcmp(feature, FUTURE_SHARED_MODULE) == 0) {
+			ff->ff_features |= CO_FUTURE_SHARED_MODULE;
 		} else if (strcmp(feature, "braces") == 0) {
 			PyErr_SetString(PyExc_SyntaxError,
 					"not a chance");

=== modified file 'Python/getargs.c'
--- Python/getargs.c	2008-04-10 16:25:37 +0000
+++ Python/getargs.c	2008-04-11 02:07:15 +0000
@@ -1778,6 +1778,90 @@
 			funcname);
 	return 0;
 }
+
+
+/* We assume args and kw were both constructed by other
+ * argument functions and neither can be modified while
+ * we iterate over them.
+ */
+int
+PyArg_RequireShareable(const char *funcname, PyObject *args, PyObject *kwargs)
+{
+	assert (args != NULL || kwargs != NULL);
+
+	if (args != NULL) {
+		Py_ssize_t i;
+		Py_ssize_t size = PyTuple_Size(args);
+		for (i = 0; i < size; i++) {
+			if (!PyObject_IsShareable(PyTuple_GetItem(args, i))) {
+				PyErr_Format(PyExc_TypeError, "%s requires "
+					"shareable arguments; positional "
+					"argument %d is not shareable",
+					funcname, i+1);
+				return 0;
+			}
+		}
+	}
+
+	if (kwargs != NULL) {
+		PyObject *key, *value;
+		Py_ssize_t pos = 0;
+		while (PyDict_Next(kwargs, &pos, &key, &value)) {
+			if (!PyObject_IsShareable(key)) {
+				char *ks = PyString_AsString(key);
+				PyErr_Format(PyExc_TypeError, "%s requires "
+					"shareable arguments; keyword "
+					"argument %s's key is not shareable",
+					funcname, ks);
+				return 0;
+			}
+			if (!PyObject_IsShareable(value)) {
+				char *ks = PyString_AsString(key);
+				PyErr_Format(PyExc_TypeError, "%s requires "
+					"shareable arguments; keyword "
+					"argument %s's value is not shareable",
+					funcname, ks);
+				return 0;
+			}
+		}
+	}
+
+	return 1;
+}
+
+/* funcname is the outer function (written in C) which wants a shareable object.
+ * innerfunc is the inner function that just returned a (hopefully) shareable object.
+ * The error context will be checked AND CHANGED to be shareable.
+ */
+int
+PyArg_RequireShareableReturn(const char *funcname, PyObject *innerfunc, PyObject *result)
+{
+	if (result != NULL) {
+		if (PyErr_Occurred())
+			Py_FatalError("Both exception and return value set");
+
+		if (PyObject_IsShareable(result))
+			return 1;
+
+		if (PyFunction_Check(innerfunc)) {
+			char *innerfuncname = PyString_AsString(
+				((PyFunctionObject *)innerfunc)->func_name);
+			PyErr_Format(PyExc_TypeError, "%s given unshareable return "
+				"value by %s()", funcname, innerfuncname);
+		} else
+			PyErr_Format(PyExc_TypeError, "%s given unshareable return "
+				"value by callable", funcname);
+
+		return 0;
+	} else {
+		if (!PyErr_Occurred())
+			Py_FatalError("Neither exception nor return value set");
+
+		/* XXX FIXME */
+		return 1;
+	}
+}
+
 #ifdef __cplusplus
 };
 #endif

=== modified file 'Python/import.c'
--- Python/import.c	2008-03-26 23:24:27 +0000
+++ Python/import.c	2008-04-11 02:07:15 +0000
@@ -14,6 +14,7 @@
 #include "eval.h"
 #include "osdefs.h"
 #include "importdl.h"
+#include "pystate.h"
 
 #ifdef HAVE_FCNTL_H
 #include <fcntl.h>
@@ -118,6 +119,10 @@
 };
 
 
+static PyObject *_PyImport_Modules;
+static PyObject *_PyImport_Modules_Reloading;
+
+
 /* Initialize things */
 
 void
@@ -128,6 +133,13 @@
 	int countD = 0;
 	int countS = 0;
 
+	_PyImport_Modules = PyDict_New();
+	if (_PyImport_Modules == NULL)
+		Py_FatalError("_PyImport_Init: can't make modules dictionary");
+	_PyImport_Modules_Reloading = PyDict_New();
+	if (_PyImport_Modules_Reloading == NULL)
+		Py_FatalError("_PyImport_Init: can't make modules_reloading dictionary");
+
 	/* prepare _PyImport_Filetab: copy entries from
 	   _PyImport_DynLoadFiletab and _PyImport_StandardFiletab.
 	 */
@@ -254,63 +266,53 @@
 
 #include "pythread.h"
 
-static PyThread_type_lock import_lock = 0;
-static long import_lock_thread = -1;
+#warning Import locking is all bodged and needs a rewrite
+static PyThread_type_lock *import_lock = 0;
+static PyState *import_lock_thread = NULL;
 static int import_lock_level = 0;
 
 static void
 lock_import(void)
 {
-	long me = PyThread_get_thread_ident();
-	if (me == -1)
-		return; /* Too bad */
+	PyState *pystate = PyState_Get();
 	if (import_lock == NULL) {
-		import_lock = PyThread_allocate_lock();
+		import_lock = PyThread_lock_allocate();
 		if (import_lock == NULL)
 			return;  /* Nothing much we can do. */
 	}
-	if (import_lock_thread == me) {
+	if (import_lock_thread == pystate) {
 		import_lock_level++;
 		return;
 	}
-	if (import_lock_thread != -1 || !PyThread_acquire_lock(import_lock, 0))
+	if (import_lock_thread != NULL || !PyThread_lock_tryacquire(import_lock))
 	{
-		PyThreadState *tstate = PyEval_SaveThread();
-		PyThread_acquire_lock(import_lock, 1);
-		PyEval_RestoreThread(tstate);
+		//PyState *pystate = PyEval_SaveThread();
+		PyState_Suspend();
+		PyThread_lock_acquire(import_lock);
+		/* XXX This should be replaced with a "large lock" with deadlock detection */
+		//PyEval_RestoreThread(pystate);
+		PyState_Resume();
 	}
-	import_lock_thread = me;
+	import_lock_thread = pystate;
 	import_lock_level = 1;
 }
 
 static int
 unlock_import(void)
 {
-	long me = PyThread_get_thread_ident();
-	if (me == -1 || import_lock == NULL)
+	PyState *pystate = PyState_Get();
+	if (import_lock == NULL)
 		return 0; /* Too bad */
-	if (import_lock_thread != me)
+	if (import_lock_thread != pystate)
 		return -1;
 	import_lock_level--;
 	if (import_lock_level == 0) {
-		import_lock_thread = -1;
-		PyThread_release_lock(import_lock);
+		import_lock_thread = NULL;
+		PyThread_lock_release(import_lock);
 	}
 	return 1;
 }
 
-/* This function is called from PyOS_AfterFork to ensure that newly
-   created child processes do not share locks with the parent. */
-
-void
-_PyImport_ReInitLock(void)
-{
-#ifdef _AIX
-	if (import_lock != NULL)
-		import_lock = PyThread_allocate_lock();
-#endif
-}
-
 #else
 
 #define lock_import()
@@ -322,7 +324,7 @@
 imp_lock_held(PyObject *self, PyObject *noargs)
 {
 #ifdef WITH_THREAD
-	return PyBool_FromLong(import_lock_thread != -1);
+	return PyBool_FromLong(import_lock_thread != NULL);
 #else
 	return PyBool_FromLong(0);
 #endif
@@ -355,9 +357,8 @@
 static void
 imp_modules_reloading_clear(void)
 {
-	PyInterpreterState *interp = PyThreadState_Get()->interp;
-	if (interp->modules_reloading != NULL)
-		PyDict_Clear(interp->modules_reloading);
+	if (_PyImport_Modules_Reloading != NULL)
+		PyDict_Clear(_PyImport_Modules_Reloading);
 }
 
 /* Helper for sys */
@@ -365,10 +366,9 @@
 PyObject *
 PyImport_GetModuleDict(void)
 {
-	PyInterpreterState *interp = PyThreadState_GET()->interp;
-	if (interp->modules == NULL)
+	if (_PyImport_Modules == NULL)
 		Py_FatalError("PyImport_GetModuleDict: no module dictionary!");
-	return interp->modules;
+	return _PyImport_Modules;
 }
 
 
@@ -398,8 +398,7 @@
 	Py_ssize_t pos, ndone;
 	char *name;
 	PyObject *key, *value, *dict;
-	PyInterpreterState *interp = PyThreadState_GET()->interp;
-	PyObject *modules = interp->modules;
+	PyObject *modules = _PyImport_Modules;
 
 	if (modules == NULL)
 		return; /* Already done */
@@ -466,7 +465,7 @@
 		ndone = 0;
 		pos = 0;
 		while (PyDict_Next(modules, &pos, &key, &value)) {
-			if (value->ob_refcnt != 1)
+			if (!Py_RefcntMatches(value, 1))
 				continue;
 			if (PyUnicode_Check(key) && PyModule_Check(value)) {
 				name = PyUnicode_AsString(key);
@@ -518,9 +517,9 @@
 
 	/* Finally, clear and delete the modules directory */
 	PyDict_Clear(modules);
-	interp->modules = NULL;
+	_PyImport_Modules = NULL;
 	Py_DECREF(modules);
-	Py_CLEAR(interp->modules_reloading);
+	Py_CLEAR(_PyImport_Modules_Reloading);
 }
 
 
@@ -603,13 +602,19 @@
 PyObject *
 PyImport_AddModule(const char *name)
 {
+	return PyImport_AddModuleEx(name, 0);
+}
+
+PyObject *
+PyImport_AddModuleEx(const char *name, int shared)
+{
 	PyObject *modules = PyImport_GetModuleDict();
 	PyObject *m;
 
 	if ((m = PyDict_GetItemString(modules, name)) != NULL &&
 	    PyModule_Check(m))
 		return m;
-	m = PyModule_New(name);
+	m = PyModule_NewEx(name, shared);
 	if (m == NULL)
 		return NULL;
 	if (PyDict_SetItemString(modules, name, m) != 0) {
@@ -652,19 +657,31 @@
 PyImport_ExecCodeModuleEx(char *name, PyObject *co, char *pathname)
 {
 	PyObject *modules = PyImport_GetModuleDict();
-	PyObject *m, *d, *v;
-
-	m = PyImport_AddModule(name);
-	if (m == NULL)
+	PyObject *m, *d, *v, *tmp;
+	int shared = 0;
+
+	PyState_EnterImport(); /* XXX should probably be done earlier */
+	if (((PyCodeObject *)co)->co_flags & CO_FUTURE_SHARED_MODULE)
+		shared = 1;
+
+	m = PyImport_AddModuleEx(name, shared);
+	if (m == NULL) {
+		PyState_ExitImport();
 		return NULL;
+	}
+
 	/* If the module is being reloaded, we get the old module back
 	   and re-use its dict to exec the new code. */
 	d = PyModule_GetDict(m);
-	if (PyDict_GetItemString(d, "__builtins__") == NULL) {
+	if (PyDict_GetItemStringEx(d, "__builtins__", &tmp) < 0)
+		goto error;
+	if (tmp == NULL) {
 		if (PyDict_SetItemString(d, "__builtins__",
 					 PyEval_GetBuiltins()) != 0)
 			goto error;
-	}
+	} else
+		Py_DECREF(tmp);
+
 	/* Remember the filename as the __file__ attribute */
 	v = NULL;
 	if (pathname != NULL) {
@@ -689,15 +706,18 @@
 		PyErr_Format(PyExc_ImportError,
 			     "Loaded module %.200s not found in sys.modules",
 			     name);
+		PyState_ExitImport();
 		return NULL;
 	}
 
 	Py_INCREF(m);
 
+	PyState_ExitImport();
 	return m;
 
   error:
 	_RemoveModule(name);
+	PyState_ExitImport();
 	return NULL;
 }
 
@@ -1959,7 +1979,7 @@
 {
 	PyObject *result;
 	PyObject *modules;
-	long me;
+	PyState *pystate = PyState_Get();
 
 	/* Try to get the module from sys.modules[name] */
 	modules = PyImport_GetModuleDict();
@@ -1978,8 +1998,7 @@
 	/* check the import lock
 	 * me might be -1 but I ignore the error here, the lock function
 	 * takes care of the problem */
-	me = PyThread_get_thread_ident();
-	if (import_lock_thread == -1 || import_lock_thread == me) {
+	if (import_lock_thread == NULL || import_lock_thread == pystate) {
 		/* no thread or me is holding the lock */
 		return PyImport_ImportModule(name);
 	}
@@ -2500,8 +2519,7 @@
 PyObject *
 PyImport_ReloadModule(PyObject *m)
 {
-	PyInterpreterState *interp = PyThreadState_Get()->interp;
-	PyObject *modules_reloading = interp->modules_reloading;
+	PyObject *modules_reloading = _PyImport_Modules_Reloading;
 	PyObject *modules = PyImport_GetModuleDict();
 	PyObject *path = NULL, *loader = NULL, *existing_m = NULL;
 	char *name, *subname;
@@ -3191,7 +3209,6 @@
 	0,                         /* tp_descr_set */
 	0,                         /* tp_dictoffset */
 	(initproc)NullImporter_init,      /* tp_init */
-	0,                         /* tp_alloc */
 	PyType_GenericNew          /* tp_new */
 };
 

=== modified file 'Python/modsupport.c'
--- Python/modsupport.c	2008-01-19 20:08:23 +0000
+++ Python/modsupport.c	2008-03-24 04:28:03 +0000
@@ -32,6 +32,14 @@
 Py_InitModule4(const char *name, PyMethodDef *methods, const char *doc,
 	       PyObject *passthrough, int module_api_version)
 {
+	return Py_InitModule5(name, methods, doc, passthrough,
+		module_api_version, 0);
+}
+
+PyObject *
+Py_InitModule5(const char *name, PyMethodDef *methods, const char *doc,
+	       PyObject *passthrough, int module_api_version, int shared)
+{
 	PyObject *m, *d, *v, *n;
 	PyMethodDef *ml;
 	if (!Py_IsInitialized())
@@ -61,7 +69,7 @@
 			_Py_PackageContext = NULL;
 		}
 	}
-	if ((m = PyImport_AddModule(name)) == NULL)
+	if ((m = PyImport_AddModuleEx(name, shared)) == NULL)
 		return NULL;
 	d = PyModule_GetDict(m);
 	if (methods != NULL) {

=== modified file 'Python/pystate.c'
--- Python/pystate.c	2008-01-21 11:20:28 +0000
+++ Python/pystate.c	2008-04-08 22:46:14 +0000
@@ -2,6 +2,8 @@
 /* Thread and interpreter state structures and their interfaces */
 
 #include "Python.h"
+#include "monitorobject.h"
+#include "cancelobject.h"
 
 /* --------------------------------------------------------------------------
 CAUTION
@@ -13,632 +15,807 @@
 the expense of doing their own locking).
 -------------------------------------------------------------------------- */
 
-#ifdef HAVE_DLOPEN
-#ifdef HAVE_DLFCN_H
-#include <dlfcn.h>
-#endif
-#ifndef RTLD_LAZY
-#define RTLD_LAZY 1
-#endif
-#endif
-
-
-#ifdef WITH_THREAD
+
 #include "pythread.h"
-static PyThread_type_lock head_mutex = NULL; /* Protects interp->tstate_head */
-#define HEAD_INIT() (void)(head_mutex || (head_mutex = PyThread_allocate_lock()))
-#define HEAD_LOCK() PyThread_acquire_lock(head_mutex, WAIT_LOCK)
-#define HEAD_UNLOCK() PyThread_release_lock(head_mutex)
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
-/* The single PyInterpreterState used by this process'
-   GILState implementation
-*/
-static PyInterpreterState *autoInterpreterState = NULL;
-static int autoTLSkey = 0;
-#else
-#define HEAD_INIT() /* Nothing */
-#define HEAD_LOCK() /* Nothing */
-#define HEAD_UNLOCK() /* Nothing */
-#endif
-
-static PyInterpreterState *interp_head = NULL;
-
-PyThreadState *_PyThreadState_Current = NULL;
-PyThreadFrameGetter _PyThreadState_GetFrame = NULL;
-
-#ifdef WITH_THREAD
-static void _PyGILState_NoteThreadState(PyThreadState* tstate);
-#endif
-
-
-PyInterpreterState *
-PyInterpreterState_New(void)
-{
-	PyInterpreterState *interp = (PyInterpreterState *)
-				     malloc(sizeof(PyInterpreterState));
-
-	if (interp != NULL) {
-		HEAD_INIT();
-#ifdef WITH_THREAD
-		if (head_mutex == NULL)
-			Py_FatalError("Can't initialize threads for interpreter");
-#endif
-		interp->modules = NULL;
-		interp->modules_reloading = NULL;
-		interp->sysdict = NULL;
-		interp->builtins = NULL;
-		interp->tstate_head = NULL;
-		interp->codec_search_path = NULL;
-		interp->codec_search_cache = NULL;
-		interp->codec_error_registry = NULL;
-#ifdef HAVE_DLOPEN
-#ifdef RTLD_NOW
-                interp->dlopenflags = RTLD_NOW;
-#else
-		interp->dlopenflags = RTLD_LAZY;
-#endif
-#endif
-#ifdef WITH_TSC
-		interp->tscdump = 0;
-#endif
-
-		HEAD_LOCK();
-		interp->next = interp_head;
-		interp_head = interp;
-		HEAD_UNLOCK();
-	}
-
-	return interp;
-}
-
-
-void
-PyInterpreterState_Clear(PyInterpreterState *interp)
-{
-	PyThreadState *p;
-	HEAD_LOCK();
-	for (p = interp->tstate_head; p != NULL; p = p->next)
-		PyThreadState_Clear(p);
-	HEAD_UNLOCK();
-	Py_CLEAR(interp->codec_search_path);
-	Py_CLEAR(interp->codec_search_cache);
-	Py_CLEAR(interp->codec_error_registry);
-	Py_CLEAR(interp->modules);
-	Py_CLEAR(interp->modules_reloading);
-	Py_CLEAR(interp->sysdict);
-	Py_CLEAR(interp->builtins);
-}
-
-
-static void
-zapthreads(PyInterpreterState *interp)
-{
-	PyThreadState *p;
-	/* No need to lock the mutex here because this should only happen
-	   when the threads are all really dead (XXX famous last words). */
-	while ((p = interp->tstate_head) != NULL) {
-		PyThreadState_Delete(p);
-	}
-}
-
-
-void
-PyInterpreterState_Delete(PyInterpreterState *interp)
-{
-	PyInterpreterState **p;
-	zapthreads(interp);
-	HEAD_LOCK();
-	for (p = &interp_head; ; p = &(*p)->next) {
-		if (*p == NULL)
-			Py_FatalError(
-				"PyInterpreterState_Delete: invalid interp");
-		if (*p == interp)
-			break;
-	}
-	if (interp->tstate_head != NULL)
-		Py_FatalError("PyInterpreterState_Delete: remaining threads");
-	*p = interp->next;
-	HEAD_UNLOCK();
-	free(interp);
-}
-
-
-/* Default implementation for _PyThreadState_GetFrame */
+static PyThread_type_key *autoTLSkey = NULL;
+static AO_t thread_count;
+
+static PyState *pystate_head;
+
+static PyThread_type_lock *world_lock;
+static PyThread_type_lock *world_wakeup_lock;
+static PyLinkedList world_wakeup_list;
+static AO_t world_sleep;
+
+/* This hook exists so psyco can provide it's own frame objects */
+static struct _frame *threadstate_getframe(PyState *self);
+PyThreadFrameGetter _PyState_GetFrame = threadstate_getframe;
+
+#ifdef HAVE_THREAD_LOCAL_VARIABLE
+__thread PyState *_py_local_pystate;
+#endif
+
+
+int
+_PyState_SingleThreaded(void)
+{
+    return AO_load_full(&thread_count) == 1;
+}
+
+
+/* Default implementation for _PyState_GetFrame */
 static struct _frame *
-threadstate_getframe(PyThreadState *self)
-{
-	return self->frame;
-}
-
-PyThreadState *
-PyThreadState_New(PyInterpreterState *interp)
-{
-	PyThreadState *tstate = (PyThreadState *)malloc(sizeof(PyThreadState));
-
-	if (_PyThreadState_GetFrame == NULL)
-		_PyThreadState_GetFrame = threadstate_getframe;
-
-	if (tstate != NULL) {
-		tstate->interp = interp;
-
-		tstate->frame = NULL;
-		tstate->recursion_depth = 0;
-		tstate->overflowed = 0;
-		tstate->recursion_critical = 0;
-		tstate->tracing = 0;
-		tstate->use_tracing = 0;
-		tstate->tick_counter = 0;
-		tstate->gilstate_counter = 0;
-		tstate->async_exc = NULL;
-#ifdef WITH_THREAD
-		tstate->thread_id = PyThread_get_thread_ident();
+threadstate_getframe(PyState *self)
+{
+    return self->frame;
+}
+
+PyState *
+_PyState_New(void)
+{
+    PyState *pystate;
+    int i, j;
+
+    pystate = malloc(sizeof(PyState));
+    if (pystate == NULL)
+        return NULL;
+
+    pystate->used = 0;
+    pystate->deleted = 0;
+
+    pystate->frame = NULL;
+    pystate->recursion_depth = 0;
+    pystate->overflowed = 0;
+    pystate->recursion_critical = 0;
+    pystate->dealloc_depth = 0;
+    pystate->tracing = 0;
+    pystate->use_tracing = 0;
+
+    pystate->large_ticks = 0;
+    pystate->small_ticks = 0;
+
+    pystate->thread_lock = NULL;
+    pystate->world_wakeup = NULL;
+    PyLinkedList_InitNode(&pystate->world_wakeup_links);
+
+    pystate->refowner_lock = NULL;
+    pystate->refowner_waiting_lock = NULL;
+    pystate->refowner_waiting_flag = 0;
+
+    pystate->suspended = 1;
+
+    pystate->enterframe = NULL;
+
+    pystate->dict = NULL;
+
+    pystate->curexc_type = NULL;
+    pystate->curexc_value = NULL;
+    pystate->curexc_traceback = NULL;
+
+    pystate->exc_type = NULL;
+    pystate->exc_value = NULL;
+    pystate->exc_traceback = NULL;
+
+    pystate->c_profilefunc = NULL;
+    pystate->c_tracefunc = NULL;
+    pystate->c_profileobj = NULL;
+    pystate->c_traceobj = NULL;
+
+    pystate->import_depth = 0;
+    PyLinkedList_InitBase(&pystate->monitorspaces,
+        offsetof(PyMonitorSpaceFrame, links));
+
+    for (i = 0; i < PYMALLOC_CACHE_SIZECLASSES; i++) {
+        for (j = 0; j < PYMALLOC_CACHE_COUNT; j++)
+            pystate->malloc_cache[i][j] = NULL;
+    }
+
+    for (i = 0; i < PYGC_CACHE_SIZECLASSES; i++) {
+        for (j = 0; j < PYGC_CACHE_COUNT; j++)
+            pystate->gc_object_cache[i][j] = NULL;
+    }
+
+    for (i = 0; i < Py_ASYNCREFCOUNT_TABLE; i ++) {
+        pystate->async_refcounts[i].obj = NULL;
+        pystate->async_refcounts[i].diff = 0;
+    }
+
+    PyLinkedList_InitBase(&pystate->cancel_stack,
+        offsetof(PyCancelObject, stack_links));
+
+    pystate->critical_section = NULL;
+
+    //pystate->active_lock = NULL;
+    //pystate->lockwait_prev = NULL;
+    //pystate->lockwait_next = NULL;
+    //pystate->lockwait_cond = NULL;
+    pystate->waitfor.self = pystate;
+    pystate->waitfor.blocker = NULL;
+    PyLinkedList_InitNode(&pystate->monitorspace_waitinglinks);
+    pystate->waitfor.checking_deadlock = 0;
+    pystate->waitfor.abortfunc = NULL;
+    PyLinkedList_InitNode(&pystate->waitfor.inspection_links);
+
+    PyLinkedList_InitNode(&pystate->condition_links);
+
+    pystate->cancel_crit = PyCritical_Allocate(PyCRITICAL_CANCEL);
+    //pystate->lockwait_cond = PyThread_cond_allocate();
+    pystate->monitorspace_timeout = PyThread_timeout_allocate();
+    pystate->waitfor.lock = PyThread_lock_allocate();
+    pystate->monitorspace_waitingflag = PyThread_flag_allocate();
+    pystate->condition_flag = PyThread_flag_allocate();
+    pystate->thread_lock = PyThread_lock_allocate();
+    pystate->world_wakeup = PyThread_sem_allocate(0);
+
+    pystate->refowner_lock = PyThread_lock_allocate();
+    pystate->refowner_waiting_lock = PyThread_lock_allocate();
+
+    if (!pystate->cancel_crit || !pystate->monitorspace_timeout ||
+            !pystate->waitfor.lock || !pystate->monitorspace_waitingflag ||
+            !pystate->condition_flag || !pystate->thread_lock ||
+            !pystate->world_wakeup || !pystate->refowner_lock ||
+            !pystate->refowner_waiting_lock)
+        goto failed;
+
+    //printf("New pystate %p\n", pystate);
+    return pystate;
+
+failed:
+    if (pystate->cancel_crit)
+        PyCritical_Free(pystate->cancel_crit);
+    //if (pystate->lockwait_cond)
+    //    PyThread_cond_free(pystate->lockwait_cond);
+    if (pystate->monitorspace_timeout)
+        PyThread_timeout_free(pystate->monitorspace_timeout);
+    if (pystate->waitfor.lock)
+        PyThread_lock_free(pystate->waitfor.lock);
+    if (pystate->monitorspace_waitingflag)
+        PyThread_flag_free(pystate->monitorspace_waitingflag);
+    if (pystate->condition_flag)
+        PyThread_flag_free(pystate->condition_flag);
+    if (pystate->thread_lock)
+        PyThread_lock_free(pystate->thread_lock);
+    if (pystate->world_wakeup)
+        PyThread_sem_free(pystate->world_wakeup);
+
+    if (pystate->refowner_lock)
+        PyThread_lock_free(pystate->refowner_lock);
+    if (pystate->refowner_waiting_lock)
+        PyThread_lock_free(pystate->refowner_waiting_lock);
+    free(pystate);
+    return NULL;
+}
+
+void
+_PyState_Delete(PyState *pystate)
+{
+    if (pystate->used)
+        Py_FatalError("Cannot delete used PyState");
+
+    assert(pystate->critical_section == NULL);
+    assert(pystate->suspended);
+    assert(PyLinkedList_Empty(&pystate->monitorspaces));
+    assert(pystate->enterframe == NULL);
+    assert(pystate->waitfor.blocker == NULL);
+    assert(PyLinkedList_Detached(&pystate->monitorspace_waitinglinks));
+    assert(pystate->waitfor.checking_deadlock == 0);
+    assert(PyLinkedList_Detached(&pystate->waitfor.inspection_links));
+    assert(PyLinkedList_Detached(&pystate->condition_links));
+    assert(!pystate->deleted);
+
+    /* pystate was never bound, or the tracing GC has cleaned it up */
+    /* XXX FIXME nothing currently does this, and they're never
+     * removed from the linked list */
+    //fprintf(stderr, "Deleting pystate %p\n", pystate);
+    PyCritical_Free(pystate->cancel_crit);
+    //PyThread_cond_free(pystate->lockwait_cond);
+    PyThread_timeout_free(pystate->monitorspace_timeout);
+    PyThread_lock_free(pystate->waitfor.lock);
+    PyThread_flag_free(pystate->monitorspace_waitingflag);
+    PyThread_flag_free(pystate->condition_flag);
+    PyThread_lock_free(pystate->thread_lock);
+    PyThread_sem_free(pystate->world_wakeup);
+
+    PyThread_lock_free(pystate->refowner_lock);
+    PyThread_lock_free(pystate->refowner_waiting_lock);
+    free(pystate);
+}
+
+static void
+_PyState_Bind(PyState *pystate)
+{
+    assert(autoTLSkey);
+    if (PyThread_get_key_value(autoTLSkey) != 0)
+        Py_FatalError("Thread already has PyState");
+
+    assert(!pystate->used);
+    assert(pystate->deleted == 0);
+    pystate->used = 1;
+    PyThread_set_key_value(autoTLSkey, pystate);
+#ifdef HAVE_THREAD_LOCAL_VARIABLE
+    _py_local_pystate = pystate;
+#endif
+
+    AO_fetch_and_add1_full(&thread_count);
+
+    PyThread_lock_acquire(world_lock);
+    pystate->next = pystate_head;
+    pystate_head = pystate;
+    PyThread_lock_release(world_lock);
+}
+
+/* Undoes the work of _New, _Bind, and _Resume */
+static void
+_PyState_Terminate(PyState *pystate)
+{
+    assert(pystate != NULL && pystate == PyState_Get());
+    assert(!pystate->suspended);
+    assert(PyLinkedList_Empty(&pystate->monitorspaces));
+    assert(pystate->enterframe == NULL);
+    assert(pystate->used);
+    assert(!pystate->deleted);
+
+    _PyGC_Object_Cache_Flush();
+    _PyGC_AsyncRefcount_Flush(pystate);
+
+    /* Undo _Bind */
+    AO_fetch_and_sub1_full(&thread_count);
+    PyThread_delete_key_value(autoTLSkey);
+#ifdef HAVE_THREAD_LOCAL_VARIABLE
+    _py_local_pystate = NULL;
+#endif
+
+    /* Indirectly undo _New.  The tracing GC will do the real work. */
+    pystate->deleted = 1;
+
+    /* Undo _Resume */
+    pystate->suspended = 1;
+    PyThread_lock_release(pystate->refowner_lock);
+    PyThread_lock_release(pystate->thread_lock);
+}
+
+static void
+_PyState_Clear(PyState *pystate)
+{
+    Py_CLEAR(pystate->frame);
+
+    Py_CLEAR(pystate->dict);
+
+    Py_CLEAR(pystate->curexc_type);
+    Py_CLEAR(pystate->curexc_value);
+    Py_CLEAR(pystate->curexc_traceback);
+
+    Py_CLEAR(pystate->exc_type);
+    Py_CLEAR(pystate->exc_value);
+    Py_CLEAR(pystate->exc_traceback);
+
+    pystate->c_profilefunc = NULL;
+    pystate->c_tracefunc = NULL;
+    Py_CLEAR(pystate->c_profileobj);
+    Py_CLEAR(pystate->c_traceobj);
+}
+
+
+PyState *
+_PyState_Get(void)
+{
+#ifdef HAVE_THREAD_LOCAL_VARIABLE
+    PyState *pystate = _py_local_pystate;
 #else
-		tstate->thread_id = 0;
-#endif
-
-		tstate->dict = NULL;
-
-		tstate->curexc_type = NULL;
-		tstate->curexc_value = NULL;
-		tstate->curexc_traceback = NULL;
-
-		tstate->exc_type = NULL;
-		tstate->exc_value = NULL;
-		tstate->exc_traceback = NULL;
-
-		tstate->c_profilefunc = NULL;
-		tstate->c_tracefunc = NULL;
-		tstate->c_profileobj = NULL;
-		tstate->c_traceobj = NULL;
-
-#ifdef WITH_THREAD
-		_PyGILState_NoteThreadState(tstate);
-#endif
-
-		HEAD_LOCK();
-		tstate->next = interp->tstate_head;
-		interp->tstate_head = tstate;
-		HEAD_UNLOCK();
-	}
-
-	return tstate;
-}
-
-
-void
-PyThreadState_Clear(PyThreadState *tstate)
-{
-	if (Py_VerboseFlag && tstate->frame != NULL)
-		fprintf(stderr,
-		  "PyThreadState_Clear: warning: thread still has a frame\n");
-
-	Py_CLEAR(tstate->frame);
-
-	Py_CLEAR(tstate->dict);
-	Py_CLEAR(tstate->async_exc);
-
-	Py_CLEAR(tstate->curexc_type);
-	Py_CLEAR(tstate->curexc_value);
-	Py_CLEAR(tstate->curexc_traceback);
-
-	Py_CLEAR(tstate->exc_type);
-	Py_CLEAR(tstate->exc_value);
-	Py_CLEAR(tstate->exc_traceback);
-
-	tstate->c_profilefunc = NULL;
-	tstate->c_tracefunc = NULL;
-	Py_CLEAR(tstate->c_profileobj);
-	Py_CLEAR(tstate->c_traceobj);
-}
-
-
-/* Common code for PyThreadState_Delete() and PyThreadState_DeleteCurrent() */
-static void
-tstate_delete_common(PyThreadState *tstate)
-{
-	PyInterpreterState *interp;
-	PyThreadState **p;
-	PyThreadState *prev_p = NULL;
-	if (tstate == NULL)
-		Py_FatalError("PyThreadState_Delete: NULL tstate");
-	interp = tstate->interp;
-	if (interp == NULL)
-		Py_FatalError("PyThreadState_Delete: NULL interp");
-	HEAD_LOCK();
-	for (p = &interp->tstate_head; ; p = &(*p)->next) {
-		if (*p == NULL)
-			Py_FatalError(
-				"PyThreadState_Delete: invalid tstate");
-		if (*p == tstate)
-			break;
-		if (*p == prev_p)
-			Py_FatalError(
-				"PyThreadState_Delete: small circular list(!)"
-                                " and tstate not found.");
-		prev_p = *p;
-		if ((*p)->next == interp->tstate_head)
-			Py_FatalError(
-				"PyThreadState_Delete: circular list(!) and"
-                                " tstate not found.");
-	}
-	*p = tstate->next;
-	HEAD_UNLOCK();
-	free(tstate);
-}
-
-
-void
-PyThreadState_Delete(PyThreadState *tstate)
-{
-	if (tstate == _PyThreadState_Current)
-		Py_FatalError("PyThreadState_Delete: tstate is still current");
-	tstate_delete_common(tstate);
-#ifdef WITH_THREAD
-	if (autoTLSkey && PyThread_get_key_value(autoTLSkey) == tstate)
-		PyThread_delete_key_value(autoTLSkey);
-#endif /* WITH_THREAD */
-}
-
-
-#ifdef WITH_THREAD
-void
-PyThreadState_DeleteCurrent()
-{
-	PyThreadState *tstate = _PyThreadState_Current;
-	if (tstate == NULL)
-		Py_FatalError(
-			"PyThreadState_DeleteCurrent: no current tstate");
-	_PyThreadState_Current = NULL;
-	tstate_delete_common(tstate);
-	if (autoTLSkey && PyThread_get_key_value(autoTLSkey) == tstate)
-		PyThread_delete_key_value(autoTLSkey);
-	PyEval_ReleaseLock();
-}
-#endif /* WITH_THREAD */
-
-
-PyThreadState *
-PyThreadState_Get(void)
-{
-	if (_PyThreadState_Current == NULL)
-		Py_FatalError("PyThreadState_Get: no current thread");
-
-	return _PyThreadState_Current;
-}
-
-
-PyThreadState *
-PyThreadState_Swap(PyThreadState *newts)
-{
-	PyThreadState *oldts = _PyThreadState_Current;
-
-	_PyThreadState_Current = newts;
-	/* It should not be possible for more than one thread state
-	   to be used for a thread.  Check this the best we can in debug
-	   builds.
-	*/
-#if defined(Py_DEBUG) && defined(WITH_THREAD)
-	if (newts) {
-		/* This can be called from PyEval_RestoreThread(). Similar
-		   to it, we need to ensure errno doesn't change.
-		*/
-		int err = errno;
-		PyThreadState *check = PyGILState_GetThisThreadState();
-		if (check && check->interp == newts->interp && check != newts)
-			Py_FatalError("Invalid thread state for this thread");
-		errno = err;
-	}
-#endif
-	return oldts;
-}
+    PyState *pystate = PyThread_get_key_value(autoTLSkey);
+#endif
+    if (pystate == NULL)
+        Py_FatalError("PyState_Get: no current thread");
+    return pystate;
+}
+
 
 /* An extension mechanism to store arbitrary additional per-thread state.
-   PyThreadState_GetDict() returns a dictionary that can be used to hold such
+   PyState_GetDict() returns a dictionary that can be used to hold such
    state; the caller should pick a unique key and store its state there.  If
-   PyThreadState_GetDict() returns NULL, an exception has *not* been raised
+   PyState_GetDict() returns NULL, an exception has *not* been raised
    and the caller should assume no per-thread state is available. */
 
 PyObject *
-PyThreadState_GetDict(void)
-{
-	if (_PyThreadState_Current == NULL)
-		return NULL;
-
-	if (_PyThreadState_Current->dict == NULL) {
-		PyObject *d;
-		_PyThreadState_Current->dict = d = PyDict_New();
-		if (d == NULL)
-			PyErr_Clear();
-	}
-	return _PyThreadState_Current->dict;
-}
-
-
-/* Asynchronously raise an exception in a thread.
-   Requested by Just van Rossum and Alex Martelli.
-   To prevent naive misuse, you must write your own extension
-   to call this, or use ctypes.  Must be called with the GIL held.
-   Returns the number of tstates modified (normally 1, but 0 if `id` didn't
-   match any known thread id).  Can be called with exc=NULL to clear an
-   existing async exception.  This raises no exceptions. */
-
-int
-PyThreadState_SetAsyncExc(long id, PyObject *exc) {
-	PyThreadState *tstate = PyThreadState_GET();
-	PyInterpreterState *interp = tstate->interp;
-	PyThreadState *p;
-
-	/* Although the GIL is held, a few C API functions can be called
-	 * without the GIL held, and in particular some that create and
-	 * destroy thread and interpreter states.  Those can mutate the
-	 * list of thread states we're traversing, so to prevent that we lock
-	 * head_mutex for the duration.
-	 */
-	HEAD_LOCK();
-	for (p = interp->tstate_head; p != NULL; p = p->next) {
-		if (p->thread_id == id) {
-			/* Tricky:  we need to decref the current value
-			 * (if any) in p->async_exc, but that can in turn
-			 * allow arbitrary Python code to run, including
-			 * perhaps calls to this function.  To prevent
-			 * deadlock, we need to release head_mutex before
-			 * the decref.
-			 */
-			PyObject *old_exc = p->async_exc;
-			Py_XINCREF(exc);
-			p->async_exc = exc;
-			HEAD_UNLOCK();
-			Py_XDECREF(old_exc);
-			return 1;
-		}
-	}
-	HEAD_UNLOCK();
-	return 0;
-}
-
-
-/* Routines for advanced debuggers, requested by David Beazley.
-   Don't use unless you know what you are doing! */
-
-PyInterpreterState *
-PyInterpreterState_Head(void)
-{
-	return interp_head;
-}
-
-PyInterpreterState *
-PyInterpreterState_Next(PyInterpreterState *interp) {
-	return interp->next;
-}
-
-PyThreadState *
-PyInterpreterState_ThreadHead(PyInterpreterState *interp) {
-	return interp->tstate_head;
-}
-
-PyThreadState *
-PyThreadState_Next(PyThreadState *tstate) {
-	return tstate->next;
-}
-
-/* The implementation of sys._current_frames().  This is intended to be
-   called with the GIL held, as it will be when called via
-   sys._current_frames().  It's possible it would work fine even without
-   the GIL held, but haven't thought enough about that.
-*/
-PyObject *
-_PyThread_CurrentFrames(void)
-{
-	PyObject *result;
-	PyInterpreterState *i;
-
-	result = PyDict_New();
-	if (result == NULL)
-		return NULL;
-
-	/* for i in all interpreters:
-	 *     for t in all of i's thread states:
-	 *          if t's frame isn't NULL, map t's id to its frame
-	 * Because these lists can mutute even when the GIL is held, we
-	 * need to grab head_mutex for the duration.
-	 */
-	HEAD_LOCK();
-	for (i = interp_head; i != NULL; i = i->next) {
-		PyThreadState *t;
-		for (t = i->tstate_head; t != NULL; t = t->next) {
-			PyObject *id;
-			int stat;
-			struct _frame *frame = t->frame;
-			if (frame == NULL)
-				continue;
-			id = PyLong_FromLong(t->thread_id);
-			if (id == NULL)
-				goto Fail;
-			stat = PyDict_SetItem(result, id, (PyObject *)frame);
-			Py_DECREF(id);
-			if (stat < 0)
-				goto Fail;
-		}
-	}
-	HEAD_UNLOCK();
-	return result;
-
- Fail:
- 	HEAD_UNLOCK();
- 	Py_DECREF(result);
- 	return NULL;
-}
-
-/* Python "auto thread state" API. */
-#ifdef WITH_THREAD
-
-/* Keep this as a static, as it is not reliable!  It can only
-   ever be compared to the state for the *current* thread.
-   * If not equal, then it doesn't matter that the actual
-     value may change immediately after comparison, as it can't
-     possibly change to the current thread's state.
-   * If equal, then the current thread holds the lock, so the value can't
-     change until we yield the lock.
-*/
-static int
-PyThreadState_IsCurrent(PyThreadState *tstate)
-{
-	/* Must be the tstate for this thread */
-	assert(PyGILState_GetThisThreadState()==tstate);
-	/* On Windows at least, simple reads and writes to 32 bit values
-	   are atomic.
-	*/
-	return tstate == _PyThreadState_Current;
+PyState_GetDict(void)
+{
+#ifdef HAVE_THREAD_LOCAL_VARIABLE
+    PyState *pystate = _py_local_pystate;
+#else
+    PyState *pystate = PyThread_get_key_value(autoTLSkey);
+#endif
+    if (pystate == NULL)
+        return NULL;
+
+    if (pystate->dict == NULL) {
+        PyObject *d;
+        pystate->dict = d = PyDict_New();
+        if (d == NULL)
+            PyErr_Clear();
+    }
+    return pystate->dict;
+}
+
+
+PyState_EnterFrame *
+PyState_Enter(void)
+{
+    PyState_EnterFrame *frame;
+
+    frame = malloc(sizeof(PyState_EnterFrame));
+    if (frame == NULL)
+        return NULL;
+
+    if (_PyState_EnterPreallocated(frame, NULL)) {
+        free(frame);
+        return NULL;
+    }
+
+    return frame;
+}
+
+int
+_PyState_EnterPreallocated(PyState_EnterFrame *frame, PyState *pystate)
+{
+#ifdef HAVE_THREAD_LOCAL_VARIABLE
+    PyState *old_pystate = _py_local_pystate;
+#else
+    PyState *old_pystate = PyThread_get_key_value(autoTLSkey);
+#endif
+
+    if (old_pystate == NULL) {
+        /* Create a new thread state for this thread */
+        if (pystate == NULL) {
+            pystate = _PyState_New();
+            if (pystate == NULL)
+                return 1;
+        }
+
+        _PyState_Bind(pystate);
+    } else {
+        if (pystate != NULL)
+            Py_FatalError("Unexpected new_pystate");
+        pystate = old_pystate;
+
+        if (pystate->enterframe->locked)
+            PyState_Suspend();
+    }
+
+    PyLinkedList_InitNode(&frame->monitorspaceframe.links);
+    frame->prevframe = pystate->enterframe;
+    pystate->enterframe = frame;
+    frame->locked = 0;
+    PyLinkedList_Append(&pystate->monitorspaces,
+        &frame->monitorspaceframe);
+    frame->monitorspaceframe.monitorspace = NULL;
+
+    PyState_Resume();
+    return 0;
+}
+
+void
+PyState_Exit(PyState_EnterFrame *frame)
+{
+    _PyState_ExitPreallocated(frame);
+    free(frame);
+}
+
+/* This consumes the pystate originally passed in to
+ * _PyState_EnterPreallocated, if any */
+void
+_PyState_ExitPreallocated(PyState_EnterFrame *frame)
+{
+    PyState *pystate = PyState_Get();
+
+    if (frame != pystate->enterframe)
+        Py_FatalError("PyState_Exit called with wrong frame");
+    if (pystate->suspended)
+        Py_FatalError("PyState_Exit called while suspended");
+    if (!frame->locked)
+        Py_FatalError("PyState_Exit called in an unlocked state");
+
+    if (frame->prevframe == NULL) {
+        assert(PyLinkedList_Empty(&pystate->cancel_stack));
+
+        assert(PyLinkedList_Last(&pystate->monitorspaces) ==
+            &frame->monitorspaceframe);
+        Py_CLEAR(frame->monitorspaceframe.monitorspace);
+        _PyState_Clear(pystate);
+
+        assert(frame->monitorspaceframe.monitorspace == NULL);
+        PyLinkedList_Remove(&frame->monitorspaceframe.links);
+        pystate->enterframe = frame->prevframe;
+
+        _PyState_Terminate(pystate);
+    } else {
+        PyState_Suspend();
+#warning XXX FIXME ExitPreallocated should not suspend at this point!
+
+        assert(PyLinkedList_Last(&pystate->monitorspaces) ==
+            &frame->monitorspaceframe);
+        PyLinkedList_Remove(&frame->monitorspaceframe.links);
+        Py_XDECREF(frame->monitorspaceframe.monitorspace);
+
+        pystate->enterframe = frame->prevframe;
+
+        if (pystate->enterframe->locked)
+            PyState_Resume();
+    }
+}
+
+
+void
+PyState_EnterImport(void)
+{
+    PyState *pystate = PyState_Get();
+
+    pystate->import_depth++;
+}
+
+void
+PyState_ExitImport(void)
+{
+    PyState *pystate = PyState_Get();
+
+    pystate->import_depth--;
+    assert(pystate->import_depth >= 0);
+}
+
+
+/* Stops all other threads from accessing their PyState */
+void
+PyState_StopTheWorld(void)
+{
+    PyState *t;
+    PyState *pystate = PyState_Get();
+
+    //fprintf(stderr, "%p Stopping the world\n", pystate);
+    assert(!pystate->suspended);
+    if (pystate->critical_section != NULL)
+        Py_FatalError("PyState_StopTheWorld cannot be called while in "
+            "a critical section");
+
+    PyState_Suspend();
+    PyThread_lock_acquire(world_lock);
+    AO_store_full(&world_sleep, 1);
+
+    t = pystate_head;
+    while (t != NULL) {
+        if (t != pystate)
+            PyThread_lock_acquire(t->thread_lock);
+        t = t->next;
+    }
+
+    PyState_Resume();
+}
+
+void
+PyState_StartTheWorld(void)
+{
+    PyState *t;
+    PyState *pystate = PyState_Get();
+
+    //fprintf(stderr, "%p Starting the world\n", pystate);
+    AO_store_full(&world_sleep, 0);
+
+    t = pystate_head;
+    while (t != NULL) {
+        if (t != pystate)
+            PyThread_lock_release(t->thread_lock);
+        t = t->next;
+    }
+
+    PyThread_lock_acquire(world_wakeup_lock);
+
+    while (!PyLinkedList_Empty(&world_wakeup_list)) {
+        t = PyLinkedList_First(&world_wakeup_list);
+        assert(t != pystate);
+        PyLinkedList_Remove(&t->world_wakeup_links);
+        PyThread_sem_release(t->world_wakeup);
+    }
+
+    PyThread_lock_release(world_wakeup_lock);
+
+    PyThread_lock_release(world_lock);
+}
+
+
+void
+PyState_Suspend(void)
+{
+    PyState *pystate = PyState_Get();
+    if (pystate->critical_section != NULL)
+        Py_FatalError("PyState_Suspend called while in a critical section");
+    PyState_MaybeSuspend();
+}
+
+void
+PyState_Resume(void)
+{
+    PyState *pystate = PyState_Get();
+    if (pystate->critical_section != NULL)
+        Py_FatalError("PyState_Resume called while in a critical section");
+    PyState_MaybeResume();
+}
+
+void
+PyState_MaybeSuspend(void)
+{
+    int err = errno;
+    PyState *pystate = PyState_Get();
+
+    //fprintf(stderr, "%p Suspending\n", pystate);
+    assert(!pystate->suspended);
+    pystate->suspended = 1;
+    pystate->enterframe->locked = 0;
+    PyThread_lock_release(pystate->refowner_lock);
+    /* XXX FIXME add a SuspendRefowner that doesn't release thread_lock? */
+    if (pystate->critical_section == NULL)
+        PyThread_lock_release(pystate->thread_lock);
+    //fprintf(stderr, "%p Suspended\n", pystate);
+
+    errno = err;
+}
+
+void
+PyState_MaybeResume(void)
+{
+    int err = errno;
+    PyState *pystate = PyState_Get();
+
+    //fprintf(stderr, "%p Resuming\n", pystate);
+    assert(pystate->suspended);
+    if (pystate->critical_section == NULL)
+        PyThread_lock_acquire(pystate->thread_lock);
+    PyThread_lock_acquire(pystate->refowner_lock);
+    pystate->suspended = 0;
+    pystate->enterframe->locked = 1;
+    //fprintf(stderr, "%p Resumed\n", pystate);
+
+    errno = err;
+}
+
+
+/* Do periodic things.  This is called from the main event loop, so we
+ * take care to reduce the per-call costs. */
+int
+PyState_Tick(void)
+{
+    PyState *pystate = PyState_Get();
+
+    if (pystate->critical_section != NULL)
+        Py_FatalError("PyState_Tick called while in critical section");
+
+    if (AO_load_acquire(&world_sleep)) {
+        PyThread_lock_acquire(world_wakeup_lock);
+        PyLinkedList_Append(&world_wakeup_list, pystate);
+        PyThread_lock_release(world_wakeup_lock);
+
+        PyThread_lock_release(pystate->refowner_lock);
+        PyThread_lock_release(pystate->thread_lock);
+
+        PyThread_sem_acquire(pystate->world_wakeup);
+
+        PyThread_lock_acquire(pystate->thread_lock);
+        PyThread_lock_acquire(pystate->refowner_lock);
+    } else if (AO_load_acquire(&pystate->refowner_waiting_flag)) {
+#if 0
+        PyState_Suspend();
+        PyState_Resume();
+#else
+        PyThread_lock_release(pystate->refowner_lock);
+        PyThread_lock_acquire(pystate->refowner_waiting_lock);
+        PyThread_lock_acquire(pystate->refowner_lock);
+        PyThread_lock_release(pystate->refowner_waiting_lock);
+#endif
+    }
+
+#if 0
+    if (pystate->small_ticks > 0) {
+        pystate->small_ticks--;
+        return 0;
+    } else {
+        PyState_Suspend();
+        PyState_Resume();
+
+        pystate->large_ticks++;
+        pystate->small_ticks = _Py_CheckInterval; /* XXX use atomic access? */
+
+        return 0;
+    }
+#endif
+    return 0;
+}
+
+
+PyCritical *
+PyCritical_Allocate(Py_ssize_t depth)
+{
+    PyCritical *crit = malloc(sizeof(PyCritical));
+    if (crit == NULL)
+        return NULL;
+
+    crit->lock = PyThread_lock_allocate();
+    if (!crit->lock) {
+        free(crit);
+        return NULL;
+    }
+
+    crit->depth = depth;
+    crit->prev = NULL;
+
+    return crit;
+}
+
+void
+PyCritical_Free(PyCritical *crit)
+{
+    PyThread_lock_free(crit->lock);
+    free(crit);
+}
+
+void
+PyCritical_Enter(PyCritical *crit)
+{
+    PyState *pystate = PyState_Get();
+
+    assert(!pystate->suspended);
+    assert(crit->lock != NULL);
+
+    if (pystate->critical_section != NULL &&
+                pystate->critical_section->depth <= crit->depth)
+        Py_FatalError("PyCritical_Enter called while already in deeper "
+            "critical section");
+
+    if (!PyThread_lock_tryacquire(crit->lock)) {
+        PyState_MaybeSuspend();
+        PyThread_lock_acquire(crit->lock);
+        PyState_MaybeResume();
+    }
+
+    assert(crit->prev == NULL);
+    crit->prev = pystate->critical_section;
+    pystate->critical_section = crit;
+}
+
+void
+PyCritical_Exit(PyCritical *crit)
+{
+    PyState *pystate = PyState_Get();
+
+    assert(!pystate->suspended);
+    assert(crit->lock != NULL);
+
+    if (pystate->critical_section != crit)
+        Py_FatalError("PyCritical_Exit called with wrong critical section");
+
+    pystate->critical_section = crit->prev;
+    crit->prev = NULL;
+
+    PyThread_lock_release(crit->lock);
+}
+
+void
+PyCritical_EnterDummy(PyCritical *crit, Py_ssize_t depth)
+{
+    PyState *pystate = PyState_Get();
+
+    assert(!pystate->suspended);
+
+    crit->lock = NULL;
+    crit->depth = depth;
+    crit->prev = NULL;
+
+    if (pystate->critical_section != NULL &&
+                pystate->critical_section->depth <= crit->depth)
+        Py_FatalError("PyCritical_EnterDummy called while already in "
+            "deeper critical section");
+
+    assert(crit->prev == NULL);
+    crit->prev = pystate->critical_section;
+    pystate->critical_section = crit;
+}
+
+void
+PyCritical_ExitDummy(PyCritical *crit)
+{
+    PyState *pystate = PyState_Get();
+
+    assert(!pystate->suspended);
+    assert(crit->lock == NULL);
+
+    if (pystate->critical_section != crit)
+        Py_FatalError("PyCritical_ExitDummy called with wrong critical "
+            "section");
+
+    pystate->critical_section = crit->prev;
+    crit->prev = NULL;
+}
+
+/* This is just a bodge for deathqueue_wait.  It shouldn't be used in general */
+void
+_PyCritical_CondWait(PyCritical *crit, PyThread_type_cond *cond)
+{
+    PyState *pystate = PyState_Get();
+
+    assert(!pystate->suspended);
+
+    if (pystate->critical_section != crit)
+        Py_FatalError("_PyCritical_CondWait called with wrong "
+            "critical section");
+
+    if (crit->prev != NULL)
+        Py_FatalError("_PyCritical_CondWait called while in nested "
+            "critical section");
+
+    pystate->critical_section = crit->prev;
+    crit->prev = NULL;
+    PyState_Suspend();
+
+#warning FIXME _PyCritical_CondWait should be cancellable
+    PyThread_cond_wait(cond, crit->lock);
+
+    PyState_Resume();
+    crit->prev = pystate->critical_section;
+    pystate->critical_section = crit;
+}
+
+
+extern PyState * (*pymalloc_pystate_hook)(void);
+
+void
+_PyState_InitThreads(void)
+{
+    PyLinkedList_InitBase(&world_wakeup_list, offsetof(PyState, world_wakeup_links));
+    world_lock = PyThread_lock_allocate();
+    world_wakeup_lock = PyThread_lock_allocate();
+    autoTLSkey = PyThread_create_key();
+    if (!world_lock || !world_wakeup_lock || !autoTLSkey)
+        Py_FatalError("Allocation failed in _PyState_InitThreads");
+    pymalloc_pystate_hook = PyState_Get;
+}
+
+void
+_PyState_ClearThreads(void)
+{
+    PyState *pystate;
+
+    if (!_PyState_SingleThreaded())
+        Py_FatalError("_PyState_ClearThreads should only be called with 1 thread left");
+
+    /* If this blocks, something is seriously wrong */
+    PyThread_lock_acquire(world_lock);
+    for (pystate = pystate_head; pystate != NULL; pystate = pystate->next)
+        _PyState_Clear(pystate);
+    PyThread_lock_release(world_lock);
+}
+
+void
+_PyState_FlushAsyncRefcounts(void)
+{
+    PyState *pystate;
+
+    /* This should only be called with the world stopped */
+    for (pystate = pystate_head; pystate != NULL; pystate = pystate->next)
+        _PyGC_AsyncRefcount_Flush(pystate);
 }
 
 /* Internal initialization/finalization functions called by
    Py_Initialize/Py_Finalize
 */
 void
-_PyGILState_Init(PyInterpreterState *i, PyThreadState *t)
-{
-	assert(i && t); /* must init with valid states */
-	autoTLSkey = PyThread_create_key();
-	autoInterpreterState = i;
-	assert(PyThread_get_key_value(autoTLSkey) == NULL);
-	assert(t->gilstate_counter == 0);
-
-	_PyGILState_NoteThreadState(t);
-}
-
-void
-_PyGILState_Fini(void)
-{
-	PyThread_delete_key(autoTLSkey);
-	autoTLSkey = 0;
-	autoInterpreterState = NULL;
-}
-
-/* When a thread state is created for a thread by some mechanism other than
-   PyGILState_Ensure, it's important that the GILState machinery knows about
-   it so it doesn't try to create another thread state for the thread (this is
-   a better fix for SF bug #1010677 than the first one attempted).
-*/
-static void
-_PyGILState_NoteThreadState(PyThreadState* tstate)
-{
-	/* If autoTLSkey is 0, this must be the very first threadstate created
-	   in Py_Initialize().  Don't do anything for now (we'll be back here
-	   when _PyGILState_Init is called). */
-	if (!autoTLSkey)
-		return;
-
-	/* Stick the thread state for this thread in thread local storage.
-
-	   The only situation where you can legitimately have more than one
-	   thread state for an OS level thread is when there are multiple
-	   interpreters, when:
-
-	       a) You shouldn't really be using the PyGILState_ APIs anyway,
-	          and:
-
-	       b) The slightly odd way PyThread_set_key_value works (see
-	          comments by its implementation) means that the first thread
-	          state created for that given OS level thread will "win",
-	          which seems reasonable behaviour.
-	*/
-	if (PyThread_set_key_value(autoTLSkey, (void *)tstate) < 0)
-		Py_FatalError("Couldn't create autoTLSkey mapping");
-
-	/* PyGILState_Release must not try to delete this thread state. */
-	tstate->gilstate_counter = 1;
-}
-
-/* The public functions */
-PyThreadState *
-PyGILState_GetThisThreadState(void)
-{
-	if (autoInterpreterState == NULL || autoTLSkey == 0)
-		return NULL;
-	return (PyThreadState *)PyThread_get_key_value(autoTLSkey);
-}
-
-PyGILState_STATE
-PyGILState_Ensure(void)
-{
-	int current;
-	PyThreadState *tcur;
-	/* Note that we do not auto-init Python here - apart from
-	   potential races with 2 threads auto-initializing, pep-311
-	   spells out other issues.  Embedders are expected to have
-	   called Py_Initialize() and usually PyEval_InitThreads().
-	*/
-	assert(autoInterpreterState); /* Py_Initialize() hasn't been called! */
-	tcur = (PyThreadState *)PyThread_get_key_value(autoTLSkey);
-	if (tcur == NULL) {
-		/* Create a new thread state for this thread */
-		tcur = PyThreadState_New(autoInterpreterState);
-		if (tcur == NULL)
-			Py_FatalError("Couldn't create thread-state for new thread");
-		/* This is our thread state!  We'll need to delete it in the
-		   matching call to PyGILState_Release(). */
-		tcur->gilstate_counter = 0;
-		current = 0; /* new thread state is never current */
-	}
-	else
-		current = PyThreadState_IsCurrent(tcur);
-	if (current == 0)
-		PyEval_RestoreThread(tcur);
-	/* Update our counter in the thread-state - no need for locks:
-	   - tcur will remain valid as we hold the GIL.
-	   - the counter is safe as we are the only thread "allowed"
-	     to modify this value
-	*/
-	++tcur->gilstate_counter;
-	return current ? PyGILState_LOCKED : PyGILState_UNLOCKED;
-}
-
-void
-PyGILState_Release(PyGILState_STATE oldstate)
-{
-	PyThreadState *tcur = (PyThreadState *)PyThread_get_key_value(
-                                                                autoTLSkey);
-	if (tcur == NULL)
-		Py_FatalError("auto-releasing thread-state, "
-		              "but no thread-state for this thread");
-	/* We must hold the GIL and have our thread state current */
-	/* XXX - remove the check - the assert should be fine,
-	   but while this is very new (April 2003), the extra check
-	   by release-only users can't hurt.
-	*/
-	if (! PyThreadState_IsCurrent(tcur))
-		Py_FatalError("This thread state must be current when releasing");
-	assert(PyThreadState_IsCurrent(tcur));
-	--tcur->gilstate_counter;
-	assert(tcur->gilstate_counter >= 0); /* illegal counter value */
-
-	/* If we're going to destroy this thread-state, we must
-	 * clear it while the GIL is held, as destructors may run.
-	 */
-	if (tcur->gilstate_counter == 0) {
-		/* can't have been locked when we created it */
-		assert(oldstate == PyGILState_UNLOCKED);
-		PyThreadState_Clear(tcur);
-		/* Delete the thread-state.  Note this releases the GIL too!
-		 * It's vital that the GIL be held here, to avoid shutdown
-		 * races; see bugs 225673 and 1061968 (that nasty bug has a
-		 * habit of coming back).
-		 */
-		PyThreadState_DeleteCurrent();
-	}
-	/* Release the lock if necessary */
-	else if (oldstate == PyGILState_UNLOCKED)
-		PyEval_SaveThread();
-}
+_PyState_Fini(void)
+{
+    PyThread_delete_key(autoTLSkey);
+    autoTLSkey = 0;
+}
+
 
 #ifdef __cplusplus
 }
 #endif
-
-#endif /* WITH_THREAD */
-
-

=== modified file 'Python/pythonrun.c'
--- Python/pythonrun.c	2008-04-10 21:03:09 +0000
+++ Python/pythonrun.c	2008-04-11 05:40:41 +0000
@@ -17,6 +17,7 @@
 #include "ast.h"
 #include "eval.h"
 #include "marshal.h"
+#include "branchobject.h"
 #include "osdefs.h"
 
 #ifdef HAVE_SIGNAL_H
@@ -51,6 +52,8 @@
 extern grammar _PyParser_Grammar; /* From graminit.c */
 
 /* Forward */
+static void initfinalize(void);
+static void finifinalize(void);
 static void initmain(void);
 static void initsite(void);
 static int initstdio(void);
@@ -60,18 +63,25 @@
 static PyObject *run_pyc_file(FILE *, const char *, PyObject *, PyObject *,
 			      PyCompilerFlags *);
 static void err_input(perrdetail *);
-static void initsigs(void);
 static void call_py_exitfuncs(void);
 static void call_ll_exitfuncs(void);
+extern void _PyGC_Init(void);
+extern void _PyUnicode_PreInit(void);
 extern void _PyUnicode_Init(void);
 extern void _PyUnicode_Fini(void);
+extern void _PyUnicode_PostFini(void);
+extern void _PyDict_PreInit(void);
 extern int _PyLong_Init(void);
 extern void PyLong_Fini(void);
-
-#ifdef WITH_THREAD
-extern void _PyGILState_Init(PyInterpreterState *, PyThreadState *);
-extern void _PyGILState_Fini(void);
-#endif /* WITH_THREAD */
+extern void _PyAbstract_Init(void);
+extern void _PyMonitor_Init(void);
+
+extern void _PyState_InitThreads(void);
+extern void _PyState_ClearThreads(void);
+extern void _PyState_Fini(void);
+
+extern void _Py_Refchain_Init(void);
+extern void _Py_Refchain_Fini(void);
 
 int Py_DebugFlag; /* Needed by parser.c */
 int Py_VerboseFlag; /* Needed by import.c */
@@ -84,11 +94,15 @@
 int Py_FrozenFlag; /* Needed by getpath.c */
 int Py_IgnoreEnvironmentFlag; /* e.g. PYTHONPATH, PYTHONHOME */
 
+static PyState_EnterFrame *enterframe;
+
 /* Reference to 'warnings' module, to avoid importing it
    on the fly when the import lock may be held.  See 683658/771097
 */
 static PyObject *warnings_module = NULL;
 
+static PyObject *finalize_branch = NULL;
+
 /* Returns a borrowed reference to the 'warnings' module, or NULL.
    If the module is returned, it is guaranteed to have been obtained
    without acquiring the import lock
@@ -118,6 +132,7 @@
 	return warnings_module;
 }
 
+/* 0 for uninitialized, 1 for initialized, -1 for finalized */
 static int initialized = 0;
 
 /* API to access the initialized flag -- useful for esoteric use */
@@ -125,7 +140,9 @@
 int
 Py_IsInitialized(void)
 {
-	return initialized;
+    /* Typical callers don't want to know we're finalized, so we make
+     * sure they don't have to test for it. */
+    return initialized == 1;
 }
 
 /* Global initializations.  Can be undone by Py_Finalize().  Don't
@@ -152,19 +169,21 @@
 }
 
 void
-Py_InitializeEx(int install_sigs)
+Py_InitializeEx(int handle_sigint)
 {
-	PyInterpreterState *interp;
-	PyThreadState *tstate;
-	PyObject *bimod, *sysmod, *pstderr;
+	PyObject *pstderr;
 	char *p;
 #if defined(HAVE_LANGINFO_H) && defined(CODESET)
 	char *codeset;
 #endif
 	extern void _Py_ReadyTypes(void);
 
-	if (initialized)
-		return;
+	if (initialized == 1)
+		Py_FatalError("Cannot call Py_Initialize: already initialized");
+	if (initialized == -1)
+		Py_FatalError("Cannot call Py_Initialize: already finalized");
+	if (initialized != 0)
+		Py_FatalError("Cannot call Py_Initialize: unknown initialized stated");
 	initialized = 1;
 
 #ifdef HAVE_SETLOCALE
@@ -183,60 +202,56 @@
 	if ((p = Py_GETENV("PYTHONDONTWRITEBYTECODE")) && *p != '\0')
 		Py_DontWriteBytecodeFlag = add_flag(Py_DontWriteBytecodeFlag, p);
 
-	interp = PyInterpreterState_New();
-	if (interp == NULL)
-		Py_FatalError("Py_Initialize: can't make first interpreter");
-
-	tstate = PyThreadState_New(interp);
-	if (tstate == NULL)
-		Py_FatalError("Py_Initialize: can't make first thread");
-	(void) PyThreadState_Swap(tstate);
-
-	_Py_ReadyTypes();
+	_PyGC_Init();
+
+	_Py_Refchain_Init();
+
+	_PyState_InitThreads();
+
+	enterframe = PyState_Enter();
+	if (enterframe == NULL)
+		Py_FatalError("Py_Initialize: PyState_Enter failed");
+
+	/* Bare minimum before other types */
+	_PyUnicode_PreInit();
+	_PyDict_PreInit();
 
 	if (!_PyFrame_Init())
 		Py_FatalError("Py_Initialize: can't init frames");
-
+	_PyMethod_Init();
 	if (!_PyLong_Init())
 		Py_FatalError("Py_Initialize: can't init longs");
-
+	_PyFloat_Init();
+	_PyList_Init();
+	_PySet_Init();
 	if (!PyBytes_Init())
 		Py_FatalError("Py_Initialize: can't init bytes");
-
-	_PyFloat_Init();
-
-	interp->modules = PyDict_New();
-	if (interp->modules == NULL)
-		Py_FatalError("Py_Initialize: can't make modules dictionary");
-	interp->modules_reloading = PyDict_New();
-	if (interp->modules_reloading == NULL)
-		Py_FatalError("Py_Initialize: can't make modules_reloading dictionary");
+	_PyCFunction_Init();
 
 	/* Init Unicode implementation; relies on the codec registry */
 	_PyUnicode_Init();
 
-	bimod = _PyBuiltin_Init();
-	if (bimod == NULL)
+	_PyAbstract_Init();
+
+	_PyMonitor_Init();
+
+	_Py_ReadyTypes();
+
+	_PyImport_Init();
+
+	if (_PyBuiltin_Init())
 		Py_FatalError("Py_Initialize: can't initialize builtins modules");
-	interp->builtins = PyModule_GetDict(bimod);
-	if (interp->builtins == NULL)
-		Py_FatalError("Py_Initialize: can't initialize builtins dict");
-	Py_INCREF(interp->builtins);
+
+	_Py_ThreadTools_Init();
 
 	/* initialize builtin exceptions */
 	_PyExc_Init();
 
-	sysmod = _PySys_Init();
-	if (sysmod == NULL)
+	if (_PySys_Init())
 		Py_FatalError("Py_Initialize: can't initialize sys");
-	interp->sysdict = PyModule_GetDict(sysmod);
-	if (interp->sysdict == NULL)
-		Py_FatalError("Py_Initialize: can't initialize sys dict");
-	Py_INCREF(interp->sysdict);
 	_PyImport_FixupExtension("sys", "sys");
 	PySys_SetPath(Py_GetPath());
-	PyDict_SetItemString(interp->sysdict, "modules",
-			     interp->modules);
+	PySys_SetObject("modules", PyImport_GetModuleDict());
 
 	/* Set up a preliminary stderr printer until we have enough
 	   infrastructure for the io module in place. */
@@ -246,15 +261,16 @@
 	PySys_SetObject("stderr", pstderr);
 	PySys_SetObject("__stderr__", pstderr);
 
-	_PyImport_Init();
-
 	/* phase 2 of builtins */
 	_PyImport_FixupExtension("builtins", "builtins");
 
 	_PyImportHooks_Init();
 
-	if (install_sigs)
-		initsigs(); /* Signal handling stuff, including initintr() */
+	_PySignal_Init();
+
+	initfinalize();
+
+	_PySignal_InitSigInt(handle_sigint);
 
 	initmain(); /* Module __main__ */
 	if (initstdio() < 0)
@@ -263,11 +279,6 @@
 	if (!Py_NoSiteFlag)
 		initsite(); /* Module site */
 
-	/* auto-thread-state API, if available */
-#ifdef WITH_THREAD
-	_PyGILState_Init(interp, tstate);
-#endif /* WITH_THREAD */
-
 	warnings_module = PyImport_ImportModule("warnings");
 	if (!warnings_module) {
 		PyErr_Clear();
@@ -375,11 +386,12 @@
 void
 Py_Finalize(void)
 {
-	PyInterpreterState *interp;
-	PyThreadState *tstate;
-
-	if (!initialized)
-		return;
+	if (initialized == 0)
+		Py_FatalError("Cannot call Py_Finalize: not yet initialized");
+	if (initialized == -1)
+		Py_FatalError("Cannot call Py_Finalize: already finalized");
+	if (initialized != 1)
+		Py_FatalError("Cannot call Py_Finalize: unknown initialized stated");
 
 	/* The interpreter is still entirely intact at this point, and the
 	 * exit funcs may be relying on that.  In particular, if some thread
@@ -390,18 +402,21 @@
 	 * threads created thru it, so this also protects pending imports in
 	 * the threads created via Threading.
 	 */
+	/* XXX FIXME this isn't done in a thread-safe fashion.  The
+	 * initialized variable itself isn't accessed atomically, but we
+	 * also have a race before we change it after checking it. */
 	call_py_exitfuncs();
-	initialized = 0;
+	initialized = -1;
 
 	/* Flush stdout+stderr */
 	flush_std_files();
 
-	/* Get current thread state and interpreter pointer */
-	tstate = PyThreadState_GET();
-	interp = tstate->interp;
+	_PySignal_FiniSigInt();
+
+	finifinalize();
 
 	/* Disable signal handling */
-	PyOS_FiniInterrupts();
+	_PySignal_Fini();
 
 	/* drop module references we saved */
 	Py_XDECREF(warnings_module);
@@ -435,7 +450,8 @@
 	PyImport_Cleanup();
 
 	/* Flush stdout+stderr (again, in case more was printed) */
-	flush_std_files();
+	/* XXX io.py is long gone at this point */
+	//flush_std_files();
 
 	/* Collect final garbage.  This disposes of cycles created by
 	 * new-style class definitions, for example.
@@ -452,9 +468,7 @@
 	 * XXX seen segfaults then, after adding print statements to the
 	 * XXX Python code getting called.
 	 */
-#if 0
 	PyGC_Collect();
-#endif
 
 	/* Destroy the database used by _PyImport_{Fixup,Find}Extension */
 	_PyImport_Fini();
@@ -476,32 +490,22 @@
 		_Py_PrintReferences(stderr);
 #endif /* Py_TRACE_REFS */
 
-	/* Clear interpreter state */
-	PyInterpreterState_Clear(interp);
+	_PyState_ClearThreads();
 
 	/* Now we decref the exception classes.  After this point nothing
 	   can raise an exception.  That's okay, because each Fini() method
 	   below has been checked to make sure no exceptions are ever
 	   raised.
 	*/
-
 	_PyExc_Fini();
 
-	/* Cleanup auto-thread-state */
-#ifdef WITH_THREAD
-	_PyGILState_Fini();
-#endif /* WITH_THREAD */
-
-	/* Delete current thread */
-	PyThreadState_Swap(NULL);
-	PyInterpreterState_Delete(interp);
-
 	/* Sundry finalizers */
 	PyMethod_Fini();
 	PyFrame_Fini();
 	PyCFunction_Fini();
 	PyTuple_Fini();
 	PyList_Fini();
+	PyDict_Fini();
 	PySet_Fini();
 	PyString_Fini();
 	PyBytes_Fini();
@@ -539,116 +543,19 @@
 		_PyObject_DebugMallocStats();
 #endif
 
+	_PyUnicode_PostFini();
+
+	/* Delete current thread */
+	PyState_Exit(enterframe);
+
+	/* Cleanup auto-thread-state */
+	_PyState_Fini();
+
+	_Py_Refchain_Fini();
+
 	call_ll_exitfuncs();
 }
 
-/* Create and initialize a new interpreter and thread, and return the
-   new thread.  This requires that Py_Initialize() has been called
-   first.
-
-   Unsuccessful initialization yields a NULL pointer.  Note that *no*
-   exception information is available even in this case -- the
-   exception information is held in the thread, and there is no
-   thread.
-
-   Locking: as above.
-
-*/
-
-PyThreadState *
-Py_NewInterpreter(void)
-{
-	PyInterpreterState *interp;
-	PyThreadState *tstate, *save_tstate;
-	PyObject *bimod, *sysmod;
-
-	if (!initialized)
-		Py_FatalError("Py_NewInterpreter: call Py_Initialize first");
-
-	interp = PyInterpreterState_New();
-	if (interp == NULL)
-		return NULL;
-
-	tstate = PyThreadState_New(interp);
-	if (tstate == NULL) {
-		PyInterpreterState_Delete(interp);
-		return NULL;
-	}
-
-	save_tstate = PyThreadState_Swap(tstate);
-
-	/* XXX The following is lax in error checking */
-
-	interp->modules = PyDict_New();
-	interp->modules_reloading = PyDict_New();
-
-	bimod = _PyImport_FindExtension("builtins", "builtins");
-	if (bimod != NULL) {
-		interp->builtins = PyModule_GetDict(bimod);
-		if (interp->builtins == NULL)
-			goto handle_error;
-		Py_INCREF(interp->builtins);
-	}
-	sysmod = _PyImport_FindExtension("sys", "sys");
-	if (bimod != NULL && sysmod != NULL) {
-		interp->sysdict = PyModule_GetDict(sysmod);
-		if (interp->sysdict == NULL)
-			goto handle_error;
-		Py_INCREF(interp->sysdict);
-		PySys_SetPath(Py_GetPath());
-		PyDict_SetItemString(interp->sysdict, "modules",
-				     interp->modules);
-		_PyImportHooks_Init();
-		initmain();
-		if (!Py_NoSiteFlag)
-			initsite();
-	}
-
-	if (!PyErr_Occurred())
-		return tstate;
-
-handle_error:
-	/* Oops, it didn't work.  Undo it all. */
-
-	PyErr_Print();
-	PyThreadState_Clear(tstate);
-	PyThreadState_Swap(save_tstate);
-	PyThreadState_Delete(tstate);
-	PyInterpreterState_Delete(interp);
-
-	return NULL;
-}
-
-/* Delete an interpreter and its last thread.  This requires that the
-   given thread state is current, that the thread has no remaining
-   frames, and that it is its interpreter's only remaining thread.
-   It is a fatal error to violate these constraints.
-
-   (Py_Finalize() doesn't have these constraints -- it zaps
-   everything, regardless.)
-
-   Locking: as above.
-
-*/
-
-void
-Py_EndInterpreter(PyThreadState *tstate)
-{
-	PyInterpreterState *interp = tstate->interp;
-
-	if (tstate != PyThreadState_GET())
-		Py_FatalError("Py_EndInterpreter: thread is not current");
-	if (tstate->frame != NULL)
-		Py_FatalError("Py_EndInterpreter: thread still has a frame");
-	if (tstate != interp->tstate_head || tstate->next != NULL)
-		Py_FatalError("Py_EndInterpreter: not the last thread");
-
-	PyImport_Cleanup();
-	PyInterpreterState_Clear(interp);
-	PyThreadState_Swap(NULL);
-	PyInterpreterState_Delete(interp);
-}
-
 static wchar_t *progname = L"python";
 
 void
@@ -689,6 +596,87 @@
 	return home;
 }
 
+/* Create finalizer thread */
+static void
+initfinalize(void)
+{
+    PyObject *queue, *runfinalizers, *x;
+
+    queue = PyObject_CallObject((PyObject *)&_PyDeathQueue_Type, NULL);
+    if (queue == NULL)
+        Py_FatalError("Py_Initialize: can't initialize finalizequeue");
+    if (PySys_SetObject("finalizequeue", queue) != 0)
+        Py_FatalError("Py_Initialize: can't assign finalizequeue");
+
+    runfinalizers = PySys_GetObject("_runfinalizers");
+    if (runfinalizers == NULL)
+        Py_FatalError("lost sys._runfinalizers");
+    Py_INCREF(runfinalizers);  /* PySys_GetObject returns a borrowed reference */
+
+    finalize_branch = PyObject_CallObject((PyObject *)&PyBranch_Type, NULL);
+    if (finalize_branch == NULL)
+        Py_FatalError("Failed to initialize finalize_branch");
+    x = PyObject_CallMethod(finalize_branch, "__enter__", "");
+    if (x == NULL)
+        Py_FatalError("Failed to call finalize_branch.__enter__()");
+    Py_DECREF(x);
+
+    x = PyObject_CallMethod(finalize_branch, "add", "OO", runfinalizers, queue);
+    if (x == NULL)
+        Py_FatalError("Failed to spawn finalizer thread");
+    Py_DECREF(queue);
+    Py_DECREF(runfinalizers);
+    Py_DECREF(x);
+}
+
+/* Destroy the finalizer thread */
+static void
+finifinalize(void)
+{
+    PyObject *x, *dummy, *queue;
+    PyObject *e_type, *e_val, *e_tb;
+
+    dummy = PySet_New(NULL);
+    if (dummy == NULL)
+        Py_FatalError("failed to create dummy to exit finalizer thread");
+    queue = PySys_GetObject("finalizequeue");
+    if (queue == NULL)
+        Py_FatalError("lost sys.finalizequeue");
+
+    x = PyObject_CallMethod(queue, "watch", "OO", dummy, Py_None);
+    if (x == NULL)
+        Py_FatalError("failed to watch dummy to exit finalizer thread");
+    Py_DECREF(x);
+    Py_DECREF(dummy);
+    //Py_DECREF(queue);  // PySys_GetObject returns a borrowed reference
+
+    /* XXX We're dependant on the GC deleting dummy, and preferably
+     * immediately.  This SHOULD happen, but it's not a great assumption. */
+
+    /* XXX This is all a big bodge */
+    PyErr_Fetch(&e_type, &e_val, &e_tb);
+    PyErr_NormalizeException(&e_type, &e_val, &e_tb);
+    if (e_type == NULL) {
+        Py_INCREF(Py_None);
+        e_type = Py_None;
+        Py_INCREF(Py_None);
+        e_val = Py_None;
+    }
+    if (e_tb == NULL) {
+        Py_INCREF(Py_None);
+        e_tb = Py_None;
+    }
+    assert(e_type && e_val && e_tb);
+    x = PyObject_CallMethod(finalize_branch, "__exit__", "OOO", e_type, e_val, e_tb);
+    /* XXX any DECREFs needed? */
+    if (x == NULL)
+        PyErr_Print();
+        //Py_FatalError("failed to call finalize_branch.__exit__()");
+    Py_XDECREF(x);
+    Py_CLEAR(finalize_branch);
+    /* XXX reraise or whatever as required by __exit__ specs */
+}
+
 /* Create __main__ module */
 
 static void
@@ -1281,11 +1269,16 @@
 	if (exception == NULL)
 		return;
         /* Now we know v != NULL too */
+#warning XXX FIXME last_value (and friends) needs to be redesigned
+	/* These can actually cause a recursion loop involving
+	 * Py_FatalError and unicode's critical section */
+#if 0
 	if (set_sys_last_vars) {
 		PySys_SetObject("last_type", exception);
 		PySys_SetObject("last_value", v);
 		PySys_SetObject("last_traceback", tb ? tb : Py_None);
 	}
+#endif
 	hook = PySys_GetObject("excepthook");
 	if (hook) {
 		PyObject *args = PyTuple_Pack(3,
@@ -1822,9 +1815,15 @@
 Py_FatalError(const char *msg)
 {
 	fprintf(stderr, "Fatal Python error: %s\n", msg);
+#if 0
+	/* Py_FatalError is called when the interpreter is in a bad
+	 * state.  Trying to print the exception is impossible.  We may
+	 * want to add a variant of this function to be used for more
+	 * sane states. */
 	if (PyErr_Occurred()) {
 		PyErr_Print();
 	}
+#endif
 #ifdef MS_WINDOWS
 	OutputDebugString("Fatal Python error: ");
 	OutputDebugString(msg);
@@ -1863,6 +1862,8 @@
 static void (*exitfuncs[NEXITFUNCS])(void);
 static int nexitfuncs = 0;
 
+/* These are called after the interpreter is torn down.  Therefore, they
+ * cannot use any python APIs. */
 int Py_AtExit(void (*func)(void))
 {
 	if (nexitfuncs >= NEXITFUNCS)
@@ -1889,21 +1890,6 @@
 	exit(sts);
 }
 
-static void
-initsigs(void)
-{
-#ifdef SIGPIPE
-	PyOS_setsig(SIGPIPE, SIG_IGN);
-#endif
-#ifdef SIGXFZ
-	PyOS_setsig(SIGXFZ, SIG_IGN);
-#endif
-#ifdef SIGXFSZ
-	PyOS_setsig(SIGXFSZ, SIG_IGN);
-#endif
-	PyOS_InitInterrupts(); /* May imply initsignal() */
-}
-
 
 /*
  * The file descriptor fd is considered ``interactive'' if either
@@ -1962,63 +1948,6 @@
 #endif /* USE_STACKCHECK */
 
 
-/* Wrappers around sigaction() or signal(). */
-
-PyOS_sighandler_t
-PyOS_getsig(int sig)
-{
-#ifdef HAVE_SIGACTION
-	struct sigaction context;
-	if (sigaction(sig, NULL, &context) == -1)
-		return SIG_ERR;
-	return context.sa_handler;
-#else
-	PyOS_sighandler_t handler;
-/* Special signal handling for the secure CRT in Visual Studio 2005 */
-#if defined(_MSC_VER) && _MSC_VER >= 1400
-	switch (sig) {
-	/* Only these signals are valid */
-	case SIGINT:
-	case SIGILL:
-	case SIGFPE:
-	case SIGSEGV:
-	case SIGTERM:
-	case SIGBREAK:
-	case SIGABRT:
-		break;
-	/* Don't call signal() with other values or it will assert */
-	default:
-		return SIG_ERR;
-	}
-#endif /* _MSC_VER && _MSC_VER >= 1400 */
-	handler = signal(sig, SIG_IGN);
-	if (handler != SIG_ERR)
-		signal(sig, handler);
-	return handler;
-#endif
-}
-
-PyOS_sighandler_t
-PyOS_setsig(int sig, PyOS_sighandler_t handler)
-{
-#ifdef HAVE_SIGACTION
-	struct sigaction context, ocontext;
-	context.sa_handler = handler;
-	sigemptyset(&context.sa_mask);
-	context.sa_flags = 0;
-	if (sigaction(sig, &context, &ocontext) == -1)
-		return SIG_ERR;
-	return ocontext.sa_handler;
-#else
-	PyOS_sighandler_t oldhandler;
-	oldhandler = signal(sig, handler);
-#ifdef HAVE_SIGINTERRUPT
-	siginterrupt(sig, 1);
-#endif
-	return oldhandler;
-#endif
-}
-
 /* Deprecated C API functions still provided for binary compatiblity */
 
 #undef PyParser_SimpleParseFile

=== modified file 'Python/sigcheck.c'
--- Python/sigcheck.c	2000-09-01 23:29:29 +0000
+++ Python/sigcheck.c	2008-03-24 04:28:03 +0000
@@ -1,19 +0,0 @@
-
-/* Sigcheck is similar to intrcheck() but sets an exception when an
-   interrupt occurs.  It can't be in the intrcheck.c file since that
-   file (and the whole directory it is in) doesn't know about objects
-   or exceptions.  It can't be in errors.c because it can be
-   overridden (at link time) by a more powerful version implemented in
-   signalmodule.c. */
-
-#include "Python.h"
-
-/* ARGSUSED */
-int
-PyErr_CheckSignals(void)
-{
-	if (!PyOS_InterruptOccurred())
-		return 0;
-	PyErr_SetNone(PyExc_KeyboardInterrupt);
-	return -1;
-}

=== modified file 'Python/symtable.c'
--- Python/symtable.c	2008-03-31 05:14:30 +0000
+++ Python/symtable.c	2008-04-11 02:55:55 +0000
@@ -33,7 +33,7 @@
 	k = PyLong_FromVoidPtr(key);
 	if (k == NULL)
 		goto fail;
-	ste = PyObject_New(PySTEntryObject, &PySTEntry_Type);
+	ste = PyObject_New(&PySTEntry_Type);
 	if (ste == NULL)
 		goto fail;
 	ste->ste_table = st;
@@ -156,7 +156,6 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	0,					/* tp_new */
 };
 

=== modified file 'Python/sysmodule.c'
--- Python/sysmodule.c	2008-04-05 20:41:37 +0000
+++ Python/sysmodule.c	2008-04-11 02:07:15 +0000
@@ -19,6 +19,7 @@
 #include "code.h"
 #include "frameobject.h"
 #include "eval.h"
+#include "monitorobject.h"
 
 #include "osdefs.h"
 
@@ -42,38 +43,46 @@
 #include <langinfo.h>
 #endif
 
+#ifdef HAVE_DLOPEN
+#ifdef HAVE_DLFCN_H
+#include <dlfcn.h>
+#endif
+#ifndef RTLD_LAZY
+#define RTLD_LAZY 1
+#endif
+#endif
+
+
+static PyObject *_PySys_Dict;
+
 PyObject *
 PySys_GetObject(const char *name)
 {
-	PyThreadState *tstate = PyThreadState_GET();
-	PyObject *sd = tstate->interp->sysdict;
-	if (sd == NULL)
-		return NULL;
-	return PyDict_GetItemString(sd, name);
+	return PyDict_GetItemString(_PySys_Dict, name);
 }
 
 int
 PySys_SetObject(const char *name, PyObject *v)
 {
-	PyThreadState *tstate = PyThreadState_GET();
-	PyObject *sd = tstate->interp->sysdict;
 	if (v == NULL) {
-		if (PyDict_GetItemString(sd, name) == NULL)
+		if (PyDict_GetItemString(_PySys_Dict, name) == NULL)
 			return 0;
 		else
-			return PyDict_DelItemString(sd, name);
+			return PyDict_DelItemString(_PySys_Dict, name);
 	}
 	else
-		return PyDict_SetItemString(sd, name, v);
+		return PyDict_SetItemString(_PySys_Dict, name, v);
 }
 
 static PyObject *
 sys_displayhook(PyObject *self, PyObject *o)
 {
 	PyObject *outf;
-	PyInterpreterState *interp = PyThreadState_GET()->interp;
-	PyObject *modules = interp->modules;
-	PyObject *builtins = PyDict_GetItemString(modules, "builtins");
+	PyObject *modules = PyImport_GetModuleDict();
+	PyObject *builtins;
+
+	if (PyDict_GetItemStringEx(modules, "builtins", &builtins) < 0)
+		return NULL;
 
 	if (builtins == NULL) {
 		PyErr_SetString(PyExc_RuntimeError, "lost builtins module");
@@ -84,24 +93,32 @@
 	/* After printing, also assign to '_' */
 	/* Before, set '_' to None to avoid recursion */
 	if (o == Py_None) {
+		Py_DECREF(builtins);
 		Py_INCREF(Py_None);
 		return Py_None;
 	}
 	if (PyObject_SetAttrString(builtins, "_", Py_None) != 0)
-		return NULL;
+		goto failed;
 	outf = PySys_GetObject("stdout");
 	if (outf == NULL || outf == Py_None) {
 		PyErr_SetString(PyExc_RuntimeError, "lost sys.stdout");
-		return NULL;
+		goto failed;
 	}
 	if (PyFile_WriteObject(o, outf, 0) != 0)
-		return NULL;
+		goto failed;
 	if (PyFile_WriteString("\n", outf) != 0)
-		return NULL;
-	if (PyObject_SetAttrString(builtins, "_", o) != 0)
-		return NULL;
+		goto failed;
+	/* XXX FIXME this'll fail if o isn't shareable */
+#warning XXX FIXME displayhook
+	//if (PyObject_SetAttrString(builtins, "_", o) != 0)
+	//	goto failed;
+	Py_DECREF(builtins);
 	Py_INCREF(Py_None);
 	return Py_None;
+
+failed:
+	Py_DECREF(builtins);
+	return NULL;
 }
 
 PyDoc_STRVAR(displayhook_doc,
@@ -130,14 +147,14 @@
 static PyObject *
 sys_exc_info(PyObject *self, PyObject *noargs)
 {
-	PyThreadState *tstate;
-	tstate = PyThreadState_GET();
+	PyState *pystate;
+	pystate = PyState_Get();
 	return Py_BuildValue(
 		"(OOO)",
-		tstate->exc_type != NULL ? tstate->exc_type : Py_None,
-		tstate->exc_value != NULL ? tstate->exc_value : Py_None,
-		tstate->exc_traceback != NULL ?
-			tstate->exc_traceback : Py_None);
+		pystate->exc_type != NULL ? pystate->exc_type : Py_None,
+		pystate->exc_value != NULL ? pystate->exc_value : Py_None,
+		pystate->exc_traceback != NULL ?
+			pystate->exc_traceback : Py_None);
 }
 
 PyDoc_STRVAR(exc_info_doc,
@@ -271,7 +288,7 @@
 
 
 static PyObject *
-call_trampoline(PyThreadState *tstate, PyObject* callback,
+call_trampoline(PyState *pystate, PyObject* callback,
 		PyFrameObject *frame, int what, PyObject *arg)
 {
 	PyObject *args = PyTuple_New(3);
@@ -306,12 +323,12 @@
 profile_trampoline(PyObject *self, PyFrameObject *frame,
 		   int what, PyObject *arg)
 {
-	PyThreadState *tstate = frame->f_tstate;
+	PyState *pystate = frame->f_pystate;
 	PyObject *result;
 
 	if (arg == NULL)
 		arg = Py_None;
-	result = call_trampoline(tstate, self, frame, what, arg);
+	result = call_trampoline(pystate, self, frame, what, arg);
 	if (result == NULL) {
 		PyEval_SetProfile(NULL, NULL);
 		return -1;
@@ -324,7 +341,7 @@
 trace_trampoline(PyObject *self, PyFrameObject *frame,
 		 int what, PyObject *arg)
 {
-	PyThreadState *tstate = frame->f_tstate;
+	PyState *pystate = frame->f_pystate;
 	PyObject *callback;
 	PyObject *result;
 
@@ -334,7 +351,7 @@
 		callback = frame->f_trace;
 	if (callback == NULL)
 		return 0;
-	result = call_trampoline(tstate, callback, frame, what, arg);
+	result = call_trampoline(pystate, callback, frame, what, arg);
 	if (result == NULL) {
 		PyEval_SetTrace(NULL, NULL);
 		Py_XDECREF(frame->f_trace);
@@ -376,8 +393,8 @@
 static PyObject *
 sys_gettrace(PyObject *self, PyObject *args)
 {
-	PyThreadState *tstate = PyThreadState_GET();
-	PyObject *temp = tstate->c_traceobj;
+	PyState *pystate = PyState_Get();
+	PyObject *temp = pystate->c_traceobj;
 
 	if (temp == NULL)
 		temp = Py_None;
@@ -415,8 +432,8 @@
 static PyObject *
 sys_getprofile(PyObject *self, PyObject *args)
 {
-	PyThreadState *tstate = PyThreadState_GET();
-	PyObject *temp = tstate->c_profileobj;
+	PyState *pystate = PyState_Get();
+	PyObject *temp = pystate->c_profileobj;
 
 	if (temp == NULL)
 		temp = Py_None;
@@ -458,18 +475,20 @@
 );
 
 #ifdef WITH_TSC
+int _PySys_TSCDump;
+
 static PyObject *
 sys_settscdump(PyObject *self, PyObject *args)
 {
 	int bool;
-	PyThreadState *tstate = PyThreadState_Get();
+	PyState *pystate = PyState_Get();
 
 	if (!PyArg_ParseTuple(args, "i:settscdump", &bool))
 		return NULL;
 	if (bool)
-		tstate->interp->tscdump = 1;
+		_PySys_TSCDump = 1;
 	else
-		tstate->interp->tscdump = 0;
+		_PySys_TSCDump = 0;
 	Py_INCREF(Py_None);
 	return Py_None;
 
@@ -523,6 +542,40 @@
 recursion from causing an overflow of the C stack and crashing Python."
 );
 
+static PyObject *
+sys_setdeadlockdelay(PyObject *self, PyObject *args)
+{
+    double new_delay;
+    if (!PyArg_ParseTuple(args, "d:setdeadlockdelay", &new_delay))
+        return NULL;
+    if (new_delay < 0.0) {
+        PyErr_SetString(PyExc_ValueError,
+            "deadlock delay must be positive or zero");
+        return NULL;
+    }
+    PyMonitorSpace_SetDeadlockDelay(new_delay);
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+PyDoc_STRVAR(setdeadlockdelay_doc,
+"setdeadlockdelay(n)\n\
+\n\
+Set the delay before checking for deadlocks to n seconds.  Higher\n\
+values may reduce contention, improving performance.");
+
+static PyObject *
+sys_getdeadlockdelay(PyObject *self)
+{
+    return PyFloat_FromDouble(PyMonitorSpace_GetDeadlockDelay());
+}
+
+PyDoc_STRVAR(getdeadlockdelay_doc,
+"getdeadlockdelay()\n\
+\n\
+Return the current value of the deadlock delay.  Higher values may\n\
+reduce contention, improving performance.");
+
 #ifdef MS_WINDOWS
 PyDoc_STRVAR(getwindowsversion_doc,
 "getwindowsversion()\n\
@@ -552,16 +605,22 @@
 #endif /* MS_WINDOWS */
 
 #ifdef HAVE_DLOPEN
+#ifdef RTLD_NOW
+int _PySys_DLOpenFlags = RTLD_NOW;
+#else
+int _PySys_DLOpenFlags = RTLD_LAZY;
+#endif
+
 static PyObject *
 sys_setdlopenflags(PyObject *self, PyObject *args)
 {
 	int new_val;
-        PyThreadState *tstate = PyThreadState_GET();
+        PyState *pystate = PyState_Get();
 	if (!PyArg_ParseTuple(args, "i:setdlopenflags", &new_val))
 		return NULL;
-        if (!tstate)
+        if (!pystate)
 		return NULL;
-        tstate->interp->dlopenflags = new_val;
+        _PySys_DLOpenFlags = new_val;
 	Py_INCREF(Py_None);
 	return Py_None;
 }
@@ -579,10 +638,10 @@
 static PyObject *
 sys_getdlopenflags(PyObject *self, PyObject *args)
 {
-        PyThreadState *tstate = PyThreadState_GET();
-        if (!tstate)
+        PyState *pystate = PyState_Get();
+        if (!pystate)
 		return NULL;
-        return PyLong_FromLong(tstate->interp->dlopenflags);
+        return PyLong_FromLong(_PySys_DLOpenFlags);
 }
 
 PyDoc_STRVAR(getdlopenflags_doc,
@@ -612,7 +671,7 @@
 static PyObject *
 sys_getrefcount(PyObject *self, PyObject *arg)
 {
-	return PyLong_FromSsize_t(arg->ob_refcnt);
+	return PyLong_FromSsize_t(Py_RefcntSnoop(arg));
 }
 
 #ifdef Py_REF_DEBUG
@@ -656,7 +715,7 @@
 static PyObject *
 sys_getframe(PyObject *self, PyObject *args)
 {
-	PyFrameObject *f = PyThreadState_GET()->frame;
+	PyFrameObject *f = PyState_Get()->frame;
 	int depth = -1;
 
 	if (!PyArg_ParseTuple(args, "|i:_getframe", &depth))
@@ -675,21 +734,6 @@
 	return (PyObject*)f;
 }
 
-PyDoc_STRVAR(current_frames_doc,
-"_current_frames() -> dictionary\n\
-\n\
-Return a dictionary mapping each current thread T's thread id to T's\n\
-current stack frame.\n\
-\n\
-This function should be used for specialized purposes only."
-);
-
-static PyObject *
-sys_current_frames(PyObject *self, PyObject *noargs)
-{
-	return _PyThread_CurrentFrames();
-}
-
 PyDoc_STRVAR(call_tracing_doc,
 "call_tracing(func, args) -> object\n\
 \n\
@@ -730,6 +774,33 @@
 10. Number of stack pops performed by call_function()"
 );
 
+static PyObject *
+sys_runfinalizers(PyObject *self, PyObject *queue)
+{
+    PyObject *core, *res;
+
+    while (1) {
+        core = PyObject_CallMethod(queue, "pop", "");
+        if (core == NULL)
+            return NULL;
+        if (core == Py_None)
+            return Py_None;  /* Just steal the reference that was core */
+        res = PyObject_CallMethod(core, "__finalize__", "");
+        Py_DECREF(core);
+        if (res == NULL)
+            return NULL;
+        Py_DECREF(res);
+    }
+}
+
+PyDoc_STRVAR(runfinalizers_doc,
+"_runfinalizers(queue)\n\
+\n\
+Run all __finalize__ methods of objects returned by queue.pop(),\n\
+blocking if none are available.  Returns if an exception is thrown or\n\
+if queue.pop() produces None."
+);
+
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -783,8 +854,6 @@
 	 sys_clear_type_cache__doc__},
 	{"_compact_freelists",	sys_compact_freelists,	  METH_NOARGS,
 	 sys_compact_freelists__doc__},
-	{"_current_frames", sys_current_frames, METH_NOARGS,
-	 current_frames_doc},
 	{"displayhook",	sys_displayhook, METH_O, displayhook_doc},
 	{"exc_info",	sys_exc_info, METH_NOARGS, exc_info_doc},
 	{"excepthook",	sys_excepthook, METH_VARARGS, excepthook_doc},
@@ -798,6 +867,8 @@
 #ifdef COUNT_ALLOCS
 	{"getcounts",	(PyCFunction)sys_getcounts, METH_NOARGS},
 #endif
+	{"getdeadlockdelay", (PyCFunction)sys_getdeadlockdelay, METH_NOARGS,
+	 getdeadlockdelay_doc},
 #ifdef DYNAMIC_EXECUTION_PROFILE
 	{"getdxp",	_Py_GetDXProfile, METH_VARARGS},
 #endif
@@ -821,12 +892,15 @@
 #ifdef USE_MALLOPT
 	{"mdebug",	sys_mdebug, METH_VARARGS},
 #endif
+	{"_runfinalizers", sys_runfinalizers, METH_O | METH_SHARED, runfinalizers_doc},
 	{"setdefaultencoding", sys_setdefaultencoding, METH_VARARGS,
 	 setdefaultencoding_doc},
 	{"setcheckinterval",	sys_setcheckinterval, METH_VARARGS,
 	 setcheckinterval_doc},
 	{"getcheckinterval",	sys_getcheckinterval, METH_NOARGS,
 	 getcheckinterval_doc},
+	{"setdeadlockdelay", sys_setdeadlockdelay, METH_VARARGS,
+	 setdeadlockdelay_doc},
 #ifdef HAVE_DLOPEN
 	{"setdlopenflags", sys_setdlopenflags, METH_VARARGS,
 	 setdlopenflags_doc},
@@ -1152,20 +1226,23 @@
 	return seq;
 }
 
-PyObject *
+int
 _PySys_Init(void)
 {
-	PyObject *m, *v, *sysdict;
+	PyObject *m, *v;
 	char *s;
 
 	m = Py_InitModule3("sys", sys_methods, sys_doc);
 	if (m == NULL)
-		return NULL;
-	sysdict = PyModule_GetDict(m);
+		return 1;
+	_PySys_Dict = PyModule_GetDict(m);
+	if (_PySys_Dict == NULL)
+		Py_FatalError("_PySys_Init: can't retrieve dict");
+	Py_INCREF(_PySys_Dict);
 #define SET_SYS_FROM_STRING(key, value)			\
 	v = value;					\
 	if (v != NULL)					\
-		PyDict_SetItemString(sysdict, key, v);	\
+		PyDict_SetItemString(_PySys_Dict, key, v);	\
 	Py_XDECREF(v)
 
 	{
@@ -1182,10 +1259,10 @@
 
         /* stdin/stdout/stderr are now set by pythonrun.c */
 
-	PyDict_SetItemString(sysdict, "__displayhook__",
-                             PyDict_GetItemString(sysdict, "displayhook"));
-	PyDict_SetItemString(sysdict, "__excepthook__",
-                             PyDict_GetItemString(sysdict, "excepthook"));
+	PyDict_SetItemString(_PySys_Dict, "__displayhook__",
+                             PyDict_GetItemString(_PySys_Dict, "displayhook"));
+	PyDict_SetItemString(_PySys_Dict, "__excepthook__",
+                             PyDict_GetItemString(_PySys_Dict, "excepthook"));
 	SET_SYS_FROM_STRING("version",
 			     PyUnicode_FromString(Py_GetVersion()));
 	SET_SYS_FROM_STRING("hexversion",
@@ -1263,7 +1340,7 @@
 		Py_INCREF(warnoptions);
 	}
 	if (warnoptions != NULL) {
-		PyDict_SetItemString(sysdict, "warnoptions", warnoptions);
+		PyDict_SetItemString(_PySys_Dict, "warnoptions", warnoptions);
 	}
 
 	if (FlagsType.tp_name == 0)
@@ -1275,8 +1352,8 @@
 
 #undef SET_SYS_FROM_STRING
 	if (PyErr_Occurred())
-		return NULL;
-	return m;
+		return 1;
+	return 0;
 }
 
 static PyObject *

=== modified file 'Python/thread.c'
--- Python/thread.c	2008-01-07 21:14:23 +0000
+++ Python/thread.c	2008-03-24 04:28:03 +0000
@@ -202,7 +202,7 @@
 While some of these functions have error-return values, none set any
 Python exception.
 
-None of the functions does memory management on behalf of the void* values.
+None of the functions do memory management on behalf of the void* values.
 You need to allocate and deallocate them yourself.  If the void* values
 happen to be PyObject*, these functions don't do refcount operations on
 them either.
@@ -233,7 +233,7 @@
 };
 
 static struct key *keyhead = NULL;
-static PyThread_type_lock keymutex = NULL;
+static PyThread_type_lock *keymutex = NULL;
 static int nkeys = 0;  /* PyThread_create_key() hands out nkeys+1 next */
 
 /* Internal helper.
@@ -265,7 +265,7 @@
 
 	if (!keymutex)
 		return NULL;
-	PyThread_acquire_lock(keymutex, 1);
+	PyThread_lock_acquire(keymutex);
 	for (p = keyhead; p != NULL; p = p->next) {
 		if (p->id == id && p->key == key)
 			goto Done;
@@ -283,7 +283,7 @@
 		keyhead = p;
 	}
  Done:
-	PyThread_release_lock(keymutex);
+	PyThread_lock_release(keymutex);
 	return p;
 }
 
@@ -298,7 +298,7 @@
 	 * threads simultaneously.
 	 */
 	if (keymutex == NULL)
-		keymutex = PyThread_allocate_lock();
+		keymutex = PyThread_lock_allocate();
 	return ++nkeys;
 }
 
@@ -308,7 +308,7 @@
 {
 	struct key *p, **q;
 
-	PyThread_acquire_lock(keymutex, 1);
+	PyThread_lock_acquire(keymutex);
 	q = &keyhead;
 	while ((p = *q) != NULL) {
 		if (p->key == key) {
@@ -319,7 +319,7 @@
 		else
 			q = &p->next;
 	}
-	PyThread_release_lock(keymutex);
+	PyThread_lock_release(keymutex);
 }
 
 /* Confusing:  If the current thread has an association for key,
@@ -362,7 +362,7 @@
 	long id = PyThread_get_thread_ident();
 	struct key *p, **q;
 
-	PyThread_acquire_lock(keymutex, 1);
+	PyThread_lock_acquire(keymutex);
 	q = &keyhead;
 	while ((p = *q) != NULL) {
 		if (p->key == key && p->id == id) {
@@ -374,7 +374,7 @@
 		else
 			q = &p->next;
 	}
-	PyThread_release_lock(keymutex);
+	PyThread_lock_release(keymutex);
 }
 
 #endif /* Py_HAVE_NATIVE_TLS */

=== modified file 'Python/thread_pthread.h'
--- Python/thread_pthread.h	2006-08-11 14:57:12 +0000
+++ Python/thread_pthread.h	2008-04-10 19:00:51 +0000
@@ -12,6 +12,10 @@
 #endif
 #include <signal.h>
 
+#include <sys/time.h>
+#include <time.h>
+#include <math.h>
+
 /* The POSIX spec requires that use of pthread_attr_setstacksize
    be conditional on _POSIX_THREAD_ATTR_STACKSIZE being defined. */
 #ifdef _POSIX_THREAD_ATTR_STACKSIZE
@@ -83,6 +87,7 @@
 #endif
 
 
+#if 0
 /* A pthread mutex isn't sufficient to model the Python lock type
  * because, according to Draft 5 of the docs (P1003.4a/D5), both of the
  * following are undefined:
@@ -104,8 +109,53 @@
 	pthread_cond_t   lock_released;
 	pthread_mutex_t  mut;
 } pthread_lock;
+#endif
+
+
+struct _PyThread_type_lock {
+    pthread_mutex_t mutex;
+};
+
+#ifdef USE_SEMAPHORES
+struct _PyThread_type_sem {
+    sem_t sem;
+};
+#else
+struct _PyThread_type_sem {
+    int available;
+    pthread_cond_t released;
+    pthread_mutex_t mutex;
+};
+#endif
+
+struct _PyThread_type_cond {
+    pthread_cond_t cond;
+};
+
+struct _PyThread_type_key {
+    pthread_key_t key;
+};
+
+struct _PyThread_type_handle {
+    /* Note, these are not comparable.  Compare PyStates instead. */
+    pthread_t value;
+};
+
+struct _PyThread_type_timeout {
+    struct timespec abstime;
+    int expired;
+};
+
+struct _PyThread_type_flag {
+    int value;
+    int waiting;
+    pthread_cond_t wakeup;
+    pthread_mutex_t mutex;
+};
+
 
 #define CHECK_STATUS(name)  if (status != 0) { perror(name); error = 1; }
+#define CHECK_STATUS_ABORT(name)  if (status != 0) { perror(name); abort(); }
 
 /*
  * Initialization.
@@ -144,25 +194,32 @@
  */
 
 
-long
-PyThread_start_new_thread(void (*func)(void *), void *arg)
+int
+PyThread_start_new_thread(PyThread_type_handle **handle,
+		void (*func)(void *), void *arg)
 {
-	pthread_t th;
+	pthread_t id;
 	int status;
 #if defined(THREAD_STACK_SIZE) || defined(PTHREAD_SYSTEM_SCHED_SUPPORTED)
 	pthread_attr_t attrs;
 #endif
 #if defined(THREAD_STACK_SIZE)
-	size_t	tss;
+	size_t tss;
 #endif
 
 	dprintf(("PyThread_start_new_thread called\n"));
 	if (!initialized)
 		PyThread_init_thread();
 
+	if (handle != NULL) {
+		*handle = malloc(sizeof(PyThread_type_handle));
+		if (*handle == NULL)
+			return -1;
+	}
+
 #if defined(THREAD_STACK_SIZE) || defined(PTHREAD_SYSTEM_SCHED_SUPPORTED)
 	if (pthread_attr_init(&attrs) != 0)
-		return -1;
+		goto failed;
 #endif
 #if defined(THREAD_STACK_SIZE)
 	tss = (_pythread_stacksize != 0) ? _pythread_stacksize
@@ -170,7 +227,7 @@
 	if (tss != 0) {
 		if (pthread_attr_setstacksize(&attrs, tss) != 0) {
 			pthread_attr_destroy(&attrs);
-			return -1;
+			goto failed;
 		}
 	}
 #endif
@@ -178,7 +235,7 @@
         pthread_attr_setscope(&attrs, PTHREAD_SCOPE_SYSTEM);
 #endif
 
-	status = pthread_create(&th, 
+	status = pthread_create(&id,
 #if defined(THREAD_STACK_SIZE) || defined(PTHREAD_SYSTEM_SCHED_SUPPORTED)
 				 &attrs,
 #else
@@ -191,138 +248,267 @@
 #if defined(THREAD_STACK_SIZE) || defined(PTHREAD_SYSTEM_SCHED_SUPPORTED)
 	pthread_attr_destroy(&attrs);
 #endif
-	if (status != 0)
-            return -1;
-
-        pthread_detach(th);
-
-#if SIZEOF_PTHREAD_T <= SIZEOF_LONG
-	return (long) th;
-#else
-	return (long) *(long *) &th;
-#endif
-}
-
-/* XXX This implementation is considered (to quote Tim Peters) "inherently
-   hosed" because:
-     - It does not guarantee the promise that a non-zero integer is returned.
-     - The cast to long is inherently unsafe.
-     - It is not clear that the 'volatile' (for AIX?) and ugly casting in the
-       latter return statement (for Alpha OSF/1) are any longer necessary.
-*/
-long 
-PyThread_get_thread_ident(void)
-{
-	volatile pthread_t threadid;
-	if (!initialized)
-		PyThread_init_thread();
-	/* Jump through some hoops for Alpha OSF/1 */
-	threadid = pthread_self();
-#if SIZEOF_PTHREAD_T <= SIZEOF_LONG
-	return (long) threadid;
-#else
-	return (long) *(long *) &threadid;
-#endif
-}
-
-static void 
-do_PyThread_exit_thread(int no_cleanup)
-{
-	dprintf(("PyThread_exit_thread called\n"));
-	if (!initialized) {
-		if (no_cleanup)
-			_exit(0);
-		else
-			exit(0);
-	}
-}
-
-void 
-PyThread_exit_thread(void)
-{
-	do_PyThread_exit_thread(0);
-}
-
-void 
-PyThread__exit_thread(void)
-{
-	do_PyThread_exit_thread(1);
-}
-
-#ifndef NO_EXIT_PROG
-static void 
-do_PyThread_exit_prog(int status, int no_cleanup)
-{
-	dprintf(("PyThread_exit_prog(%d) called\n", status));
-	if (!initialized)
-		if (no_cleanup)
-			_exit(status);
-		else
-			exit(status);
-}
-
-void 
-PyThread_exit_prog(int status)
-{
-	do_PyThread_exit_prog(status, 0);
-}
-
-void 
-PyThread__exit_prog(int status)
-{
-	do_PyThread_exit_prog(status, 1);
-}
-#endif /* NO_EXIT_PROG */
-
-#ifdef USE_SEMAPHORES
+	if (status != 0) {
+		goto failed;
+	}
+
+	pthread_detach(id);
+
+	if (handle != NULL)
+		(*handle)->value = id;
+
+	return 0;
+
+failed:
+	if (handle != NULL) {
+		free(*handle);
+		*handle = NULL;
+	}
+	return -1;
+}
+
+PyThread_type_handle *
+PyThread_get_handle(void)
+{
+    PyThread_type_handle *handle;
+    handle = malloc(sizeof(PyThread_type_handle));
+    if (handle == NULL)
+        return NULL;
+    handle->value = pthread_self();
+    return handle;
+}
+
+void
+PyThread_free_handle(PyThread_type_handle *handle)
+{
+    assert(handle != NULL);
+    free(handle);
+}
+
+void
+PyThread_send_signal(PyThread_type_handle *handle, int signum)
+{
+    int status;
+
+    assert(handle != NULL);
+
+    status = pthread_kill(handle->value, signum);
+    if (status < 0) {
+        fprintf(stderr, "pthread_kill failed with %d\n", errno);
+        Py_FatalError("PyThread_send_signal failed calling pthread_kill");
+    }
+}
+
 
 /*
  * Lock support.
  */
 
-PyThread_type_lock 
-PyThread_allocate_lock(void)
+PyThread_type_lock *
+PyThread_lock_allocate(void)
 {
-	sem_t *lock;
+	//sem_t *lock;
+	PyThread_type_lock *lock;
 	int status, error = 0;
 
 	dprintf(("PyThread_allocate_lock called\n"));
 	if (!initialized)
 		PyThread_init_thread();
 
-	lock = (sem_t *)malloc(sizeof(sem_t));
+	//lock = (sem_t *)malloc(sizeof(sem_t));
+	lock = malloc(sizeof(PyThread_type_lock));
 
 	if (lock) {
-		status = sem_init(lock,0,1);
+		//status = sem_init(lock,0,1);
+#if 0
+		pthread_mutexattr_t attr;
+		status = pthread_mutexattr_init(&attr);
+		CHECK_STATUS_ABORT("pthread_mutexattr_init");
+
+		status = pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_ERRORCHECK_NP);
+		CHECK_STATUS_ABORT("pthread_mutexattr_settype");
+
+		pthread_mutex_init(&lock->mutex, &attr);
+		CHECK_STATUS("pthread_mutex_init");
+
+		status = pthread_mutexattr_destroy(&attr);
+		CHECK_STATUS_ABORT("pthread_mutexattr_destroy");
+#else
+		status = pthread_mutex_init(&lock->mutex, NULL);
+		CHECK_STATUS("pthread_mutex_init");
+#endif
+
+		if (error) {
+			free(lock);
+			lock = NULL;
+		}
+	}
+
+	dprintf(("PyThread_allocate_lock() -> %p\n", lock));
+	return lock;
+}
+
+void
+PyThread_lock_free(PyThread_type_lock *lock)
+{
+	//sem_t *thelock = (sem_t *)lock;
+	int status;
+
+	dprintf(("PyThread_free_lock(%p) called\n", lock));
+
+	assert(lock);
+
+	//status = sem_destroy(thelock);
+	status = pthread_mutex_destroy(&lock->mutex);
+	CHECK_STATUS_ABORT("pthread_mutex_destroy");
+
+	free(lock);
+}
+
+#include <execinfo.h>
+
+void
+PyThread_lock_acquire(PyThread_type_lock *lock)
+{
+	//sem_t *thelock = (sem_t *)lock;
+	int status;
+#if 0
+	static unsigned long long count;
+
+	count++;
+	if ((count % 10000) == 0) {
+		void *scratch[10] = {};
+		printf("PyThread_lock_acquire: %llu\n", count);
+		backtrace(scratch, 10);
+		backtrace_symbols_fd(scratch, 2, 1);
+		printf("*****\n");
+	}
+#endif
+
+	dprintf(("PyThread_acquire_lock(%p) called\n", lock));
+
+	//if (!waitflag)
+	//	abort();
+	status = pthread_mutex_lock(&lock->mutex);
+	CHECK_STATUS_ABORT("pthread_mutex_lock");
+
+	dprintf(("PyThread_acquire_lock(%p) done\n", lock));
+}
+
+/* Returns 1 on success, 0 on failure. */
+int
+PyThread_lock_tryacquire(PyThread_type_lock *lock)
+{
+	int success;
+	//sem_t *thelock = (sem_t *)lock;
+	int status;
+
+	dprintf(("PyThread_tryacquire_lock(%p) called\n", lock));
+
+	//if (!waitflag)
+	//	abort();
+	status = pthread_mutex_trylock(&lock->mutex);
+	if (status != EBUSY)
+		CHECK_STATUS_ABORT("pthread_mutex_trylock");
+
+	success = (status == 0) ? 1 : 0;
+	dprintf(("PyThread_tryacquire_lock(%p) done -> %d\n", lock, success));
+	return success;
+}
+
+void
+PyThread_lock_release(PyThread_type_lock *lock)
+{
+	//sem_t *thelock = (sem_t *)lock;
+	int status;
+
+	dprintf(("PyThread_release_lock(%p) called\n", lock));
+
+	//status = sem_post(thelock);
+	status = pthread_mutex_unlock(&lock->mutex);
+	CHECK_STATUS_ABORT("pthread_mutex_unlock");
+
+	dprintf(("PyThread_release_lock(%p) done\n", lock));
+}
+
+
+/*
+ * Semaphore support.
+ */
+
+PyThread_type_sem *
+PyThread_sem_allocate(int initial_value)
+{
+	PyThread_type_sem *sem;
+	int status, error = 0;
+
+	dprintf(("PyThread_sem_allocate called\n"));
+	if (!initialized)
+		PyThread_init_thread();
+
+	if (initial_value < 0 || initial_value > 1)
+		Py_FatalError("PyThread_sem_allocate given invalid initial_value");
+
+	sem = malloc(sizeof(PyThread_type_sem));
+
+	if (sem) {
+#ifdef USE_SEMAPHORES
+		status = sem_init(&sem->sem, 0, initial_value);
 		CHECK_STATUS("sem_init");
 
 		if (error) {
-			free((void *)lock);
-			lock = NULL;
-		}
+			free(sem);
+			sem = NULL;
+		}
+#else
+		sem->available = initial_value;
+		status = pthread_cond_init(&sem->released, NULL);
+		CHECK_STATUS("pthread_cond_init");
+
+		if (error) {
+			free(sem);
+			sem = NULL;
+		} else {
+			status = pthread_mutex_init(&sem->mutex, NULL);
+			CHECK_STATUS("pthread_mutex_init");
+
+			if (error) {
+				status = pthread_cond_destroy(&sem->released);
+				CHECK_STATUS_ABORT("pthread_cond_destroy");
+				free(sem);
+				sem = NULL;
+			}
+		}
+#endif
 	}
 
-	dprintf(("PyThread_allocate_lock() -> %p\n", lock));
-	return (PyThread_type_lock)lock;
+	dprintf(("PyThread_sem_allocate() -> %p\n", sem));
+	return sem;
 }
 
-void 
-PyThread_free_lock(PyThread_type_lock lock)
+void
+PyThread_sem_free(PyThread_type_sem *sem)
 {
-	sem_t *thelock = (sem_t *)lock;
-	int status, error = 0;
-
-	dprintf(("PyThread_free_lock(%p) called\n", lock));
-
-	if (!thelock)
-		return;
-
-	status = sem_destroy(thelock);
-	CHECK_STATUS("sem_destroy");
-
-	free((void *)thelock);
+	int status;
+
+	dprintf(("PyThread_sem_free(%p) called\n", sem));
+
+	assert(sem);
+
+#ifdef USE_SEMAPHORES
+	status = sem_destroy(&sem->sem);
+	CHECK_STATUS_ABORT("sem_destroy");
+#else
+	status = pthread_cond_destroy(&sem->released);
+	CHECK_STATUS_ABORT("pthread_cond_destroy");
+	status = pthread_mutex_destroy(&sem->mutex);
+	CHECK_STATUS_ABORT("pthread_mutex_destroy");
+#endif
+
+	free(sem);
 }
 
+#ifdef USE_SEMAPHORES
 /*
  * As of February 2002, Cygwin thread implementations mistakenly report error
  * codes in the return value of the sem_ calls (like the pthread_ functions).
@@ -330,162 +516,243 @@
  * either.
  */
 static int
-fix_status(int status)
+fix_sem_status(int status)
 {
 	return (status == -1) ? errno : status;
 }
+#endif
 
-int 
-PyThread_acquire_lock(PyThread_type_lock lock, int waitflag)
+void
+PyThread_sem_acquire(PyThread_type_sem *sem)
 {
-	int success;
-	sem_t *thelock = (sem_t *)lock;
-	int status, error = 0;
-
-	dprintf(("PyThread_acquire_lock(%p, %d) called\n", lock, waitflag));
-
+	int status;
+
+	dprintf(("PyThread_sem_acquire(%p) called\n", sem));
+
+#ifdef USE_SEMAPHORES
 	do {
-		if (waitflag)
-			status = fix_status(sem_wait(thelock));
-		else
-			status = fix_status(sem_trywait(thelock));
+		status = fix_sem_status(sem_wait(&sem->sem));
 	} while (status == EINTR); /* Retry if interrupted by a signal */
 
-	if (waitflag) {
-		CHECK_STATUS("sem_wait");
-	} else if (status != EAGAIN) {
-		CHECK_STATUS("sem_trywait");
+	if (status != EINTR)
+		CHECK_STATUS_ABORT("sem_wait");
+#else
+	status = pthread_mutex_lock(&sem->mutex);
+	CHECK_STATUS_ABORT("pthread_mutex_lock");
+
+	while (!sem->available) {
+		status = pthread_cond_wait(&sem->released, &sem->mutex);
+		CHECK_STATUS_ABORT("pthread_cond_wait");
 	}
-	
-	success = (status == 0) ? 1 : 0;
-
-	dprintf(("PyThread_acquire_lock(%p, %d) -> %d\n", lock, waitflag, success));
-	return success;
+
+	sem->available = 0;
+	status = pthread_mutex_unlock(&sem->mutex);
+	CHECK_STATUS_ABORT("pthread_mutex_unlock");
+#endif
+
+	dprintf(("PyThread_sem_acquire(%p)\n", sem));
 }
 
-void 
-PyThread_release_lock(PyThread_type_lock lock)
+void
+PyThread_sem_release(PyThread_type_sem *sem)
 {
-	sem_t *thelock = (sem_t *)lock;
-	int status, error = 0;
-
-	dprintf(("PyThread_release_lock(%p) called\n", lock));
-
-	status = sem_post(thelock);
-	CHECK_STATUS("sem_post");
+	int status;
+#ifdef USE_SEMAPHORES
+	int value = 0;
+#endif
+
+	dprintf(("PyThread_sem_release(%p) called\n", sem));
+
+#ifdef USE_SEMAPHORES
+	status = sem_getvalue(&sem->sem, &value);
+	CHECK_STATUS_ABORT("sem_getvalue");
+	if (value >= 1)
+		Py_FatalError("PyThread_sem_release may not increase the value beyond 1");
+	/* XXX There is a race here, but since one path is a FatalError
+	 * anyway it's not a big deal. */
+
+	status = sem_post(&sem->sem);
+	CHECK_STATUS_ABORT("sem_post");
+#else
+	status = pthread_mutex_lock(&sem->mutex);
+	CHECK_STATUS_ABORT("pthread_mutex_lock");
+
+	if (sem->available)
+		Py_FatalError("PyThread_sem_release may not increase the value beyond 1");
+
+	status = pthread_cond_signal(&sem->released);
+	CHECK_STATUS_ABORT("pthread_cond_signal");
+
+	sem->available = 1;
+	status = pthread_mutex_unlock(&sem->mutex);
+	CHECK_STATUS_ABORT("pthread_mutex_unlock");
+#endif
 }
 
-#else /* USE_SEMAPHORES */
 
 /*
- * Lock support.
+ * Condition support.
  */
-PyThread_type_lock 
-PyThread_allocate_lock(void)
+
+PyThread_type_cond *
+PyThread_cond_allocate(void)
 {
-	pthread_lock *lock;
+	PyThread_type_cond *cond;
 	int status, error = 0;
 
-	dprintf(("PyThread_allocate_lock called\n"));
+	dprintf(("PyThread_cond_allocate called\n"));
 	if (!initialized)
 		PyThread_init_thread();
 
-	lock = (pthread_lock *) malloc(sizeof(pthread_lock));
-	if (lock) {
-		memset((void *)lock, '\0', sizeof(pthread_lock));
-		lock->locked = 0;
-
-		status = pthread_mutex_init(&lock->mut,
-					    pthread_mutexattr_default);
-		CHECK_STATUS("pthread_mutex_init");
-
-		status = pthread_cond_init(&lock->lock_released,
-					   pthread_condattr_default);
+	cond = malloc(sizeof(PyThread_type_cond));
+
+	if (cond) {
+		status = pthread_cond_init(&cond->cond, NULL);
 		CHECK_STATUS("pthread_cond_init");
 
 		if (error) {
-			free((void *)lock);
-			lock = 0;
-		}
-	}
-
-	dprintf(("PyThread_allocate_lock() -> %p\n", lock));
-	return (PyThread_type_lock) lock;
-}
-
-void 
-PyThread_free_lock(PyThread_type_lock lock)
-{
-	pthread_lock *thelock = (pthread_lock *)lock;
-	int status, error = 0;
-
-	dprintf(("PyThread_free_lock(%p) called\n", lock));
-
-	status = pthread_mutex_destroy( &thelock->mut );
-	CHECK_STATUS("pthread_mutex_destroy");
-
-	status = pthread_cond_destroy( &thelock->lock_released );
-	CHECK_STATUS("pthread_cond_destroy");
-
-	free((void *)thelock);
-}
-
-int 
-PyThread_acquire_lock(PyThread_type_lock lock, int waitflag)
-{
-	int success;
-	pthread_lock *thelock = (pthread_lock *)lock;
-	int status, error = 0;
-
-	dprintf(("PyThread_acquire_lock(%p, %d) called\n", lock, waitflag));
-
-	status = pthread_mutex_lock( &thelock->mut );
-	CHECK_STATUS("pthread_mutex_lock[1]");
-	success = thelock->locked == 0;
-
-	if ( !success && waitflag ) {
-		/* continue trying until we get the lock */
-
-		/* mut must be locked by me -- part of the condition
-		 * protocol */
-		while ( thelock->locked ) {
-			status = pthread_cond_wait(&thelock->lock_released,
-						   &thelock->mut);
-			CHECK_STATUS("pthread_cond_wait");
-		}
-		success = 1;
-	}
-	if (success) thelock->locked = 1;
-	status = pthread_mutex_unlock( &thelock->mut );
-	CHECK_STATUS("pthread_mutex_unlock[1]");
-
-	if (error) success = 0;
-	dprintf(("PyThread_acquire_lock(%p, %d) -> %d\n", lock, waitflag, success));
-	return success;
-}
-
-void 
-PyThread_release_lock(PyThread_type_lock lock)
-{
-	pthread_lock *thelock = (pthread_lock *)lock;
-	int status, error = 0;
-
-	dprintf(("PyThread_release_lock(%p) called\n", lock));
-
-	status = pthread_mutex_lock( &thelock->mut );
-	CHECK_STATUS("pthread_mutex_lock[3]");
-
-	thelock->locked = 0;
-
-	status = pthread_mutex_unlock( &thelock->mut );
-	CHECK_STATUS("pthread_mutex_unlock[3]");
-
-	/* wake up someone (anyone, if any) waiting on the lock */
-	status = pthread_cond_signal( &thelock->lock_released );
-	CHECK_STATUS("pthread_cond_signal");
-}
-
-#endif /* USE_SEMAPHORES */
+			free(cond);
+			cond = NULL;
+		}
+	}
+
+	dprintf(("PyThread_cond_allocate() -> %p\n", cond));
+	return cond;
+}
+
+void
+PyThread_cond_free(PyThread_type_cond *cond)
+{
+	int status;
+
+	dprintf(("PyThread_cond_free(%p) called\n", cond));
+
+	assert(cond);
+
+	status = pthread_cond_destroy(&cond->cond);
+	CHECK_STATUS_ABORT("pthread_cond_destroy");
+
+	free(cond);
+}
+
+void
+PyThread_cond_wait(PyThread_type_cond *cond, PyThread_type_lock *lock)
+{
+	int status;
+
+	dprintf(("PyThread_cond_wait(%p, %p) called\n", cond, lock));
+
+	status = pthread_cond_wait(&cond->cond, &lock->mutex);
+	CHECK_STATUS_ABORT("pthread_cond_wait");
+	
+	dprintf(("PyThread_cond_wait(%p, %p) done\n", cond, lock));
+}
+
+void
+PyThread_cond_timedwait(PyThread_type_cond *cond, PyThread_type_lock *lock,
+        PyThread_type_timeout *timeout)
+{
+    int status;
+
+    status = pthread_cond_timedwait(&cond->cond, &lock->mutex, &timeout->abstime);
+    if (status == ETIMEDOUT)
+        timeout->expired = 1;
+    else
+        CHECK_STATUS_ABORT("pthread_cond_timedwait");
+}
+
+void
+PyThread_cond_wakeone(PyThread_type_cond *cond)
+{
+	int status;
+
+	dprintf(("PyThread_cond_wakeone(%p) called\n", cond));
+
+	status = pthread_cond_signal(&cond->cond);
+	CHECK_STATUS_ABORT("pthread_cond_signal");
+	
+	dprintf(("PyThread_cond_wakeone(%p) done\n", cond));
+}
+
+void
+PyThread_cond_wakeall(PyThread_type_cond *cond)
+{
+	int status;
+
+	dprintf(("PyThread_cond_wakeall(%p) called\n", cond));
+
+	status = pthread_cond_broadcast(&cond->cond);
+	CHECK_STATUS_ABORT("pthread_cond_broadcast");
+	
+	dprintf(("PyThread_cond_wakeall(%p) done\n", cond));
+}
+
+
+/*
+ * Thread-local Storage support.
+ */
+
+#define Py_HAVE_NATIVE_TLS
+
+PyThread_type_key *
+PyThread_create_key(void)
+{
+	PyThread_type_key *key;
+	int status, error = 0;
+
+	key = malloc(sizeof(PyThread_type_key));
+
+	if (key) {
+		//status = sem_init(lock,0,1);
+		//status = pthread_mutex_init(lock, NULL);
+		status = pthread_key_create(&key->key, NULL);
+		CHECK_STATUS("pthread_key_create");
+
+		if (error) {
+			free(key);
+			key = NULL;
+		}
+	}
+
+	return key;
+}
+
+void
+PyThread_delete_key(PyThread_type_key *key)
+{
+	int status = 0;
+
+	status = pthread_key_delete(key->key);
+	CHECK_STATUS_ABORT("pthread_key_delete");
+}
+
+/* Unlock the default implementation, I consider replacing an existing
+ * key to be an error.  I'm not going to check it. */
+void
+PyThread_set_key_value(PyThread_type_key *key, void *value)
+{
+	int status = 0;
+
+	assert(key != NULL); /* Use PyThread_delete_key_value to delete */
+	status = pthread_setspecific(key->key, value);
+	CHECK_STATUS_ABORT("pthread_setspecific");
+}
+
+void *
+PyThread_get_key_value(PyThread_type_key *key)
+{
+	return pthread_getspecific(key->key);
+}
+
+void
+PyThread_delete_key_value(PyThread_type_key *key)
+{
+	int status = 0;
+
+	status = pthread_setspecific(key->key, NULL);
+	CHECK_STATUS_ABORT("pthread_setspecific");
+}
+
 
 /* set the thread stack size.
  * Return 0 if size is valid, -1 if size is invalid,
@@ -531,3 +798,214 @@
 }
 
 #define THREAD_SET_STACKSIZE(x)	_pythread_pthread_set_stacksize(x)
+
+
+PyThread_type_timeout *
+PyThread_timeout_allocate(void)
+{
+    PyThread_type_timeout *timeout;
+
+    timeout = malloc(sizeof(PyThread_type_timeout));
+    if (timeout == NULL)
+        return NULL;
+
+    timeout->abstime.tv_sec = 0;
+    timeout->abstime.tv_nsec = 0;
+    timeout->expired = 1;
+
+    return timeout;
+}
+
+void
+PyThread_timeout_free(PyThread_type_timeout *timeout)
+{
+    assert(timeout);
+    free(timeout);
+}
+
+#define BOUND(low, value, high) ((low) >= (value) ? (low) : (high) <= (value) ? (high) : (value))
+#define MAX_DELAY (60*60*24*365)
+
+static void
+timeout_convertdelay(struct timespec *abstime, double delay)
+{
+    int status;
+    struct timeval tv;
+    double frac, integral;
+    time_t sec;
+    long nsec;
+
+    status = gettimeofday(&tv, NULL);
+    CHECK_STATUS_ABORT("gettimeofday");
+
+    if (delay <= 0.0)
+        delay = 0.0;
+    else if (delay >= MAX_DELAY)
+        /* Ensure no overflows until at least 2037.  By then you should
+         * be using at least 64-bit anyway. */
+        delay = MAX_DELAY;
+
+    frac = modf(delay, &integral);
+    sec = (time_t)integral;
+    nsec = BOUND(0, (long)(frac*1000000000), 999999999);
+
+    abstime->tv_sec = tv.tv_sec + sec;
+    abstime->tv_nsec = tv.tv_usec * 1000 + nsec;
+    if (abstime->tv_nsec >= 1000000000) {
+        abstime->tv_sec += 1;
+        abstime->tv_nsec -= 1000000000;
+    }
+}
+
+void
+PyThread_timeout_set(PyThread_type_timeout *timeout, double delay)
+{
+    timeout_convertdelay(&timeout->abstime, delay);
+    timeout->expired = 0;
+}
+
+/* Note that a timeout is only set to expired when it is used.  This
+ * function does *not* check the current time. */
+int
+PyThread_timeout_expired(PyThread_type_timeout *timeout)
+{
+    return timeout->expired;
+}
+
+
+PyThread_type_flag *
+PyThread_flag_allocate(void)
+{
+    PyThread_type_flag *flag;
+    int status, error = 0;
+
+    flag = malloc(sizeof(PyThread_type_flag));
+    if (flag == NULL)
+        return NULL;
+
+    flag->value = 0;
+    flag->waiting = 0;
+    status = pthread_cond_init(&flag->wakeup, NULL);
+    CHECK_STATUS("pthread_cond_init");
+
+    if (error) {
+            free(flag);
+            flag = NULL;
+    } else {
+            status = pthread_mutex_init(&flag->mutex, NULL);
+            CHECK_STATUS("pthread_mutex_init");
+
+            if (error) {
+                    status = pthread_cond_destroy(&flag->wakeup);
+                    CHECK_STATUS_ABORT("pthread_cond_destroy");
+                    free(flag);
+                    flag = NULL;
+            }
+    }
+
+    return flag;
+}
+
+void
+PyThread_flag_free(PyThread_type_flag *flag)
+{
+    int status;
+
+    assert(flag);
+    status = pthread_cond_destroy(&flag->wakeup);
+    CHECK_STATUS_ABORT("pthread_cond_destroy");
+    status = pthread_mutex_destroy(&flag->mutex);
+    CHECK_STATUS_ABORT("pthread_mutex_destroy");
+    free(flag);
+}
+
+void
+PyThread_flag_set(PyThread_type_flag *flag)
+{
+    int status;
+
+    status = pthread_mutex_lock(&flag->mutex);
+    CHECK_STATUS_ABORT("pthread_mutex_lock");
+
+    if (!flag->value && flag->waiting) {
+        status = pthread_cond_signal(&flag->wakeup);
+        CHECK_STATUS_ABORT("pthread_cond_signal");
+    }
+    flag->value = 1;
+
+    status = pthread_mutex_unlock(&flag->mutex);
+    CHECK_STATUS_ABORT("pthread_mutex_unlock");
+}
+
+void
+PyThread_flag_clear(PyThread_type_flag *flag)
+{
+    int status;
+
+    status = pthread_mutex_lock(&flag->mutex);
+    CHECK_STATUS_ABORT("pthread_mutex_lock");
+
+    if (flag->waiting)
+        Py_FatalError("A flag cannoted be cleared while a thread is waiting");
+
+    flag->value = 0;
+
+    status = pthread_mutex_unlock(&flag->mutex);
+    CHECK_STATUS_ABORT("pthread_mutex_unlock");
+}
+
+void
+PyThread_flag_wait(PyThread_type_flag *flag)
+{
+    int status;
+
+    status = pthread_mutex_lock(&flag->mutex);
+    CHECK_STATUS_ABORT("pthread_mutex_lock");
+
+    if (flag->waiting)
+        Py_FatalError("Only one thread may wait on a flag");
+    flag->waiting = 1;
+
+    while (!flag->value) {
+            status = pthread_cond_wait(&flag->wakeup, &flag->mutex);
+            CHECK_STATUS_ABORT("pthread_cond_wait");
+    }
+
+    flag->waiting = 0;
+
+    status = pthread_mutex_unlock(&flag->mutex);
+    CHECK_STATUS_ABORT("pthread_mutex_unlock");
+}
+
+int
+PyThread_flag_timedwait(PyThread_type_flag *flag, double delay)
+{
+    struct timespec abstime;
+    int status, value;
+
+    timeout_convertdelay(&abstime, delay);
+
+    status = pthread_mutex_lock(&flag->mutex);
+    CHECK_STATUS_ABORT("pthread_mutex_lock");
+
+    if (flag->waiting)
+        Py_FatalError("Only one thread may wait on a flag");
+    flag->waiting = 1;
+
+    while (!flag->value) {
+            status = pthread_cond_timedwait(&flag->wakeup, &flag->mutex,
+                &abstime);
+            if (status == ETIMEDOUT)
+                break;
+            else
+                CHECK_STATUS_ABORT("pthread_cond_wait");
+    }
+
+    value = flag->value;
+    flag->waiting = 0;
+
+    status = pthread_mutex_unlock(&flag->mutex);
+    CHECK_STATUS_ABORT("pthread_mutex_unlock");
+
+    return value;
+}

=== modified file 'Python/traceback.c'
--- Python/traceback.c	2008-01-18 09:56:22 +0000
+++ Python/traceback.c	2008-03-24 04:28:03 +0000
@@ -34,12 +34,9 @@
 static void
 tb_dealloc(PyTracebackObject *tb)
 {
-	PyObject_GC_UnTrack(tb);
-	Py_TRASHCAN_SAFE_BEGIN(tb)
 	Py_XDECREF(tb->tb_next);
 	Py_XDECREF(tb->tb_frame);
-	PyObject_GC_Del(tb);
-	Py_TRASHCAN_SAFE_END(tb)
+	PyObject_Del(tb);
 }
 
 static int
@@ -101,7 +98,7 @@
 		PyErr_BadInternalCall();
 		return NULL;
 	}
-	tb = PyObject_GC_New(PyTracebackObject, &PyTraceBack_Type);
+	tb = PyObject_New(&PyTraceBack_Type);
 	if (tb != NULL) {
 		Py_XINCREF(next);
 		tb->tb_next = next;
@@ -110,7 +107,6 @@
 		tb->tb_lasti = frame->f_lasti;
 		tb->tb_lineno = PyCode_Addr2Line(frame->f_code, 
 						 frame->f_lasti);
-		PyObject_GC_Track(tb);
 	}
 	return tb;
 }
@@ -118,12 +114,12 @@
 int
 PyTraceBack_Here(PyFrameObject *frame)
 {
-	PyThreadState *tstate = PyThreadState_GET();
-	PyTracebackObject *oldtb = (PyTracebackObject *) tstate->curexc_traceback;
+	PyState *pystate = PyState_Get();
+	PyTracebackObject *oldtb = (PyTracebackObject *) pystate->curexc_traceback;
 	PyTracebackObject *tb = newtracebackobject(oldtb, frame);
 	if (tb == NULL)
 		return -1;
-	tstate->curexc_traceback = (PyObject *)tb;
+	pystate->curexc_traceback = (PyObject *)tb;
 	Py_XDECREF(oldtb);
 	return 0;
 }
@@ -182,7 +178,13 @@
 		}
 	}
 	PyOS_snprintf(linebuf, sizeof(linebuf), FMT, filename, lineno, name);
-	err = PyFile_WriteString(linebuf, f);
+
+	if (f == NULL) {
+		PySys_WriteStderr("%s", linebuf);
+		err = 0;
+	} else
+		err = PyFile_WriteString(linebuf, f);
+
 	if (xfp == NULL)
 		return err;
 	else if (err != 0) {
@@ -237,8 +239,6 @@
 		}
 		depth--;
 		tb = tb->tb_next;
-		if (err == 0)
-			err = PyErr_CheckSignals();
 	}
 	return err;
 }
@@ -280,7 +280,13 @@
 		}
 		PyErr_Restore(exc_type, exc_value, exc_tb);
 	}
-	err = PyFile_WriteString("Traceback (most recent call last):\n", f);
+
+	if (f == NULL) {
+		PySys_WriteStderr("Traceback (most recent call last):\n");
+		err = 0;
+	} else
+		err = PyFile_WriteString("Traceback (most recent call last):\n", f);
+
 	if (!err)
 		err = tb_printinternal((PyTracebackObject *)v, f, limit);
 	return err;

=== modified file 'configure'
--- configure	2008-04-04 10:18:23 +0000
+++ configure	2008-04-11 02:56:37 +0000
@@ -1,5 +1,5 @@
 #! /bin/sh
-# From configure.in Revision: 62003 .
+# From configure.in Revision.
 # Guess values for system-dependent variables and create Makefiles.
 # Generated by GNU Autoconf 2.61 for python 3.0.
 #
@@ -711,8 +711,6 @@
 LINKFORSHARED
 CFLAGSFORSHARED
 SHLIBS
-USE_SIGNAL_MODULE
-SIGNAL_OBJS
 USE_THREAD_MODULE
 LDLAST
 THREADOBJ
@@ -1332,7 +1330,6 @@
   --with-pydebug          build with Py_DEBUG defined
   --with-libs='lib1 ...'  link against additional libs
   --with-system-ffi       build _ctypes module using an installed ffi library
-  --with-signal-module    disable/enable signal module
   --with-dec-threads      use DEC Alpha/OSF1 thread-safe libraries
   --with(out)-threads[=DIRECTORY]
                           disable/enable thread support
@@ -1343,6 +1340,7 @@
   --with(out)-tsc         enable/disable timestamp counter profile
   --with(out)-pymalloc    disable/enable specialized mallocs
   --with-wctype-functions use wctype.h functions
+  --with(out)-gil         disables the GIL
   --with-fpectl           enable SIGFPE catching
   --with-libm=STRING      math library
   --with-libc=STRING      C library
@@ -13223,7 +13221,7 @@
 fi
 	# Dynamic linking for HP-UX
 
-# only check for sem_ini if thread support is requested
+# only check for sem_init if thread support is requested
 if test "$with_threads" = "yes" -o -z "$with_threads"; then
     { echo "$as_me:$LINENO: checking for library containing sem_init" >&5
 echo $ECHO_N "checking for library containing sem_init... $ECHO_C" >&6; }
@@ -13601,32 +13599,6 @@
 { echo "$as_me:$LINENO: result: $with_system_ffi" >&5
 echo "${ECHO_T}$with_system_ffi" >&6; }
 
-# Determine if signalmodule should be used.
-
-
-{ echo "$as_me:$LINENO: checking for --with-signal-module" >&5
-echo $ECHO_N "checking for --with-signal-module... $ECHO_C" >&6; }
-
-# Check whether --with-signal-module was given.
-if test "${with_signal_module+set}" = set; then
-  withval=$with_signal_module;
-fi
-
-
-if test -z "$with_signal_module"
-then with_signal_module="yes"
-fi
-{ echo "$as_me:$LINENO: result: $with_signal_module" >&5
-echo "${ECHO_T}$with_signal_module" >&6; }
-
-if test "${with_signal_module}" = "yes"; then
-	USE_SIGNAL_MODULE=""
-	SIGNAL_OBJS=""
-else
-	USE_SIGNAL_MODULE="#"
-	SIGNAL_OBJS="Parser/intrcheck.o Python/sigcheck.o"
-fi
-
 # This is used to generate Setup.config
 
 USE_THREAD_MODULE=""
@@ -15057,6 +15029,62 @@
 fi
 done
 
+
+      { echo "$as_me:$LINENO: checking for __thread storage class specifier" >&5
+echo $ECHO_N "checking for __thread storage class specifier... $ECHO_C" >&6; }
+      cat >conftest.$ac_ext <<_ACEOF
+/* confdefs.h.  */
+_ACEOF
+cat confdefs.h >>conftest.$ac_ext
+cat >>conftest.$ac_ext <<_ACEOF
+/* end confdefs.h.  */
+#ifdef HAVE_PTHREAD_H
+        #include <pthread.h>
+        #endif
+int
+main ()
+{
+static __thread int foo = 1;
+  ;
+  return 0;
+}
+_ACEOF
+rm -f conftest.$ac_objext
+if { (ac_try="$ac_compile"
+case "(($ac_try" in
+  *\"* | *\`* | *\\*) ac_try_echo=\$ac_try;;
+  *) ac_try_echo=$ac_try;;
+esac
+eval "echo \"\$as_me:$LINENO: $ac_try_echo\"") >&5
+  (eval "$ac_compile") 2>conftest.er1
+  ac_status=$?
+  grep -v '^ *+' conftest.er1 >conftest.err
+  rm -f conftest.er1
+  cat conftest.err >&5
+  echo "$as_me:$LINENO: \$? = $ac_status" >&5
+  (exit $ac_status); } && {
+	 test -z "$ac_c_werror_flag" ||
+	 test ! -s conftest.err
+       } && test -s conftest.$ac_objext; then
+
+          { echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6; }
+
+cat >>confdefs.h <<\_ACEOF
+#define HAVE_THREAD_LOCAL_VARIABLE 1
+_ACEOF
+
+
+else
+  echo "$as_me: failed program was:" >&5
+sed 's/^/| /' conftest.$ac_ext >&5
+
+	{ echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6; }
+
+fi
+
+rm -f core conftest.err conftest.$ac_objext conftest.$ac_ext
 fi
 
 
@@ -15488,6 +15516,30 @@
 fi
 
 
+# Check for --without-gil
+{ echo "$as_me:$LINENO: checking for --with-gil" >&5
+echo $ECHO_N "checking for --with-gil... $ECHO_C" >&6; }
+
+# Check whether --with-gil was given.
+if test "${with_gil+set}" = set; then
+  withval=$with_gil;
+fi
+
+
+if test -z "$with_gil"
+then with_gil="yes"
+fi
+if test "$with_gil" != "no"
+then
+
+cat >>confdefs.h <<\_ACEOF
+#define WITH_GIL 1
+_ACEOF
+
+fi
+{ echo "$as_me:$LINENO: result: $with_gil" >&5
+echo "${ECHO_T}$with_gil" >&6; }
+
 # -I${DLINCLDIR} is added to the compile rule for importdl.o
 
 DLINCLDIR=.
@@ -24836,8 +24888,8 @@
 LINKFORSHARED!$LINKFORSHARED$ac_delim
 CFLAGSFORSHARED!$CFLAGSFORSHARED$ac_delim
 SHLIBS!$SHLIBS$ac_delim
-USE_SIGNAL_MODULE!$USE_SIGNAL_MODULE$ac_delim
-SIGNAL_OBJS!$SIGNAL_OBJS$ac_delim
+USE_THREAD_MODULE!$USE_THREAD_MODULE$ac_delim
+LDLAST!$LDLAST$ac_delim
 _ACEOF
 
   if test `sed -n "s/.*$ac_delim\$/X/p" conf$$subs.sed | grep -c X` = 97; then
@@ -24879,8 +24931,6 @@
 ac_delim='%!_!# '
 for ac_last_try in false false false false false :; do
   cat >conf$$subs.sed <<_ACEOF
-USE_THREAD_MODULE!$USE_THREAD_MODULE$ac_delim
-LDLAST!$LDLAST$ac_delim
 THREADOBJ!$THREADOBJ$ac_delim
 DLINCLDIR!$DLINCLDIR$ac_delim
 DYNLOADFILE!$DYNLOADFILE$ac_delim
@@ -24899,7 +24949,7 @@
 LTLIBOBJS!$LTLIBOBJS$ac_delim
 _ACEOF
 
-  if test `sed -n "s/.*$ac_delim\$/X/p" conf$$subs.sed | grep -c X` = 18; then
+  if test `sed -n "s/.*$ac_delim\$/X/p" conf$$subs.sed | grep -c X` = 16; then
     break
   elif $ac_last_try; then
     { { echo "$as_me:$LINENO: error: could not make $CONFIG_STATUS" >&5

=== modified file 'configure.in'
--- configure.in	2008-04-04 10:18:23 +0000
+++ configure.in	2008-04-11 02:07:02 +0000
@@ -1696,7 +1696,7 @@
 AC_CHECK_LIB(dl, dlopen)	# Dynamic linking for SunOS/Solaris and SYSV
 AC_CHECK_LIB(dld, shl_load)	# Dynamic linking for HP-UX
 
-# only check for sem_ini if thread support is requested
+# only check for sem_init if thread support is requested
 if test "$with_threads" = "yes" -o -z "$with_threads"; then
     AC_SEARCH_LIBS(sem_init, pthread rt posix4) # 'Real Time' functions on Solaris
 						# posix4 on Solaris 2.6
@@ -1741,26 +1741,6 @@
 
 AC_MSG_RESULT($with_system_ffi)
 
-# Determine if signalmodule should be used.
-AC_SUBST(USE_SIGNAL_MODULE)
-AC_SUBST(SIGNAL_OBJS)
-AC_MSG_CHECKING(for --with-signal-module)
-AC_ARG_WITH(signal-module,
-            AC_HELP_STRING(--with-signal-module, disable/enable signal module))
-
-if test -z "$with_signal_module"
-then with_signal_module="yes"
-fi
-AC_MSG_RESULT($with_signal_module)
-
-if test "${with_signal_module}" = "yes"; then
-	USE_SIGNAL_MODULE=""
-	SIGNAL_OBJS=""
-else
-	USE_SIGNAL_MODULE="#"
-	SIGNAL_OBJS="Parser/intrcheck.o Python/sigcheck.o"
-fi
-
 # This is used to generate Setup.config
 AC_SUBST(USE_THREAD_MODULE)
 USE_THREAD_MODULE=""
@@ -1995,6 +1975,19 @@
             [Define if pthread_sigmask() does not work on your system.])
             ;;
         esac])
+
+      AC_MSG_CHECKING(for __thread storage class specifier)
+      AC_TRY_COMPILE([#ifdef HAVE_PTHREAD_H
+        #include <pthread.h>
+        #endif],
+        [static __thread int foo = 1;],
+        [
+          AC_MSG_RESULT(yes)
+          AC_DEFINE(HAVE_THREAD_LOCAL_VARIABLE, 1,
+            [Define if your toolchain supports __thread storage class specifier.])
+        ],
+        AC_MSG_RESULT(no)
+      )
 fi
 
 
@@ -2223,6 +2216,21 @@
 fi],
 [AC_MSG_RESULT(no)])
 
+# Check for --without-gil
+AC_MSG_CHECKING(for --with-gil)
+AC_ARG_WITH(gil,
+            AC_HELP_STRING(--with(out)-gil, disables the GIL))
+
+if test -z "$with_gil"
+then with_gil="yes"
+fi
+if test "$with_gil" != "no"
+then
+    AC_DEFINE(WITH_GIL, 1,
+     [Define if you want to build an interpreter with the GIL, for single-threaded performance rather than multi-threaded])
+fi
+AC_MSG_RESULT($with_gil)
+
 # -I${DLINCLDIR} is added to the compile rule for importdl.o
 AC_SUBST(DLINCLDIR)
 DLINCLDIR=.

=== modified file 'pyconfig.h.in'
--- pyconfig.h.in	2008-03-28 10:53:29 +0000
+++ pyconfig.h.in	2008-04-11 02:07:02 +0000
@@ -727,6 +727,9 @@
 /* Define to 1 if you have the <thread.h> header file. */
 #undef HAVE_THREAD_H
 
+/* Define if your toolchain supports __thread storage class specifier. */
+#undef HAVE_THREAD_LOCAL_VARIABLE
+
 /* Define to 1 if you have the `timegm' function. */
 #undef HAVE_TIMEGM
 
@@ -957,6 +960,10 @@
    Dyld is necessary to support frameworks. */
 #undef WITH_DYLD
 
+/* Define if you want to build an interpreter with the GIL, for
+   single-threaded performance rather than multi-threaded */
+#undef WITH_GIL
+
 /* Define to 1 if libintl is needed for locale functions. */
 #undef WITH_LIBINTL
 

