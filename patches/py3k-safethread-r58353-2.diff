Index: Python/codecs.c
===================================================================
--- Python/codecs.c	(revision 58355)
+++ Python/codecs.c	(working copy)
@@ -28,7 +28,7 @@
 
 int PyCodec_Register(PyObject *search_function)
 {
-    PyInterpreterState *interp = PyThreadState_GET()->interp;
+    PyInterpreterState *interp = PyThreadState_Get()->interp;
     if (interp->codec_search_path == NULL && _PyCodecRegistry_Init())
 	goto onError;
     if (search_function == NULL) {
@@ -102,7 +102,7 @@
 	goto onError;
     }
 
-    interp = PyThreadState_GET()->interp;
+    interp = PyThreadState_Get()->interp;
     if (interp->codec_search_path == NULL && _PyCodecRegistry_Init())
 	goto onError;
 
@@ -410,7 +410,7 @@
    Return 0 on success, -1 on error */
 int PyCodec_RegisterError(const char *name, PyObject *error)
 {
-    PyInterpreterState *interp = PyThreadState_GET()->interp;
+    PyInterpreterState *interp = PyThreadState_Get()->interp;
     if (interp->codec_search_path == NULL && _PyCodecRegistry_Init())
 	return -1;
     if (!PyCallable_Check(error)) {
@@ -428,7 +428,7 @@
 {
     PyObject *handler = NULL;
 
-    PyInterpreterState *interp = PyThreadState_GET()->interp;
+    PyInterpreterState *interp = PyThreadState_Get()->interp;
     if (interp->codec_search_path == NULL && _PyCodecRegistry_Init())
 	return NULL;
 
@@ -805,7 +805,7 @@
 	}
     };
 
-    PyInterpreterState *interp = PyThreadState_GET()->interp;
+    PyInterpreterState *interp = PyThreadState_Get()->interp;
     PyObject *mod;
     unsigned i;
 
Index: Python/errors.c
===================================================================
--- Python/errors.c	(revision 58355)
+++ Python/errors.c	(working copy)
@@ -24,7 +24,7 @@
 void
 PyErr_Restore(PyObject *type, PyObject *value, PyObject *traceback)
 {
-	PyThreadState *tstate = PyThreadState_GET();
+	PyThreadState *tstate = PyThreadState_Get();
 	PyObject *oldtype, *oldvalue, *oldtraceback;
 
 	if (traceback != NULL && !PyTraceBack_Check(traceback)) {
@@ -52,6 +52,8 @@
 void
 PyErr_SetObject(PyObject *exception, PyObject *value)
 {
+	if (exception != NULL && exception->ob_type == NULL)
+		Py_FatalError("Unitialized exception type passed to PyErr_SetObject");
 	if (exception != NULL &&
 	    !PyExceptionClass_Check(exception)) {
 		PyErr_Format(PyExc_SystemError,
@@ -82,7 +84,7 @@
 PyObject *
 PyErr_Occurred(void)
 {
-	PyThreadState *tstate = PyThreadState_GET();
+	PyThreadState *tstate = PyThreadState_Get();
 
 	return tstate->curexc_type;
 }
@@ -215,7 +217,7 @@
 			Py_DECREF(initial_tb);
 	}
 	/* normalize recursively */
-	tstate = PyThreadState_GET();
+	tstate = PyThreadState_Get();
 	if (++tstate->recursion_depth > Py_GetRecursionLimit()) {
 	    --tstate->recursion_depth;
 	    PyErr_SetObject(PyExc_RuntimeError, PyExc_RecursionErrorInst);
@@ -225,11 +227,20 @@
 	--tstate->recursion_depth;
 }
 
+PyObject *
+PyErr_SimplifyException(PyObject *exc, PyObject *val, PyObject *tb)
+{
+    PyErr_NormalizeException(&exc, &val, &tb);
+    Py_DECREF(exc);
+    Py_XDECREF(tb);
+    return val;
+}
 
+
 void
 PyErr_Fetch(PyObject **p_type, PyObject **p_value, PyObject **p_traceback)
 {
-	PyThreadState *tstate = PyThreadState_GET();
+	PyThreadState *tstate = PyThreadState_Get();
 
 	*p_type = tstate->curexc_type;
 	*p_value = tstate->curexc_value;
@@ -291,11 +302,6 @@
 #endif /* Unix/Windows */
 #endif /* PLAN 9*/
 
-#ifdef EINTR
-	if (i == EINTR && PyErr_CheckSignals())
-		return NULL;
-#endif
-
 #ifdef PLAN9
 	rerrstr(errbuf, sizeof errbuf);
 	message = PyUnicode_DecodeUTF8(errbuf, strlen(errbuf), "ignore");
Index: Python/ceval.c
===================================================================
--- Python/ceval.c	(revision 58355)
+++ Python/ceval.c	(working copy)
@@ -79,7 +79,7 @@
 
 #ifdef Py_DEBUG
 /* For debugging the interpreter: */
-#define LLTRACE  1	/* Low-level trace feature */
+//#define LLTRACE  1	/* Low-level trace feature */
 #define CHECKEXC 1	/* Double-check exception checking */
 #endif
 
@@ -87,11 +87,11 @@
 
 /* Forward declarations */
 #ifdef WITH_TSC
-static PyObject * call_function(PyObject ***, int, uint64*, uint64*);
+static PyObject * call_function(PyThreadState *, PyObject ***, int, uint64*, uint64*);
 #else
-static PyObject * call_function(PyObject ***, int);
+static PyObject * call_function(PyThreadState *, PyObject ***, int);
 #endif
-static PyObject * fast_function(PyObject *, PyObject ***, int, int, int);
+static PyObject * fast_function(PyThreadState *, PyObject *, PyObject ***, int, int, int);
 static PyObject * do_call(PyObject *, PyObject ***, int, int);
 static PyObject * ext_do_call(PyObject *, PyObject ***, int, int, int);
 static PyObject * update_keyword_args(PyObject *, int, PyObject ***,
@@ -199,222 +199,12 @@
 #endif
 
 
-#ifdef WITH_THREAD
-
 #ifdef HAVE_ERRNO_H
 #include <errno.h>
 #endif
 #include "pythread.h"
 
-static PyThread_type_lock interpreter_lock = 0; /* This is the GIL */
-static long main_thread = 0;
 
-int
-PyEval_ThreadsInitialized(void)
-{
-	return interpreter_lock != 0;
-}
-
-void
-PyEval_InitThreads(void)
-{
-	if (interpreter_lock)
-		return;
-	interpreter_lock = PyThread_allocate_lock();
-	PyThread_acquire_lock(interpreter_lock, 1);
-	main_thread = PyThread_get_thread_ident();
-}
-
-void
-PyEval_AcquireLock(void)
-{
-	PyThread_acquire_lock(interpreter_lock, 1);
-}
-
-void
-PyEval_ReleaseLock(void)
-{
-	PyThread_release_lock(interpreter_lock);
-}
-
-void
-PyEval_AcquireThread(PyThreadState *tstate)
-{
-	if (tstate == NULL)
-		Py_FatalError("PyEval_AcquireThread: NULL new thread state");
-	/* Check someone has called PyEval_InitThreads() to create the lock */
-	assert(interpreter_lock);
-	PyThread_acquire_lock(interpreter_lock, 1);
-	if (PyThreadState_Swap(tstate) != NULL)
-		Py_FatalError(
-			"PyEval_AcquireThread: non-NULL old thread state");
-}
-
-void
-PyEval_ReleaseThread(PyThreadState *tstate)
-{
-	if (tstate == NULL)
-		Py_FatalError("PyEval_ReleaseThread: NULL thread state");
-	if (PyThreadState_Swap(NULL) != tstate)
-		Py_FatalError("PyEval_ReleaseThread: wrong thread state");
-	PyThread_release_lock(interpreter_lock);
-}
-
-/* This function is called from PyOS_AfterFork to ensure that newly
-   created child processes don't hold locks referring to threads which
-   are not running in the child process.  (This could also be done using
-   pthread_atfork mechanism, at least for the pthreads implementation.) */
-
-void
-PyEval_ReInitThreads(void)
-{
-	if (!interpreter_lock)
-		return;
-	/*XXX Can't use PyThread_free_lock here because it does too
-	  much error-checking.  Doing this cleanly would require
-	  adding a new function to each thread_*.h.  Instead, just
-	  create a new lock and waste a little bit of memory */
-	interpreter_lock = PyThread_allocate_lock();
-	PyThread_acquire_lock(interpreter_lock, 1);
-	main_thread = PyThread_get_thread_ident();
-}
-#endif
-
-/* Functions save_thread and restore_thread are always defined so
-   dynamically loaded modules needn't be compiled separately for use
-   with and without threads: */
-
-PyThreadState *
-PyEval_SaveThread(void)
-{
-	PyThreadState *tstate = PyThreadState_Swap(NULL);
-	if (tstate == NULL)
-		Py_FatalError("PyEval_SaveThread: NULL tstate");
-#ifdef WITH_THREAD
-	if (interpreter_lock)
-		PyThread_release_lock(interpreter_lock);
-#endif
-	return tstate;
-}
-
-void
-PyEval_RestoreThread(PyThreadState *tstate)
-{
-	if (tstate == NULL)
-		Py_FatalError("PyEval_RestoreThread: NULL tstate");
-#ifdef WITH_THREAD
-	if (interpreter_lock) {
-		int err = errno;
-		PyThread_acquire_lock(interpreter_lock, 1);
-		errno = err;
-	}
-#endif
-	PyThreadState_Swap(tstate);
-}
-
-
-/* Mechanism whereby asynchronously executing callbacks (e.g. UNIX
-   signal handlers or Mac I/O completion routines) can schedule calls
-   to a function to be called synchronously.
-   The synchronous function is called with one void* argument.
-   It should return 0 for success or -1 for failure -- failure should
-   be accompanied by an exception.
-
-   If registry succeeds, the registry function returns 0; if it fails
-   (e.g. due to too many pending calls) it returns -1 (without setting
-   an exception condition).
-
-   Note that because registry may occur from within signal handlers,
-   or other asynchronous events, calling malloc() is unsafe!
-
-#ifdef WITH_THREAD
-   Any thread can schedule pending calls, but only the main thread
-   will execute them.
-#endif
-
-   XXX WARNING!  ASYNCHRONOUSLY EXECUTING CODE!
-   There are two possible race conditions:
-   (1) nested asynchronous registry calls;
-   (2) registry calls made while pending calls are being processed.
-   While (1) is very unlikely, (2) is a real possibility.
-   The current code is safe against (2), but not against (1).
-   The safety against (2) is derived from the fact that only one
-   thread (the main thread) ever takes things out of the queue.
-
-   XXX Darn!  With the advent of thread state, we should have an array
-   of pending calls per thread in the thread state!  Later...
-*/
-
-#define NPENDINGCALLS 32
-static struct {
-	int (*func)(void *);
-	void *arg;
-} pendingcalls[NPENDINGCALLS];
-static volatile int pendingfirst = 0;
-static volatile int pendinglast = 0;
-static volatile int things_to_do = 0;
-
-int
-Py_AddPendingCall(int (*func)(void *), void *arg)
-{
-	static volatile int busy = 0;
-	int i, j;
-	/* XXX Begin critical section */
-	/* XXX If you want this to be safe against nested
-	   XXX asynchronous calls, you'll have to work harder! */
-	if (busy)
-		return -1;
-	busy = 1;
-	i = pendinglast;
-	j = (i + 1) % NPENDINGCALLS;
-	if (j == pendingfirst) {
-		busy = 0;
-		return -1; /* Queue full */
-	}
-	pendingcalls[i].func = func;
-	pendingcalls[i].arg = arg;
-	pendinglast = j;
-
-	_Py_Ticker = 0;
-	things_to_do = 1; /* Signal main loop */
-	busy = 0;
-	/* XXX End critical section */
-	return 0;
-}
-
-int
-Py_MakePendingCalls(void)
-{
-	static int busy = 0;
-#ifdef WITH_THREAD
-	if (main_thread && PyThread_get_thread_ident() != main_thread)
-		return 0;
-#endif
-	if (busy)
-		return 0;
-	busy = 1;
-	things_to_do = 0;
-	for (;;) {
-		int i;
-		int (*func)(void *);
-		void *arg;
-		i = pendingfirst;
-		if (i == pendinglast)
-			break; /* Queue empty */
-		func = pendingcalls[i].func;
-		arg = pendingcalls[i].arg;
-		pendingfirst = (i + 1) % NPENDINGCALLS;
-		if (func(arg) < 0) {
-			busy = 0;
-			things_to_do = 1; /* We're not done yet */
-			return -1;
-		}
-	}
-	busy = 0;
-	return 0;
-}
-
-
 /* The interpreter's recursion limit */
 
 #ifndef Py_DEFAULT_RECURSION_LIMIT
@@ -444,7 +234,7 @@
 int
 _Py_CheckRecursiveCall(char *where)
 {
-	PyThreadState *tstate = PyThreadState_GET();
+	PyThreadState *tstate = PyThreadState_Get();
 
 #ifdef USE_STACKCHECK
 	if (PyOS_CheckStack()) {
@@ -491,8 +281,8 @@
 
 /* for manipulating the thread switch and periodic "stuff" - used to be
    per thread, now just a pair o' globals */
-int _Py_CheckInterval = 100;
-volatile int _Py_Ticker = 100;
+int _Py_CheckInterval = 10000;
+//volatile int _Py_Ticker = 100;
 
 PyObject *
 PyEval_EvalCode(PyCodeObject *co, PyObject *globals, PyObject *locals)
@@ -528,14 +318,14 @@
 	register int oparg;	/* Current opcode argument, if any */
 	register enum why_code why; /* Reason for block stack unwind */
 	register int err;	/* Error status -- nonzero if error */
-	register PyObject *x;	/* Result object -- NULL if error */
+	PyObject *x;	/* Result object -- NULL if error */
 	register PyObject *v;	/* Temporary objects popped off stack */
 	register PyObject *w;
 	register PyObject *u;
 	register PyObject *t;
 	register PyObject **fastlocals, **freevars;
 	PyObject *retval = NULL;	/* Return value */
-	PyThreadState *tstate = PyThreadState_GET();
+	PyThreadState *tstate = PyThreadState_Get();
 	PyCodeObject *co;
 
 	/* when tracing we set things up so that
@@ -689,7 +479,7 @@
    variable would be pointing to already-freed memory. */
 #define SETLOCAL(i, value)	do { PyObject *tmp = GETLOCAL(i); \
 				     GETLOCAL(i) = value; \
-                                     Py_XDECREF(tmp); } while (0)
+                                     Py_XDECREFTS(tmp); } while (0)
 
 /* Start of code */
 
@@ -700,6 +490,7 @@
 	if (Py_EnterRecursiveCall(""))
 		return NULL;
 
+	//printf("%p's old %p replaced with f %p\n", tstate, tstate->frame, f);
 	tstate->frame = f;
 
 	if (tstate->use_tracing) {
@@ -801,63 +592,12 @@
 		assert(stack_pointer >= f->f_valuestack); /* else underflow */
 		assert(STACK_LEVEL() <= co->co_stacksize);  /* else overflow */
 
-		/* Do periodic things.  Doing this every time through
-		   the loop would add too much overhead, so we do it
-		   only every Nth instruction.  We also do it if
-		   ``things_to_do'' is set, i.e. when an asynchronous
-		   event needs attention (e.g. a signal handler or
-		   async I/O handler); see Py_AddPendingCall() and
-		   Py_MakePendingCalls() above. */
-
-		if (--_Py_Ticker < 0) {
-			if (*next_instr == SETUP_FINALLY) {
-				/* Make the last opcode before
-				   a try: finally: block uninterruptable. */
-				goto fast_next_opcode;
-			}
-			_Py_Ticker = _Py_CheckInterval;
-			tstate->tick_counter++;
-#ifdef WITH_TSC
-			ticked = 1;
-#endif
-			if (things_to_do) {
-				if (Py_MakePendingCalls() < 0) {
-					why = WHY_EXCEPTION;
-					goto on_error;
-				}
-				if (things_to_do)
-					/* MakePendingCalls() didn't succeed.
-					   Force early re-execution of this
-					   "periodic" code, possibly after
-					   a thread switch */
-					_Py_Ticker = 0;
-			}
-#ifdef WITH_THREAD
-			if (interpreter_lock) {
-				/* Give another thread a chance */
-
-				if (PyThreadState_Swap(NULL) != tstate)
-					Py_FatalError("ceval: tstate mix-up");
-				PyThread_release_lock(interpreter_lock);
-
-				/* Other threads may run now */
-
-				PyThread_acquire_lock(interpreter_lock, 1);
-				if (PyThreadState_Swap(tstate) != NULL)
-					Py_FatalError("ceval: orphan tstate");
-
-				/* Check for thread interrupts */
-
-				if (tstate->async_exc != NULL) {
-					x = tstate->async_exc;
-					tstate->async_exc = NULL;
-					PyErr_SetNone(x);
-					Py_DECREF(x);
-					why = WHY_EXCEPTION;
-					goto on_error;
-				}
-			}
-#endif
+		/* Check for asynchronous events, unless we're at the
+		 * last opcode before a try-finally block. */
+		if (*next_instr != SETUP_FINALLY && PyThreadState_Tick()) {
+			assert(PyErr_Occurred());
+			why = WHY_EXCEPTION;
+			goto on_error;
 		}
 
 	fast_next_opcode:
@@ -895,6 +635,7 @@
 			oparg = NEXTARG();
 	  dispatch_opcode:
 #ifdef DYNAMIC_EXECUTION_PROFILE
+#error bleh
 #ifdef DXPAIRS
 		dxpairs[lastopcode][opcode]++;
 		lastopcode = opcode;
@@ -903,6 +644,7 @@
 #endif
 
 #ifdef LLTRACE
+#error bleh lltrace
 		/* Instruction tracing */
 
 		if (lltrace) {
@@ -935,7 +677,7 @@
 		case LOAD_FAST:
 			x = GETLOCAL(oparg);
 			if (x != NULL) {
-				Py_INCREF(x);
+				Py_INCREFTS(x);
 				PUSH(x);
 				goto fast_next_opcode;
 			}
@@ -946,7 +688,7 @@
 
 		case LOAD_CONST:
 			x = GETITEM(consts, oparg);
-			Py_INCREF(x);
+			Py_INCREFTS(x);
 			PUSH(x);
 			goto fast_next_opcode;
 
@@ -959,7 +701,7 @@
 		PREDICTED(POP_TOP);
 		case POP_TOP:
 			v = POP();
-			Py_DECREF(v);
+			Py_DECREFTS(v);
 			goto fast_next_opcode;
 
 		case ROT_TWO:
@@ -991,27 +733,27 @@
 
 		case DUP_TOP:
 			v = TOP();
-			Py_INCREF(v);
+			Py_INCREFTS(v);
 			PUSH(v);
 			goto fast_next_opcode;
 
 		case DUP_TOPX:
 			if (oparg == 2) {
 				x = TOP();
-				Py_INCREF(x);
+				Py_INCREFTS(x);
 				w = SECOND();
-				Py_INCREF(w);
+				Py_INCREFTS(w);
 				STACKADJ(2);
 				SET_TOP(x);
 				SET_SECOND(w);
 				goto fast_next_opcode;
 			} else if (oparg == 3) {
 				x = TOP();
-				Py_INCREF(x);
+				Py_INCREFTS(x);
 				w = SECOND();
-				Py_INCREF(w);
+				Py_INCREFTS(w);
 				v = THIRD();
-				Py_INCREF(v);
+				Py_INCREFTS(v);
 				STACKADJ(3);
 				SET_TOP(x);
 				SET_SECOND(w);
@@ -1025,7 +767,7 @@
 		case UNARY_POSITIVE:
 			v = TOP();
 			x = PyNumber_Positive(v);
-			Py_DECREF(v);
+			Py_DECREFTS(v);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1033,7 +775,7 @@
 		case UNARY_NEGATIVE:
 			v = TOP();
 			x = PyNumber_Negative(v);
-			Py_DECREF(v);
+			Py_DECREFTS(v);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1041,14 +783,14 @@
 		case UNARY_NOT:
 			v = TOP();
 			err = PyObject_IsTrue(v);
-			Py_DECREF(v);
+			Py_DECREFTS(v);
 			if (err == 0) {
-				Py_INCREF(Py_True);
+				Py_INCREFTS(Py_True);
 				SET_TOP(Py_True);
 				continue;
 			}
 			else if (err > 0) {
-				Py_INCREF(Py_False);
+				Py_INCREFTS(Py_False);
 				SET_TOP(Py_False);
 				err = 0;
 				continue;
@@ -1059,7 +801,7 @@
 		case UNARY_INVERT:
 			v = TOP();
 			x = PyNumber_Invert(v);
-			Py_DECREF(v);
+			Py_DECREFTS(v);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1068,8 +810,8 @@
 			w = POP();
 			v = TOP();
 			x = PyNumber_Power(v, w, Py_None);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREFTS(v);
+			Py_DECREFTS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1078,8 +820,8 @@
 			w = POP();
 			v = TOP();
 			x = PyNumber_Multiply(v, w);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREFTS(v);
+			Py_DECREFTS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1088,8 +830,8 @@
 			w = POP();
 			v = TOP();
 			x = PyNumber_TrueDivide(v, w);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREFTS(v);
+			Py_DECREFTS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1098,8 +840,8 @@
 			w = POP();
 			v = TOP();
 			x = PyNumber_FloorDivide(v, w);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREFTS(v);
+			Py_DECREFTS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1108,8 +850,8 @@
 			w = POP();
 			v = TOP();
 			x = PyNumber_Remainder(v, w);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREFTS(v);
+			Py_DECREFTS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1137,9 +879,9 @@
 			  slow_add:
 				x = PyNumber_Add(v, w);
 			}
-			Py_DECREF(v);
+			Py_DECREFTS(v);
 		  skip_decref_vx:
-			Py_DECREF(w);
+			Py_DECREFTS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1161,8 +903,8 @@
 			  slow_sub:
 				x = PyNumber_Subtract(v, w);
 			}
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREFTS(v);
+			Py_DECREFTS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1177,7 +919,7 @@
 					i += PyList_GET_SIZE(v);
 				if (i >= 0 && i < PyList_GET_SIZE(v)) {
 					x = PyList_GET_ITEM(v, i);
-					Py_INCREF(x);
+					Py_INCREFTS(x);
 				}
 				else
 					goto slow_get;
@@ -1185,8 +927,8 @@
 			else
 			  slow_get:
 				x = PyObject_GetItem(v, w);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREFTS(v);
+			Py_DECREFTS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1195,8 +937,8 @@
 			w = POP();
 			v = TOP();
 			x = PyNumber_Lshift(v, w);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREFTS(v);
+			Py_DECREFTS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1205,8 +947,8 @@
 			w = POP();
 			v = TOP();
 			x = PyNumber_Rshift(v, w);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREFTS(v);
+			Py_DECREFTS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1215,8 +957,8 @@
 			w = POP();
 			v = TOP();
 			x = PyNumber_And(v, w);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREFTS(v);
+			Py_DECREFTS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1225,8 +967,8 @@
 			w = POP();
 			v = TOP();
 			x = PyNumber_Xor(v, w);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREFTS(v);
+			Py_DECREFTS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1235,8 +977,8 @@
 			w = POP();
 			v = TOP();
 			x = PyNumber_Or(v, w);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREFTS(v);
+			Py_DECREFTS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1245,8 +987,8 @@
 			w = POP();
 			v = POP();
 			err = PyList_Append(v, w);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREFTS(v);
+			Py_DECREFTS(w);
 			if (err == 0) {
 				PREDICT(JUMP_ABSOLUTE);
 				continue;
@@ -1257,8 +999,8 @@
 			w = POP();
 			v = POP();
 			err = PySet_Add(v, w);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREFTS(v);
+			Py_DECREFTS(w);
 			if (err == 0) {
 				PREDICT(JUMP_ABSOLUTE);
 				continue;
@@ -1269,8 +1011,8 @@
 			w = POP();
 			v = TOP();
 			x = PyNumber_InPlacePower(v, w, Py_None);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREFTS(v);
+			Py_DECREFTS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1279,8 +1021,8 @@
 			w = POP();
 			v = TOP();
 			x = PyNumber_InPlaceMultiply(v, w);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREFTS(v);
+			Py_DECREFTS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1289,8 +1031,8 @@
 			w = POP();
 			v = TOP();
 			x = PyNumber_InPlaceTrueDivide(v, w);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREFTS(v);
+			Py_DECREFTS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1299,8 +1041,8 @@
 			w = POP();
 			v = TOP();
 			x = PyNumber_InPlaceFloorDivide(v, w);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREFTS(v);
+			Py_DECREFTS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1309,8 +1051,8 @@
 			w = POP();
 			v = TOP();
 			x = PyNumber_InPlaceRemainder(v, w);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREFTS(v);
+			Py_DECREFTS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1338,9 +1080,9 @@
 			  slow_iadd:
 				x = PyNumber_InPlaceAdd(v, w);
 			}
-			Py_DECREF(v);
+			Py_DECREFTS(v);
 		  skip_decref_v:
-			Py_DECREF(w);
+			Py_DECREFTS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1362,8 +1104,8 @@
 			  slow_isub:
 				x = PyNumber_InPlaceSubtract(v, w);
 			}
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREFTS(v);
+			Py_DECREFTS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1372,8 +1114,8 @@
 			w = POP();
 			v = TOP();
 			x = PyNumber_InPlaceLshift(v, w);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREFTS(v);
+			Py_DECREFTS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1382,8 +1124,8 @@
 			w = POP();
 			v = TOP();
 			x = PyNumber_InPlaceRshift(v, w);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREFTS(v);
+			Py_DECREFTS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1392,8 +1134,8 @@
 			w = POP();
 			v = TOP();
 			x = PyNumber_InPlaceAnd(v, w);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREFTS(v);
+			Py_DECREFTS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1402,8 +1144,8 @@
 			w = POP();
 			v = TOP();
 			x = PyNumber_InPlaceXor(v, w);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREFTS(v);
+			Py_DECREFTS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1412,8 +1154,8 @@
 			w = POP();
 			v = TOP();
 			x = PyNumber_InPlaceOr(v, w);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREFTS(v);
+			Py_DECREFTS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1425,9 +1167,9 @@
 			STACKADJ(-3);
 			/* v[w] = u */
 			err = PyObject_SetItem(v, w, u);
-			Py_DECREF(u);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREFTS(u);
+			Py_DECREFTS(v);
+			Py_DECREFTS(w);
 			if (err == 0) continue;
 			break;
 
@@ -1437,8 +1179,8 @@
 			STACKADJ(-2);
 			/* del v[w] */
 			err = PyObject_DelItem(v, w);
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREFTS(v);
+			Py_DECREFTS(w);
 			if (err == 0) continue;
 			break;
 
@@ -1458,12 +1200,12 @@
 			}
 			if (err == 0) {
 				w = PyEval_CallObject(w, x);
-				Py_XDECREF(w);
+				Py_XDECREFTS(w);
 				if (w == NULL)
 					err = -1;
 			}
-			Py_DECREF(v);
-			Py_XDECREF(x);
+			Py_DECREFTS(v);
+			Py_XDECREFTS(x);
 			break;
 
 #ifdef CASE_TOO_BIG
@@ -1490,7 +1232,7 @@
 		case STORE_LOCALS:
 			x = POP();
 			v = f->f_locals;
-			Py_XDECREF(v);
+			Py_XDECREFTS(v);
 			f->f_locals = x;
 			continue;
 
@@ -1510,7 +1252,7 @@
 				PyTryBlock *b = PyFrame_BlockPop(f);
 				while (STACK_LEVEL() > b->b_level) {
 					v = POP();
-					Py_DECREF(v);
+					Py_DECREFTS(v);
 				}
 			}
 			continue;
@@ -1536,18 +1278,19 @@
 					"'finally' pops bad exception");
 				why = WHY_EXCEPTION;
 			}
-			Py_DECREF(v);
+			Py_DECREFTS(v);
 			break;
 
 		case LOAD_BUILD_CLASS:
-			x = PyDict_GetItemString(f->f_builtins,
-						 "__build_class__");
+			if (PyDict_GetItemStringEx(f->f_builtins,
+					"__build_class__", &x) < 0)
+				break;
 			if (x == NULL) {
 				PyErr_SetString(PyExc_ImportError,
 						"__build_class__ not found");
 				break;
 			}
-			Py_INCREF(x);
+			/*Py_INCREFTS(x);*/
 			PUSH(x);
 			break;
 
@@ -1559,7 +1302,7 @@
 					err = PyDict_SetItem(x, w, v);
 				else
 					err = PyObject_SetItem(x, w, v);
-				Py_DECREF(v);
+				Py_DECREFTS(v);
 				if (err == 0) continue;
 				break;
 			}
@@ -1591,10 +1334,10 @@
 					((PyTupleObject *)v)->ob_item;
 				while (oparg--) {
 					w = items[oparg];
-					Py_INCREF(w);
+					Py_INCREFTS(w);
 					PUSH(w);
 				}
-				Py_DECREF(v);
+				Py_DECREFTS(v);
 				continue;
 			} else if (PyList_CheckExact(v) &&
 				   PyList_GET_SIZE(v) == oparg) {
@@ -1602,7 +1345,7 @@
 					((PyListObject *)v)->ob_item;
 				while (oparg--) {
 					w = items[oparg];
-					Py_INCREF(w);
+					Py_INCREFTS(w);
 					PUSH(w);
 				}
 			} else if (unpack_iterable(v, oparg, -1,
@@ -1612,7 +1355,7 @@
 				/* unpack_iterable() raised an exception */
 				why = WHY_EXCEPTION;
 			}
-			Py_DECREF(v);
+			Py_DECREFTS(v);
 			break;
 
 		case UNPACK_EX:
@@ -1626,7 +1369,7 @@
 			} else {
 				why = WHY_EXCEPTION;
 			}
-			Py_DECREF(v);
+			Py_DECREFTS(v);
 			break;
 		}
 
@@ -1636,8 +1379,8 @@
 			u = SECOND();
 			STACKADJ(-2);
 			err = PyObject_SetAttr(v, w, u); /* v.w = u */
-			Py_DECREF(v);
-			Py_DECREF(u);
+			Py_DECREFTS(v);
+			Py_DECREFTS(u);
 			if (err == 0) continue;
 			break;
 
@@ -1646,14 +1389,14 @@
 			v = POP();
 			err = PyObject_SetAttr(v, w, (PyObject *)NULL);
 							/* del v.w */
-			Py_DECREF(v);
+			Py_DECREFTS(v);
 			break;
 
 		case STORE_GLOBAL:
 			w = GETITEM(names, oparg);
 			v = POP();
 			err = PyDict_SetItem(f->f_globals, w, v);
-			Py_DECREF(v);
+			Py_DECREFTS(v);
 			if (err == 0) continue;
 			break;
 
@@ -1674,9 +1417,8 @@
 			}
 			if (PyDict_CheckExact(v)) {
 				x = PyDict_GetItem(v, w);
-				Py_XINCREF(x);
-			}
-			else {
+				Py_XINCREFTS(x);
+			} else {
 				x = PyObject_GetItem(v, w);
 				if (x == NULL && PyErr_Occurred()) {
 					if (!PyErr_ExceptionMatches(
@@ -1686,9 +1428,11 @@
 				}
 			}
 			if (x == NULL) {
-				x = PyDict_GetItem(f->f_globals, w);
+				if (PyDict_GetItemEx(f->f_globals, w, &x) < 0)
+					break;
 				if (x == NULL) {
-					x = PyDict_GetItem(f->f_builtins, w);
+					if (PyDict_GetItemEx(f->f_builtins, w, &x) < 0)
+						break;
 					if (x == NULL) {
 						format_exc_check_arg(
 							    PyExc_NameError,
@@ -1696,7 +1440,6 @@
 						break;
 					}
 				}
-				Py_INCREF(x);
 			}
 			PUSH(x);
 			continue;
@@ -1711,37 +1454,52 @@
 				if (hash != -1) {
 					PyDictObject *d;
 					PyDictEntry *e;
+					PyDict_LockState lockstate;
+
 					d = (PyDictObject *)(f->f_globals);
-					e = d->ma_lookup(d, w, hash);
+					_pydictlock_initstate_read(&lockstate);
+					_pydictlock_acquire(d, &lockstate);
+					e = d->ma_lookup(d, w, hash, &lockstate);
 					if (e == NULL) {
+						_pydictlock_release(d, &lockstate);
 						x = NULL;
 						break;
 					}
 					x = e->me_value;
 					if (x != NULL) {
-						Py_INCREF(x);
+						Py_INCREFTS(x);
+						_pydictlock_release(d, &lockstate);
 						PUSH(x);
 						continue;
 					}
+					_pydictlock_release(d, &lockstate);
+
 					d = (PyDictObject *)(f->f_builtins);
-					e = d->ma_lookup(d, w, hash);
+					_pydictlock_initstate_read(&lockstate);
+					_pydictlock_acquire(d, &lockstate);
+					e = d->ma_lookup(d, w, hash, &lockstate);
 					if (e == NULL) {
+						_pydictlock_release(d, &lockstate);
 						x = NULL;
 						break;
 					}
 					x = e->me_value;
 					if (x != NULL) {
-						Py_INCREF(x);
+						Py_INCREFTS(x);
+						_pydictlock_release(d, &lockstate);
 						PUSH(x);
 						continue;
 					}
+					_pydictlock_release(d, &lockstate);
 					goto load_global_error;
 				}
 			}
 			/* This is the un-inlined version of the code above */
-			x = PyDict_GetItem(f->f_globals, w);
+			if (PyDict_GetItemEx(f->f_builtins, w, &x) < 0)
+				break;
 			if (x == NULL) {
-				x = PyDict_GetItem(f->f_builtins, w);
+				if (PyDict_GetItemEx(f->f_builtins, w, &x) < 0)
+					break;
 				if (x == NULL) {
 				  load_global_error:
 					format_exc_check_arg(
@@ -1750,7 +1508,6 @@
 					break;
 				}
 			}
-			Py_INCREF(x);
 			PUSH(x);
 			continue;
 
@@ -1769,7 +1526,7 @@
 
 		case LOAD_CLOSURE:
 			x = freevars[oparg];
-			Py_INCREF(x);
+			Py_INCREFTS(x);
 			PUSH(x);
 			if (x != NULL) continue;
 			break;
@@ -1804,7 +1561,7 @@
 			w = POP();
 			x = freevars[oparg];
 			PyCell_Set(x, w);
-			Py_DECREF(w);
+			Py_DECREFTS(w);
 			continue;
 
 		case BUILD_TUPLE:
@@ -1838,10 +1595,10 @@
 					w = POP();
 					if (err == 0)
 						err = PySet_Add(x, w);
-					Py_DECREF(w);
+					Py_DECREFTS(w);
 				}
 				if (err != 0) {
-					Py_DECREF(x);
+					Py_DECREFTS(x);
 					break;
 				}
 				PUSH(x);
@@ -1863,7 +1620,7 @@
 					PyString_GET_SIZE(w));
 			else
 				x = NULL;
-			Py_DECREF(w);
+			Py_DECREFTS(w);
 			PUSH(x);
 			if (x != NULL) continue;
 			break;
@@ -1872,7 +1629,7 @@
 			w = GETITEM(names, oparg);
 			v = TOP();
 			x = PyObject_GetAttr(v, w);
-			Py_DECREF(v);
+			Py_DECREFTS(v);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -1898,14 +1655,14 @@
 				default: goto slow_compare;
 				}
 				x = res ? Py_True : Py_False;
-				Py_INCREF(x);
+				Py_INCREFTS(x);
 			}
 			else {
 			  slow_compare:
 				x = cmp_outcome(oparg, v, w);
 			}
-			Py_DECREF(v);
-			Py_DECREF(w);
+			Py_DECREFTS(v);
+			Py_DECREFTS(w);
 			SET_TOP(x);
 			if (x == NULL) break;
 			PREDICT(JUMP_IF_FALSE);
@@ -1914,7 +1671,9 @@
 
 		case IMPORT_NAME:
 			w = GETITEM(names, oparg);
-			x = PyDict_GetItemString(f->f_builtins, "__import__");
+			if (PyDict_GetItemStringEx(f->f_builtins,
+					"__import__", &x) < 0)
+				break;
 			if (x == NULL) {
 				PyErr_SetString(PyExc_ImportError,
 						"__import__ not found");
@@ -1937,19 +1696,20 @@
 					    f->f_locals == NULL ?
 						  Py_None : f->f_locals,
 					    v);
-			Py_DECREF(v);
-			Py_DECREF(u);
+			Py_DECREFTS(v);
+			Py_DECREFTS(u);
 			if (w == NULL) {
 				u = POP();
-				x = NULL;
+				Py_CLEARTS(x);
 				break;
 			}
 			READ_TIMESTAMP(intr0);
-			x = PyEval_CallObject(x, w);
+			v = PyEval_CallObject(x, w);
+			Py_CLEARTS(x);
 			READ_TIMESTAMP(intr1);
-			Py_DECREF(w);
-			SET_TOP(x);
-			if (x != NULL) continue;
+			Py_DECREFTS(w);
+			SET_TOP(v);
+			if (v != NULL) continue;
 			break;
 
 		case IMPORT_STAR:
@@ -1964,7 +1724,7 @@
 			err = import_all_from(x, v);
 			READ_TIMESTAMP(intr1);
 			PyFrame_LocalsToFast(f, 0);
-			Py_DECREF(v);
+			Py_DECREFTS(v);
 			if (err == 0) continue;
 			break;
 
@@ -2033,7 +1793,7 @@
 			/* before: [obj]; after [getiter(obj)] */
 			v = TOP();
 			x = PyObject_GetIter(v);
-			Py_DECREF(v);
+			Py_DECREFTS(v);
 			if (x != NULL) {
 				SET_TOP(x);
 				PREDICT(FOR_ITER);
@@ -2046,6 +1806,10 @@
 		case FOR_ITER:
 			/* before: [iter]; after: [iter, iter()] *or* [] */
 			v = TOP();
+			extern PyTypeObject PyFakeRange_Type;
+			if (v->ob_type == &PyFakeRange_Type) {
+				//printf("Moo %p %s %p %p %p %p\n", v, v->ob_type->tp_name, stack_pointer, next_instr, freevars, fastlocals);
+			}
 			x = (*v->ob_type->tp_iternext)(v);
 			if (x != NULL) {
 				PUSH(x);
@@ -2061,7 +1825,7 @@
 			}
 			/* iterator ended normally */
  			x = v = POP();
-			Py_DECREF(v);
+			Py_DECREFTS(v);
 			JUMPBY(oparg);
 			continue;
 
@@ -2126,20 +1890,20 @@
 				break; /* Go to error exit */
 			if (u != Py_None && PyObject_IsTrue(x)) {
 				/* There was an exception and a true return */
-				Py_DECREF(x);
+				Py_DECREFTS(x);
 				x = TOP(); /* Again */
 				STACKADJ(-3);
-				Py_INCREF(Py_None);
+				Py_INCREFTS(Py_None);
 				SET_TOP(Py_None);
-				Py_DECREF(x);
-				Py_DECREF(u);
-				Py_DECREF(v);
-				Py_DECREF(w);
+				Py_DECREFTS(x);
+				Py_DECREFTS(u);
+				Py_DECREFTS(v);
+				Py_DECREFTS(w);
 			} else {
 				/* Let END_FINALLY do its thing */
-				Py_DECREF(x);
+				Py_DECREFTS(x);
 				x = POP();
-				Py_DECREF(x);
+				Py_DECREFTS(x);
 			}
 			break;
 		}
@@ -2150,9 +1914,9 @@
 			PCALL(PCALL_ALL);
 			sp = stack_pointer;
 #ifdef WITH_TSC
-			x = call_function(&sp, oparg, &intr0, &intr1);
+			x = call_function(tstate, &sp, oparg, &intr0, &intr1);
 #else
-			x = call_function(&sp, oparg);
+			x = call_function(tstate, &sp, oparg);
 #endif
 			stack_pointer = sp;
 			PUSH(x);
@@ -2181,25 +1945,25 @@
 		    if (PyMethod_Check(func)
 			&& PyMethod_GET_SELF(func) != NULL) {
 			    PyObject *self = PyMethod_GET_SELF(func);
-			    Py_INCREF(self);
+			    Py_INCREFTS(self);
 			    func = PyMethod_GET_FUNCTION(func);
-			    Py_INCREF(func);
-			    Py_DECREF(*pfunc);
+			    Py_INCREFTS(func);
+			    Py_DECREFTS(*pfunc);
 			    *pfunc = self;
 			    na++;
 			    n++;
 		    } else
-			    Py_INCREF(func);
+			    Py_INCREFTS(func);
 		    sp = stack_pointer;
 		    READ_TIMESTAMP(intr0);
 		    x = ext_do_call(func, &sp, flags, na, nk);
 		    READ_TIMESTAMP(intr1);
 		    stack_pointer = sp;
-		    Py_DECREF(func);
+		    Py_DECREFTS(func);
 
 		    while (stack_pointer > pfunc) {
 			    w = POP();
-			    Py_DECREF(w);
+			    Py_DECREFTS(w);
 		    }
 		    PUSH(x);
 		    if (x != NULL)
@@ -2216,12 +1980,12 @@
 
 			v = POP(); /* code object */
 			x = PyFunction_New(v, f->f_globals);
-			Py_DECREF(v);
+			Py_DECREFTS(v);
 			
 			if (x != NULL && opcode == MAKE_CLOSURE) {
 				v = POP();
 				err = PyFunction_SetClosure(x, v);
-				Py_DECREF(v);
+				Py_DECREFTS(v);
 			}
 
 			if (x != NULL && num_annotations > 0) {
@@ -2229,7 +1993,7 @@
 				u = POP(); /* names of args with annotations */
 				v = PyDict_New();
 				if (v == NULL) {
-					Py_DECREF(x);
+					Py_DECREFTS(x);
 					x = NULL;
 					break;
 				}
@@ -2241,19 +2005,19 @@
 					w = POP();
 					/* XXX(nnorwitz): check for errors */
 					PyDict_SetItem(v, t, w);
-					Py_DECREF(w);
+					Py_DECREFTS(w);
 				}
 
 				err = PyFunction_SetAnnotations(x, v);
-				Py_DECREF(v);
-				Py_DECREF(u);
+				Py_DECREFTS(v);
+				Py_DECREFTS(u);
 			}
 
 			/* XXX Maybe this should be a separate opcode? */
 			if (x != NULL && posdefaults > 0) {
 				v = PyTuple_New(posdefaults);
 				if (v == NULL) {
-					Py_DECREF(x);
+					Py_DECREFTS(x);
 					x = NULL;
 					break;
 				}
@@ -2262,12 +2026,12 @@
 					PyTuple_SET_ITEM(v, posdefaults, w);
 				}
 				err = PyFunction_SetDefaults(x, v);
-				Py_DECREF(v);
+				Py_DECREFTS(v);
 			}
 			if (x != NULL && kwdefaults > 0) {
 				v = PyDict_New();
 				if (v == NULL) {
-					Py_DECREF(x);
+					Py_DECREFTS(x);
 					x = NULL;
 					break;
 				}
@@ -2276,11 +2040,11 @@
 					u = POP(); /* kw only arg name */
 					/* XXX(nnorwitz): check for errors */
 					PyDict_SetItem(v, u, w);
-					Py_DECREF(w);
-					Py_DECREF(u);
+					Py_DECREFTS(w);
+					Py_DECREFTS(u);
 				}
 				err = PyFunction_SetKwDefaults(x, v);
-				Py_DECREF(v);
+				Py_DECREFTS(v);
 			}
 			PUSH(x);
 			break;
@@ -2294,9 +2058,9 @@
 			v = POP();
 			u = TOP();
 			x = PySlice_New(u, v, w);
-			Py_DECREF(u);
-			Py_DECREF(v);
-			Py_XDECREF(w);
+			Py_DECREFTS(u);
+			Py_DECREFTS(v);
+			Py_XDECREFTS(w);
 			SET_TOP(x);
 			if (x != NULL) continue;
 			break;
@@ -2397,13 +2161,13 @@
 						   b->b_level);
 				why = WHY_NOT;
 				JUMPTO(PyInt_AS_LONG(retval));
-				Py_DECREF(retval);
+				Py_DECREFTS(retval);
 				break;
 			}
 
 			while (STACK_LEVEL() > b->b_level) {
 				v = POP();
-				Py_XDECREF(v);
+				Py_XDECREFTS(v);
 			}
 			if (b->b_type == SETUP_LOOP && why == WHY_BREAK) {
 				why = WHY_NOT;
@@ -2418,7 +2182,7 @@
 					PyErr_Fetch(&exc, &val, &tb);
 					if (val == NULL) {
 						val = Py_None;
-						Py_INCREF(val);
+						Py_INCREFTS(val);
 					}
 					/* Make the raw exception data
 					   available to the handler,
@@ -2432,7 +2196,7 @@
 							     exc, val, tb);
 					}
 					if (tb == NULL) {
-						Py_INCREF(Py_None);
+						Py_INCREFTS(Py_None);
 						PUSH(Py_None);
 					} else
 						PUSH(tb);
@@ -2463,7 +2227,7 @@
 	/* Pop remaining stack entries. */
 	while (!EMPTY()) {
 		v = POP();
-		Py_XDECREF(v);
+		Py_XDECREFTS(v);
 	}
 
 	if (why != WHY_RETURN)
@@ -2476,7 +2240,7 @@
 				if (call_trace(tstate->c_tracefunc,
 					       tstate->c_traceobj, f,
 					       PyTrace_RETURN, retval)) {
-					Py_XDECREF(retval);
+					Py_XDECREFTS(retval);
 					retval = NULL;
 					why = WHY_EXCEPTION;
 				}
@@ -2495,7 +2259,7 @@
 			else if (call_trace(tstate->c_profilefunc,
 					    tstate->c_profileobj, f,
 					    PyTrace_RETURN, retval)) {
-				Py_XDECREF(retval);
+				Py_XDECREFTS(retval);
 				retval = NULL;
 				why = WHY_EXCEPTION;
 			}
@@ -2512,6 +2276,7 @@
 	/* pop frame */
 exit_eval_frame:
 	Py_LeaveRecursiveCall();
+	//printf("%p's old %p replaced with f->f_back %p\n", tstate, tstate->frame, f->f_back);
 	tstate->frame = f->f_back;
 
 	return retval;
@@ -2529,7 +2294,7 @@
 	register PyFrameObject *f;
 	register PyObject *retval = NULL;
 	register PyObject **fastlocals, **freevars;
-	PyThreadState *tstate = PyThreadState_GET();
+	PyThreadState *tstate = PyThreadState_Get();
 	PyObject *x, *u;
 
 	if (globals == NULL) {
@@ -2579,7 +2344,7 @@
 		}
 		for (i = 0; i < n; i++) {
 			x = args[i];
-			Py_INCREF(x);
+			Py_INCREFTS(x);
 			SETLOCAL(i, x);
 		}
 		if (co->co_flags & CO_VARARGS) {
@@ -2589,7 +2354,7 @@
 			SETLOCAL(co->co_argcount + co->co_kwonlyargcount, u);
 			for (i = n; i < argcount; i++) {
 				x = args[i];
-				Py_INCREF(x);
+				Py_INCREFTS(x);
 				PyTuple_SET_ITEM(u, i-n, x);
 			}
 		}
@@ -2640,7 +2405,7 @@
 					     keyword);
 					goto fail;
 				}
-				Py_INCREF(value);
+				Py_INCREFTS(value);
 				SETLOCAL(j, value);
 			}
 		}
@@ -2656,7 +2421,7 @@
 				if (kwdefs != NULL)
 					def = PyDict_GetItem(kwdefs, name);
 				if (def != NULL) {
-					Py_INCREF(def);
+					Py_INCREFTS(def);
 					SETLOCAL(i, def);
 					continue;
 				}
@@ -2690,7 +2455,7 @@
 			for (; i < defcount; i++) {
 				if (GETLOCAL(m+i) == NULL) {
 					PyObject *def = defs[i];
-					Py_INCREF(def);
+					Py_INCREFTS(def);
 					SETLOCAL(m+i, def);
 				}
 			}
@@ -2753,7 +2518,7 @@
 		int i;
 		for (i = 0; i < PyTuple_GET_SIZE(co->co_freevars); ++i) {
 			PyObject *o = PyTuple_GET_ITEM(closure, i);
-			Py_INCREF(o);
+			Py_INCREFTS(o);
 			freevars[PyTuple_GET_SIZE(co->co_cellvars) + i] = o;
 		}
 	}
@@ -2761,7 +2526,7 @@
 	if (co->co_flags & CO_GENERATOR) {
 		/* Don't need to keep the reference to f_back, it will be set
 		 * when the generator is resumed. */
-		Py_XDECREF(f->f_back);
+		Py_XDECREFTS(f->f_back);
 		f->f_back = NULL;
 
 		PCALL(PCALL_GENERATOR);
@@ -2782,7 +2547,7 @@
 	*/
 	assert(tstate != NULL);
 	++tstate->recursion_depth;
-	Py_DECREF(f);
+	Py_DECREFTS(f);
 	--tstate->recursion_depth;
 	return retval;
 }
@@ -2866,12 +2631,12 @@
 		/* Save previous exception of this thread in this frame. */
 		if (tstate->exc_type == NULL) {
 			/* XXX Why is this set to Py_None? */
-			Py_INCREF(Py_None);
+			Py_INCREFTS(Py_None);
 			tstate->exc_type = Py_None;
 		}
-		Py_INCREF(tstate->exc_type);
-		Py_XINCREF(tstate->exc_value);
-		Py_XINCREF(tstate->exc_traceback);
+		Py_INCREFTS(tstate->exc_type);
+		Py_XINCREFTS(tstate->exc_value);
+		Py_XINCREFTS(tstate->exc_traceback);
 		frame->f_exc_type = tstate->exc_type;
 		frame->f_exc_value = tstate->exc_value;
 		frame->f_exc_traceback = tstate->exc_traceback;
@@ -2880,16 +2645,16 @@
 	tmp_type = tstate->exc_type;
 	tmp_value = tstate->exc_value;
 	tmp_tb = tstate->exc_traceback;
-	Py_INCREF(type);
-	Py_XINCREF(value);
-	Py_XINCREF(tb);
+	Py_INCREFTS(type);
+	Py_XINCREFTS(value);
+	Py_XINCREFTS(tb);
 	tstate->exc_type = type;
 	tstate->exc_value = value;
 	tstate->exc_traceback = tb;
 	PyException_SetTraceback(value, tb);
-	Py_XDECREF(tmp_type);
-	Py_XDECREF(tmp_value);
-	Py_XDECREF(tmp_tb);
+	Py_XDECREFTS(tmp_type);
+	Py_XDECREFTS(tmp_value);
+	Py_XDECREFTS(tmp_tb);
 }
 
 static void
@@ -2910,15 +2675,15 @@
 	tmp_type = tstate->exc_type;
 	tmp_value = tstate->exc_value;
 	tmp_tb = tstate->exc_traceback;
-	Py_INCREF(frame->f_exc_type);
-	Py_XINCREF(frame->f_exc_value);
-	Py_XINCREF(frame->f_exc_traceback);
+	Py_INCREFTS(frame->f_exc_type);
+	Py_XINCREFTS(frame->f_exc_value);
+	Py_XINCREFTS(frame->f_exc_traceback);
 	tstate->exc_type = frame->f_exc_type;
 	tstate->exc_value = frame->f_exc_value;
 	tstate->exc_traceback = frame->f_exc_traceback;
-	Py_XDECREF(tmp_type);
-	Py_XDECREF(tmp_value);
-	Py_XDECREF(tmp_tb);
+	Py_XDECREFTS(tmp_type);
+	Py_XDECREFTS(tmp_value);
+	Py_XDECREFTS(tmp_tb);
 
 	/* Clear the frame's exception info. */
 	tmp_type = frame->f_exc_type;
@@ -2927,9 +2692,9 @@
 	frame->f_exc_type = NULL;
 	frame->f_exc_value = NULL;
 	frame->f_exc_traceback = NULL;
-	Py_DECREF(tmp_type);
-	Py_XDECREF(tmp_value);
-	Py_XDECREF(tmp_tb);
+	Py_DECREFTS(tmp_type);
+	Py_XDECREFTS(tmp_value);
+	Py_XDECREFTS(tmp_tb);
 }
 
 /* Logic for the raise statement (too complicated for inlining).
@@ -2941,7 +2706,7 @@
 
 	if (exc == NULL) {
 		/* Reraise */
-		PyThreadState *tstate = PyThreadState_GET();
+		PyThreadState *tstate = PyThreadState_Get();
 		type = tstate->exc_type;
 		value = tstate->exc_value;
 		tb = tstate->exc_traceback;
@@ -2985,16 +2750,26 @@
 	tb = PyException_GetTraceback(value);
 	if (cause) {
 		PyObject *fixed_cause;
+		int i;
 		if (PyExceptionClass_Check(cause)) {
 			fixed_cause = PyObject_CallObject(cause, NULL);
 			if (fixed_cause == NULL)
 				goto raise_error;
 			Py_DECREF(cause);
-		}
-		else if (PyExceptionInstance_Check(cause)) {
+		} else if (PyExceptionInstance_Check(cause)) {
 			fixed_cause = cause;
-		}
-		else {
+		} else if (PyTuple_Check(cause)) {
+			for (i = 0; i < PyTuple_GET_SIZE(cause); i++) {
+				PyObject *ob = PyTuple_GET_ITEM(cause, i);
+				if (!PyExceptionInstance_Check(ob)) {
+					PyErr_SetString(PyExc_TypeError,
+						"exception causes must "
+						"derive from BaseException");
+					goto raise_error;
+				}
+			}
+			fixed_cause = cause;
+		} else {
 			PyErr_SetString(PyExc_TypeError,
 					"exception causes must derive from "
 					"BaseException");
@@ -3220,14 +2995,14 @@
 void
 PyEval_SetProfile(Py_tracefunc func, PyObject *arg)
 {
-	PyThreadState *tstate = PyThreadState_GET();
+	PyThreadState *tstate = PyThreadState_Get();
 	PyObject *temp = tstate->c_profileobj;
-	Py_XINCREF(arg);
+	Py_XINCREFTS(arg);
 	tstate->c_profilefunc = NULL;
 	tstate->c_profileobj = NULL;
 	/* Must make sure that tracing is not ignored if 'temp' is freed */
 	tstate->use_tracing = tstate->c_tracefunc != NULL;
-	Py_XDECREF(temp);
+	Py_XDECREFTS(temp);
 	tstate->c_profilefunc = func;
 	tstate->c_profileobj = arg;
 	/* Flag that tracing or profiling is turned on */
@@ -3237,14 +3012,14 @@
 void
 PyEval_SetTrace(Py_tracefunc func, PyObject *arg)
 {
-	PyThreadState *tstate = PyThreadState_GET();
+	PyThreadState *tstate = PyThreadState_Get();
 	PyObject *temp = tstate->c_traceobj;
-	Py_XINCREF(arg);
+	Py_XINCREFTS(arg);
 	tstate->c_tracefunc = NULL;
 	tstate->c_traceobj = NULL;
 	/* Must make sure that profiling is not ignored if 'temp' is freed */
 	tstate->use_tracing = tstate->c_profilefunc != NULL;
-	Py_XDECREF(temp);
+	Py_XDECREFTS(temp);
 	tstate->c_tracefunc = func;
 	tstate->c_traceobj = arg;
 	/* Flag that tracing or profiling is turned on */
@@ -3257,7 +3032,7 @@
 {
 	PyFrameObject *current_frame = PyEval_GetFrame();
 	if (current_frame == NULL)
-		return PyThreadState_GET()->interp->builtins;
+		return PyThreadState_Get()->interp->builtins;
 	else
 		return current_frame->f_builtins;
 }
@@ -3285,7 +3060,7 @@
 PyFrameObject *
 PyEval_GetFrame(void)
 {
-	PyThreadState *tstate = PyThreadState_GET();
+	PyThreadState *tstate = PyThreadState_Get();
 	return _PyThreadState_GetFrame(tstate);
 }
 
@@ -3431,7 +3206,7 @@
 	}
 
 static PyObject *
-call_function(PyObject ***pp_stack, int oparg
+call_function(PyThreadState *tstate, PyObject ***pp_stack, int oparg
 #ifdef WITH_TSC
 		, uint64* pintr0, uint64* pintr1
 #endif
@@ -3449,7 +3224,6 @@
 	*/
 	if (PyCFunction_Check(func) && nk == 0) {
 		int flags = PyCFunction_GET_FLAGS(func);
-		PyThreadState *tstate = PyThreadState_GET();
 
 		PCALL(PCALL_CFUNCTION);
 		if (flags & (METH_NOARGS | METH_O)) {
@@ -3461,7 +3235,7 @@
 			else if (flags & METH_O && na == 1) {
 				PyObject *arg = EXT_POP(*pp_stack);
 				C_TRACE(x, (*meth)(self,arg));
-				Py_DECREF(arg);
+				Py_DECREFTS(arg);
 			}
 			else {
 				err_args(func, flags, na);
@@ -3474,7 +3248,7 @@
 			READ_TIMESTAMP(*pintr0);
 			C_TRACE(x, PyCFunction_Call(func,callargs,NULL));
 			READ_TIMESTAMP(*pintr1);
-			Py_XDECREF(callargs);
+			Py_XDECREFTS(callargs);
 		}
 	} else {
 		if (PyMethod_Check(func) && PyMethod_GET_SELF(func) != NULL) {
@@ -3482,22 +3256,22 @@
 			PyObject *self = PyMethod_GET_SELF(func);
 			PCALL(PCALL_METHOD);
 			PCALL(PCALL_BOUND_METHOD);
-			Py_INCREF(self);
+			Py_INCREFTS(self);
 			func = PyMethod_GET_FUNCTION(func);
-			Py_INCREF(func);
-			Py_DECREF(*pfunc);
+			Py_INCREFTS(func);
+			Py_DECREFTS(*pfunc);
 			*pfunc = self;
 			na++;
 			n++;
 		} else
-			Py_INCREF(func);
+			Py_INCREFTS(func);
 		READ_TIMESTAMP(*pintr0);
 		if (PyFunction_Check(func))
-			x = fast_function(func, pp_stack, n, na, nk);
+			x = fast_function(tstate, func, pp_stack, n, na, nk);
 		else
 			x = do_call(func, pp_stack, na, nk);
 		READ_TIMESTAMP(*pintr1);
-		Py_DECREF(func);
+		Py_DECREFTS(func);
 	}
 
 	/* Clear the stack of the function object.  Also removes
@@ -3506,7 +3280,7 @@
 	 */
 	while ((*pp_stack) > pfunc) {
 		w = EXT_POP(*pp_stack);
-		Py_DECREF(w);
+		Py_DECREFTS(w);
 		PCALL(PCALL_POP);
 	}
 	return x;
@@ -3522,7 +3296,7 @@
 */
 
 static PyObject *
-fast_function(PyObject *func, PyObject ***pp_stack, int n, int na, int nk)
+fast_function(PyThreadState *tstate, PyObject *func, PyObject ***pp_stack, int n, int na, int nk)
 {
 	PyCodeObject *co = (PyCodeObject *)PyFunction_GET_CODE(func);
 	PyObject *globals = PyFunction_GET_GLOBALS(func);
@@ -3538,7 +3312,6 @@
 	    co->co_flags == (CO_OPTIMIZED | CO_NEWLOCALS | CO_NOFREE)) {
 		PyFrameObject *f;
 		PyObject *retval = NULL;
-		PyThreadState *tstate = PyThreadState_GET();
 		PyObject **fastlocals, **stack;
 		int i;
 
@@ -3557,12 +3330,12 @@
 		stack = (*pp_stack) - n;
 
 		for (i = 0; i < n; i++) {
-			Py_INCREF(*stack);
+			Py_INCREFTS(*stack);
 			fastlocals[i] = *stack++;
 		}
 		retval = PyEval_EvalFrameEx(f,0);
 		++tstate->recursion_depth;
-		Py_DECREF(f);
+		Py_DECREFTS(f);
 		--tstate->recursion_depth;
 		return retval;
 	}
@@ -3966,6 +3739,7 @@
 {
 	/* This function implements 'variable += expr' when both arguments
 	   are strings. */
+	PyThreadState *tstate = PyThreadState_Get();
 	Py_ssize_t v_len = PyString_GET_SIZE(v);
 	Py_ssize_t w_len = PyString_GET_SIZE(w);
 	Py_ssize_t new_len = v_len + w_len;
@@ -3975,7 +3749,7 @@
 		return NULL;
 	}
 
-	if (v->ob_refcnt == 2) {
+	if (Py_RefcntMatches(v, 2)) {
 		/* In the common case, there are 2 references to the value
 		 * stored in 'variable' when the += is performed: one on the
 		 * value stack (in 'v') and one still stored in the
@@ -4016,7 +3790,7 @@
 		}
 	}
 
-	if (v->ob_refcnt == 1 && !PyString_CHECK_INTERNED(v)) {
+	if (Py_RefcntMatches(v, 1) && !_PyString_SnoopState((PyStringObject *)v)) {
 		/* Now we own the last reference to 'v', so we can resize it
 		 * in-place.
 		 */
Index: Python/getargs.c
===================================================================
--- Python/getargs.c	(revision 58355)
+++ Python/getargs.c	(working copy)
@@ -1846,6 +1846,90 @@
 			funcname);
 	return 0;
 }
+
+
+/* We assume args and kw were both constructed by other
+ * argument functions and neither can be modified while
+ * we iterate over them.
+ */
+int
+PyArg_RequireShareable(const char *funcname, PyObject *args, PyObject *kwargs)
+{
+	assert (args != NULL || kwargs != NULL);
+
+	if (args != NULL) {
+		Py_ssize_t i;
+		Py_ssize_t size = PyTuple_Size(args);
+		for (i = 0; i < size; i++) {
+			if (!PyObject_IsShareable(PyTuple_GetItem(args, i))) {
+				PyErr_Format(PyExc_TypeError, "%s requires "
+					"shareable arguments; positional "
+					"argument %d is not shareable",
+					funcname, i+1);
+				return 0;
+			}
+		}
+	}
+
+	if (kwargs != NULL) {
+		PyObject *key, *value;
+		Py_ssize_t pos = 0;
+		while (PyDict_Next(kwargs, &pos, &key, &value)) {
+			if (!PyObject_IsShareable(key)) {
+				char *ks = PyString_AsString(key);
+				PyErr_Format(PyExc_TypeError, "%s requires "
+					"shareable arguments; keyword "
+					"argument %s's key is not shareable",
+					funcname, ks);
+				return 0;
+			}
+			if (!PyObject_IsShareable(value)) {
+				char *ks = PyString_AsString(key);
+				PyErr_Format(PyExc_TypeError, "%s requires "
+					"shareable arguments; keyword "
+					"argument %s's value is not shareable",
+					funcname, ks);
+				return 0;
+			}
+		}
+	}
+
+	return 1;
+}
+
+/* funcname is the outer function (written in C) which wants a shareable object.
+ * innerfunc is the inner function that just returned a (hopefully) shareable object.
+ * The error context will be checked AND CHANGED to be shareable.
+ */
+int
+PyArg_RequireShareableReturn(const char *funcname, PyObject *innerfunc, PyObject *result)
+{
+	if (result != NULL) {
+		if (PyErr_Occurred())
+			Py_FatalError("Both exception and return value set");
+
+		if (PyObject_IsShareable(result))
+			return 1;
+
+		if (PyFunction_Check(innerfunc)) {
+			char *innerfuncname = PyString_AsString(
+				((PyFunctionObject *)innerfunc)->func_name);
+			PyErr_Format(PyExc_TypeError, "%s given unshareable return "
+				"value by %s()", funcname, innerfuncname);
+		} else
+			PyErr_Format(PyExc_TypeError, "%s given unshareable return "
+				"value by callable", funcname);
+
+		return 0;
+	} else {
+		if (!PyErr_Occurred())
+			Py_FatalError("Neither exception nor return value set");
+
+		/* XXX FIXME */
+		return 1;
+	}
+}
+
 #ifdef __cplusplus
 };
 #endif
Index: Python/traceback.c
===================================================================
--- Python/traceback.c	(revision 58355)
+++ Python/traceback.c	(working copy)
@@ -34,12 +34,9 @@
 static void
 tb_dealloc(PyTracebackObject *tb)
 {
-	PyObject_GC_UnTrack(tb);
-	Py_TRASHCAN_SAFE_BEGIN(tb)
 	Py_XDECREF(tb->tb_next);
 	Py_XDECREF(tb->tb_frame);
-	PyObject_GC_Del(tb);
-	Py_TRASHCAN_SAFE_END(tb)
+	PyObject_DEL(tb);
 }
 
 static int
@@ -101,7 +98,7 @@
 		PyErr_BadInternalCall();
 		return NULL;
 	}
-	tb = PyObject_GC_New(PyTracebackObject, &PyTraceBack_Type);
+	tb = PyObject_NEW(PyTracebackObject, &PyTraceBack_Type);
 	if (tb != NULL) {
 		Py_XINCREF(next);
 		tb->tb_next = next;
@@ -110,7 +107,6 @@
 		tb->tb_lasti = frame->f_lasti;
 		tb->tb_lineno = PyCode_Addr2Line(frame->f_code, 
 						 frame->f_lasti);
-		PyObject_GC_Track(tb);
 	}
 	return tb;
 }
@@ -118,7 +114,7 @@
 int
 PyTraceBack_Here(PyFrameObject *frame)
 {
-	PyThreadState *tstate = PyThreadState_GET();
+	PyThreadState *tstate = PyThreadState_Get();
 	PyTracebackObject *oldtb = (PyTracebackObject *) tstate->curexc_traceback;
 	PyTracebackObject *tb = newtracebackobject(oldtb, frame);
 	if (tb == NULL)
@@ -181,7 +177,13 @@
 		}
 	}
 	PyOS_snprintf(linebuf, sizeof(linebuf), FMT, filename, lineno, name);
-	err = PyFile_WriteString(linebuf, f);
+
+	if (f == NULL) {
+		PySys_WriteStderr("%s", linebuf);
+		err = 0;
+	} else
+		err = PyFile_WriteString(linebuf, f);
+
 	if (xfp == NULL)
 		return err;
 	else if (err != 0) {
@@ -236,8 +238,6 @@
 		}
 		depth--;
 		tb = tb->tb_next;
-		if (err == 0)
-			err = PyErr_CheckSignals();
 	}
 	return err;
 }
@@ -260,7 +260,13 @@
 		if (limit <= 0)
 			return 0;
 	}
-	err = PyFile_WriteString("Traceback (most recent call last):\n", f);
+
+	if (f == NULL) {
+		PySys_WriteStderr("Traceback (most recent call last):\n");
+		err = 0;
+	} else
+		err = PyFile_WriteString("Traceback (most recent call last):\n", f);
+
 	if (!err)
 		err = tb_printinternal((PyTracebackObject *)v, f, limit);
 	return err;
Index: Python/sigcheck.c
===================================================================
--- Python/sigcheck.c	(revision 58355)
+++ Python/sigcheck.c	(working copy)
@@ -1,19 +0,0 @@
-
-/* Sigcheck is similar to intrcheck() but sets an exception when an
-   interrupt occurs.  It can't be in the intrcheck.c file since that
-   file (and the whole directory it is in) doesn't know about objects
-   or exceptions.  It can't be in errors.c because it can be
-   overridden (at link time) by a more powerful version implemented in
-   signalmodule.c. */
-
-#include "Python.h"
-
-/* ARGSUSED */
-int
-PyErr_CheckSignals(void)
-{
-	if (!PyOS_InterruptOccurred())
-		return 0;
-	PyErr_SetNone(PyExc_KeyboardInterrupt);
-	return -1;
-}
Index: Python/thread_pthread.h
===================================================================
--- Python/thread_pthread.h	(revision 58355)
+++ Python/thread_pthread.h	(working copy)
@@ -106,6 +106,7 @@
 } pthread_lock;
 
 #define CHECK_STATUS(name)  if (status != 0) { perror(name); error = 1; }
+#define CHECK_STATUS_ABORT(name)  if (status != 0) { perror(name); abort(); }
 
 /*
  * Initialization.
@@ -144,18 +145,21 @@
  */
 
 
-long
-PyThread_start_new_thread(void (*func)(void *), void *arg)
+int
+PyThread_start_new_thread(PyThread_type_handle *handle, void (*func)(void *), void *arg)
 {
-	pthread_t th;
+	PyThread_type_handle dummy_handle;
 	int status;
 #if defined(THREAD_STACK_SIZE) || defined(PTHREAD_SYSTEM_SCHED_SUPPORTED)
 	pthread_attr_t attrs;
 #endif
 #if defined(THREAD_STACK_SIZE)
-	size_t	tss;
+	size_t tss;
 #endif
 
+	if (handle == NULL)
+		handle = &dummy_handle;
+
 	dprintf(("PyThread_start_new_thread called\n"));
 	if (!initialized)
 		PyThread_init_thread();
@@ -178,7 +182,7 @@
         pthread_attr_setscope(&attrs, PTHREAD_SCOPE_SYSTEM);
 #endif
 
-	status = pthread_create(&th, 
+	status = pthread_create(&handle->_value,
 #if defined(THREAD_STACK_SIZE) || defined(PTHREAD_SYSTEM_SCHED_SUPPORTED)
 				 &attrs,
 #else
@@ -194,133 +198,199 @@
 	if (status != 0)
             return -1;
 
-        pthread_detach(th);
+        pthread_detach(handle->_value);
 
-#if SIZEOF_PTHREAD_T <= SIZEOF_LONG
-	return (long) th;
-#else
-	return (long) *(long *) &th;
-#endif
+        return 0;
 }
 
-/* XXX This implementation is considered (to quote Tim Peters) "inherently
-   hosed" because:
-     - It does not guarantee the promise that a non-zero integer is returned.
-     - The cast to long is inherently unsafe.
-     - It is not clear that the 'volatile' (for AIX?) and ugly casting in the
-       latter return statement (for Alpha OSF/1) are any longer necessary.
-*/
-long 
-PyThread_get_thread_ident(void)
+PyThread_type_handle
+PyThread_get_handle(void)
 {
-	volatile pthread_t threadid;
-	if (!initialized)
-		PyThread_init_thread();
-	/* Jump through some hoops for Alpha OSF/1 */
-	threadid = pthread_self();
-#if SIZEOF_PTHREAD_T <= SIZEOF_LONG
-	return (long) threadid;
-#else
-	return (long) *(long *) &threadid;
-#endif
+    PyThread_type_handle handle;
+    handle._value = pthread_self();
+    return handle;
 }
 
-static void 
-do_PyThread_exit_thread(int no_cleanup)
+void
+PyThread_send_signal(PyThread_type_handle handle, int signum)
 {
-	dprintf(("PyThread_exit_thread called\n"));
-	if (!initialized) {
-		if (no_cleanup)
-			_exit(0);
-		else
-			exit(0);
-	}
+    int status = pthread_kill(handle._value, signum);
+    if (status < 0) {
+        fprintf(stderr, "pthread_kill failed with %d\n", errno);
+        Py_FatalError("PyThread_send_signal failed calling pthread_kill");
+    }
 }
 
-void 
-PyThread_exit_thread(void)
+
+/*
+ * Lock support.
+ */
+
+PyThread_type_lock
+PyThread_lock_allocate(void)
 {
-	do_PyThread_exit_thread(0);
+	//sem_t *lock;
+	pthread_mutex_t *lock;
+	int status, error = 0;
+
+	dprintf(("PyThread_allocate_lock called\n"));
+	if (!initialized)
+		PyThread_init_thread();
+
+	//lock = (sem_t *)malloc(sizeof(sem_t));
+	lock = malloc(sizeof(pthread_mutex_t));
+
+	if (lock) {
+		//status = sem_init(lock,0,1);
+		status = pthread_mutex_init(lock, NULL);
+		CHECK_STATUS("pthread_mutex_init");
+
+		if (error) {
+			free((void *)lock);
+			lock = NULL;
+		}
+	}
+
+	dprintf(("PyThread_allocate_lock() -> %p\n", lock));
+	return (PyThread_type_lock)lock;
 }
 
-void 
-PyThread__exit_thread(void)
+void
+PyThread_lock_free(PyThread_type_lock lock)
 {
-	do_PyThread_exit_thread(1);
+	//sem_t *thelock = (sem_t *)lock;
+	pthread_mutex_t *thelock = (pthread_mutex_t *)lock;
+	int status;
+
+	dprintf(("PyThread_free_lock(%p) called\n", lock));
+
+	if (!thelock)
+		return;
+
+	//status = sem_destroy(thelock);
+	status = pthread_mutex_destroy(thelock);
+	CHECK_STATUS_ABORT("pthread_mutex_destroy");
+
+	free((void *)thelock);
 }
 
-#ifndef NO_EXIT_PROG
-static void 
-do_PyThread_exit_prog(int status, int no_cleanup)
+#include <execinfo.h>
+
+void
+PyThread_lock_acquire(PyThread_type_lock lock)
 {
-	dprintf(("PyThread_exit_prog(%d) called\n", status));
-	if (!initialized)
-		if (no_cleanup)
-			_exit(status);
-		else
-			exit(status);
+	//sem_t *thelock = (sem_t *)lock;
+	pthread_mutex_t *thelock = (pthread_mutex_t *)lock;
+	int status;
+	static unsigned long long count;
+
+#if 0
+	count++;
+	if ((count % 10000) == 0) {
+		void *scratch[10] = {};
+		printf("PyThread_lock_acquire: %llu\n", count);
+		backtrace(scratch, 10);
+		backtrace_symbols_fd(scratch, 2, 1);
+		printf("*****\n");
+	}
+#endif
+
+	dprintf(("PyThread_acquire_lock(%p) called\n", lock));
+
+	//if (!waitflag)
+	//	abort();
+	status = pthread_mutex_lock(thelock);
+	CHECK_STATUS_ABORT("pthread_mutex_lock");
+
+	dprintf(("PyThread_acquire_lock(%p)\n", lock));
 }
 
-void 
-PyThread_exit_prog(int status)
+/* This is only temporary, until a better interface is available to those
+ * who need such functionality. */
+int
+_PyThread_lock_tryacquire(PyThread_type_lock lock)
 {
-	do_PyThread_exit_prog(status, 0);
+	int success;
+	//sem_t *thelock = (sem_t *)lock;
+	pthread_mutex_t *thelock = (pthread_mutex_t *)lock;
+	int status;
+
+	dprintf(("PyThread_tryacquire_lock(%p) called\n", lock));
+
+	//if (!waitflag)
+	//	abort();
+	status = pthread_mutex_trylock(thelock);
+	if (status != EBUSY)
+		CHECK_STATUS_ABORT("pthread_mutex_trylock");
+
+	success = (status == 0) ? 1 : 0;
+	dprintf(("PyThread_tryacquire_lock(%p) -> %d\n", lock, success));
+	return success;
 }
 
-void 
-PyThread__exit_prog(int status)
+void
+PyThread_lock_release(PyThread_type_lock lock)
 {
-	do_PyThread_exit_prog(status, 1);
+	//sem_t *thelock = (sem_t *)lock;
+	pthread_mutex_t *thelock = (pthread_mutex_t *)lock;
+	int status;
+
+	dprintf(("PyThread_release_lock(%p) called\n", lock));
+
+	//status = sem_post(thelock);
+	status = pthread_mutex_unlock(thelock);
+	CHECK_STATUS_ABORT("pthread_mutex_unlock");
 }
-#endif /* NO_EXIT_PROG */
 
-#ifdef USE_SEMAPHORES
 
 /*
- * Lock support.
+ * Semaphore support.
  */
 
-PyThread_type_lock 
-PyThread_allocate_lock(void)
+PyThread_type_sem
+PyThread_sem_allocate(int initial_value)
 {
-	sem_t *lock;
+	sem_t *sem;
 	int status, error = 0;
 
-	dprintf(("PyThread_allocate_lock called\n"));
+	dprintf(("PyThread_sem_allocate called\n"));
 	if (!initialized)
 		PyThread_init_thread();
 
-	lock = (sem_t *)malloc(sizeof(sem_t));
+	if (initial_value < 0 || initial_value > 1)
+		Py_FatalError("PyThread_sem_allocate given invalid initial_value");
 
-	if (lock) {
-		status = sem_init(lock,0,1);
+	sem = malloc(sizeof(sem_t));
+
+	if (sem) {
+		status = sem_init(sem, 0, initial_value);
 		CHECK_STATUS("sem_init");
 
 		if (error) {
-			free((void *)lock);
-			lock = NULL;
+			free((void *)sem);
+			sem = NULL;
 		}
 	}
 
-	dprintf(("PyThread_allocate_lock() -> %p\n", lock));
-	return (PyThread_type_lock)lock;
+	dprintf(("PyThread_sem_allocate() -> %p\n", sem));
+	return (PyThread_type_sem)sem;
 }
 
-void 
-PyThread_free_lock(PyThread_type_lock lock)
+void
+PyThread_sem_free(PyThread_type_sem sem)
 {
-	sem_t *thelock = (sem_t *)lock;
-	int status, error = 0;
+	sem_t *thesem = (sem_t *)sem;
+	int status;
 
-	dprintf(("PyThread_free_lock(%p) called\n", lock));
+	dprintf(("PyThread_sem_free(%p) called\n", sem));
 
-	if (!thelock)
+	if (!thesem)
 		return;
 
-	status = sem_destroy(thelock);
-	CHECK_STATUS("sem_destroy");
+	status = sem_destroy(thesem);
+	CHECK_STATUS_ABORT("sem_destroy");
 
-	free((void *)thelock);
+	free((void *)thesem);
 }
 
 /*
@@ -330,162 +400,202 @@
  * either.
  */
 static int
-fix_status(int status)
+fix_sem_status(int status)
 {
 	return (status == -1) ? errno : status;
 }
 
-int 
-PyThread_acquire_lock(PyThread_type_lock lock, int waitflag)
+void
+PyThread_sem_wait(PyThread_type_sem sem)
 {
-	int success;
-	sem_t *thelock = (sem_t *)lock;
-	int status, error = 0;
+	sem_t *thesem = (sem_t *)sem;
+	int status;
 
-	dprintf(("PyThread_acquire_lock(%p, %d) called\n", lock, waitflag));
+	dprintf(("PyThread_sem_wait(%p) called\n", sem));
 
 	do {
-		if (waitflag)
-			status = fix_status(sem_wait(thelock));
-		else
-			status = fix_status(sem_trywait(thelock));
+		status = fix_sem_status(sem_wait(thesem));
 	} while (status == EINTR); /* Retry if interrupted by a signal */
 
-	if (waitflag) {
-		CHECK_STATUS("sem_wait");
-	} else if (status != EAGAIN) {
-		CHECK_STATUS("sem_trywait");
-	}
+	if (status != EINTR)
+		CHECK_STATUS_ABORT("sem_wait");
 	
-	success = (status == 0) ? 1 : 0;
-
-	dprintf(("PyThread_acquire_lock(%p, %d) -> %d\n", lock, waitflag, success));
-	return success;
+	dprintf(("PyThread_sem_wait(%p)\n", sem));
 }
 
-void 
-PyThread_release_lock(PyThread_type_lock lock)
+void
+PyThread_sem_post(PyThread_type_sem sem)
 {
-	sem_t *thelock = (sem_t *)lock;
-	int status, error = 0;
+	sem_t *thesem = (sem_t *)sem;
+	int status;
 
-	dprintf(("PyThread_release_lock(%p) called\n", lock));
+	dprintf(("PyThread_sem_post(%p) called\n", sem));
 
-	status = sem_post(thelock);
-	CHECK_STATUS("sem_post");
+	status = sem_post(thesem);
+	CHECK_STATUS_ABORT("sem_post");
 }
 
-#else /* USE_SEMAPHORES */
 
 /*
- * Lock support.
+ * Condition support.
  */
-PyThread_type_lock 
-PyThread_allocate_lock(void)
+
+PyThread_type_cond
+PyThread_cond_allocate(void)
 {
-	pthread_lock *lock;
+	pthread_cond_t *cond;
 	int status, error = 0;
 
-	dprintf(("PyThread_allocate_lock called\n"));
+	dprintf(("PyThread_cond_allocate called\n"));
 	if (!initialized)
 		PyThread_init_thread();
 
-	lock = (pthread_lock *) malloc(sizeof(pthread_lock));
-	if (lock) {
-		memset((void *)lock, '\0', sizeof(pthread_lock));
-		lock->locked = 0;
+	cond = malloc(sizeof(pthread_cond_t));
 
-		status = pthread_mutex_init(&lock->mut,
-					    pthread_mutexattr_default);
-		CHECK_STATUS("pthread_mutex_init");
-
-		status = pthread_cond_init(&lock->lock_released,
-					   pthread_condattr_default);
+	if (cond) {
+		status = pthread_cond_init(cond, NULL);
 		CHECK_STATUS("pthread_cond_init");
 
 		if (error) {
-			free((void *)lock);
-			lock = 0;
+			free((void *)cond);
+			cond = NULL;
 		}
 	}
 
-	dprintf(("PyThread_allocate_lock() -> %p\n", lock));
-	return (PyThread_type_lock) lock;
+	dprintf(("PyThread_cond_allocate() -> %p\n", cond));
+	return (PyThread_type_cond)cond;
 }
 
-void 
-PyThread_free_lock(PyThread_type_lock lock)
+void
+PyThread_cond_free(PyThread_type_cond cond)
 {
-	pthread_lock *thelock = (pthread_lock *)lock;
-	int status, error = 0;
+	pthread_cond_t *thecond = (pthread_cond_t *)cond;
+	int status;
 
-	dprintf(("PyThread_free_lock(%p) called\n", lock));
+	dprintf(("PyThread_cond_free(%p) called\n", cond));
 
-	status = pthread_mutex_destroy( &thelock->mut );
-	CHECK_STATUS("pthread_mutex_destroy");
+	if (!thecond)
+		return;
 
-	status = pthread_cond_destroy( &thelock->lock_released );
-	CHECK_STATUS("pthread_cond_destroy");
+	status = pthread_cond_destroy(thecond);
+	CHECK_STATUS_ABORT("pthread_cond_destroy");
 
-	free((void *)thelock);
+	free((void *)thecond);
 }
 
-int 
-PyThread_acquire_lock(PyThread_type_lock lock, int waitflag)
+void
+PyThread_cond_wait(PyThread_type_cond cond, PyThread_type_lock lock)
 {
-	int success;
-	pthread_lock *thelock = (pthread_lock *)lock;
+	pthread_cond_t *thecond = (pthread_cond_t *)cond;
+	pthread_mutex_t *thelock = (pthread_mutex_t *)lock;
+	int status;
+
+	dprintf(("PyThread_cond_wait(%p, %p) called\n", cond, lock));
+
+	status = pthread_cond_wait(thecond, thelock);
+	CHECK_STATUS_ABORT("pthread_cond_wait");
+	
+	dprintf(("PyThread_cond_wait(%p, %p)\n", cond, lock));
+}
+
+void
+PyThread_cond_wakeone(PyThread_type_cond cond)
+{
+	pthread_cond_t *thecond = (pthread_cond_t *)cond;
+	int status;
+
+	dprintf(("PyThread_cond_wait(%p) called\n", cond));
+
+	status = pthread_cond_signal(thecond);
+	CHECK_STATUS_ABORT("pthread_cond_signal");
+	
+	dprintf(("PyThread_cond_wait(%p)\n", cond));
+}
+
+void
+PyThread_cond_wakeall(PyThread_type_cond cond)
+{
+	pthread_cond_t *thecond = (pthread_cond_t *)cond;
+	int status;
+
+	dprintf(("PyThread_cond_wait(%p) called\n", cond));
+
+	status = pthread_cond_broadcast(thecond);
+	CHECK_STATUS_ABORT("pthread_cond_broadcast");
+	
+	dprintf(("PyThread_cond_wait(%p)\n", cond));
+}
+
+
+/*
+ * Thread-local Storage support.
+ */
+
+#define Py_HAVE_NATIVE_TLS
+
+PyThread_type_key
+PyThread_create_key(void)
+{
+	pthread_key_t *thekey;
 	int status, error = 0;
 
-	dprintf(("PyThread_acquire_lock(%p, %d) called\n", lock, waitflag));
+	thekey = malloc(sizeof(pthread_key_t));
 
-	status = pthread_mutex_lock( &thelock->mut );
-	CHECK_STATUS("pthread_mutex_lock[1]");
-	success = thelock->locked == 0;
+	if (thekey) {
+		//status = sem_init(lock,0,1);
+		//status = pthread_mutex_init(lock, NULL);
+		status = pthread_key_create(thekey, NULL);
+		CHECK_STATUS("pthread_key_create");
 
-	if ( !success && waitflag ) {
-		/* continue trying until we get the lock */
-
-		/* mut must be locked by me -- part of the condition
-		 * protocol */
-		while ( thelock->locked ) {
-			status = pthread_cond_wait(&thelock->lock_released,
-						   &thelock->mut);
-			CHECK_STATUS("pthread_cond_wait");
+		if (error) {
+			free((void *)thekey);
+			thekey = NULL;
 		}
-		success = 1;
 	}
-	if (success) thelock->locked = 1;
-	status = pthread_mutex_unlock( &thelock->mut );
-	CHECK_STATUS("pthread_mutex_unlock[1]");
 
-	if (error) success = 0;
-	dprintf(("PyThread_acquire_lock(%p, %d) -> %d\n", lock, waitflag, success));
-	return success;
+	return (PyThread_type_key *)thekey;
 }
 
-void 
-PyThread_release_lock(PyThread_type_lock lock)
+void
+PyThread_delete_key(PyThread_type_key key)
 {
-	pthread_lock *thelock = (pthread_lock *)lock;
-	int status, error = 0;
+	pthread_key_t *thekey = (pthread_key_t *)key;
+	int status = 0;
 
-	dprintf(("PyThread_release_lock(%p) called\n", lock));
+	status = pthread_key_delete(*thekey);
+	CHECK_STATUS_ABORT("pthread_key_delete");
+}
 
-	status = pthread_mutex_lock( &thelock->mut );
-	CHECK_STATUS("pthread_mutex_lock[3]");
+/* Unlock the default implementation, I consider replacing an existing
+ * key to be an error.  I'm not going to check it. */
+void
+PyThread_set_key_value(PyThread_type_key key, void *value)
+{
+	pthread_key_t *thekey = (pthread_key_t *)key;
+	int status = 0;
 
-	thelock->locked = 0;
+	assert(thekey != NULL); /* Use PyThread_delete_key_value to delete */
+	status = pthread_setspecific(*thekey, value);
+	CHECK_STATUS_ABORT("pthread_setspecific");
+}
 
-	status = pthread_mutex_unlock( &thelock->mut );
-	CHECK_STATUS("pthread_mutex_unlock[3]");
+void *
+PyThread_get_key_value(PyThread_type_key key)
+{
+	pthread_key_t *thekey = (pthread_key_t *)key;
+	return pthread_getspecific(*thekey);
+}
 
-	/* wake up someone (anyone, if any) waiting on the lock */
-	status = pthread_cond_signal( &thelock->lock_released );
-	CHECK_STATUS("pthread_cond_signal");
+void
+PyThread_delete_key_value(PyThread_type_key key)
+{
+	pthread_key_t *thekey = (pthread_key_t *)key;
+	int status = 0;
+
+	status = pthread_setspecific(*thekey, NULL);
+	CHECK_STATUS_ABORT("pthread_setspecific");
 }
 
-#endif /* USE_SEMAPHORES */
 
 /* set the thread stack size.
  * Return 0 if size is valid, -1 if size is invalid,
Index: Python/ast.c
===================================================================
--- Python/ast.c	(revision 58355)
+++ Python/ast.c	(working copy)
@@ -1645,6 +1645,7 @@
             return NULL;
         s[0] = '-';
         strcpy(s + 1, STR(pnum));
+        //printf("Old %p '%s' -> new %p '%s'\n", STR(pnum), STR(pnum), s, s);
         PyObject_FREE(STR(pnum));
         STR(pnum) = s;
         return ast_for_atom(c, patom);
@@ -3117,6 +3118,7 @@
     char *buf;
     char *p;
     const char *end;
+    const char *orig_s = s;
     if (encoding == NULL) {
         buf = (char *)s;
         u = NULL;
@@ -3131,6 +3133,8 @@
         p = buf = PyString_AsString(u);
         end = s + len;
         while (s < end) {
+            if (*s == '\0')
+                Py_FatalError("Meh");
             if (*s == '\\') {
                 *p++ = *s++;
                 if (*s & 0x80) {
@@ -3162,9 +3166,14 @@
                 *p++ = *s++;
             }
         }
+        *p = '\0';
         len = p - buf;
         s = buf;
+//        if (s[len] == '\0')
+//            Py_FatalError("Feh");
     }
+//    if (s - orig_s > strlen(orig_s))
+//        Py_FatalError("decode_unicode went too far\n");
     if (rawmode)
         v = PyUnicode_DecodeRawUnicodeEscape(s, len, NULL);
     else
Index: Python/pystate.c
===================================================================
--- Python/pystate.c	(revision 58355)
+++ Python/pystate.c	(working copy)
@@ -2,6 +2,8 @@
 /* Thread and interpreter state structures and their interfaces */
 
 #include "Python.h"
+#include "monitorobject.h"
+#include "interruptobject.h"
 
 /* --------------------------------------------------------------------------
 CAUTION
@@ -23,55 +25,69 @@
 #endif
 
 
-#ifdef WITH_THREAD
 #include "pythread.h"
 static PyThread_type_lock head_mutex = NULL; /* Protects interp->tstate_head */
-#define HEAD_INIT() (void)(head_mutex || (head_mutex = PyThread_allocate_lock()))
-#define HEAD_LOCK() PyThread_acquire_lock(head_mutex, WAIT_LOCK)
-#define HEAD_UNLOCK() PyThread_release_lock(head_mutex)
+#define HEAD_INIT() (void)(head_mutex || (head_mutex = PyThread_lock_allocate()))
+#define HEAD_LOCK() PyThread_lock_acquire(head_mutex)
+#define HEAD_UNLOCK() PyThread_lock_release(head_mutex)
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
+void _PyMonitorSpace_Push(PyMonitorSpaceFrame *frame, struct _PyMonitorSpaceObject *monitorspace);
+void _PyMonitorSpace_Pop(PyMonitorSpaceFrame *frame);
+
 /* The single PyInterpreterState used by this process'
    GILState implementation
 */
 static PyInterpreterState *autoInterpreterState = NULL;
-static int autoTLSkey = 0;
-#else
-#define HEAD_INIT() /* Nothing */
-#define HEAD_LOCK() /* Nothing */
-#define HEAD_UNLOCK() /* Nothing */
-#endif
+static PyThread_type_key autoTLSkey = 0;
 
 static PyInterpreterState *interp_head = NULL;
 
-PyThreadState *_PyThreadState_Current = NULL;
-PyThreadFrameGetter _PyThreadState_GetFrame = NULL;
+/* This hook exists so psyco can provide it's own frame objects */
+static struct _frame *threadstate_getframe(PyThreadState *self);
+PyThreadFrameGetter _PyThreadState_GetFrame = threadstate_getframe;
 
-#ifdef WITH_THREAD
-static void _PyGILState_NoteThreadState(PyThreadState* tstate);
-#endif
+typedef struct _pending_writer {
+	struct _pending_writer *next;
+	PyThread_type_sem sem;
+} pending_writer;
 
+static PyThread_type_lock interpreter_lock = NULL; /* This is the GIL */
+static PyThread_type_cond pending_readers;
+static PyThread_type_cond active_readers;
+static Py_ssize_t pending_readers_count;
+static Py_ssize_t active_readers_count;
+static int active_writer;
+static pending_writer *pending_writers;
+static pending_writer *pending_writers_last;
 
+__thread PyThreadState *_py_local_tstate;
+
+
 PyInterpreterState *
 PyInterpreterState_New(void)
 {
-	PyInterpreterState *interp = (PyInterpreterState *)
-				     malloc(sizeof(PyInterpreterState));
+	PyInterpreterState *interp;
 
+	if (autoInterpreterState)
+		Py_FatalError("InterpreterState already exists");
+
+	interp = malloc(sizeof(PyInterpreterState));
+
 	if (interp != NULL) {
 		HEAD_INIT();
-#ifdef WITH_THREAD
 		if (head_mutex == NULL)
 			Py_FatalError("Can't initialize threads for interpreter");
-#endif
 		interp->modules = NULL;
 		interp->modules_reloading = NULL;
 		interp->sysdict = NULL;
 		interp->builtins = NULL;
 		interp->tstate_head = NULL;
+		interp->tstate_count = 0;
+		interp->entertag = 0;
 		interp->codec_search_path = NULL;
 		interp->codec_search_cache = NULL;
 		interp->codec_error_registry = NULL;
@@ -90,6 +106,8 @@
 		interp->next = interp_head;
 		interp_head = interp;
 		HEAD_UNLOCK();
+
+		autoInterpreterState = interp;
 	}
 
 	return interp;
@@ -114,23 +132,12 @@
 }
 
 
-static void
-zapthreads(PyInterpreterState *interp)
-{
-	PyThreadState *p;
-	/* No need to lock the mutex here because this should only happen
-	   when the threads are all really dead (XXX famous last words). */
-	while ((p = interp->tstate_head) != NULL) {
-		PyThreadState_Delete(p);
-	}
-}
-
-
 void
 PyInterpreterState_Delete(PyInterpreterState *interp)
 {
 	PyInterpreterState **p;
-	zapthreads(interp);
+	if (AO_load_full(&interp->tstate_count) != 0)
+		Py_FatalError("Attempting to delete PyInterpreterState with threads left");
 	HEAD_LOCK();
 	for (p = &interp_head; ; p = &(*p)->next) {
 		if (*p == NULL)
@@ -144,6 +151,7 @@
 	*p = interp->next;
 	HEAD_UNLOCK();
 	free(interp);
+	autoInterpreterState = NULL;
 }
 
 
@@ -155,71 +163,138 @@
 }
 
 PyThreadState *
-PyThreadState_New(PyInterpreterState *interp)
+_PyThreadState_New(void)
 {
-	PyThreadState *tstate = (PyThreadState *)malloc(sizeof(PyThreadState));
+	PyThreadState *tstate;
+	PyObject *monitorspace;
+	int i, j;
 
-	if (_PyThreadState_GetFrame == NULL)
-		_PyThreadState_GetFrame = threadstate_getframe;
+	tstate = malloc(sizeof(PyThreadState));
+	if (tstate == NULL)
+		return NULL;
 
-	if (tstate != NULL) {
-		tstate->interp = interp;
+	tstate->interp = NULL;
 
-		tstate->frame = NULL;
-		tstate->recursion_depth = 0;
-		tstate->overflowed = 0;
-		tstate->recursion_critical = 0;
-		tstate->tracing = 0;
-		tstate->use_tracing = 0;
-		tstate->tick_counter = 0;
-		tstate->gilstate_counter = 0;
-		tstate->async_exc = NULL;
-#ifdef WITH_THREAD
-		tstate->thread_id = PyThread_get_thread_ident();
-#else
-		tstate->thread_id = 0;
-#endif
+	tstate->frame = NULL;
+	tstate->recursion_depth = 0;
+	tstate->overflowed = 0;
+	tstate->recursion_critical = 0;
+	tstate->dealloc_depth = 0;
+	tstate->tracing = 0;
+	tstate->use_tracing = 0;
 
-		tstate->dict = NULL;
+	tstate->large_ticks = 0;
+	tstate->small_ticks = 0;
 
-		tstate->curexc_type = NULL;
-		tstate->curexc_value = NULL;
-		tstate->curexc_traceback = NULL;
+	tstate->inspect_count = 0;
+	tstate->inspect_queue_lock = NULL;
+	tstate->inspect_lock = NULL;
+	tstate->inspect_flag = 0;
 
-		tstate->exc_type = NULL;
-		tstate->exc_value = NULL;
-		tstate->exc_traceback = NULL;
+	tstate->suspended = 1;
 
-		tstate->c_profilefunc = NULL;
-		tstate->c_tracefunc = NULL;
-		tstate->c_profileobj = NULL;
-		tstate->c_traceobj = NULL;
+	tstate->enterframe = NULL;
 
-#ifdef WITH_THREAD
-		_PyGILState_NoteThreadState(tstate);
-#endif
+	tstate->dict = NULL;
 
-		HEAD_LOCK();
-		tstate->next = interp->tstate_head;
-		interp->tstate_head = tstate;
-		HEAD_UNLOCK();
+	tstate->curexc_type = NULL;
+	tstate->curexc_value = NULL;
+	tstate->curexc_traceback = NULL;
+
+	tstate->exc_type = NULL;
+	tstate->exc_value = NULL;
+	tstate->exc_traceback = NULL;
+
+	tstate->c_profilefunc = NULL;
+	tstate->c_tracefunc = NULL;
+	tstate->c_profileobj = NULL;
+	tstate->c_traceobj = NULL;
+
+	tstate->import_depth = 0;
+	tstate->monitorspace_frame = &tstate->_base_monitorspace_frame;
+	tstate->_base_monitorspace_frame.prevframe = NULL;
+	tstate->_base_monitorspace_frame.monitorspace = NULL;
+
+	for (i = 0; i < PYMALLOC_CACHE_SIZECLASSES; i++) {
+		for (j = 0; j < PYMALLOC_CACHE_COUNT; j++)
+			tstate->malloc_cache[i][j] = NULL;
 	}
 
+	for (i = 0; i < PYGC_CACHE_SIZECLASSES; i++) {
+		for (j = 0; j < PYGC_CACHE_COUNT; j++)
+			tstate->gc_object_cache[i][j] = NULL;
+	}
+
+	for (i = 0; i < Py_ASYNCREFCOUNT_TABLE; i ++) {
+		tstate->async_refcounts[i].obj = NULL;
+		tstate->async_refcounts[i].diff = 0;
+	}
+
+	tstate->interrupt_point = NULL;
+
+	tstate->critical_section = NULL;
+
+	tstate->active_lock = NULL;
+	tstate->lockwait_prev = NULL;
+	tstate->lockwait_next = NULL;
+	tstate->lockwait_cond = NULL;
+
+	tstate->lockwait_cond = PyThread_cond_allocate();
+	if (!tstate->lockwait_cond)
+		goto failed;
+	tstate->inspect_queue_lock = PyThread_lock_allocate();
+	if (!tstate->inspect_queue_lock)
+		goto failed;
+	tstate->inspect_lock = PyThread_lock_allocate();
+	if (!tstate->inspect_lock)
+		goto failed;
+
+	//printf("New tstate %p\n", tstate);
 	return tstate;
+
+failed:
+	if (tstate->lockwait_cond)
+		PyThread_cond_free(tstate->lockwait_cond);
+	if (tstate->inspect_queue_lock)
+		PyThread_lock_free(tstate->inspect_queue_lock);
+	if (tstate->inspect_lock)
+		PyThread_lock_free(tstate->inspect_lock);
+	free(tstate);
+	return NULL;
 }
 
+static void
+_PyThreadState_Bind(PyInterpreterState *interp, PyThreadState *tstate)
+{
+	assert(autoTLSkey);
+	if (PyThread_get_key_value(autoTLSkey) != 0)
+		Py_FatalError("Thread already has PyThreadState");
 
+	tstate->interp = interp;
+	PyThread_set_key_value(autoTLSkey, tstate);
+	_py_local_tstate = tstate;
+
+	AO_fetch_and_add1_full(&interp->tstate_count);
+
+	HEAD_LOCK();
+	tstate->next = interp->tstate_head;
+	interp->tstate_head = tstate;
+	HEAD_UNLOCK();
+}
+
 void
 PyThreadState_Clear(PyThreadState *tstate)
 {
 	if (Py_VerboseFlag && tstate->frame != NULL)
 		fprintf(stderr,
 		  "PyThreadState_Clear: warning: thread still has a frame\n");
+	if (Py_VerboseFlag && tstate->monitorspace_frame != &tstate->_base_monitorspace_frame)
+		fprintf(stderr,
+		  "PyThreadState_Clear: warning: thread still has monitorspace frame\n");
 
 	Py_CLEAR(tstate->frame);
 
 	Py_CLEAR(tstate->dict);
-	Py_CLEAR(tstate->async_exc);
 
 	Py_CLEAR(tstate->curexc_type);
 	Py_CLEAR(tstate->curexc_value);
@@ -235,18 +310,41 @@
 	Py_CLEAR(tstate->c_traceobj);
 }
 
+void
+_PyThreadState_Delete(PyThreadState *tstate)
+{
+	assert(tstate->interp == NULL);
+	assert(tstate->critical_section == NULL);
 
-/* Common code for PyThreadState_Delete() and PyThreadState_DeleteCurrent() */
+	//printf("Deleting tstate %p\n", tstate);
+	//free(tstate);
+	/* XXX FIXME We need a users count and we need to delay actual
+	 * deletion until the tracing GC goes through and resets the
+	 * owner fields. */
+	/* We're also leaking locks and stuff */
+}
+
 static void
-tstate_delete_common(PyThreadState *tstate)
+_PyThreadState_Unbind(PyThreadState *tstate)
 {
 	PyInterpreterState *interp;
 	PyThreadState **p;
+
+	assert(tstate != NULL && tstate == PyThreadState_Get());
+	_PyGC_Object_Cache_Flush();
+	_PyGC_AsyncRefcount_Flush();
+	PyState_Suspend();
+
 	if (tstate == NULL)
 		Py_FatalError("PyThreadState_Delete: NULL tstate");
 	interp = tstate->interp;
 	if (interp == NULL)
 		Py_FatalError("PyThreadState_Delete: NULL interp");
+
+	assert(tstate->interrupt_point == NULL);
+	assert(tstate->active_lock == NULL);
+	PyThread_cond_free(tstate->lockwait_cond);
+
 	HEAD_LOCK();
 	for (p = &interp->tstate_head; ; p = &(*p)->next) {
 		if (*p == NULL)
@@ -257,75 +355,27 @@
 	}
 	*p = tstate->next;
 	HEAD_UNLOCK();
-	free(tstate);
-}
 
+	AO_fetch_and_sub1_full(&tstate->interp->tstate_count);
 
-void
-PyThreadState_Delete(PyThreadState *tstate)
-{
-	if (tstate == _PyThreadState_Current)
-		Py_FatalError("PyThreadState_Delete: tstate is still current");
-	tstate_delete_common(tstate);
-#ifdef WITH_THREAD
-	if (autoTLSkey && PyThread_get_key_value(autoTLSkey) == tstate)
-		PyThread_delete_key_value(autoTLSkey);
-#endif /* WITH_THREAD */
-}
+	PyThread_delete_key_value(autoTLSkey);
+	_py_local_tstate = NULL;
 
-
-#ifdef WITH_THREAD
-void
-PyThreadState_DeleteCurrent()
-{
-	PyThreadState *tstate = _PyThreadState_Current;
-	if (tstate == NULL)
-		Py_FatalError(
-			"PyThreadState_DeleteCurrent: no current tstate");
-	_PyThreadState_Current = NULL;
-	tstate_delete_common(tstate);
-	if (autoTLSkey && PyThread_get_key_value(autoTLSkey) == tstate)
-		PyThread_delete_key_value(autoTLSkey);
-	PyEval_ReleaseLock();
+	tstate->interp = NULL;
 }
-#endif /* WITH_THREAD */
 
 
 PyThreadState *
-PyThreadState_Get(void)
+_PyThreadState_Get(void)
 {
-	if (_PyThreadState_Current == NULL)
+	//PyThreadState *tstate = PyThread_get_key_value(autoTLSkey);
+	PyThreadState *tstate = _py_local_tstate;
+	if (tstate == NULL)
 		Py_FatalError("PyThreadState_Get: no current thread");
-
-	return _PyThreadState_Current;
+	return tstate;
 }
 
 
-PyThreadState *
-PyThreadState_Swap(PyThreadState *newts)
-{
-	PyThreadState *oldts = _PyThreadState_Current;
-
-	_PyThreadState_Current = newts;
-	/* It should not be possible for more than one thread state
-	   to be used for a thread.  Check this the best we can in debug
-	   builds.
-	*/
-#if defined(Py_DEBUG) && defined(WITH_THREAD)
-	if (newts) {
-		/* This can be called from PyEval_RestoreThread(). Similar
-		   to it, we need to ensure errno doesn't change.
-		*/
-		int err = errno;
-		PyThreadState *check = PyGILState_GetThisThreadState();
-		if (check && check->interp == newts->interp && check != newts)
-			Py_FatalError("Invalid thread state for this thread");
-		errno = err;
-	}
-#endif
-	return oldts;
-}
-
 /* An extension mechanism to store arbitrary additional per-thread state.
    PyThreadState_GetDict() returns a dictionary that can be used to hold such
    state; the caller should pick a unique key and store its state there.  If
@@ -335,19 +385,23 @@
 PyObject *
 PyThreadState_GetDict(void)
 {
-	if (_PyThreadState_Current == NULL)
+	//PyThreadState *tstate = PyThread_get_key_value(autoTLSkey);
+	PyThreadState *tstate = _py_local_tstate;
+	if (tstate == NULL)
 		return NULL;
 
-	if (_PyThreadState_Current->dict == NULL) {
+	if (tstate->dict == NULL) {
 		PyObject *d;
-		_PyThreadState_Current->dict = d = PyDict_New();
+		tstate->dict = d = PyDict_New();
 		if (d == NULL)
 			PyErr_Clear();
 	}
-	return _PyThreadState_Current->dict;
+	return tstate->dict;
 }
 
 
+/* XXX FIXME rebuild this as part of a much broader debugging hooks API */
+#if 0
 /* Asynchronously raise an exception in a thread.
    Requested by Just van Rossum and Alex Martelli.
    To prevent naive misuse, you must write your own extension
@@ -355,10 +409,10 @@
    Returns the number of tstates modified (normally 1, but 0 if `id` didn't
    match any known thread id).  Can be called with exc=NULL to clear an
    existing async exception.  This raises no exceptions. */
-
+/* XXX FIXME scrap and redesign */
 int
 PyThreadState_SetAsyncExc(long id, PyObject *exc) {
-	PyThreadState *tstate = PyThreadState_GET();
+	PyThreadState *tstate = PyThreadState_Get();
 	PyInterpreterState *interp = tstate->interp;
 	PyThreadState *p;
 
@@ -389,11 +443,46 @@
 	HEAD_UNLOCK();
 	return 0;
 }
+#endif
 
+/* Do periodic things.  This is called from the main event loop, so we
+ * take care to reduce the per-call costs. */
+int
+PyThreadState_Tick(void)
+{
+	PyThreadState *tstate = PyThreadState_Get();
 
+	if (AO_load_acquire(&tstate->inspect_flag)) {
+#if 0
+		PyState_Suspend();
+		PyState_Resume();
+#else
+		PyThread_lock_release(tstate->inspect_lock);
+		PyThread_lock_acquire(tstate->inspect_queue_lock);
+		PyThread_lock_acquire(tstate->inspect_lock);
+		PyThread_lock_release(tstate->inspect_queue_lock);
+#endif
+	}
+
+	if (tstate->small_ticks > 0) {
+		tstate->small_ticks--;
+		return 0;
+	} else {
+		PyState_Suspend();
+		PyState_Resume();
+
+		tstate->large_ticks++;
+		tstate->small_ticks = _Py_CheckInterval; /* XXX use atomic access? */
+
+		return 0;
+	}
+}
+
+
 /* Routines for advanced debuggers, requested by David Beazley.
    Don't use unless you know what you are doing! */
-
+/* XXX FIXME not even slightly thread-safe!  These should be scrapped
+   and redesigned! */
 PyInterpreterState *
 PyInterpreterState_Head(void)
 {
@@ -415,6 +504,7 @@
 	return tstate->next;
 }
 
+
 /* The implementation of sys._current_frames().  This is intended to be
    called with the GIL held, as it will be when called via
    sys._current_frames().  It's possible it would work fine even without
@@ -445,7 +535,7 @@
 			struct _frame *frame = t->frame;
 			if (frame == NULL)
 				continue;
-			id = PyInt_FromLong(t->thread_id);
+			id = PyLong_FromVoidPtr(t);
 			if (id == NULL)
 				goto Fail;
 			stat = PyDict_SetItem(result, id, (PyObject *)frame);
@@ -463,172 +553,384 @@
  	return NULL;
 }
 
-/* Python "auto thread state" API. */
-#ifdef WITH_THREAD
 
-/* Keep this as a static, as it is not reliable!  It can only
-   ever be compared to the state for the *current* thread.
-   * If not equal, then it doesn't matter that the actual
-     value may change immediately after comparison, as it can't
-     possibly change to the current thread's state.
-   * If equal, then the current thread holds the lock, so the value can't
-     change until we yield the lock.
-*/
-static int
-PyThreadState_IsCurrent(PyThreadState *tstate)
+static void
+state_interrupt_callback(struct _PyInterruptQueue *queue, void *arg)
 {
-	/* Must be the tstate for this thread */
-	assert(PyGILState_GetThisThreadState()==tstate);
-	/* On Windows at least, simple reads and writes to 32 bit values
-	   are atomic.
-	*/
-	return tstate == _PyThreadState_Current;
 }
 
-/* Internal initialization/finalization functions called by
-   Py_Initialize/Py_Finalize
-*/
+PyState_EnterFrame *
+PyState_Enter(void)
+{
+	PyState_EnterFrame *enterframe;
+	PyMonitorSpaceObject *monitorspace;
+	PyMonitorSpaceFrame *monitorframe;
+
+	enterframe = _PyState_EnterPreallocated(NULL);
+	if (enterframe == NULL)
+		return NULL;
+
+#if 0
+	monitorframe = malloc(sizeof(PyMonitorSpaceFrame));
+	if (monitorframe == NULL) {
+		_PyState_ExitSimple(enterframe);
+		return NULL;
+	}
+	//*monitorframe = PyMonitorSpaceFrame_INIT;
+	monitorframe->prevframe = NULL;
+	monitorframe->monitorspace = NULL;
+
+	monitorspace = (PyMonitorSpaceObject *)PyObject_CallObject((PyObject *)&PyMonitorSpace_Type, NULL);
+	if (monitorspace == NULL) {
+		free(monitorframe);
+		_PyState_ExitSimple(enterframe);
+		return NULL;
+	}
+
+	_PyMonitorSpace_Push(monitorframe, monitorspace);
+#elif 1
+	monitorframe = malloc(sizeof(PyMonitorSpaceFrame));
+	if (monitorframe == NULL) {
+		_PyState_ExitSimple(enterframe);
+		return NULL;
+	}
+	//*monitorframe = PyMonitorSpaceFrame_INIT;
+	monitorframe->prevframe = NULL;
+	monitorframe->monitorspace = NULL;
+	_PyMonitorSpace_Push(monitorframe, NULL);
+#endif
+	return enterframe;
+}
+
+PyState_EnterFrame *
+_PyState_EnterPreallocated(PyThreadState *new_tstate)
+{
+	PyThreadState *tstate;
+	PyState_EnterFrame *frame;
+	static const PyMonitorSpaceFrame initframe = PyMonitorSpaceFrame_INIT;
+
+	assert(autoInterpreterState);
+	//tstate = (PyThreadState *)PyThread_get_key_value(autoTLSkey);
+	tstate = _py_local_tstate;
+
+	frame = malloc(sizeof(PyState_EnterFrame));
+	if (frame == NULL)
+		return NULL;
+
+	if (tstate == NULL) {
+		PyInterruptObject *point;
+		/* Create a new thread state for this thread */
+		if (new_tstate == NULL) {
+			tstate = _PyThreadState_New();
+			if (tstate == NULL) {
+				free(frame);
+				return NULL;
+			}
+		} else
+			tstate = new_tstate;
+
+		_PyThreadState_Bind(autoInterpreterState, tstate);
+		frame->prevframe = tstate->enterframe;
+		tstate->enterframe = frame;
+		frame->locked = 0;
+		frame->monitorspaceframe = initframe;
+
+		PyState_Resume();
+		point = PyInterrupt_New(state_interrupt_callback, NULL, NULL);
+		if (point == NULL) {
+			PyState_Suspend();
+			_PyThreadState_Unbind(tstate);
+			_PyThreadState_Delete(tstate);
+			free(frame);
+			return NULL;
+		}
+		PyInterrupt_Push(point);
+		PyState_Suspend();
+	} else {
+		if (new_tstate != NULL)
+			Py_FatalError("Unexpected new_tstate");
+
+		if (tstate->enterframe->locked)
+			PyState_Suspend();
+
+		frame->prevframe = tstate->enterframe;
+		tstate->enterframe = frame;
+		frame->locked = 0;
+		frame->monitorspaceframe = initframe;
+	}
+
+	PyState_Resume();
+	return frame;
+}
+
 void
-_PyGILState_Init(PyInterpreterState *i, PyThreadState *t)
+PyState_Exit(PyState_EnterFrame *enterframe)
 {
-	assert(i && t); /* must init with valid states */
-	autoTLSkey = PyThread_create_key();
-	autoInterpreterState = i;
-	assert(PyThread_get_key_value(autoTLSkey) == NULL);
-	assert(t->gilstate_counter == 0);
+#if 0
+	PyThreadState *tstate = PyThreadState_Get();
+	PyMonitorSpaceFrame *monitorframe = tstate->monitorspace_frame;
+	PyMonitorSpaceObject *monitorspace = monitorframe->monitorspace;
 
-	_PyGILState_NoteThreadState(t);
+	_PyMonitorSpace_Pop(monitorframe);
+	Py_DECREF(monitorspace);
+	free(monitorframe);
+#endif
+	_PyState_ExitSimple(enterframe);
 }
 
 void
-_PyGILState_Fini(void)
+_PyState_ExitSimple(PyState_EnterFrame *enterframe)
 {
-	PyThread_delete_key(autoTLSkey);
-	autoTLSkey = 0;
-	autoInterpreterState = NULL;
+	PyThreadState *tstate = PyThreadState_Get();
+	PyState_EnterFrame *oldframe;
+
+	oldframe = tstate->enterframe;
+	if (enterframe != oldframe)
+		Py_FatalError("PyState_Exit called with wrong frame");
+
+	if (tstate->suspended)
+		Py_FatalError("PyState_Exit called while suspended");
+
+	if (!oldframe->locked)
+		Py_FatalError("PyState_Exit called in an unlocked state");
+
+	if (oldframe->prevframe == NULL) {
+		PyInterrupt_Pop(tstate->interrupt_point);
+		Py_CLEAR(tstate->interrupt_point);
+		PyThreadState_Clear(tstate);
+		_PyThreadState_Unbind(tstate);
+		_PyThreadState_Delete(tstate);
+		free(oldframe);
+	} else {
+		PyState_Suspend();
+
+		tstate->enterframe = oldframe->prevframe;
+		free(oldframe);
+
+		if (tstate->enterframe->locked)
+			PyState_Resume();
+	}
 }
 
-/* When a thread state is created for a thread by some mechanism other than
-   PyGILState_Ensure, it's important that the GILState machinery knows about
-   it so it doesn't try to create another thread state for the thread (this is
-   a better fix for SF bug #1010677 than the first one attempted).
-*/
-static void
-_PyGILState_NoteThreadState(PyThreadState* tstate)
+
+void
+PyState_EnterImport(void)
 {
-	/* If autoTLSkey is 0, this must be the very first threadstate created
-	   in Py_Initialize().  Don't do anything for now (we'll be back here
-	   when _PyGILState_Init is called). */
-	if (!autoTLSkey)
-		return;
+	PyThreadState *tstate = PyThreadState_Get();
 
-	/* Stick the thread state for this thread in thread local storage.
+	tstate->import_depth++;
+}
 
-	   The only situation where you can legitimately have more than one
-	   thread state for an OS level thread is when there are multiple
-	   interpreters, when:
+void
+PyState_ExitImport(void)
+{
+	PyThreadState *tstate = PyThreadState_Get();
 
-	       a) You shouldn't really be using the PyGILState_ APIs anyway,
-	          and:
+	tstate->import_depth--;
+	assert(tstate->import_depth >= 0);
+}
 
-	       b) The slightly odd way PyThread_set_key_value works (see
-	          comments by its implementation) means that the first thread
-	          state created for that given OS level thread will "win",
-	          which seems reasonable behaviour.
-	*/
-	if (PyThread_set_key_value(autoTLSkey, (void *)tstate) < 0)
-		Py_FatalError("Couldn't create autoTLSkey mapping");
 
-	/* PyGILState_Release must not try to delete this thread state. */
-	tstate->gilstate_counter = 1;
+/* Stops all other threads from accessing their PyState */
+void
+PyState_StopTheWorld(void)
+{
+	/* XXX FIXME */
+    Py_FatalError("FIXME StopTheWorld");
 }
 
-/* The public functions */
-PyThreadState *
-PyGILState_GetThisThreadState(void)
+void
+PyState_StartTheWorld(void)
 {
-	if (autoInterpreterState == NULL || autoTLSkey == 0)
-		return NULL;
-	return (PyThreadState *)PyThread_get_key_value(autoTLSkey);
+    Py_FatalError("FIXME StartTheWorld");
 }
 
-PyGILState_STATE
-PyGILState_Ensure(void)
+
+/* XXX change "active" MonitorSpace to none */
+void
+PyState_Suspend(void)
 {
-	int current;
-	PyThreadState *tcur;
-	/* Note that we do not auto-init Python here - apart from
-	   potential races with 2 threads auto-initializing, pep-311
-	   spells out other issues.  Embedders are expected to have
-	   called Py_Initialize() and usually PyEval_InitThreads().
-	*/
-	assert(autoInterpreterState); /* Py_Initialize() hasn't been called! */
-	tcur = (PyThreadState *)PyThread_get_key_value(autoTLSkey);
-	if (tcur == NULL) {
-		/* Create a new thread state for this thread */
-		tcur = PyThreadState_New(autoInterpreterState);
-		if (tcur == NULL)
-			Py_FatalError("Couldn't create thread-state for new thread");
-		/* This is our thread state!  We'll need to delete it in the
-		   matching call to PyGILState_Release(). */
-		tcur->gilstate_counter = 0;
-		current = 0; /* new thread state is never current */
+	int err = errno;
+	PyThreadState *tstate = PyThreadState_Get();
+
+	assert(!tstate->suspended);
+	tstate->suspended = 1;
+	tstate->enterframe->locked = 0;
+	PyThread_lock_release(tstate->inspect_lock);
+
+	errno = err;
+}
+
+/* XXX Reactivate MonitorSpace */
+void
+PyState_Resume(void)
+{
+	int err = errno;
+	PyThreadState *tstate = PyThreadState_Get();
+
+	assert(tstate->suspended);
+	PyThread_lock_acquire(tstate->inspect_lock);
+	tstate->suspended = 0;
+	tstate->enterframe->locked = 1;
+
+	errno = err;
+}
+
+
+PyCritical *
+PyCritical_Allocate(Py_ssize_t depth)
+{
+	PyCritical *crit = malloc(sizeof(PyCritical));
+	if (crit == NULL)
+		return NULL;
+
+	crit->lock = PyThread_lock_allocate();
+	if (!crit->lock) {
+		free(crit);
+		return NULL;
 	}
-	else
-		current = PyThreadState_IsCurrent(tcur);
-	if (current == 0)
-		PyEval_RestoreThread(tcur);
-	/* Update our counter in the thread-state - no need for locks:
-	   - tcur will remain valid as we hold the GIL.
-	   - the counter is safe as we are the only thread "allowed"
-	     to modify this value
-	*/
-	++tcur->gilstate_counter;
-	return current ? PyGILState_LOCKED : PyGILState_UNLOCKED;
+
+	crit->depth = depth;
+	crit->prev = NULL;
+
+	return crit;
 }
 
 void
-PyGILState_Release(PyGILState_STATE oldstate)
+PyCritical_Free(PyCritical *crit)
 {
-	PyThreadState *tcur = (PyThreadState *)PyThread_get_key_value(
-                                                                autoTLSkey);
-	if (tcur == NULL)
-		Py_FatalError("auto-releasing thread-state, "
-		              "but no thread-state for this thread");
-	/* We must hold the GIL and have our thread state current */
-	/* XXX - remove the check - the assert should be fine,
-	   but while this is very new (April 2003), the extra check
-	   by release-only users can't hurt.
-	*/
-	if (! PyThreadState_IsCurrent(tcur))
-		Py_FatalError("This thread state must be current when releasing");
-	assert(PyThreadState_IsCurrent(tcur));
-	--tcur->gilstate_counter;
-	assert(tcur->gilstate_counter >= 0); /* illegal counter value */
+	PyThread_lock_free(crit->lock);
+	free(crit);
+}
 
-	/* If we're going to destroy this thread-state, we must
-	 * clear it while the GIL is held, as destructors may run.
-	 */
-	if (tcur->gilstate_counter == 0) {
-		/* can't have been locked when we created it */
-		assert(oldstate == PyGILState_UNLOCKED);
-		PyThreadState_Clear(tcur);
-		/* Delete the thread-state.  Note this releases the GIL too!
-		 * It's vital that the GIL be held here, to avoid shutdown
-		 * races; see bugs 225673 and 1061968 (that nasty bug has a
-		 * habit of coming back).
-		 */
-		PyThreadState_DeleteCurrent();
+void
+PyCritical_Enter(PyCritical *crit)
+{
+	PyThreadState *tstate = PyThreadState_Get();
+
+	assert(!tstate->suspended);
+
+	if (tstate->critical_section != NULL &&
+			tstate->critical_section->depth <= crit->depth)
+		Py_FatalError("PyCritical_Enter called while "
+			"already in deeper critical section");
+
+	if (!_PyThread_lock_tryacquire(crit->lock)) {
+		PyState_Suspend();
+		PyThread_lock_acquire(crit->lock);
+		PyState_Resume();
 	}
-	/* Release the lock if necessary */
-	else if (oldstate == PyGILState_UNLOCKED)
-		PyEval_SaveThread();
+
+	assert(crit->prev == NULL);
+	crit->prev = tstate->critical_section;
+	tstate->critical_section = crit;
 }
 
-#ifdef __cplusplus
+void
+PyCritical_Exit(PyCritical *crit)
+{
+	PyThreadState *tstate = PyThreadState_Get();
+
+	assert(!tstate->suspended);
+
+	if (tstate->critical_section != crit)
+		Py_FatalError("PyCritical_Exit called with wrong "
+			"critical section");
+
+	tstate->critical_section = crit->prev;
+	crit->prev = NULL;
+
+	PyThread_lock_release(crit->lock);
 }
-#endif
 
-#endif /* WITH_THREAD */
+/* This is just a bodge for deathqueue_wait.  It shouldn't be used in general */
+void
+_PyCritical_CondWait(PyCritical *crit, PyThread_type_cond cond)
+{
+    PyThreadState *tstate = PyThreadState_Get();
 
+    assert(!tstate->suspended);
 
+    if (tstate->critical_section != crit)
+        Py_FatalError("_PyCritical_CondWait called with wrong "
+            "critical section");
+
+    PyThread_cond_wait(cond, crit->lock);
+}
+
+
+extern PyThreadState * (*pymalloc_threadstate_hook)(void);
+
+void
+_PyState_InitThreads(void)
+{
+	if (interpreter_lock)
+		Py_FatalError("Interpreter state already initialized");
+	interpreter_lock = PyThread_lock_allocate();
+	pending_readers = PyThread_cond_allocate();
+	active_readers = PyThread_cond_allocate();
+	autoTLSkey = PyThread_create_key();
+	if (!interpreter_lock || !pending_readers || !active_readers ||
+			!autoTLSkey)
+		Py_FatalError("Allocation failed in _PyState_InitThreads");
+	pymalloc_threadstate_hook = PyThreadState_Get;
+}
+
+void
+PyState_PrepareFork(void)
+{
+	PyThread_lock_acquire(interpreter_lock);
+}
+
+void
+PyState_CleanupForkParent(void)
+{
+	PyThread_lock_release(interpreter_lock);
+}
+
+/* This function is called from PyOS_AfterFork to reset the interpreter's
+   locks so they can be used in the child process.  (This could also be
+   done using pthread_atfork mechanism, at least for the pthreads
+   implementation.)
+
+   However, this only resets a few of the locks that may be in use, so
+   doing anything non-trivial is almost certainly unsafe.
+
+   Cleaning up properly is impossible.  The users of fork should really
+   be rewritten in C so they don't need to touch python objects before
+   they exec.  For now, we bodge things.*/
+void
+PyState_CleanupForkChild(void)
+{
+	PyState_EnterTag entertag;
+
+	if (!interpreter_lock)
+		return;
+
+	interpreter_lock = PyThread_lock_allocate();
+	if (!interpreter_lock)
+		Py_FatalError("Unable to allocate lock");
+	pending_readers_count = 0;
+	active_readers_count = 0;
+	active_writer = 0;
+	pending_writers = NULL;
+	PyThread_delete_key_value(autoTLSkey);
+	entertag = PyState_Enter();
+	if (!entertag)
+		Py_FatalError("Unable to re-enter state after fork");
+}
+
+/* Internal initialization/finalization functions called by
+   Py_Initialize/Py_Finalize
+*/
+void
+_PyState_Fini(void)
+{
+	PyThread_delete_key(autoTLSkey);
+	autoTLSkey = 0;
+}
+
+
+#ifdef __cplusplus
+}
+#endif
Index: Python/pythonrun.c
===================================================================
--- Python/pythonrun.c	(revision 58355)
+++ Python/pythonrun.c	(working copy)
@@ -17,6 +17,7 @@
 #include "ast.h"
 #include "eval.h"
 #include "marshal.h"
+#include "branchobject.h"
 
 #ifdef HAVE_SIGNAL_H
 #include <signal.h>
@@ -49,6 +50,8 @@
 extern grammar _PyParser_Grammar; /* From graminit.c */
 
 /* Forward */
+static void initfinalize(void);
+static void finifinalize(void);
 static void initmain(void);
 static void initsite(void);
 static PyObject *run_mod(mod_ty, const char *, PyObject *, PyObject *,
@@ -59,16 +62,22 @@
 static void initsigs(void);
 static void call_py_exitfuncs(void);
 static void call_ll_exitfuncs(void);
+extern void _PyGC_Init(void);
+extern void _PyUnicode_PreInit(void);
 extern void _PyUnicode_Init(void);
 extern void _PyUnicode_Fini(void);
+extern void _PyUnicode_PostFini(void);
+extern void _PyString_PostFini(void);
+extern void _PyDict_PreInit(void);
 extern int _PyLong_Init(void);
 extern void PyLong_Fini(void);
 
-#ifdef WITH_THREAD
-extern void _PyGILState_Init(PyInterpreterState *, PyThreadState *);
-extern void _PyGILState_Fini(void);
-#endif /* WITH_THREAD */
+extern void _PyState_InitThreads(void);
+extern void _PyState_Fini(void);
 
+extern void _Py_Refchain_Init(void);
+extern void _Py_Refchain_Fini(void);
+
 int Py_DebugFlag; /* Needed by parser.c */
 int Py_VerboseFlag; /* Needed by import.c */
 int Py_InteractiveFlag; /* Needed by Py_FdIsInteractive() below */
@@ -83,6 +92,8 @@
 */
 static PyObject *warnings_module = NULL;
 
+static PyObject *finalize_branch = NULL;
+
 /* Returns a borrowed reference to the 'warnings' module, or NULL.
    If the module is returned, it is guaranteed to have been obtained
    without acquiring the import lock
@@ -112,6 +123,7 @@
 	return warnings_module;
 }
 
+/* 0 for uninitialized, 1 for initialized, -1 for finalized */
 static int initialized = 0;
 
 /* API to access the initialized flag -- useful for esoteric use */
@@ -119,7 +131,9 @@
 int
 Py_IsInitialized(void)
 {
-	return initialized;
+    /* Typical callers don't want to know we're finalized, so we make
+     * sure they don't have to test for it. */
+    return initialized == 1;
 }
 
 /* Global initializations.  Can be undone by Py_Finalize().  Don't
@@ -146,10 +160,10 @@
 }
 
 void
-Py_InitializeEx(int install_sigs)
+Py_InitializeEx(int handle_sigint)
 {
 	PyInterpreterState *interp;
-	PyThreadState *tstate;
+	//PyThreadState *tstate;
 	PyObject *bimod, *sysmod;
 	char *p;
 #if defined(HAVE_LANGINFO_H) && defined(CODESET)
@@ -157,8 +171,12 @@
 #endif
 	extern void _Py_ReadyTypes(void);
 
-	if (initialized)
-		return;
+	if (initialized == 1)
+		Py_FatalError("Cannot call Py_Initialize: already initialized");
+	if (initialized == -1)
+		Py_FatalError("Cannot call Py_Initialize: already finalized");
+	if (initialized != 0)
+		Py_FatalError("Cannot call Py_Initialize: unknown initialized stated");
 	initialized = 1;
 
 #ifdef HAVE_SETLOCALE
@@ -175,28 +193,48 @@
 	if ((p = Py_GETENV("PYTHONOPTIMIZE")) && *p != '\0')
 		Py_OptimizeFlag = add_flag(Py_OptimizeFlag, p);
 
+	_PyGC_Init();
+
+	_Py_Refchain_Init();
+
+	_PyState_InitThreads();
+
 	interp = PyInterpreterState_New();
 	if (interp == NULL)
 		Py_FatalError("Py_Initialize: can't make first interpreter");
 
-	tstate = PyThreadState_New(interp);
-	if (tstate == NULL)
-		Py_FatalError("Py_Initialize: can't make first thread");
-	(void) PyThreadState_Swap(tstate);
+	interp->entertag = PyState_Enter();
+	if (!interp->entertag)
+		Py_FatalError("Py_Initialize: PySpace_Enter failed");
+	//tstate = PyThreadState_New(interp);
+	//if (tstate == NULL)
+	//	Py_FatalError("Py_Initialize: can't make first thread");
+	//(void) PyThreadState_Swap(tstate);
+	//PyState_Resume();
 
-	_Py_ReadyTypes();
+	/* Bare minimum before other types */
+	_PyUnicode_PreInit();
+	_PyDict_PreInit();
 
 	if (!_PyFrame_Init())
 		Py_FatalError("Py_Initialize: can't init frames");
-
+	_PyMethod_Init();
 	if (!_PyLong_Init())
 		Py_FatalError("Py_Initialize: can't init longs");
-
+	_PyFloat_Init();
+	_PyTuple_Init();
+	_PyList_Init();
+	_PySet_Init();
+	_PyString_Init();
 	if (!PyBytes_Init())
 		Py_FatalError("Py_Initialize: can't init bytes");
+	_PyCFunction_Init();
 
-	_PyFloat_Init();
+	/* Init Unicode implementation; relies on the codec registry */
+	_PyUnicode_Init();
 
+	_Py_ReadyTypes();
+
 	interp->modules = PyDict_New();
 	if (interp->modules == NULL)
 		Py_FatalError("Py_Initialize: can't make modules dictionary");
@@ -204,9 +242,6 @@
 	if (interp->modules_reloading == NULL)
 		Py_FatalError("Py_Initialize: can't make modules_reloading dictionary");
 
-	/* Init Unicode implementation; relies on the codec registry */
-	_PyUnicode_Init();
-
 	bimod = _PyBuiltin_Init();
 	if (bimod == NULL)
 		Py_FatalError("Py_Initialize: can't initialize __builtin__");
@@ -215,6 +250,8 @@
 		Py_FatalError("Py_Initialize: can't initialize builtins dict");
 	Py_INCREF(interp->builtins);
 
+	_Py_ThreadTools_Init();
+
 	sysmod = _PySys_Init();
 	if (sysmod == NULL)
 		Py_FatalError("Py_Initialize: can't initialize sys");
@@ -229,26 +266,21 @@
 
 	_PyImport_Init();
 
-	/* initialize builtin exceptions */
-	_PyExc_Init();
-
 	/* phase 2 of builtins */
 	_PyImport_FixupExtension("__builtin__", "__builtin__");
 
 	_PyImportHooks_Init();
 
-	if (install_sigs)
-		initsigs(); /* Signal handling stuff, including initintr() */
+	_PySignal_Init();
 
+	initfinalize();
+
+	_PySignal_InitSigInt(handle_sigint);
+
 	initmain(); /* Module __main__ */
 	if (!Py_NoSiteFlag)
 		initsite(); /* Module site */
 
-	/* auto-thread-state API, if available */
-#ifdef WITH_THREAD
-	_PyGILState_Init(interp, tstate);
-#endif /* WITH_THREAD */
-
 	warnings_module = PyImport_ImportModule("warnings");
 	if (!warnings_module)
 		PyErr_Clear();
@@ -339,8 +371,12 @@
 	PyInterpreterState *interp;
 	PyThreadState *tstate;
 
-	if (!initialized)
-		return;
+	if (initialized == 0)
+		Py_FatalError("Cannot call Py_Finalize: not yet initialized");
+	if (initialized == -1)
+		Py_FatalError("Cannot call Py_Finalize: already finalized");
+	if (initialized != 1)
+		Py_FatalError("Cannot call Py_Finalize: unknown initialized stated");
 
 	/* The interpreter is still entirely intact at this point, and the
 	 * exit funcs may be relying on that.  In particular, if some thread
@@ -351,18 +387,25 @@
 	 * threads created thru it, so this also protects pending imports in
 	 * the threads created via Threading.
 	 */
+	/* XXX FIXME this isn't done in a thread-safe fashion.  The
+	 * initialized variable itself isn't accessed atomically, but we
+	 * also have a race before we change it after checking it. */
 	call_py_exitfuncs();
-	initialized = 0;
+	initialized = -1;
 
 	/* Flush stdout+stderr */
 	flush_std_files();
 
 	/* Get current thread state and interpreter pointer */
-	tstate = PyThreadState_GET();
+	tstate = PyThreadState_Get();
 	interp = tstate->interp;
 
+	_PySignal_FiniSigInt();
+
+	finifinalize();
+
 	/* Disable signal handling */
-	PyOS_FiniInterrupts();
+	_PySignal_Fini();
 
 	/* drop module references we saved */
 	Py_XDECREF(warnings_module);
@@ -380,20 +423,21 @@
 	 * XXX but I'm unclear on exactly how that one happens.  In any case,
 	 * XXX I haven't seen a real-life report of either of these.
 	 */
-	PyGC_Collect();
+	//PyGC_Collect();
 #ifdef COUNT_ALLOCS
 	/* With COUNT_ALLOCS, it helps to run GC multiple times:
 	   each collection might release some types from the type
 	   list, so they become garbage. */
-	while (PyGC_Collect() > 0)
-		/* nothing */;
+	//while (PyGC_Collect() > 0)
+	//	/* nothing */;
 #endif
 
 	/* Destroy all modules */
 	PyImport_Cleanup();
 
 	/* Flush stdout+stderr (again, in case more was printed) */
-	flush_std_files();
+	/* XXX io.py is long gone at this point */
+	//flush_std_files();
 
 	/* Collect final garbage.  This disposes of cycles created by
 	 * new-style class definitions, for example.
@@ -434,11 +478,6 @@
 		_Py_PrintReferences(stderr);
 #endif /* Py_TRACE_REFS */
 
-	/* Cleanup auto-thread-state */
-#ifdef WITH_THREAD
-	_PyGILState_Fini();
-#endif /* WITH_THREAD */
-
 	/* Clear interpreter state */
 	PyInterpreterState_Clear(interp);
 
@@ -450,16 +489,13 @@
 
 	_PyExc_Fini();
 
-	/* Delete current thread */
-	PyThreadState_Swap(NULL);
-	PyInterpreterState_Delete(interp);
-
 	/* Sundry finalizers */
 	PyMethod_Fini();
 	PyFrame_Fini();
 	PyCFunction_Fini();
 	PyTuple_Fini();
 	PyList_Fini();
+	PyDict_Fini();
 	PySet_Fini();
 	PyString_Fini();
 	PyBytes_Fini();
@@ -490,114 +526,21 @@
 		_PyObject_DebugMallocStats();
 #endif
 
+	_PyUnicode_PostFini();
+	_PyString_PostFini();
+
 	call_ll_exitfuncs();
-}
 
-/* Create and initialize a new interpreter and thread, and return the
-   new thread.  This requires that Py_Initialize() has been called
-   first.
-
-   Unsuccessful initialization yields a NULL pointer.  Note that *no*
-   exception information is available even in this case -- the
-   exception information is held in the thread, and there is no
-   thread.
-
-   Locking: as above.
-
-*/
-
-PyThreadState *
-Py_NewInterpreter(void)
-{
-	PyInterpreterState *interp;
-	PyThreadState *tstate, *save_tstate;
-	PyObject *bimod, *sysmod;
-
-	if (!initialized)
-		Py_FatalError("Py_NewInterpreter: call Py_Initialize first");
-
-	interp = PyInterpreterState_New();
-	if (interp == NULL)
-		return NULL;
-
-	tstate = PyThreadState_New(interp);
-	if (tstate == NULL) {
-		PyInterpreterState_Delete(interp);
-		return NULL;
-	}
-
-	save_tstate = PyThreadState_Swap(tstate);
-
-	/* XXX The following is lax in error checking */
-
-	interp->modules = PyDict_New();
-	interp->modules_reloading = PyDict_New();
-
-	bimod = _PyImport_FindExtension("__builtin__", "__builtin__");
-	if (bimod != NULL) {
-		interp->builtins = PyModule_GetDict(bimod);
-		if (interp->builtins == NULL)
-			goto handle_error;
-		Py_INCREF(interp->builtins);
-	}
-	sysmod = _PyImport_FindExtension("sys", "sys");
-	if (bimod != NULL && sysmod != NULL) {
-		interp->sysdict = PyModule_GetDict(sysmod);
-		if (interp->sysdict == NULL)
-			goto handle_error;
-		Py_INCREF(interp->sysdict);
-		PySys_SetPath(Py_GetPath());
-		PyDict_SetItemString(interp->sysdict, "modules",
-				     interp->modules);
-		_PyImportHooks_Init();
-		initmain();
-		if (!Py_NoSiteFlag)
-			initsite();
-	}
-
-	if (!PyErr_Occurred())
-		return tstate;
-
-handle_error:
-	/* Oops, it didn't work.  Undo it all. */
-
-	PyErr_Print();
-	PyThreadState_Clear(tstate);
-	PyThreadState_Swap(save_tstate);
-	PyThreadState_Delete(tstate);
+	/* Delete current thread */
+	//PyThreadState_Swap(NULL);
+	//PyThreadState_DeleteCurrent();
+	PyState_Exit(interp->entertag);
 	PyInterpreterState_Delete(interp);
 
-	return NULL;
-}
+	/* Cleanup auto-thread-state */
+	_PyState_Fini();
 
-/* Delete an interpreter and its last thread.  This requires that the
-   given thread state is current, that the thread has no remaining
-   frames, and that it is its interpreter's only remaining thread.
-   It is a fatal error to violate these constraints.
-
-   (Py_Finalize() doesn't have these constraints -- it zaps
-   everything, regardless.)
-
-   Locking: as above.
-
-*/
-
-void
-Py_EndInterpreter(PyThreadState *tstate)
-{
-	PyInterpreterState *interp = tstate->interp;
-
-	if (tstate != PyThreadState_GET())
-		Py_FatalError("Py_EndInterpreter: thread is not current");
-	if (tstate->frame != NULL)
-		Py_FatalError("Py_EndInterpreter: thread still has a frame");
-	if (tstate != interp->tstate_head || tstate->next != NULL)
-		Py_FatalError("Py_EndInterpreter: not the last thread");
-
-	PyImport_Cleanup();
-	PyInterpreterState_Clear(interp);
-	PyThreadState_Swap(NULL);
-	PyInterpreterState_Delete(interp);
+	_Py_Refchain_Fini();
 }
 
 static char *progname = "python";
@@ -632,6 +575,87 @@
 	return home;
 }
 
+/* Create finalizer thread */
+static void
+initfinalize(void)
+{
+    PyObject *queue, *runfinalizers, *x;
+
+    queue = PyObject_CallObject((PyObject *)&_PyDeathQueue_Type, NULL);
+    if (queue == NULL)
+        Py_FatalError("Py_Initialize: can't initialize finalizequeue");
+    if (PySys_SetObject("finalizequeue", queue) != 0)
+        Py_FatalError("Py_Initialize: can't assign finalizequeue");
+
+    runfinalizers = PySys_GetObject("_runfinalizers");
+    if (runfinalizers == NULL)
+        Py_FatalError("lost sys._runfinalizers");
+    Py_INCREF(runfinalizers);  /* PySys_GetObject returns a borrowed reference */
+
+    finalize_branch = PyObject_CallObject((PyObject *)&PyBranch_Type, NULL);
+    if (finalize_branch == NULL)
+        Py_FatalError("Failed to initialize finalize_branch");
+    x = PyObject_CallMethod(finalize_branch, "__enter__", "");
+    if (x == NULL)
+        Py_FatalError("Failed to call finalize_branch.__enter__()");
+    Py_DECREF(x);
+
+    x = PyObject_CallMethod(finalize_branch, "add", "OO", runfinalizers, queue);
+    if (x == NULL)
+        Py_FatalError("Failed to spawn finalizer thread");
+    Py_DECREF(queue);
+    Py_DECREF(runfinalizers);
+    Py_DECREF(x);
+}
+
+/* Destroy the finalizer thread */
+static void
+finifinalize(void)
+{
+    PyObject *x, *dummy, *queue;
+    PyObject *e_type, *e_val, *e_tb;
+
+    dummy = PySet_New(NULL);
+    if (dummy == NULL)
+        Py_FatalError("failed to create dummy to exit finalizer thread");
+    queue = PySys_GetObject("finalizequeue");
+    if (queue == NULL)
+        Py_FatalError("lost sys.finalizequeue");
+
+    x = PyObject_CallMethod(queue, "watch", "OO", dummy, Py_None);
+    if (x == NULL)
+        Py_FatalError("failed to watch dummy to exit finalizer thread");
+    Py_DECREF(x);
+    Py_DECREF(dummy);
+    //Py_DECREF(queue);  // PySys_GetObject returns a borrowed reference
+
+    /* XXX We're dependant on the GC deleting dummy, and preferably
+     * immediately.  This SHOULD happen, but it's not a great assumption. */
+
+    /* XXX This is all a big bodge */
+    PyErr_Fetch(&e_type, &e_val, &e_tb);
+    PyErr_NormalizeException(&e_type, &e_val, &e_tb);
+    if (e_type == NULL) {
+        Py_INCREF(Py_None);
+        e_type = Py_None;
+        Py_INCREF(Py_None);
+        e_val = Py_None;
+    }
+    if (e_tb == NULL) {
+        Py_INCREF(Py_None);
+        e_tb = Py_None;
+    }
+    assert(e_type && e_val && e_tb);
+    x = PyObject_CallMethod(finalize_branch, "__exit__", "OOO", e_type, e_val, e_tb);
+    /* XXX any DECREFs needed? */
+    if (x == NULL)
+        PyErr_Print();
+        //Py_FatalError("failed to call finalize_branch.__exit__()");
+    Py_XDECREF(x);
+    Py_CLEAR(finalize_branch);
+    /* XXX reraise or whatever as required by __exit__ specs */
+}
+
 /* Create __main__ module */
 
 static void
@@ -659,8 +683,14 @@
 	PyObject *m, *f;
 	m = PyImport_ImportModule("site");
 	if (m == NULL) {
-		f = PySys_GetObject("stderr");
-		if (Py_VerboseFlag) {
+		//f = PySys_GetObject("stderr");
+		f = NULL;
+		if (f == NULL) {
+			fprintf(stderr, "'import site' failed; retrieving "
+				"sys.stderr also failed.\n");
+			PyErr_Print();
+			//PyErr_Clear();
+		} else if (Py_VerboseFlag) {
 			PyFile_WriteString(
 				"'import site' failed; traceback:\n", f);
 			PyErr_Print();
@@ -1144,11 +1174,12 @@
 	int err = 0;
 	PyObject *f = PySys_GetObject("stderr");
 	Py_INCREF(value);
-	if (f == NULL)
+
+	if (f == NULL) {
 		_PyObject_Dump(value);
-	if (f == NULL)
+		PyTraceBack_Print(tb, NULL);  /* XXX FIXME check return? */
 		fprintf(stderr, "lost sys.stderr\n");
-	else {
+	} else {
 		fflush(stdout);
 		if (tb && tb != Py_None)
 			err = PyTraceBack_Print(tb, f);
@@ -1648,22 +1679,7 @@
 	exit(sts);
 }
 
-static void
-initsigs(void)
-{
-#ifdef SIGPIPE
-	PyOS_setsig(SIGPIPE, SIG_IGN);
-#endif
-#ifdef SIGXFZ
-	PyOS_setsig(SIGXFZ, SIG_IGN);
-#endif
-#ifdef SIGXFSZ
-	PyOS_setsig(SIGXFSZ, SIG_IGN);
-#endif
-	PyOS_InitInterrupts(); /* May imply initsignal() */
-}
 
-
 /*
  * The file descriptor fd is considered ``interactive'' if either
  *   a) isatty(fd) is TRUE, or
@@ -1715,63 +1731,6 @@
 #endif /* USE_STACKCHECK */
 
 
-/* Wrappers around sigaction() or signal(). */
-
-PyOS_sighandler_t
-PyOS_getsig(int sig)
-{
-#ifdef HAVE_SIGACTION
-	struct sigaction context;
-	if (sigaction(sig, NULL, &context) == -1)
-		return SIG_ERR;
-	return context.sa_handler;
-#else
-	PyOS_sighandler_t handler;
-/* Special signal handling for the secure CRT in Visual Studio 2005 */
-#if defined(_MSC_VER) && _MSC_VER >= 1400
-	switch (sig) {
-	/* Only these signals are valid */
-	case SIGINT:
-	case SIGILL:
-	case SIGFPE:
-	case SIGSEGV:
-	case SIGTERM:
-	case SIGBREAK:
-	case SIGABRT:
-		break;
-	/* Don't call signal() with other values or it will assert */
-	default:
-		return SIG_ERR;
-	}
-#endif /* _MSC_VER && _MSC_VER >= 1400 */
-	handler = signal(sig, SIG_IGN);
-	if (handler != SIG_ERR)
-		signal(sig, handler);
-	return handler;
-#endif
-}
-
-PyOS_sighandler_t
-PyOS_setsig(int sig, PyOS_sighandler_t handler)
-{
-#ifdef HAVE_SIGACTION
-	struct sigaction context, ocontext;
-	context.sa_handler = handler;
-	sigemptyset(&context.sa_mask);
-	context.sa_flags = 0;
-	if (sigaction(sig, &context, &ocontext) == -1)
-		return SIG_ERR;
-	return ocontext.sa_handler;
-#else
-	PyOS_sighandler_t oldhandler;
-	oldhandler = signal(sig, handler);
-#ifdef HAVE_SIGINTERRUPT
-	siginterrupt(sig, 1);
-#endif
-	return oldhandler;
-#endif
-}
-
 /* Deprecated C API functions still provided for binary compatiblity */
 
 #undef PyParser_SimpleParseFile
Index: Python/import.c
===================================================================
--- Python/import.c	(revision 58355)
+++ Python/import.c	(working copy)
@@ -14,6 +14,7 @@
 #include "eval.h"
 #include "osdefs.h"
 #include "importdl.h"
+#include "pystate.h"
 
 #ifdef HAVE_FCNTL_H
 #include <fcntl.h>
@@ -242,47 +243,49 @@
 
 #include "pythread.h"
 
+#warning Import locking is all bodged and needs a rewrite
 static PyThread_type_lock import_lock = 0;
-static long import_lock_thread = -1;
+static PyThreadState *import_lock_thread = NULL;
 static int import_lock_level = 0;
 
 static void
 lock_import(void)
 {
-	long me = PyThread_get_thread_ident();
-	if (me == -1)
-		return; /* Too bad */
+	PyThreadState *tstate = PyThreadState_Get();
 	if (import_lock == NULL) {
-		import_lock = PyThread_allocate_lock();
+		import_lock = PyThread_lock_allocate();
 		if (import_lock == NULL)
 			return;  /* Nothing much we can do. */
 	}
-	if (import_lock_thread == me) {
+	if (import_lock_thread == tstate) {
 		import_lock_level++;
 		return;
 	}
-	if (import_lock_thread != -1 || !PyThread_acquire_lock(import_lock, 0))
+	if (import_lock_thread != NULL || !_PyThread_lock_tryacquire(import_lock))
 	{
-		PyThreadState *tstate = PyEval_SaveThread();
-		PyThread_acquire_lock(import_lock, 1);
-		PyEval_RestoreThread(tstate);
+		//PyThreadState *tstate = PyEval_SaveThread();
+		PyState_Suspend();
+		PyThread_lock_acquire(import_lock);
+		/* XXX This should be replaced with a "large lock" with deadlock detection */
+		//PyEval_RestoreThread(tstate);
+		PyState_Resume();
 	}
-	import_lock_thread = me;
+	import_lock_thread = tstate;
 	import_lock_level = 1;
 }
 
 static int
 unlock_import(void)
 {
-	long me = PyThread_get_thread_ident();
-	if (me == -1 || import_lock == NULL)
+	PyThreadState *tstate = PyThreadState_Get();
+	if (import_lock == NULL)
 		return 0; /* Too bad */
-	if (import_lock_thread != me)
+	if (import_lock_thread != tstate)
 		return -1;
 	import_lock_level--;
 	if (import_lock_level == 0) {
-		import_lock_thread = -1;
-		PyThread_release_lock(import_lock);
+		import_lock_thread = NULL;
+		PyThread_lock_release(import_lock);
 	}
 	return 1;
 }
@@ -295,7 +298,7 @@
 {
 #ifdef _AIX
 	if (import_lock != NULL)
-		import_lock = PyThread_allocate_lock();
+		import_lock = PyThread_lock_allocate();
 #endif
 }
 
@@ -310,7 +313,7 @@
 imp_lock_held(PyObject *self, PyObject *noargs)
 {
 #ifdef WITH_THREAD
-	return PyBool_FromLong(import_lock_thread != -1);
+	return PyBool_FromLong(import_lock_thread != NULL);
 #else
 	return PyBool_FromLong(0);
 #endif
@@ -353,7 +356,7 @@
 PyObject *
 PyImport_GetModuleDict(void)
 {
-	PyInterpreterState *interp = PyThreadState_GET()->interp;
+	PyInterpreterState *interp = PyThreadState_Get()->interp;
 	if (interp->modules == NULL)
 		Py_FatalError("PyImport_GetModuleDict: no module dictionary!");
 	return interp->modules;
@@ -384,7 +387,7 @@
 	Py_ssize_t pos, ndone;
 	char *name;
 	PyObject *key, *value, *dict;
-	PyInterpreterState *interp = PyThreadState_GET()->interp;
+	PyInterpreterState *interp = PyThreadState_Get()->interp;
 	PyObject *modules = interp->modules;
 
 	if (modules == NULL)
@@ -452,7 +455,7 @@
 		ndone = 0;
 		pos = 0;
 		while (PyDict_Next(modules, &pos, &key, &value)) {
-			if (value->ob_refcnt != 1)
+			if (!Py_RefcntMatches(value, 1))
 				continue;
 			if (PyUnicode_Check(key) && PyModule_Check(value)) {
 				name = PyUnicode_AsString(key);
@@ -589,13 +592,19 @@
 PyObject *
 PyImport_AddModule(const char *name)
 {
+	return PyImport_AddModuleEx(name, 0);
+}
+
+PyObject *
+PyImport_AddModuleEx(const char *name, int shared)
+{
 	PyObject *modules = PyImport_GetModuleDict();
 	PyObject *m;
 
 	if ((m = PyDict_GetItemString(modules, name)) != NULL &&
 	    PyModule_Check(m))
 		return m;
-	m = PyModule_New(name);
+	m = PyModule_NewEx(name, shared);
 	if (m == NULL)
 		return NULL;
 	if (PyDict_SetItemString(modules, name, m) != 0) {
@@ -636,19 +645,31 @@
 PyImport_ExecCodeModuleEx(char *name, PyObject *co, char *pathname)
 {
 	PyObject *modules = PyImport_GetModuleDict();
-	PyObject *m, *d, *v;
+	PyObject *m, *d, *v, *tmp;
+	int shared = 0;
 
-	m = PyImport_AddModule(name);
-	if (m == NULL)
+	PyState_EnterImport(); /* XXX should probably be done earlier */
+	if (((PyCodeObject *)co)->co_flags & CO_FUTURE_SHARED_MODULE)
+		shared = 1;
+
+	m = PyImport_AddModuleEx(name, shared);
+	if (m == NULL) {
+		PyState_ExitImport();
 		return NULL;
+	}
+
 	/* If the module is being reloaded, we get the old module back
 	   and re-use its dict to exec the new code. */
 	d = PyModule_GetDict(m);
-	if (PyDict_GetItemString(d, "__builtins__") == NULL) {
+	if (PyDict_GetItemStringEx(d, "__builtins__", &tmp) < 0)
+		goto error;
+	if (tmp == NULL) {
 		if (PyDict_SetItemString(d, "__builtins__",
 					 PyEval_GetBuiltins()) != 0)
 			goto error;
-	}
+	} else
+		Py_DECREF(tmp);
+
 	/* Remember the filename as the __file__ attribute */
 	v = NULL;
 	if (pathname != NULL) {
@@ -673,15 +694,18 @@
 		PyErr_Format(PyExc_ImportError,
 			     "Loaded module %.200s not found in sys.modules",
 			     name);
+		PyState_ExitImport();
 		return NULL;
 	}
 
 	Py_INCREF(m);
 
+	PyState_ExitImport();
 	return m;
 
   error:
 	_RemoveModule(name);
+	PyState_ExitImport();
 	return NULL;
 }
 
@@ -2975,7 +2999,6 @@
 	0,                         /* tp_descr_set */
 	0,                         /* tp_dictoffset */
 	(initproc)NullImporter_init,      /* tp_init */
-	0,                         /* tp_alloc */
 	PyType_GenericNew          /* tp_new */
 };
 
Index: Python/symtable.c
===================================================================
--- Python/symtable.c	(revision 58355)
+++ Python/symtable.c	(working copy)
@@ -33,8 +33,9 @@
 	k = PyLong_FromVoidPtr(key);
 	if (k == NULL)
 		goto fail;
-	ste = (PySTEntryObject *)PyObject_New(PySTEntryObject,
-					      &PySTEntry_Type);
+	ste = PyObject_NEW(PySTEntryObject, &PySTEntry_Type);
+	if (ste == NULL)
+		Py_FatalError("Allocation failed in PySTEntry_New");
 	ste->ste_table = st;
 	ste->ste_id = k;
 	ste->ste_tmpname = 0;
@@ -102,7 +103,7 @@
 	Py_XDECREF(ste->ste_symbols);
 	Py_XDECREF(ste->ste_varnames);
 	Py_XDECREF(ste->ste_children);
-	PyObject_Del(ste);
+	PyObject_DEL(ste);
 }
 
 #define OFF(x) offsetof(PySTEntryObject, x)
@@ -155,7 +156,6 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	0,					/* tp_new */
 };
 
Index: Python/marshal.c
===================================================================
--- Python/marshal.c	(revision 58355)
+++ Python/marshal.c	(working copy)
@@ -231,7 +231,7 @@
 	}
 #endif
 	else if (PyString_Check(v)) {
-		if (p->strings && PyString_CHECK_INTERNED(v)) {
+		if (p->strings && _PyString_SnoopState((PyStringObject *)v)) {
 			PyObject *o = PyDict_GetItem(p->strings, v);
 			if (o) {
 				long w = PyInt_AsLong(o);
Index: Python/thread.c
===================================================================
--- Python/thread.c	(revision 58355)
+++ Python/thread.c	(working copy)
@@ -202,7 +202,7 @@
 While some of these functions have error-return values, none set any
 Python exception.
 
-None of the functions does memory management on behalf of the void* values.
+None of the functions do memory management on behalf of the void* values.
 You need to allocate and deallocate them yourself.  If the void* values
 happen to be PyObject*, these functions don't do refcount operations on
 them either.
@@ -265,7 +265,7 @@
 
 	if (!keymutex)
 		return NULL;
-	PyThread_acquire_lock(keymutex, 1);
+	PyThread_lock_acquire(keymutex);
 	for (p = keyhead; p != NULL; p = p->next) {
 		if (p->id == id && p->key == key)
 			goto Done;
@@ -283,7 +283,7 @@
 		keyhead = p;
 	}
  Done:
-	PyThread_release_lock(keymutex);
+	PyThread_lock_release(keymutex);
 	return p;
 }
 
@@ -298,7 +298,7 @@
 	 * threads simultaneously.
 	 */
 	if (keymutex == NULL)
-		keymutex = PyThread_allocate_lock();
+		keymutex = PyThread_lock_allocate();
 	return ++nkeys;
 }
 
@@ -308,7 +308,7 @@
 {
 	struct key *p, **q;
 
-	PyThread_acquire_lock(keymutex, 1);
+	PyThread_lock_acquire(keymutex);
 	q = &keyhead;
 	while ((p = *q) != NULL) {
 		if (p->key == key) {
@@ -319,7 +319,7 @@
 		else
 			q = &p->next;
 	}
-	PyThread_release_lock(keymutex);
+	PyThread_lock_release(keymutex);
 }
 
 /* Confusing:  If the current thread has an association for key,
@@ -362,7 +362,7 @@
 	long id = PyThread_get_thread_ident();
 	struct key *p, **q;
 
-	PyThread_acquire_lock(keymutex, 1);
+	PyThread_lock_acquire(keymutex);
 	q = &keyhead;
 	while ((p = *q) != NULL) {
 		if (p->key == key && p->id == id) {
@@ -374,7 +374,7 @@
 		else
 			q = &p->next;
 	}
-	PyThread_release_lock(keymutex);
+	PyThread_lock_release(keymutex);
 }
 
 #endif /* Py_HAVE_NATIVE_TLS */
Index: Python/future.c
===================================================================
--- Python/future.c	(revision 58355)
+++ Python/future.c	(working copy)
@@ -33,6 +33,8 @@
 			continue;
 		} else if (strcmp(feature, FUTURE_WITH_STATEMENT) == 0) {
 			continue;
+		} else if (strcmp(feature, FUTURE_SHARED_MODULE) == 0) {
+			ff->ff_features |= CO_FUTURE_SHARED_MODULE;
 		} else if (strcmp(feature, "braces") == 0) {
 			PyErr_SetString(PyExc_SyntaxError,
 					"not a chance");
Index: Python/dynload_shlib.c
===================================================================
--- Python/dynload_shlib.c	(revision 58355)
+++ Python/dynload_shlib.c	(working copy)
@@ -109,7 +109,7 @@
 	}
 
 #if !(defined(PYOS_OS2) && defined(PYCC_GCC))
-        dlopenflags = PyThreadState_GET()->interp->dlopenflags;
+        dlopenflags = PyThreadState_Get()->interp->dlopenflags;
 #endif
 
 	if (Py_VerboseFlag)
Index: Python/modsupport.c
===================================================================
--- Python/modsupport.c	(revision 58355)
+++ Python/modsupport.c	(working copy)
@@ -32,6 +32,14 @@
 Py_InitModule4(const char *name, PyMethodDef *methods, const char *doc,
 	       PyObject *passthrough, int module_api_version)
 {
+	return Py_InitModule5(name, methods, doc, passthrough,
+		module_api_version, 0);
+}
+
+PyObject *
+Py_InitModule5(const char *name, PyMethodDef *methods, const char *doc,
+	       PyObject *passthrough, int module_api_version, int shared)
+{
 	PyObject *m, *d, *v, *n;
 	PyMethodDef *ml;
 	if (!Py_IsInitialized())
@@ -61,7 +69,7 @@
 			_Py_PackageContext = NULL;
 		}
 	}
-	if ((m = PyImport_AddModule(name)) == NULL)
+	if ((m = PyImport_AddModuleEx(name, shared)) == NULL)
 		return NULL;
 	d = PyModule_GetDict(m);
 	if (methods != NULL) {
Index: Python/bltinmodule.c
===================================================================
--- Python/bltinmodule.c	(revision 58355)
+++ Python/bltinmodule.c	(working copy)
@@ -8,6 +8,9 @@
 
 #include <ctype.h>
 
+#include "monitorobject.h"
+#include "branchobject.h"
+
 /* The default encoding used by the platform file system APIs
    Can remain NULL for all platforms that don't have such a concept
 */
@@ -140,12 +143,16 @@
 	PyObject *locals = NULL;
 	PyObject *fromlist = NULL;
 	int level = -1;
+	PyObject *r;
 
 	if (!PyArg_ParseTupleAndKeywords(args, kwds, "s|OOOi:__import__",
 			kwlist, &name, &globals, &locals, &fromlist, &level))
 		return NULL;
-	return PyImport_ImportModuleLevel(name, globals, locals,
+	PyState_EnterImport();
+	r = PyImport_ImportModuleLevel(name, globals, locals,
 					  fromlist, level);
+	PyState_ExitImport();
+	return r;
 }
 
 PyDoc_STRVAR(import_doc,
@@ -287,7 +294,7 @@
 
         /* Initialize cached value */
         if (format_str == NULL) {
-                /* Initialize static variable needed by _PyType_Lookup */
+                /* Initialize static variable needed by _PyType_LookupEx */
                 format_str = PyUnicode_FromString("__format__");
                 if (format_str == NULL)
                         goto done;
@@ -307,8 +314,9 @@
                 if (PyType_Ready(Py_Type(value)) < 0)
                         goto done;
 
-        /* Find the (unbound!) __format__ method (a borrowed reference) */
-        meth = _PyType_Lookup(Py_Type(value), format_str);
+        /* Find the (unbound!) __format__ method */
+        if (_PyType_LookupEx(Py_Type(value), format_str, &meth) < 0)
+                goto done;
         if (meth == NULL) {
                 PyErr_Format(PyExc_TypeError,
                              "Type %.100s doesn't define __format__",
@@ -318,6 +326,7 @@
 
         /* And call it, binding it to the value */
         result = PyObject_CallFunctionObjArgs(meth, value, spec, NULL);
+        Py_DECREF(meth);
 
         if (result && !PyUnicode_Check(result)) {
                 PyErr_SetString(PyExc_TypeError,
@@ -1418,6 +1427,7 @@
 	int ndigits = UNDEF_NDIGITS;
 	static char *kwlist[] = {"number", "ndigits", 0};
 	PyObject *number, *round;
+	PyObject *result;
 
 	if (!PyArg_ParseTupleAndKeywords(args, kwds, "O|i:round",
                 kwlist, &number, &ndigits))
@@ -1434,7 +1444,8 @@
 			return NULL;
 	}
 
-	round = _PyType_Lookup(Py_Type(number), round_str);
+	if (_PyType_LookupEx(Py_Type(number), round_str, &round) < 0)
+		return NULL;
 	if (round == NULL) {
 		PyErr_Format(PyExc_TypeError,
 			     "type %.100s doesn't define __round__ method",
@@ -1443,9 +1454,11 @@
 	}
 
 	if (ndigits == UNDEF_NDIGITS)
-                return PyObject_CallFunction(round, "O", number);
+		result = PyObject_CallFunction(round, "O", number);
 	else
-                return PyObject_CallFunction(round, "Oi", number, ndigits);
+                result = PyObject_CallFunction(round, "Oi", number, ndigits);
+	Py_DECREF(round);
+	return result;
 #undef UNDEF_NDIGITS
 }
 
@@ -1541,6 +1554,7 @@
 {
 	static PyObject *trunc_str = NULL;
 	PyObject *trunc;
+	PyObject *result;
 
 	if (Py_Type(number)->tp_dict == NULL) {
 		if (PyType_Ready(Py_Type(number)) < 0)
@@ -1553,14 +1567,17 @@
 			return NULL;
 	}
 
-	trunc = _PyType_Lookup(Py_Type(number), trunc_str);
+	if (_PyType_LookupEx(Py_Type(number), trunc_str, &trunc) < 0)
+		return NULL;
 	if (trunc == NULL) {
 		PyErr_Format(PyExc_TypeError,
 			     "type %.100s doesn't define __trunc__ method",
 			     Py_Type(number)->tp_name);
 		return NULL;
 	}
-	return PyObject_CallFunction(trunc, "O", number);
+	result = PyObject_CallFunction(trunc, "O", number);
+	Py_DECREF(trunc);
+	return result;
 }
 
 PyDoc_STRVAR(trunc_doc,
@@ -1700,50 +1717,50 @@
 
 static PyMethodDef builtin_methods[] = {
  	{"__build_class__", (PyCFunction)builtin___build_class__,
-         METH_VARARGS | METH_KEYWORDS, build_class_doc},
- 	{"__import__",	(PyCFunction)builtin___import__, METH_VARARGS | METH_KEYWORDS, import_doc},
- 	{"abs",		builtin_abs,        METH_O, abs_doc},
- 	{"all",		builtin_all,        METH_O, all_doc},
- 	{"any",		builtin_any,        METH_O, any_doc},
-	{"bin",		builtin_bin,	    METH_O, bin_doc},
- 	{"chr",		builtin_chr,        METH_VARARGS, chr_doc},
- 	{"cmp",		builtin_cmp,        METH_VARARGS, cmp_doc},
- 	{"compile",	(PyCFunction)builtin_compile,    METH_VARARGS | METH_KEYWORDS, compile_doc},
- 	{"delattr",	builtin_delattr,    METH_VARARGS, delattr_doc},
- 	{"dir",		builtin_dir,        METH_VARARGS, dir_doc},
- 	{"divmod",	builtin_divmod,     METH_VARARGS, divmod_doc},
- 	{"eval",	builtin_eval,       METH_VARARGS, eval_doc},
-	{"exec",        builtin_exec,       METH_VARARGS, exec_doc},
- 	{"filter",	builtin_filter,     METH_VARARGS, filter_doc},
- 	{"format",	builtin_format,     METH_VARARGS, format_doc},
- 	{"getattr",	builtin_getattr,    METH_VARARGS, getattr_doc},
- 	{"globals",	(PyCFunction)builtin_globals,    METH_NOARGS, globals_doc},
- 	{"hasattr",	builtin_hasattr,    METH_VARARGS, hasattr_doc},
- 	{"hash",	builtin_hash,       METH_O, hash_doc},
- 	{"hex",		builtin_hex,        METH_O, hex_doc},
- 	{"id",		builtin_id,         METH_O, id_doc},
- 	{"input",	builtin_input,      METH_VARARGS, input_doc},
- 	{"isinstance",  builtin_isinstance, METH_VARARGS, isinstance_doc},
- 	{"issubclass",  builtin_issubclass, METH_VARARGS, issubclass_doc},
- 	{"iter",	builtin_iter,       METH_VARARGS, iter_doc},
- 	{"len",		builtin_len,        METH_O, len_doc},
- 	{"locals",	(PyCFunction)builtin_locals,     METH_NOARGS, locals_doc},
- 	{"map",		builtin_map,        METH_VARARGS, map_doc},
- 	{"max",		(PyCFunction)builtin_max,        METH_VARARGS | METH_KEYWORDS, max_doc},
- 	{"min",		(PyCFunction)builtin_min,        METH_VARARGS | METH_KEYWORDS, min_doc},
-	{"next",	(PyCFunction)builtin_next,       METH_VARARGS, next_doc},
- 	{"oct",		builtin_oct,        METH_O, oct_doc},
- 	{"ord",		builtin_ord,        METH_O, ord_doc},
- 	{"pow",		builtin_pow,        METH_VARARGS, pow_doc},
- 	{"print",	(PyCFunction)builtin_print,      METH_VARARGS | METH_KEYWORDS, print_doc},
- 	{"repr",	builtin_repr,       METH_O, repr_doc},
- 	{"round",	(PyCFunction)builtin_round,      METH_VARARGS | METH_KEYWORDS, round_doc},
- 	{"setattr",	builtin_setattr,    METH_VARARGS, setattr_doc},
- 	{"sorted",	(PyCFunction)builtin_sorted,     METH_VARARGS | METH_KEYWORDS, sorted_doc},
- 	{"sum",		builtin_sum,        METH_VARARGS, sum_doc},
- 	{"vars",	builtin_vars,       METH_VARARGS, vars_doc},
- 	{"trunc",	builtin_trunc,      METH_O, trunc_doc},
-  	{"zip",         builtin_zip,        METH_VARARGS, zip_doc},
+         METH_SHARED | METH_VARARGS | METH_KEYWORDS, build_class_doc},
+ 	{"__import__",	(PyCFunction)builtin___import__, METH_SHARED | METH_VARARGS | METH_KEYWORDS, import_doc},
+ 	{"abs",		builtin_abs,        METH_SHARED | METH_O, abs_doc},
+ 	{"all",		builtin_all,        METH_SHARED | METH_O, all_doc},
+ 	{"any",		builtin_any,        METH_SHARED | METH_O, any_doc},
+	{"bin",		builtin_bin,	    METH_SHARED | METH_O, bin_doc},
+ 	{"chr",		builtin_chr,        METH_SHARED | METH_VARARGS, chr_doc},
+ 	{"cmp",		builtin_cmp,        METH_SHARED | METH_VARARGS, cmp_doc},
+ 	{"compile",	(PyCFunction)builtin_compile,    METH_SHARED | METH_VARARGS | METH_KEYWORDS, compile_doc},
+ 	{"delattr",	builtin_delattr,    METH_SHARED | METH_VARARGS, delattr_doc},
+ 	{"dir",		builtin_dir,        METH_SHARED | METH_VARARGS, dir_doc},
+ 	{"divmod",	builtin_divmod,     METH_SHARED | METH_VARARGS, divmod_doc},
+ 	{"eval",	builtin_eval,       METH_SHARED | METH_VARARGS, eval_doc},
+	{"exec",        builtin_exec,       METH_SHARED | METH_VARARGS, exec_doc},
+ 	{"filter",	builtin_filter,     METH_SHARED | METH_VARARGS, filter_doc},
+ 	{"format",	builtin_format,     METH_SHARED | METH_VARARGS, format_doc},
+ 	{"getattr",	builtin_getattr,    METH_SHARED | METH_VARARGS, getattr_doc},
+ 	{"globals",	(PyCFunction)builtin_globals,    METH_SHARED | METH_NOARGS, globals_doc},
+ 	{"hasattr",	builtin_hasattr,    METH_SHARED | METH_VARARGS, hasattr_doc},
+ 	{"hash",	builtin_hash,       METH_SHARED | METH_O, hash_doc},
+ 	{"hex",		builtin_hex,        METH_SHARED | METH_O, hex_doc},
+ 	{"id",		builtin_id,         METH_SHARED | METH_O, id_doc},
+ 	{"input",	builtin_input,      METH_SHARED | METH_VARARGS, input_doc},
+ 	{"isinstance",  builtin_isinstance, METH_SHARED | METH_VARARGS, isinstance_doc},
+ 	{"issubclass",  builtin_issubclass, METH_SHARED | METH_VARARGS, issubclass_doc},
+ 	{"iter",	builtin_iter,       METH_SHARED | METH_VARARGS, iter_doc},
+ 	{"len",		builtin_len,        METH_SHARED | METH_O, len_doc},
+ 	{"locals",	(PyCFunction)builtin_locals,     METH_SHARED | METH_NOARGS, locals_doc},
+ 	{"map",		builtin_map,        METH_SHARED | METH_VARARGS, map_doc},
+ 	{"max",		(PyCFunction)builtin_max,        METH_SHARED | METH_VARARGS | METH_KEYWORDS, max_doc},
+ 	{"min",		(PyCFunction)builtin_min,        METH_SHARED | METH_VARARGS | METH_KEYWORDS, min_doc},
+	{"next",	(PyCFunction)builtin_next,       METH_SHARED | METH_VARARGS, next_doc},
+ 	{"oct",		builtin_oct,        METH_SHARED | METH_O, oct_doc},
+ 	{"ord",		builtin_ord,        METH_SHARED | METH_O, ord_doc},
+ 	{"pow",		builtin_pow,        METH_SHARED | METH_VARARGS, pow_doc},
+ 	{"print",	(PyCFunction)builtin_print,      METH_SHARED | METH_VARARGS | METH_KEYWORDS, print_doc},
+ 	{"repr",	builtin_repr,       METH_SHARED | METH_O, repr_doc},
+ 	{"round",	(PyCFunction)builtin_round,      METH_SHARED | METH_VARARGS | METH_KEYWORDS, round_doc},
+ 	{"setattr",	builtin_setattr,    METH_SHARED | METH_VARARGS, setattr_doc},
+ 	{"sorted",	(PyCFunction)builtin_sorted,     METH_SHARED | METH_VARARGS | METH_KEYWORDS, sorted_doc},
+ 	{"sum",		builtin_sum,        METH_SHARED | METH_VARARGS, sum_doc},
+ 	{"vars",	builtin_vars,       METH_SHARED | METH_VARARGS, vars_doc},
+ 	{"trunc",	builtin_trunc,      METH_SHARED | METH_O, trunc_doc},
+  	{"zip",         builtin_zip,        METH_SHARED | METH_VARARGS, zip_doc},
 	{NULL,		NULL},
 };
 
@@ -1752,15 +1769,19 @@
 \n\
 Noteworthy: None is the `nil' object; Ellipsis represents `...' in slices.");
 
+extern PyTypeObject PyFakeRange_Type;
 PyObject *
 _PyBuiltin_Init(void)
 {
 	PyObject *mod, *dict, *debug;
-	mod = Py_InitModule4("__builtin__", builtin_methods,
+
+	PyState_EnterImport();
+
+	mod = Py_InitModule5("__builtin__", builtin_methods,
 			     builtin_doc, (PyObject *)NULL,
-			     PYTHON_API_VERSION);
+			     PYTHON_API_VERSION, 1);
 	if (mod == NULL)
-		return NULL;
+		goto error;
 	dict = PyModule_GetDict(mod);
 
 #ifdef Py_TRACE_REFS
@@ -1777,7 +1798,7 @@
 
 #define SETBUILTIN(NAME, OBJECT) \
 	if (PyDict_SetItemString(dict, NAME, (PyObject *)OBJECT) < 0)	\
-		return NULL;						\
+		goto error;						\
 	ADD_TO_ALL(OBJECT)
 
 	SETBUILTIN("None",		Py_None);
@@ -1795,6 +1816,7 @@
 	SETBUILTIN("complex",		&PyComplex_Type);
 #endif
 	SETBUILTIN("dict",		&PyDict_Type);
+	SETBUILTIN("shareddict",	&PySharedDict_Type);
  	SETBUILTIN("enumerate",		&PyEnum_Type);
 	SETBUILTIN("float",		&PyFloat_Type);
 	SETBUILTIN("frozenset",		&PyFrozenSet_Type);
@@ -1803,6 +1825,7 @@
 	SETBUILTIN("list",		&PyList_Type);
 	SETBUILTIN("object",		&PyBaseObject_Type);
 	SETBUILTIN("range",		&PyRange_Type);
+	SETBUILTIN("fakerange",		&PyFakeRange_Type);
 	SETBUILTIN("reversed",		&PyReversed_Type);
 	SETBUILTIN("set",		&PySet_Type);
 	SETBUILTIN("slice",		&PySlice_Type);
@@ -1815,11 +1838,57 @@
 	debug = PyBool_FromLong(Py_OptimizeFlag == 0);
 	if (PyDict_SetItemString(dict, "__debug__", debug) < 0) {
 		Py_XDECREF(debug);
-		return NULL;
+		goto error;
 	}
 	Py_XDECREF(debug);
 
+	/* initialize builtin exceptions */
+	_PyExc_Init();
+
+	PyState_ExitImport();
 	return mod;
+
+error:
+	PyState_ExitImport();
+	return NULL;
 #undef ADD_TO_ALL
 #undef SETBUILTIN
 }
+
+
+/* Doesn't really belong here, but oh well */
+PyDoc_STRVAR(module_doc,
+"This is a template module just for instruction.");
+
+PyMODINIT_FUNC
+_Py_ThreadTools_Init(void)
+{
+	PyObject *mod, *dict;
+
+	mod = Py_InitModule3("_threadtools", NULL, module_doc);
+	if (mod == NULL)
+		return;
+
+	dict = PyModule_GetDict(mod);
+
+#ifdef Py_TRACE_REFS
+#define ADD_TO_ALL(OBJECT) _Py_AddToAllObjects((PyObject *)(OBJECT), 0)
+#else
+#define ADD_TO_ALL(OBJECT) (void)0
+#endif
+
+#define SETBUILTIN(NAME, OBJECT) \
+	if (PyDict_SetItemString(dict, NAME, (PyObject *)OBJECT) < 0)	\
+		goto error;						\
+	ADD_TO_ALL(OBJECT)
+
+	SETBUILTIN("MonitorMeta",	&PyMonitorMeta_Type);
+	SETBUILTIN("Monitor",		&PyMonitor_Type);
+	SETBUILTIN("MonitorSpace",	&PyMonitorSpace_Type);
+	SETBUILTIN("branch",		&PyBranch_Type);
+
+error:
+	;
+#undef ADD_TO_ALL
+#undef SETBUILTIN
+}
Index: Python/sysmodule.c
===================================================================
--- Python/sysmodule.c	(revision 58355)
+++ Python/sysmodule.c	(working copy)
@@ -48,7 +48,7 @@
 PyObject *
 PySys_GetObject(const char *name)
 {
-	PyThreadState *tstate = PyThreadState_GET();
+	PyThreadState *tstate = PyThreadState_Get();
 	PyObject *sd = tstate->interp->sysdict;
 	if (sd == NULL)
 		return NULL;
@@ -58,7 +58,7 @@
 int
 PySys_SetObject(const char *name, PyObject *v)
 {
-	PyThreadState *tstate = PyThreadState_GET();
+	PyThreadState *tstate = PyThreadState_Get();
 	PyObject *sd = tstate->interp->sysdict;
 	if (v == NULL) {
 		if (PyDict_GetItemString(sd, name) == NULL)
@@ -74,10 +74,13 @@
 sys_displayhook(PyObject *self, PyObject *o)
 {
 	PyObject *outf;
-	PyInterpreterState *interp = PyThreadState_GET()->interp;
+	PyInterpreterState *interp = PyThreadState_Get()->interp;
 	PyObject *modules = interp->modules;
-	PyObject *builtins = PyDict_GetItemString(modules, "__builtin__");
+	PyObject *builtins;
 
+	if (PyDict_GetItemStringEx(modules, "__builtin__", &builtins) < 0)
+		return NULL;
+
 	if (builtins == NULL) {
 		PyErr_SetString(PyExc_RuntimeError, "lost __builtin__");
 		return NULL;
@@ -87,24 +90,32 @@
 	/* After printing, also assign to '_' */
 	/* Before, set '_' to None to avoid recursion */
 	if (o == Py_None) {
+		Py_DECREF(builtins);
 		Py_INCREF(Py_None);
 		return Py_None;
 	}
 	if (PyObject_SetAttrString(builtins, "_", Py_None) != 0)
-		return NULL;
+		goto failed;
 	outf = PySys_GetObject("stdout");
 	if (outf == NULL) {
 		PyErr_SetString(PyExc_RuntimeError, "lost sys.stdout");
-		return NULL;
+		goto failed;
 	}
 	if (PyFile_WriteObject(o, outf, 0) != 0)
-		return NULL;
+		goto failed;
 	if (PyFile_WriteString("\n", outf) != 0)
-		return NULL;
-	if (PyObject_SetAttrString(builtins, "_", o) != 0)
-		return NULL;
+		goto failed;
+	/* XXX FIXME this'll fail if o isn't shareable */
+#warning XXX FIXME displayhook
+	//if (PyObject_SetAttrString(builtins, "_", o) != 0)
+	//	goto failed;
+	Py_DECREF(builtins);
 	Py_INCREF(Py_None);
 	return Py_None;
+
+failed:
+	Py_DECREF(builtins);
+	return NULL;
 }
 
 PyDoc_STRVAR(displayhook_doc,
@@ -134,7 +145,7 @@
 sys_exc_info(PyObject *self, PyObject *noargs)
 {
 	PyThreadState *tstate;
-	tstate = PyThreadState_GET();
+	tstate = PyThreadState_Get();
 	return Py_BuildValue(
 		"(OOO)",
 		tstate->exc_type != NULL ? tstate->exc_type : Py_None,
@@ -526,7 +537,7 @@
 sys_setdlopenflags(PyObject *self, PyObject *args)
 {
 	int new_val;
-        PyThreadState *tstate = PyThreadState_GET();
+        PyThreadState *tstate = PyThreadState_Get();
 	if (!PyArg_ParseTuple(args, "i:setdlopenflags", &new_val))
 		return NULL;
         if (!tstate)
@@ -549,7 +560,7 @@
 static PyObject *
 sys_getdlopenflags(PyObject *self, PyObject *args)
 {
-        PyThreadState *tstate = PyThreadState_GET();
+        PyThreadState *tstate = PyThreadState_Get();
         if (!tstate)
 		return NULL;
         return PyInt_FromLong(tstate->interp->dlopenflags);
@@ -582,7 +593,7 @@
 static PyObject *
 sys_getrefcount(PyObject *self, PyObject *arg)
 {
-	return PyInt_FromSsize_t(arg->ob_refcnt);
+	return PyInt_FromSsize_t(Py_RefcntSnoop(arg));
 }
 
 #ifdef Py_REF_DEBUG
@@ -626,7 +637,7 @@
 static PyObject *
 sys_getframe(PyObject *self, PyObject *args)
 {
-	PyFrameObject *f = PyThreadState_GET()->frame;
+	PyFrameObject *f = PyThreadState_Get()->frame;
 	int depth = -1;
 
 	if (!PyArg_ParseTuple(args, "|i:_getframe", &depth))
@@ -700,6 +711,33 @@
 10. Number of stack pops performed by call_function()"
 );
 
+static PyObject *
+sys_runfinalizers(PyObject *self, PyObject *queue)
+{
+    PyObject *core, *res;
+
+    while (1) {
+        core = PyObject_CallMethod(queue, "pop", "");
+        if (core == NULL)
+            return NULL;
+        if (core == Py_None)
+            return Py_None;  /* Just steal the reference that was core */
+        res = PyObject_CallMethod(core, "__finalize__", "");
+        Py_DECREF(core);
+        if (res == NULL)
+            return NULL;
+        Py_DECREF(res);
+    }
+}
+
+PyDoc_STRVAR(runfinalizers_doc,
+"_runfinalizers(queue)\n\
+\n\
+Run all __finalize__ methods of objects returned by queue.pop(),\n\
+blocking if none are available.  Returns if an exception is thrown or\n\
+if queue.pop() produces None."
+);
+
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -760,6 +798,7 @@
 #ifdef USE_MALLOPT
 	{"mdebug",	sys_mdebug, METH_VARARGS},
 #endif
+	{"_runfinalizers", sys_runfinalizers, METH_O | METH_SHARED, runfinalizers_doc},
 	{"setdefaultencoding", sys_setdefaultencoding, METH_VARARGS,
 	 setdefaultencoding_doc},
 	{"setcheckinterval",	sys_setcheckinterval, METH_VARARGS,
Index: configure
===================================================================
--- configure	(revision 58355)
+++ configure	(working copy)
@@ -1,5 +1,5 @@
 #! /bin/sh
-# From configure.in Revision: 57931 .
+# From configure.in Revision: 58054 .
 # Guess values for system-dependent variables and create Makefiles.
 # Generated by GNU Autoconf 2.61 for python 3.0.
 #
@@ -1346,6 +1346,7 @@
   --with(out)-tsc         enable/disable timestamp counter profile
   --with(out)-pymalloc    disable/enable specialized mallocs
   --with-wctype-functions use wctype.h functions
+  --with-freethread       enable free threading
   --with-fpectl           enable SIGFPE catching
   --with-libm=STRING      math library
   --with-libc=STRING      C library
@@ -14606,6 +14607,31 @@
 fi
 
 
+# Check for --with-freethread
+{ echo "$as_me:$LINENO: checking for --with-freethread" >&5
+echo $ECHO_N "checking for --with-freethread... $ECHO_C" >&6; }
+
+# Check whether --with-freethread was given.
+if test "${with_freethread+set}" = set; then
+  withval=$with_freethread;
+if test "$withval" != no
+then
+
+cat >>confdefs.h <<\_ACEOF
+#define WITH_FREETHREAD 1
+_ACEOF
+
+  { echo "$as_me:$LINENO: result: yes" >&5
+echo "${ECHO_T}yes" >&6; };
+else { echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6; };
+fi
+else
+  { echo "$as_me:$LINENO: result: no" >&5
+echo "${ECHO_T}no" >&6; }
+fi
+
+
 # -I${DLINCLDIR} is added to the compile rule for importdl.o
 
 DLINCLDIR=.
Index: LICENSE
===================================================================
--- LICENSE	(revision 58355)
+++ LICENSE	(working copy)
@@ -1,3 +1,7 @@
+The python-safethread patch is licensed under the Apache License, version 2.0.  Obviously the rest of Python is under its own license (or licenses.)
+
+~~~~~~~~~~
+
 A. HISTORY OF THE SOFTWARE
 ==========================
 
Index: Include/datetime.h
===================================================================
--- Include/datetime.h	(revision 58355)
+++ Include/datetime.h	(working copy)
@@ -76,13 +76,8 @@
 typedef struct
 {
 	_PyDateTime_TIMEHEAD
-} _PyDateTime_BaseTime;		/* hastzinfo false */
-
-typedef struct
-{
-	_PyDateTime_TIMEHEAD
 	PyObject *tzinfo;
-} PyDateTime_Time;		/* hastzinfo true */
+} PyDateTime_Time;
 
 
 /* All datetime objects are of PyDateTime_DateTimeType, but that can be
@@ -103,13 +98,8 @@
 typedef struct
 {
 	_PyDateTime_DATETIMEHEAD
-} _PyDateTime_BaseDateTime;	/* hastzinfo false */
-
-typedef struct
-{
-	_PyDateTime_DATETIMEHEAD
 	PyObject *tzinfo;
-} PyDateTime_DateTime;		/* hastzinfo true */
+} PyDateTime_DateTime;
 
 
 /* Apply for date and datetime instances. */
Index: Include/stringobject.h
===================================================================
--- Include/stringobject.h	(revision 58355)
+++ Include/stringobject.h	(working copy)
@@ -35,7 +35,7 @@
 typedef struct {
     PyObject_VAR_HEAD
     long ob_shash;
-    int ob_sstate;
+    AO_t ob_sstate;
     char ob_sval[1];
 
     /* Invariants:
@@ -76,12 +76,10 @@
 						   const char *);
 
 PyAPI_FUNC(void) PyString_InternInPlace(PyObject **);
-PyAPI_FUNC(void) PyString_InternImmortal(PyObject **);
 PyAPI_FUNC(PyObject *) PyString_InternFromString(const char *);
 PyAPI_FUNC(void) _Py_ReleaseInternedStrings(void);
 
-/* Use only if you know it's a string */
-#define PyString_CHECK_INTERNED(op) (((PyStringObject *)(op))->ob_sstate)
+PyAPI_FUNC(int) _PyString_SnoopState(PyStringObject *op);
 
 /* Macro, trading safety for speed */
 #define PyString_AS_STRING(op) (assert(PyString_Check(op)),(((PyStringObject *)(op))->ob_sval))
Index: Include/dictobject.h
===================================================================
--- Include/dictobject.h	(revision 58355)
+++ Include/dictobject.h	(working copy)
@@ -67,6 +67,7 @@
 it's two-thirds full.
 */
 typedef struct _dictobject PyDictObject;
+typedef struct _pydict_lockstate PyDict_LockState;
 struct _dictobject {
 	PyObject_HEAD
 	Py_ssize_t ma_fill;  /* # Active + # Dummy */
@@ -78,24 +79,50 @@
 	 */
 	Py_ssize_t ma_mask;
 
+	/* Counter for number of times ma_table has been reallocated and
+	 * rebuilt.  Used to detect changes during a lookup.
+	 *
+	 * It's theoretically possible for this to wrap around completely
+	 * during one lookup, causing it to not restart.  Using a 64bit
+	 * counter would be the safest defense against this, but for now
+	 * we'll just be lazy.
+	 */
+	unsigned long long ma_rebuilds;
+
 	/* ma_table points to ma_smalltable for small tables, else to
 	 * additional malloc'ed memory.  ma_table is never NULL!  This rule
 	 * saves repeated runtime null-tests in the workhorse getitem and
 	 * setitem calls.
 	 */
 	PyDictEntry *ma_table;
-	PyDictEntry *(*ma_lookup)(PyDictObject *mp, PyObject *key, long hash);
+	PyDictEntry *(*ma_lookup)(PyDictObject *mp, PyObject *key,
+		long hash, PyDict_LockState *lockstate);
 	PyDictEntry ma_smalltable[PyDict_MINSIZE];
 };
 
+typedef struct {
+    PyDictObject base;
+    AO_t readonly_mode;
+    PyCritical *crit;
+    int read_count;
+} PySharedDictObject;
+
+struct _pydict_lockstate {
+    int doing_write;  /* These two flags are mutually incompatible */
+    int skipped_lock;
+};
+
 PyAPI_DATA(PyTypeObject) PyDict_Type;
+PyAPI_DATA(PyTypeObject) PySharedDict_Type;
 
 #define PyDict_Check(op) \
                  PyType_FastSubclass(Py_Type(op), Py_TPFLAGS_DICT_SUBCLASS)
 #define PyDict_CheckExact(op) (Py_Type(op) == &PyDict_Type)
+#define PySharedDict_Check(op) (Py_Type(op) == &PySharedDict_Type)
 
 PyAPI_FUNC(PyObject *) PyDict_New(void);
 PyAPI_FUNC(PyObject *) PyDict_GetItem(PyObject *mp, PyObject *key);
+PyAPI_FUNC(int) PyDict_GetItemEx(PyObject *op, PyObject *key, PyObject **value);
 PyAPI_FUNC(int) PyDict_SetItem(PyObject *mp, PyObject *key, PyObject *item);
 PyAPI_FUNC(int) PyDict_DelItem(PyObject *mp, PyObject *key);
 PyAPI_FUNC(void) PyDict_Clear(PyObject *mp);
@@ -103,6 +130,8 @@
 	PyObject *mp, Py_ssize_t *pos, PyObject **key, PyObject **value);
 PyAPI_FUNC(int) _PyDict_Next(
 	PyObject *mp, Py_ssize_t *pos, PyObject **key, PyObject **value, long *hash);
+PyAPI_FUNC(int) PyDict_NextEx(PyObject *mp, Py_ssize_t *pos,
+    PyObject **key, PyObject **value);
 PyAPI_FUNC(PyObject *) PyDict_Keys(PyObject *mp);
 PyAPI_FUNC(PyObject *) PyDict_Values(PyObject *mp);
 PyAPI_FUNC(PyObject *) PyDict_Items(PyObject *mp);
@@ -133,8 +162,10 @@
 					   int override);
 
 PyAPI_FUNC(PyObject *) PyDict_GetItemString(PyObject *dp, const char *key);
+PyAPI_FUNC(int) PyDict_GetItemStringEx(PyObject *v, const char *key, PyObject **value);
 PyAPI_FUNC(int) PyDict_SetItemString(PyObject *dp, const char *key, PyObject *item);
 PyAPI_FUNC(int) PyDict_DelItemString(PyObject *dp, const char *key);
+PyAPI_FUNC(int) PyDict_ContainsString(PyObject *d, const char *key);
 
 #ifdef __cplusplus
 }
Index: Include/code.h
===================================================================
--- Include/code.h	(revision 58355)
+++ Include/code.h	(working copy)
@@ -49,6 +49,7 @@
 #define CO_FUTURE_ABSOLUTE_IMPORT 0x4000 /* do absolute imports by default */
 #define CO_FUTURE_WITH_STATEMENT  0x8000
 #endif
+#define CO_FUTURE_SHARED_MODULE 0x0800
 
 /* This should be defined if a future statement modifies the syntax.
    For example, when a keyword is added.
Index: Include/unicodeobject.h
===================================================================
--- Include/unicodeobject.h	(revision 58355)
+++ Include/unicodeobject.h	(working copy)
@@ -404,7 +404,7 @@
     Py_ssize_t length;		/* Length of raw Unicode data in buffer */
     Py_UNICODE *str;		/* Raw Unicode buffer */
     long hash;			/* Hash value; -1 if not set */
-    int state;			/* != 0 if interned. In this case the two
+    AO_t state;			/* != 0 if interned. In this case the two
     				 * references from the dictionary to this object
     				 * are *not* counted in ob_refcnt. */
     PyObject *defenc;		/* (Default) Encoded version as Python
@@ -415,8 +415,7 @@
 PyAPI_DATA(PyTypeObject) PyUnicode_Type;
 
 #define SSTATE_NOT_INTERNED 0
-#define SSTATE_INTERNED_MORTAL 1
-#define SSTATE_INTERNED_IMMORTAL 2
+#define SSTATE_INTERNED 1
 
 #define PyUnicode_Check(op) \
                  PyType_FastSubclass(Py_Type(op), Py_TPFLAGS_UNICODE_SUBCLASS)
@@ -551,13 +550,9 @@
 PyAPI_FUNC(PyObject *) PyUnicode_FromFormat(const char*, ...);
 
 PyAPI_FUNC(void) PyUnicode_InternInPlace(PyObject **);
-PyAPI_FUNC(void) PyUnicode_InternImmortal(PyObject **);
 PyAPI_FUNC(PyObject *) PyUnicode_InternFromString(const char *);
 PyAPI_FUNC(void) _Py_ReleaseInternedUnicodeStrings(void);
 
-/* Use only if you know it's a string */
-#define PyUnicode_CHECK_INTERNED(op) (((PyUnicodeObject *)(op))->state)
-
 /* --- wchar_t support for platforms which support it --------------------- */
 
 #ifdef HAVE_WCHAR_H
Index: Include/interruptobject.h
===================================================================
--- Include/interruptobject.h	(revision 0)
+++ Include/interruptobject.h	(revision 0)
@@ -0,0 +1,57 @@
+/* Interrupt Object */
+
+#ifndef Py_INTERRUPTOBJECT_H
+#define Py_INTERRUPTOBJECT_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "pythread.h"
+
+
+struct _PyInterruptQueue;
+
+typedef struct _PyInterruptObject {
+	PyObject_HEAD
+	PyThread_type_lock lock;
+	int interrupted;
+	struct _PyInterruptObject *parent;
+	struct _PyInterruptObject *child;
+
+	/* Either the C or the Python version will be set, but not both */
+	void (*notify_parent_int_c)(struct _PyInterruptQueue *, void *arg);
+	void *arg;
+	PyObject *notify_parent_int_python;
+
+	/* Used only when notify_parent_int_python is used */
+	struct _PyInterruptObject *next;
+} PyInterruptObject;
+
+typedef struct _PyInterruptQueue {
+	PyInterruptObject *head;
+	PyInterruptObject *tail;
+} PyInterruptQueue;
+
+
+PyAPI_DATA(PyTypeObject) PyInterrupt_Type;
+#define PyInterrupt_Check(op) (Py_Type(op) == &PyInterrupt_Type)
+
+PyAPI_FUNC(PyInterruptObject *) PyInterrupt_New(
+	void (*)(struct _PyInterruptQueue *, void *),
+	void *, PyObject *);
+PyAPI_FUNC(void) PyInterrupt_Push(PyInterruptObject *);
+PyAPI_FUNC(void) PyInterrupt_Pop(PyInterruptObject *);
+
+/* Init and Add will only run C functions, so they can be called while
+ * you hold a lock.  Finish calls any remaining python functions, so it
+ * should be called after you release your lock. */
+PyAPI_FUNC(void) PyInterruptQueue_Init(PyInterruptQueue *);
+PyAPI_FUNC(void) PyInterruptQueue_Add(PyInterruptQueue *, PyInterruptObject *);
+PyAPI_FUNC(void) PyInterruptQueue_AddFromParent(PyInterruptQueue *, PyInterruptObject *);
+PyAPI_FUNC(void) PyInterruptQueue_Finish(PyInterruptQueue *);
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_INTERRUPTOBJECT_H */
Index: Include/ceval.h
===================================================================
--- Include/ceval.h	(revision 58355)
+++ Include/ceval.h	(working copy)
@@ -39,20 +39,17 @@
    flag was set, else return 0. */
 PyAPI_FUNC(int) PyEval_MergeCompilerFlags(PyCompilerFlags *cf);
 
-PyAPI_FUNC(int) Py_AddPendingCall(int (*func)(void *), void *arg);
-PyAPI_FUNC(int) Py_MakePendingCalls(void);
-
 /* Protection against deeply nested recursive calls */
 PyAPI_FUNC(void) Py_SetRecursionLimit(int);
 PyAPI_FUNC(int) Py_GetRecursionLimit(void);
 
 #define Py_EnterRecursiveCall(where)                                    \
-	    (_Py_MakeRecCheck(PyThreadState_GET()->recursion_depth) &&  \
+	    (_Py_MakeRecCheck(PyThreadState_Get()->recursion_depth) &&  \
 	     _Py_CheckRecursiveCall(where))
 #define Py_LeaveRecursiveCall()				\
-    do{ if((--PyThreadState_GET()->recursion_depth) <   \
+    do{ if((--PyThreadState_Get()->recursion_depth) <   \
 	   _Py_CheckRecursionLimit - 50);               \
-	  PyThreadState_GET()->overflowed = 0;          \
+	  PyThreadState_Get()->overflowed = 0;          \
     } while(0)
 PyAPI_FUNC(int) _Py_CheckRecursiveCall(char *where);
 PyAPI_DATA(int) _Py_CheckRecursionLimit;
@@ -63,11 +60,11 @@
 #endif
 
 #define Py_ALLOW_RECURSION \
-  do { unsigned char _old = PyThreadState_GET()->recursion_critical;\
-    PyThreadState_GET()->recursion_critical = 1;
+  do { unsigned char _old = PyThreadState_Get()->recursion_critical;\
+    PyThreadState_Get()->recursion_critical = 1;
 
 #define Py_END_ALLOW_RECURSION \
-    PyThreadState_GET()->recursion_critical = _old; \
+    PyThreadState_Get()->recursion_critical = _old; \
   } while(0);
 
 PyAPI_FUNC(const char *) PyEval_GetFuncName(PyObject *);
@@ -81,84 +78,7 @@
 PyAPI_DATA(volatile int) _Py_Ticker;
 PyAPI_DATA(int) _Py_CheckInterval;
 
-/* Interface for threads.
 
-   A module that plans to do a blocking system call (or something else
-   that lasts a long time and doesn't touch Python data) can allow other
-   threads to run as follows:
-
-	...preparations here...
-	Py_BEGIN_ALLOW_THREADS
-	...blocking system call here...
-	Py_END_ALLOW_THREADS
-	...interpret result here...
-
-   The Py_BEGIN_ALLOW_THREADS/Py_END_ALLOW_THREADS pair expands to a
-   {}-surrounded block.
-   To leave the block in the middle (e.g., with return), you must insert
-   a line containing Py_BLOCK_THREADS before the return, e.g.
-
-	if (...premature_exit...) {
-		Py_BLOCK_THREADS
-		PyErr_SetFromErrno(PyExc_IOError);
-		return NULL;
-	}
-
-   An alternative is:
-
-	Py_BLOCK_THREADS
-	if (...premature_exit...) {
-		PyErr_SetFromErrno(PyExc_IOError);
-		return NULL;
-	}
-	Py_UNBLOCK_THREADS
-
-   For convenience, that the value of 'errno' is restored across
-   Py_END_ALLOW_THREADS and Py_BLOCK_THREADS.
-
-   WARNING: NEVER NEST CALLS TO Py_BEGIN_ALLOW_THREADS AND
-   Py_END_ALLOW_THREADS!!!
-
-   The function PyEval_InitThreads() should be called only from
-   initthread() in "threadmodule.c".
-
-   Note that not yet all candidates have been converted to use this
-   mechanism!
-*/
-
-PyAPI_FUNC(PyThreadState *) PyEval_SaveThread(void);
-PyAPI_FUNC(void) PyEval_RestoreThread(PyThreadState *);
-
-#ifdef WITH_THREAD
-
-PyAPI_FUNC(int)  PyEval_ThreadsInitialized(void);
-PyAPI_FUNC(void) PyEval_InitThreads(void);
-PyAPI_FUNC(void) PyEval_AcquireLock(void);
-PyAPI_FUNC(void) PyEval_ReleaseLock(void);
-PyAPI_FUNC(void) PyEval_AcquireThread(PyThreadState *tstate);
-PyAPI_FUNC(void) PyEval_ReleaseThread(PyThreadState *tstate);
-PyAPI_FUNC(void) PyEval_ReInitThreads(void);
-
-#define Py_BEGIN_ALLOW_THREADS { \
-			PyThreadState *_save; \
-			_save = PyEval_SaveThread();
-#define Py_BLOCK_THREADS	PyEval_RestoreThread(_save);
-#define Py_UNBLOCK_THREADS	_save = PyEval_SaveThread();
-#define Py_END_ALLOW_THREADS	PyEval_RestoreThread(_save); \
-		 }
-
-#else /* !WITH_THREAD */
-
-#define Py_BEGIN_ALLOW_THREADS {
-#define Py_BLOCK_THREADS
-#define Py_UNBLOCK_THREADS
-#define Py_END_ALLOW_THREADS }
-
-#endif /* !WITH_THREAD */
-
-PyAPI_FUNC(int) _PyEval_SliceIndex(PyObject *, Py_ssize_t *);
-
-
 #ifdef __cplusplus
 }
 #endif
Index: Include/objimpl.h
===================================================================
--- Include/objimpl.h	(revision 58355)
+++ Include/objimpl.h	(working copy)
@@ -6,6 +6,7 @@
 #define Py_OBJIMPL_H
 
 #include "pymem.h"
+#include "pythread.h"
 
 #ifdef __cplusplus
 extern "C" {
@@ -94,6 +95,7 @@
    the object gets initialized via PyObject_{Init, InitVar} after obtaining
    the raw memory.
 */
+#if 0
 PyAPI_FUNC(void *) PyObject_Malloc(size_t);
 PyAPI_FUNC(void *) PyObject_Realloc(void *, size_t);
 PyAPI_FUNC(void) PyObject_Free(void *);
@@ -130,6 +132,7 @@
 
 #define PyObject_Del		PyObject_Free
 #define PyObject_DEL		PyObject_FREE
+#endif
 
 /*
  * Generic object allocator interface
@@ -137,23 +140,31 @@
  */
 
 /* Functions */
-PyAPI_FUNC(PyObject *) PyObject_Init(PyObject *, PyTypeObject *);
-PyAPI_FUNC(PyVarObject *) PyObject_InitVar(PyVarObject *,
-                                                 PyTypeObject *, Py_ssize_t);
 PyAPI_FUNC(PyObject *) _PyObject_New(PyTypeObject *);
-PyAPI_FUNC(PyVarObject *) _PyObject_NewVar(PyTypeObject *, Py_ssize_t);
+PyAPI_FUNC(PyObject *) _PyObject_NewVar(PyTypeObject *, Py_ssize_t);
+PyAPI_FUNC(void) _PyObject_Del(PyObject *);
+PyAPI_FUNC(void) _PyObject_Revive(PyObject *);
+PyAPI_FUNC(void) _PyObject_Complete(PyObject *);
+PyAPI_FUNC(PyObject *) _PyObject_Resize(PyObject *, Py_ssize_t);
 
-#define PyObject_New(type, typeobj) \
-		( (type *) _PyObject_New(typeobj) )
-#define PyObject_NewVar(type, typeobj, n) \
-		( (type *) _PyObject_NewVar((typeobj), (n)) )
+#define PyObject_New _PyObject_New
+#define PyObject_NewVar _PyObject_NewVar
+#define PyObject_Del _PyObject_Del
+#define PyObject_Revive _PyObject_Revive
+#define PyObject_Complete _PyObject_Complete
+#define PyObject_Resize _PyObject_Resize
 
-/* Macros trading binary compatibility for speed. See also pymem.h.
-   Note that these macros expect non-NULL object pointers.*/
-#define PyObject_INIT(op, typeobj) \
-	( Py_Type(op) = (typeobj), _Py_NewReference((PyObject *)(op)), (op) )
-#define PyObject_INIT_VAR(op, typeobj, size) \
-	( Py_Size(op) = (size), PyObject_INIT((op), (typeobj)) )
+#define PyObject_NEW(type, typeobj) \
+        ((type *) _PyObject_New(typeobj))
+#define PyObject_NEWVAR(type, typeobj, n) \
+        ((type *) _PyObject_NewVar((typeobj), (n)))
+#define PyObject_DEL(op) (PyObject_Del((PyObject *)(op)))
+#define PyObject_REVIVE(op) \
+        (PyObject_Revive((PyObject *)(op)))
+#define PyObject_COMPLETE(op) \
+        (PyObject_Complete((PyObject *)(op)))
+#define PyObject_RESIZE(type, op, n) \
+        ((type *) PyObject_Resize((PyObject *)(op), (n)))
 
 #define _PyObject_SIZE(typeobj) ( (typeobj)->tp_basicsize )
 
@@ -179,15 +190,6 @@
 	  ) & ~(SIZEOF_VOID_P - 1)		\
 	)
 
-#define PyObject_NEW(type, typeobj) \
-( (type *) PyObject_Init( \
-	(PyObject *) PyObject_MALLOC( _PyObject_SIZE(typeobj) ), (typeobj)) )
-
-#define PyObject_NEW_VAR(type, typeobj, n) \
-( (type *) PyObject_InitVar( \
-      (PyVarObject *) PyObject_MALLOC(_PyObject_VAR_SIZE((typeobj),(n)) ),\
-      (typeobj), (n)) )
-
 /* This example code implements an object constructor with a custom
    allocator, where PyObject_New is inlined, and shows the important
    distinction between two steps (at least):
@@ -231,70 +233,34 @@
 #define PyObject_IS_GC(o) (PyType_IS_GC(Py_Type(o)) && \
 	(Py_Type(o)->tp_is_gc == NULL || Py_Type(o)->tp_is_gc(o)))
 
-PyAPI_FUNC(PyVarObject *) _PyObject_GC_Resize(PyVarObject *, Py_ssize_t);
-#define PyObject_GC_Resize(type, op, n) \
-		( (type *) _PyObject_GC_Resize((PyVarObject *)(op), (n)) )
-
-/* for source compatibility with 2.2 */
-#define _PyObject_GC_Del PyObject_GC_Del
-
+#if 0
 /* GC information is stored BEFORE the object structure. */
 typedef union _gc_head {
 	struct {
+		Py_ssize_t gc_sizeclass;
 		union _gc_head *gc_next;
 		union _gc_head *gc_prev;
 		Py_ssize_t gc_refs;
 	} gc;
 	long double dummy;  /* force worst-case alignment */
 } PyGC_Head;
+#else
+#define PyGC_Head PyObject
+#endif
 
 extern PyGC_Head *_PyGC_generation0;
 
+#if 0
 #define _Py_AS_GC(o) ((PyGC_Head *)(o)-1)
+#endif
 
 #define _PyGC_REFS_UNTRACKED			(-2)
 #define _PyGC_REFS_REACHABLE			(-3)
 #define _PyGC_REFS_TENTATIVELY_UNREACHABLE	(-4)
 
-/* Tell the GC to track this object.  NB: While the object is tracked the
- * collector it must be safe to call the ob_traverse method. */
-#define _PyObject_GC_TRACK(o) do { \
-	PyGC_Head *g = _Py_AS_GC(o); \
-	if (g->gc.gc_refs != _PyGC_REFS_UNTRACKED) \
-		Py_FatalError("GC object already tracked"); \
-	g->gc.gc_refs = _PyGC_REFS_REACHABLE; \
-	g->gc.gc_next = _PyGC_generation0; \
-	g->gc.gc_prev = _PyGC_generation0->gc.gc_prev; \
-	g->gc.gc_prev->gc.gc_next = g; \
-	_PyGC_generation0->gc.gc_prev = g; \
-    } while (0);
+PyAPI_FUNC(void) _PyGC_Object_Cache_Flush(void);
 
-/* Tell the GC to stop tracking this object.
- * gc_next doesn't need to be set to NULL, but doing so is a good
- * way to provoke memory errors if calling code is confused.
- */
-#define _PyObject_GC_UNTRACK(o) do { \
-	PyGC_Head *g = _Py_AS_GC(o); \
-	assert(g->gc.gc_refs != _PyGC_REFS_UNTRACKED); \
-	g->gc.gc_refs = _PyGC_REFS_UNTRACKED; \
-	g->gc.gc_prev->gc.gc_next = g->gc.gc_next; \
-	g->gc.gc_next->gc.gc_prev = g->gc.gc_prev; \
-	g->gc.gc_next = NULL; \
-    } while (0);
 
-PyAPI_FUNC(PyObject *) _PyObject_GC_Malloc(size_t);
-PyAPI_FUNC(PyObject *) _PyObject_GC_New(PyTypeObject *);
-PyAPI_FUNC(PyVarObject *) _PyObject_GC_NewVar(PyTypeObject *, Py_ssize_t);
-PyAPI_FUNC(void) PyObject_GC_Track(void *);
-PyAPI_FUNC(void) PyObject_GC_UnTrack(void *);
-PyAPI_FUNC(void) PyObject_GC_Del(void *);
-
-#define PyObject_GC_New(type, typeobj) \
-		( (type *) _PyObject_GC_New(typeobj) )
-#define PyObject_GC_NewVar(type, typeobj, n) \
-		( (type *) _PyObject_GC_NewVar((typeobj), (n)) )
-
-
 /* Utility macro to help write tp_traverse functions.
  * To use this macro, the tp_traverse function must name its arguments
  * "visit" and "arg".  This is intended to keep tp_traverse functions
@@ -322,9 +288,6 @@
 /* Test if a type supports weak references */
 #define PyType_SUPPORTS_WEAKREFS(t) ((t)->tp_weaklistoffset > 0)
 
-#define PyObject_GET_WEAKREFS_LISTPTR(o) \
-	((PyObject **) (((char *) (o)) + Py_Type(o)->tp_weaklistoffset))
-
 #ifdef __cplusplus
 }
 #endif
Index: Include/moduleobject.h
===================================================================
--- Include/moduleobject.h	(revision 58355)
+++ Include/moduleobject.h	(working copy)
@@ -13,6 +13,7 @@
 #define PyModule_CheckExact(op) (Py_Type(op) == &PyModule_Type)
 
 PyAPI_FUNC(PyObject *) PyModule_New(const char *);
+PyAPI_FUNC(PyObject *) PyModule_NewEx(const char *, int);
 PyAPI_FUNC(PyObject *) PyModule_GetDict(PyObject *);
 PyAPI_FUNC(const char *) PyModule_GetName(PyObject *);
 PyAPI_FUNC(const char *) PyModule_GetFilename(PyObject *);
Index: Include/monitorobject.h
===================================================================
--- Include/monitorobject.h	(revision 0)
+++ Include/monitorobject.h	(revision 0)
@@ -0,0 +1,51 @@
+/* Monitor object and Monitor Space interface */
+
+#ifndef Py_MONITOROBJECT_H
+#define Py_MONITOROBJECT_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "pythread.h"
+
+
+typedef struct {
+	PyObject_HEAD
+	PyObject *mon_monitorspace;  /* The monitorspace that contains us */
+} PyMonitorObject;
+
+typedef struct _PyMonitorSpaceObject {
+	PyObject_HEAD
+	PyThread_type_lock lock;
+	/* XXX FIXME rename struct _ts */
+	struct _ts *lock_holder;
+	struct _ts *first_waiter;
+	struct _ts *last_waiter;
+	/* XXX flag (or counter?) used by PyState_StopTheWorld */
+} PyMonitorSpaceObject;
+
+PyAPI_DATA(PyTypeObject) PyMonitorMeta_Type;
+PyAPI_DATA(PyTypeObject) PyMonitor_Type;
+PyAPI_DATA(PyTypeObject) PyMonitorSpace_Type;
+
+#define PyMonitorMeta_Check(op) PyObject_TypeCheck(op, &PyMonitorMeta_Type)
+#define PyMonitorMeta_CheckExact(op) ((op)->ob_type == &PyMonitorMeta_Type)
+
+#define PyMonitor_Check(op) \
+	PyType_FastSubclass((op)->ob_type, Py_TPFLAGS_MONITOR_SUBCLASS)
+#define PyMonitor_CheckExact(op) ((op)->ob_type == &PyMonitor_Type)
+
+#define PyMonitorSpace_Check(op) PyObject_TypeCheck(op, &PyMonitorSpace_Type)
+#define PyMonitorSpace_CheckExact(op) ((op)->ob_type == &PyMonitorSpace_Type)
+
+#define PyMonitor_GetMonitorSpace(op) \
+	((PyMonitorSpaceObject *)(((PyMonitorObject *)op)->mon_monitorspace))
+
+PyAPI_FUNC(int) PyMonitorSpace_IsCurrent(struct _PyMonitorSpaceObject *);
+PyAPI_FUNC(PyObject *) PyMonitorSpace_GetCurrent(void);
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_MONITOROBJECT_H */
Index: Include/Python.h
===================================================================
--- Include/Python.h	(revision 58355)
+++ Include/Python.h	(working copy)
@@ -107,7 +107,7 @@
 #include "pythonrun.h"
 #include "ceval.h"
 #include "sysmodule.h"
-#include "intrcheck.h"
+#include "pysignal.h"
 #include "import.h"
 
 #include "abstract.h"
Index: Include/branchobject.h
===================================================================
--- Include/branchobject.h	(revision 0)
+++ Include/branchobject.h	(revision 0)
@@ -0,0 +1,66 @@
+/* Branch object */
+
+#ifndef Py_BRANCHOBJECT_H
+#define Py_BRANCHOBJECT_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "pythread.h"
+#include "pystate.h"
+
+
+struct _PyInterruptObject; /* Avoid including interruptobject.h */
+
+struct _PyBranchObject;
+
+typedef struct _PyBranchChild {
+	PyInterpreterState *interp;
+	PyThreadState *tstate;
+	struct _PyInterruptObject *interrupt_point;
+	struct _PyBranchObject *branch;
+	PyObject *func;
+	PyObject *args;
+	PyObject *kwds;
+	int save_result;
+	PyObject *result;
+	PyObject *exception;
+	struct _PyBranchChild *prev;
+	struct _PyBranchChild *next;
+} PyBranchChild;
+
+typedef struct _PyBranchObject {
+	PyObject_HEAD
+	PyThread_type_lock col_lock;
+	int col_state;
+
+	PyObject *col_ownerthread;
+	PyObject *col_threads;
+	PyBranchChild *col_mainthread;
+	PyBranchChild *col_head;
+	PyBranchChild *col_tail;
+	Py_ssize_t col_threadcount;
+	PyThread_type_sem col_nothreads;
+
+	struct _PyInterruptObject *col_baseinterrupt;
+
+	int col_interrupting;
+	Py_ssize_t col_resultcount;
+	Py_ssize_t col_exceptioncount;
+} PyBranchObject;
+
+PyAPI_DATA(PyTypeObject) PyBranch_Type;
+
+#define PyBranch_Check(op) PyObject_TypeCheck(op, &PyBranch_Type)
+#define PyBranch_CheckExact(op) (Py_Type(op) == &PyBranch_Type)
+
+#define BRANCH_NEW	1
+#define BRANCH_ALIVE	2
+#define BRANCH_DYING	3
+#define BRANCH_DEAD	4
+
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_BRANCHOBJECT_H */
Index: Include/pymem.h
===================================================================
--- Include/pymem.h	(revision 58355)
+++ Include/pymem.h	(working copy)
@@ -49,6 +49,72 @@
    performed on failure (no exception is set, no warning is printed, etc).
 */
 
+#if 1
+PyAPI_FUNC(void) Py_FatalError(const char *message);
+
+/* XXX Must match up with obmalloc.c's size_classes */
+#define PYMALLOC_CACHE_SIZECLASSES 13
+
+#define PYMALLOC_CACHE_COUNT 32
+
+
+PyAPI_FUNC(void *) pymemcache_malloc(size_t);
+PyAPI_FUNC(void *) pymemcache_realloc(void *, size_t);
+PyAPI_FUNC(void) pymemcache_free(void *);
+
+
+/* pymemwrap is just a temporary bodge until the different names are
+ * properly unified. */
+PyAPI_FUNC(void *) _pymemwrap_malloc(const char *, const char *, size_t);
+PyAPI_FUNC(void *) _pymemwrap_realloc(const char *, const char *, void *, size_t);
+PyAPI_FUNC(void) _pymemwrap_free(const char *, const char *, void *);
+
+#define PyMEMWRAP_MALLOC(name, group) \
+static inline void * \
+name(size_t size) \
+{ \
+	return _pymemwrap_malloc(#name, #group, size); \
+}
+
+#define PyMEMWRAP_REALLOC(name, group) \
+static inline void * \
+name(void *oldmem, size_t size) \
+{ \
+	return _pymemwrap_realloc(#name, #group, oldmem, size); \
+}
+
+#define PyMEMWRAP_FREE(name, group) \
+static inline void \
+name(void *mem) \
+{ \
+	_pymemwrap_free(#name, #group, mem); \
+}
+
+PyMEMWRAP_MALLOC(PyMem_Malloc, PyMem_Camel)
+PyMEMWRAP_REALLOC(PyMem_Realloc, PyMem_Camel)
+PyMEMWRAP_FREE(PyMem_Free, PyMem_Camel)
+
+PyMEMWRAP_MALLOC(PyMem_MALLOC, PyMem_UPPER)
+PyMEMWRAP_REALLOC(PyMem_REALLOC, PyMem_UPPER)
+PyMEMWRAP_FREE(PyMem_FREE, PyMem_UPPER)
+
+PyMEMWRAP_MALLOC(PyObject_Malloc, PyObject_Camel)
+PyMEMWRAP_REALLOC(PyObject_Realloc, PyObject_Camel)
+PyMEMWRAP_FREE(PyObject_Free, PyObject_Camel)
+
+PyMEMWRAP_MALLOC(PyObject_MALLOC, PyObject_UPPER)
+PyMEMWRAP_REALLOC(PyObject_REALLOC, PyObject_UPPER)
+PyMEMWRAP_FREE(PyObject_FREE, PyObject_UPPER)
+
+/* PyMem_Del is only used by multibytecodec.c */
+PyMEMWRAP_FREE(PyMem_Del, PyMem_CamelDel)
+PyMEMWRAP_FREE(PyMem_DEL, PyMem_UPPERDEL)
+
+//PyMEMWRAP_FREE(hidden_PyObject_Del, PyObject_CamelDel)
+//PyAPI_FUNC(void) PyObject_Del(void *);
+//PyMEMWRAP_FREE(PyObject_DEL, PyObject_UPPERDEL)
+
+#else
 PyAPI_FUNC(void *) PyMem_Malloc(size_t);
 PyAPI_FUNC(void *) PyMem_Realloc(void *, size_t);
 PyAPI_FUNC(void) PyMem_Free(void *);
@@ -74,6 +140,7 @@
 #define PyMem_FREE		free
 
 #endif	/* PYMALLOC_DEBUG */
+#endif
 
 /*
  * Type-oriented memory interface
@@ -97,8 +164,8 @@
 /* PyMem{Del,DEL} are left over from ancient days, and shouldn't be used
  * anymore.  They're just confusing aliases for PyMem_{Free,FREE} now.
  */
-#define PyMem_Del		PyMem_Free
-#define PyMem_DEL		PyMem_FREE
+//#define PyMem_Del		PyMem_Free
+//#define PyMem_DEL		PyMem_FREE
 
 #ifdef __cplusplus
 }
Index: Include/pystate.h
===================================================================
--- Include/pystate.h	(revision 58355)
+++ Include/pystate.h	(working copy)
@@ -8,15 +8,35 @@
 extern "C" {
 #endif
 
+#include <atomic_ops.h>
+
+#include "pythread.h"
+
+
+/* XXX Must match up with gcmodule.c's gc_cache_size_classes */
+#define PYGC_CACHE_SIZECLASSES 13
+
+#define PYGC_CACHE_COUNT 32
+
+/* XXX Must be a power of 2 */
+//#define Py_ASYNCREFCOUNT_TABLE 1024
+#define Py_ASYNCREFCOUNT_TABLE 2048
+
+
 /* State shared between threads */
 
 struct _ts; /* Forward */
 struct _is; /* Forward */
+struct _PyMonitorSpaceFrame; /* Forward */
+struct _PyState_EnterFrame;
+typedef struct _PyState_EnterFrame *PyState_EnterTag;
 
 typedef struct _is {
 
     struct _is *next;
     struct _ts *tstate_head;
+    AO_t tstate_count;
+    PyState_EnterTag entertag;
 
     PyObject *modules;
     PyObject *sysdict;
@@ -40,6 +60,8 @@
 /* State unique per thread */
 
 struct _frame; /* Avoid including frameobject.h */
+struct _PyMonitorSpaceObject; /* Avoid including monitorobject.h */
+struct _PyInterruptObject; /* Avoid including interruptobject.h */
 
 /* Py_tracefunc return -1 when raising an exception, or 0 for success. */
 typedef int (*Py_tracefunc)(PyObject *, struct _frame *, int, PyObject *);
@@ -53,6 +75,32 @@
 #define PyTrace_C_EXCEPTION 5
 #define PyTrace_C_RETURN 6
 
+typedef struct _PyMonitorSpaceFrame {
+	struct _PyMonitorSpaceFrame *prevframe;
+	struct _PyMonitorSpaceObject *monitorspace;
+} PyMonitorSpaceFrame;
+
+#define PyMonitorSpaceFrame_INIT {NULL, NULL}
+
+typedef struct _PyState_EnterFrame {
+	struct _PyState_EnterFrame *prevframe;
+	PyMonitorSpaceFrame monitorspaceframe;
+	int locked;
+} PyState_EnterFrame;
+
+typedef struct _PyCritical {
+    PyThread_type_lock lock;
+    Py_ssize_t depth;
+    struct _PyCritical *prev;
+} PyCritical;
+
+struct _object;  /* From object.h, which includes us.  Doh! */
+
+typedef struct {
+	struct _object *obj;
+	AO_t diff;
+} PyAsyncRefEntry;
+
 typedef struct _ts {
     /* See Python/ceval.c for comments explaining most fields */
 
@@ -62,9 +110,10 @@
     struct _frame *frame;
     int recursion_depth;
     char overflowed; /* The stack has overflowed. Allow 50 more calls
-		        to handle the runtime error. */
-    char recursion_critical; /* The current calls must not cause 
-				a stack overflow. */
+                        to handle the runtime error. */
+    char recursion_critical; /* The current calls must not cause
+                                a stack overflow. */
+    int dealloc_depth;
     /* 'tracing' keeps track of the execution depth when tracing/profiling.
        This is to prevent the actual trace/profile code from being recorded in
        the trace/profile. */
@@ -86,21 +135,45 @@
 
     PyObject *dict;  /* Stores per-thread state */
 
-    /* tick_counter is incremented whenever the check_interval ticker
+    /* large_ticks is incremented whenever the check_interval ticker
      * reaches zero. The purpose is to give a useful measure of the number
      * of interpreted bytecode instructions in a given thread.  This
      * extremely lightweight statistic collector may be of interest to
      * profilers (like psyco.jit()), although nothing in the core uses it.
      */
-    int tick_counter;
+    int large_ticks;
+    int small_ticks;
 
-    int gilstate_counter;
+    AO_t inspect_count;
+    PyThread_type_lock inspect_queue_lock;
+    PyThread_type_lock inspect_lock;
+    AO_t inspect_flag;
 
-    PyObject *async_exc; /* Asynchronous exception to raise */
-    long thread_id; /* Thread id where this tstate was created */
+    int suspended;
 
+    PyState_EnterFrame *enterframe;
+
+    Py_ssize_t import_depth;
+    PyMonitorSpaceFrame *monitorspace_frame;
+    PyMonitorSpaceFrame _base_monitorspace_frame;
+
+    struct _PyInterruptObject *interrupt_point;
+
+    /* Simple lock that doesn't employ deadlock detection */
+    PyCritical *critical_section;
+
+    /* The Monitor Space lock that this thread may be blocked on. */
+    struct _PyMonitorSpaceObject *active_lock;
+    struct _ts *lockwait_prev;
+    struct _ts *lockwait_next;
+    PyThread_type_cond lockwait_cond;
+
     /* XXX signal handlers should also be here */
 
+    void *malloc_cache[PYMALLOC_CACHE_SIZECLASSES][PYMALLOC_CACHE_COUNT];
+    void *gc_object_cache[PYGC_CACHE_SIZECLASSES][PYGC_CACHE_COUNT];
+
+    PyAsyncRefEntry async_refcounts[Py_ASYNCREFCOUNT_TABLE];
 } PyThreadState;
 
 
@@ -108,33 +181,28 @@
 PyAPI_FUNC(void) PyInterpreterState_Clear(PyInterpreterState *);
 PyAPI_FUNC(void) PyInterpreterState_Delete(PyInterpreterState *);
 
-PyAPI_FUNC(PyThreadState *) PyThreadState_New(PyInterpreterState *);
+PyAPI_FUNC(PyThreadState *) _PyThreadState_New(void);
 PyAPI_FUNC(void) PyThreadState_Clear(PyThreadState *);
-PyAPI_FUNC(void) PyThreadState_Delete(PyThreadState *);
-#ifdef WITH_THREAD
-PyAPI_FUNC(void) PyThreadState_DeleteCurrent(void);
+PyAPI_FUNC(void) _PyThreadState_Delete(PyThreadState *tstate);
+
+PyAPI_FUNC(PyThreadState *) _PyThreadState_Get(void);
+#ifdef Py_BUILD_CORE
+PyAPI_DATA(__thread PyThreadState *) _py_local_tstate;
+static inline PyThreadState *
+PyThreadState_Get(void)
+{
+	PyThreadState *tstate = _py_local_tstate;
+	if (tstate == NULL)
+		Py_FatalError("PyThreadState_Get: no current thread");
+	return tstate;
+}
+#else
+#define PyThreadState_Get _PyThreadState_Get
 #endif
-
-PyAPI_FUNC(PyThreadState *) PyThreadState_Get(void);
-PyAPI_FUNC(PyThreadState *) PyThreadState_Swap(PyThreadState *);
 PyAPI_FUNC(PyObject *) PyThreadState_GetDict(void);
 PyAPI_FUNC(int) PyThreadState_SetAsyncExc(long, PyObject *);
 
 
-/* Variable and macro for in-line access to current thread state */
-
-PyAPI_DATA(PyThreadState *) _PyThreadState_Current;
-
-#ifdef Py_DEBUG
-#define PyThreadState_GET() PyThreadState_Get()
-#else
-#define PyThreadState_GET() (_PyThreadState_Current)
-#endif
-
-typedef
-    enum {PyGILState_LOCKED, PyGILState_UNLOCKED}
-        PyGILState_STATE;
-
 /* Ensure that the current thread is ready to call the Python
    C API, regardless of the current state of Python, or of its
    thread lock.  This may be called as many times as desired
@@ -154,9 +222,10 @@
 
    When the function returns, the current thread will hold the GIL.
 
-   Failure is a fatal error.
+   0 is returned if memory is unavailable.
 */
-PyAPI_FUNC(PyGILState_STATE) PyGILState_Ensure(void);
+PyAPI_FUNC(PyState_EnterTag) PyState_Enter(void);
+PyAPI_FUNC(PyState_EnterTag) _PyState_EnterPreallocated(PyThreadState *);
 
 /* Release any resources previously acquired.  After this call, Python's
    state will be the same as it was prior to the corresponding
@@ -166,16 +235,9 @@
    Every call to PyGILState_Ensure must be matched by a call to
    PyGILState_Release on the same thread.
 */
-PyAPI_FUNC(void) PyGILState_Release(PyGILState_STATE);
+PyAPI_FUNC(void) PyState_Exit(PyState_EnterTag);
+PyAPI_FUNC(void) _PyState_ExitSimple(PyState_EnterFrame *);
 
-/* Helper/diagnostic function - get the current thread state for
-   this thread.  May return NULL if no GILState API has been used
-   on the current thread.  Note the main thread always has such a
-   thread-state, even if no auto-thread-state call has been made
-   on the main thread.
-*/
-PyAPI_FUNC(PyThreadState *) PyGILState_GetThisThreadState(void);
-
 /* The implementation of sys._current_frames()  Returns a dict mapping
    thread id to that thread's current frame.
 */
@@ -193,6 +255,115 @@
 /* hook for PyEval_GetFrame(), requested for Psyco */
 PyAPI_DATA(PyThreadFrameGetter) _PyThreadState_GetFrame;
 
+PyAPI_FUNC(int) PyThreadState_Tick(void);
+
+
+PyAPI_FUNC(void) PyState_EnterImport(void);
+PyAPI_FUNC(void) PyState_ExitImport(void);
+
+PyAPI_FUNC(void) PyState_StopTheWorld(void);
+PyAPI_FUNC(void) PyState_StartTheWorld(void);
+
+
+/* Prefered API for locking if PyState is involved.  Required if
+ * Py_INCREF/Py_DECREF are used.  The code is assumed to be a critical
+ * section (involving a known, fixed amount of code; entering other
+ * critical sections is an error.)  PyState_Suspend might be called
+ * while entering. */
+PyAPI_FUNC(PyCritical *) PyCritical_Allocate(Py_ssize_t);
+PyAPI_FUNC(void) PyCritical_Free(PyCritical *);
+PyAPI_FUNC(void) PyCritical_Enter(PyCritical *);
+PyAPI_FUNC(void) PyCritical_Exit(PyCritical *);
+/* This is just a bodge for deathqueue_wait.  It shouldn't be used in general */
+PyAPI_FUNC(void) _PyCritical_CondWait(PyCritical *, PyThread_type_cond);
+
+/* Most code only needs one critical section at a time.  They should use
+ * PyCRITICAL_NORMAL and be done with it.  Occasionally you'll need two
+ * specific critical sections at once, in which case you should add your
+ * defines and document them with your own little graph here.
+ *
+ * If there's enough independent graphs I may also add a "section" field,
+ * so you can't accidentally mix graphs.  Will I ever have a need for
+ * "universal" critical sections though, that can be entered while in
+ * any other critical section (except other universal critical sections)?
+ * XXX Using a stack-allocated critical section for INCREF/DECREF and the
+ * like would need a "universal" section field.
+ *
+ *    WEAKREF
+ *       |
+ *    HANDLE
+ *       |
+ *     QUEUE
+ */
+#define PyCRITICAL_WEAKREF_REF 2
+#define PyCRITICAL_WEAKREF_HANDLE 1
+#define PyCRITICAL_WEAKREF_QUEUE 0
+#define PyCRITICAL_NORMAL 0
+
+
+/* Interface for threads.
+
+   A module that plans to do a blocking system call (or something else
+   that lasts a long time and doesn't touch Python data) can allow other
+   threads to run as follows:
+
+	...preparations here...
+	Py_BEGIN_ALLOW_THREADS
+	...blocking system call here...
+	Py_END_ALLOW_THREADS
+	...interpret result here...
+
+   The Py_BEGIN_ALLOW_THREADS/Py_END_ALLOW_THREADS pair expands to a
+   {}-surrounded block.
+   To leave the block in the middle (e.g., with return), you must insert
+   a line containing Py_BLOCK_THREADS before the return, e.g.
+
+	if (...premature_exit...) {
+		Py_BLOCK_THREADS
+		PyErr_SetFromErrno(PyExc_IOError);
+		return NULL;
+	}
+
+   An alternative is:
+
+	Py_BLOCK_THREADS
+	if (...premature_exit...) {
+		PyErr_SetFromErrno(PyExc_IOError);
+		return NULL;
+	}
+	Py_UNBLOCK_THREADS
+
+   For convenience, that the value of 'errno' is restored across
+   Py_END_ALLOW_THREADS and Py_BLOCK_THREADS.
+
+   WARNING: NEVER NEST CALLS TO Py_BEGIN_ALLOW_THREADS AND
+   Py_END_ALLOW_THREADS!!!
+
+   The function PyEval_InitThreads() should be called only from
+   initthread() in "threadmodule.c".
+
+   Note that not yet all candidates have been converted to use this
+   mechanism!
+*/
+
+#ifndef WITH_THREAD
+#error Threading support is now unconditional
+#endif
+
+PyAPI_FUNC(void) PyState_PrepareFork(void);
+PyAPI_FUNC(void) PyState_CleanupForkParent(void);
+PyAPI_FUNC(void) PyState_CleanupForkChild(void);
+PyAPI_FUNC(void) PyState_Suspend(void);
+PyAPI_FUNC(void) PyState_Resume(void);
+
+#define Py_BEGIN_ALLOW_THREADS PyState_Suspend();
+#define Py_BLOCK_THREADS PyState_Resume();
+#define Py_UNBLOCK_THREADS PyState_Suspend();
+#define Py_END_ALLOW_THREADS PyState_Resume();
+
+PyAPI_FUNC(int) _PyEval_SliceIndex(PyObject *, Py_ssize_t *);
+
+
 #ifdef __cplusplus
 }
 #endif
Index: Include/pythonrun.h
===================================================================
--- Include/pythonrun.h	(revision 58355)
+++ Include/pythonrun.h	(working copy)
@@ -7,7 +7,7 @@
 extern "C" {
 #endif
 
-#define PyCF_MASK 0
+#define PyCF_MASK CO_FUTURE_SHARED_MODULE
 #define PyCF_MASK_OBSOLETE 0
 #define PyCF_SOURCE_IS_UTF8  0x0100
 #define PyCF_DONT_IMPLY_DEDENT 0x0200
@@ -120,6 +120,7 @@
 
 /* Internal -- various one-time initializations */
 PyAPI_FUNC(PyObject *) _PyBuiltin_Init(void);
+PyAPI_FUNC(void) _Py_ThreadTools_Init(void);
 PyAPI_FUNC(PyObject *) _PySys_Init(void);
 PyAPI_FUNC(void) _PyImport_Init(void);
 PyAPI_FUNC(void) _PyExc_Init(void);
@@ -128,6 +129,14 @@
 PyAPI_FUNC(int) _PyInt_Init(void);
 PyAPI_FUNC(void) _PyFloat_Init(void);
 PyAPI_FUNC(int) PyBytes_Init(void);
+PyAPI_FUNC(void) _PyMethod_Init(void);
+PyAPI_FUNC(void) _PyTuple_Init(void);
+PyAPI_FUNC(void) _PyList_Init(void);
+PyAPI_FUNC(void) _PySet_Init(void);
+PyAPI_FUNC(void) _PyString_Init(void);
+PyAPI_FUNC(void) _PyCFunction_Init(void);
+PyAPI_FUNC(void) _PySignal_Init(void);
+PyAPI_FUNC(void) _PySignal_InitSigInt(int);
 
 /* Various internal finalizers */
 PyAPI_FUNC(void) _PyExc_Fini(void);
@@ -142,7 +151,9 @@
 PyAPI_FUNC(void) PyBytes_Fini(void);
 PyAPI_FUNC(void) PyInt_Fini(void);
 PyAPI_FUNC(void) PyFloat_Fini(void);
-PyAPI_FUNC(void) PyOS_FiniInterrupts(void);
+PyAPI_FUNC(void) PyDict_Fini(void);
+PyAPI_FUNC(void) _PySignal_Fini(void);
+PyAPI_FUNC(void) _PySignal_FiniSigInt(void);
 
 /* Stuff with no proper home (yet) */
 PyAPI_FUNC(char *) PyOS_Readline(FILE *, FILE *, char *);
@@ -165,12 +176,7 @@
 PyAPI_FUNC(int) PyOS_CheckStack(void);
 #endif
 
-/* Signals */
-typedef void (*PyOS_sighandler_t)(int);
-PyAPI_FUNC(PyOS_sighandler_t) PyOS_getsig(int);
-PyAPI_FUNC(PyOS_sighandler_t) PyOS_setsig(int, PyOS_sighandler_t);
 
-
 #ifdef __cplusplus
 }
 #endif
Index: Include/object.h
===================================================================
--- Include/object.h	(revision 58355)
+++ Include/object.h	(working copy)
@@ -4,7 +4,9 @@
 extern "C" {
 #endif
 
+#include <atomic_ops.h>
 
+
 /* Object and type object interface */
 
 /*
@@ -51,6 +53,12 @@
 whose size is determined when the object is allocated.
 */
 
+#define Py_REFOWNER_ASYNC ((AO_t)0)
+#define Py_REFOWNER_STATICINIT ((AO_t)-1)
+#define Py_REFOWNER_DELETED ((AO_t)-2)
+
+#define Py_REFCNT_DELETED ((AO_t)-42)
+
 /* Py_DEBUG implies Py_TRACE_REFS. */
 #if defined(Py_DEBUG) && !defined(Py_TRACE_REFS)
 #define Py_TRACE_REFS
@@ -77,12 +85,16 @@
 /* PyObject_HEAD defines the initial segment of every PyObject. */
 #define PyObject_HEAD		        PyObject ob_base;
 
-#define PyObject_HEAD_INIT(type)	\
+/* XXX FIXME the default for ob_sizeclass is a cludge */
+#define PyObject_HEAD_INIT_NOCOMMA(type)	\
 	{ _PyObject_EXTRA_INIT		\
-	1, type },
+	NULL, NULL, 1, Py_REFOWNER_STATICINIT, 1, _PyGC_REFS_UNTRACKED, type }
+#define PyObject_HEAD_INIT(type) PyObject_HEAD_INIT_NOCOMMA(type),
 
-#define PyVarObject_HEAD_INIT(type, size)	\
-	{ PyObject_HEAD_INIT(type) size },
+#define PyVarObject_HEAD_INIT_NOCOMMA(type, size) \
+	{ PyObject_HEAD_INIT(type) size }
+#define PyVarObject_HEAD_INIT(type, size) \
+	PyVarObject_HEAD_INIT_NOCOMMA(type, size),
 
 /* PyObject_VAR_HEAD defines the initial segment of all variable-size
  * container objects.  These end with a declaration of an array with 1
@@ -100,7 +112,12 @@
  */
 typedef struct _object {
 	_PyObject_HEAD_EXTRA
-	Py_ssize_t ob_refcnt;
+	struct _object *ob_prev;
+	struct _object *ob_next;
+	Py_ssize_t ob_sizeclass;
+	AO_t ob_refowner;
+	AO_t ob_refcnt;
+	AO_t ob_refcnt_trace;
 	struct _typeobject *ob_type;
 } PyObject;
 
@@ -109,10 +126,30 @@
 	Py_ssize_t ob_size; /* Number of items in variable part */
 } PyVarObject;
 
-#define Py_Refcnt(ob)		(((PyObject*)(ob))->ob_refcnt)
+//#define Py_Refcnt(ob)		(((PyObject*)(ob))->ob_refcnt)
 #define Py_Type(ob)		(((PyObject*)(ob))->ob_type)
 #define Py_Size(ob)		(((PyVarObject*)(ob))->ob_size)
 
+#include "pystate.h"
+
+#define Py_RefcntMatches(ob, count) (Py_RefcntSnoop(ob) == (count))
+
+#if 0
+static inline Py_ssize_t
+_Py_RefcntSnoop(PyObject *op)
+{
+	PyThreadState *tstate = PyThreadState_Get();
+	void *owner = (void *)AO_load_full(&op->ob_refowner);
+	Py_ssize_t count = (Py_ssize_t)AO_load_full(&op->ob_refcnt);
+
+	if (owner == tstate)
+		return count;
+	else
+		return 1000000;  /* Arbitrary large value */
+}
+#endif
+#define Py_RefcntSnoop(ob) _Py_RefcntSnoop((PyObject*)(ob))
+
 /*
 Type objects contain a string containing the type name (to help somewhat
 in debugging), the allocation parameters (see PyObject_New() and
@@ -275,7 +312,6 @@
      inquiry bf_multisegment;
 } PyBufferProcs;
 
-typedef void (*freefunc)(void *);
 typedef void (*destructor)(PyObject *);
 typedef int (*printfunc)(PyObject *, FILE *, int);
 typedef PyObject *(*getattrfunc)(PyObject *, char *);
@@ -292,7 +328,7 @@
 typedef int (*descrsetfunc) (PyObject *, PyObject *, PyObject *);
 typedef int (*initproc)(PyObject *, PyObject *, PyObject *);
 typedef PyObject *(*newfunc)(struct _typeobject *, PyObject *, PyObject *);
-typedef PyObject *(*allocfunc)(struct _typeobject *, Py_ssize_t);
+typedef int (*isshareablefunc)(PyObject *);
 
 typedef struct _typeobject {
 	PyObject_VAR_HEAD
@@ -326,7 +362,7 @@
 	PyBufferProcs *tp_as_buffer;
 
 	/* Flags to define presence of optional/expanded features */
-	long tp_flags;
+	unsigned long tp_flags;
 
 	const char *tp_doc; /* Documentation string */
 
@@ -358,17 +394,17 @@
 	descrsetfunc tp_descr_set;
 	Py_ssize_t tp_dictoffset;
 	initproc tp_init;
-	allocfunc tp_alloc;
 	newfunc tp_new;
-	freefunc tp_free; /* Low-level free-memory routine */
 	inquiry tp_is_gc; /* For PyObject_IS_GC */
 	PyObject *tp_bases;
 	PyObject *tp_mro; /* method resolution order */
 	PyObject *tp_cache;
 	PyObject *tp_subclasses;
 	PyObject *tp_weaklist;
-	destructor tp_del;
 
+	/* Freezing to allow sharing between threads */
+	isshareablefunc tp_isshareable;
+
 #ifdef COUNT_ALLOCS
 	/* these must be last and never explicitly initialized */
 	Py_ssize_t tp_allocs;
@@ -416,10 +452,9 @@
 #define PyType_CheckExact(op) (Py_Type(op) == &PyType_Type)
 
 PyAPI_FUNC(int) PyType_Ready(PyTypeObject *);
-PyAPI_FUNC(PyObject *) PyType_GenericAlloc(PyTypeObject *, Py_ssize_t);
 PyAPI_FUNC(PyObject *) PyType_GenericNew(PyTypeObject *,
 					       PyObject *, PyObject *);
-PyAPI_FUNC(PyObject *) _PyType_Lookup(PyTypeObject *, PyObject *);
+PyAPI_FUNC(int) _PyType_LookupEx(PyTypeObject *, PyObject *, PyObject **);
 
 /* Generic operations on objects */
 PyAPI_FUNC(int) PyObject_Print(PyObject *, FILE *, int);
@@ -441,6 +476,7 @@
 PyAPI_FUNC(int) PyObject_SetAttr(PyObject *, PyObject *, PyObject *);
 PyAPI_FUNC(int) PyObject_HasAttr(PyObject *, PyObject *);
 PyAPI_FUNC(PyObject **) _PyObject_GetDictPtr(PyObject *);
+PyAPI_FUNC(PyObject **) _PyObject_GetDictPtr_NoCheck(PyObject *);
 PyAPI_FUNC(PyObject *) PyObject_SelfIter(PyObject *);
 PyAPI_FUNC(PyObject *) PyObject_GenericGetAttr(PyObject *, PyObject *);
 PyAPI_FUNC(int) PyObject_GenericSetAttr(PyObject *,
@@ -449,12 +485,15 @@
 PyAPI_FUNC(int) PyObject_IsTrue(PyObject *);
 PyAPI_FUNC(int) PyObject_Not(PyObject *);
 PyAPI_FUNC(int) PyCallable_Check(PyObject *);
+PyAPI_FUNC(int) PyObject_IsShareable(PyObject *);
 
-PyAPI_FUNC(void) PyObject_ClearWeakRefs(PyObject *);
+PyAPI_FUNC(int) _PyObject_TryClearWeakref(PyObject *);
 
 /* A slot function whose address we need to compare */
 extern int _PyObject_SlotCompare(PyObject *, PyObject *);
 
+PyAPI_FUNC(void) _PyGC_AsyncRefcount_Flush(void);
+PyAPI_FUNC(void) _PyGC_RefMode_Promote(PyObject *);
 
 /* PyObject_Dir(obj) acts like Python __builtin__.dir(obj), returning a
    list of strings.  PyObject_Dir(NULL) is like __builtin__.dir(),
@@ -502,37 +541,48 @@
 */
 
 /* Set if the type object is dynamically allocated */
-#define Py_TPFLAGS_HEAPTYPE (1L<<9)
+#define Py_TPFLAGS_HEAPTYPE (1UL<<9)
 
 /* Set if the type allows subclassing */
-#define Py_TPFLAGS_BASETYPE (1L<<10)
+#define Py_TPFLAGS_BASETYPE (1UL<<10)
 
 /* Set if the type is 'ready' -- fully initialized */
-#define Py_TPFLAGS_READY (1L<<12)
+#define Py_TPFLAGS_READY (1UL<<12)
 
 /* Set while the type is being 'readied', to prevent recursive ready calls */
-#define Py_TPFLAGS_READYING (1L<<13)
+#define Py_TPFLAGS_READYING (1UL<<13)
 
 /* Objects support garbage collection (see objimp.h) */
-#define Py_TPFLAGS_HAVE_GC (1L<<14)
+#define Py_TPFLAGS_HAVE_GC (1UL<<14)
 
 /* These two bits are preserved for Stackless Python, next after this is 17 */
 #ifdef STACKLESS
-#define Py_TPFLAGS_HAVE_STACKLESS_EXTENSION (3L<<15)
+#define Py_TPFLAGS_HAVE_STACKLESS_EXTENSION (3UL<<15)
 #else
 #define Py_TPFLAGS_HAVE_STACKLESS_EXTENSION 0
 #endif
 
+/* Type object is shareable */
+#define Py_TPFLAGS_SHAREABLE (1UL<<17)
+
+/* Type's tp_new will call PyObject_Complete itself.  Memory may not be
+ * wiped. */
+#define Py_TPFLAGS_SKIPWIPE (1UL<<18)
+
+/* Objects provide __finalize__ method */
+#define Py_TPFLAGS_HAVE_FINALIZE (1UL<<19)
+
 /* These flags are used to determine if a type is a subclass. */
-#define Py_TPFLAGS_INT_SUBCLASS		(1L<<23)
-#define Py_TPFLAGS_LONG_SUBCLASS	(1L<<24)
-#define Py_TPFLAGS_LIST_SUBCLASS	(1L<<25)
-#define Py_TPFLAGS_TUPLE_SUBCLASS	(1L<<26)
-#define Py_TPFLAGS_STRING_SUBCLASS	(1L<<27)
-#define Py_TPFLAGS_UNICODE_SUBCLASS	(1L<<28)
-#define Py_TPFLAGS_DICT_SUBCLASS	(1L<<29)
-#define Py_TPFLAGS_BASE_EXC_SUBCLASS	(1L<<30)
-#define Py_TPFLAGS_TYPE_SUBCLASS	(1L<<31)
+#define Py_TPFLAGS_MONITOR_SUBCLASS	(1UL<<22)
+#define Py_TPFLAGS_INT_SUBCLASS		(1UL<<23)
+#define Py_TPFLAGS_LONG_SUBCLASS	(1UL<<24)
+#define Py_TPFLAGS_LIST_SUBCLASS	(1UL<<25)
+#define Py_TPFLAGS_TUPLE_SUBCLASS	(1UL<<26)
+#define Py_TPFLAGS_STRING_SUBCLASS	(1UL<<27)
+#define Py_TPFLAGS_UNICODE_SUBCLASS	(1UL<<28)
+#define Py_TPFLAGS_DICT_SUBCLASS	(1UL<<29)
+#define Py_TPFLAGS_BASE_EXC_SUBCLASS	(1UL<<30)
+#define Py_TPFLAGS_TYPE_SUBCLASS	(1UL<<31)
 
 #define Py_TPFLAGS_DEFAULT  ( \
                              Py_TPFLAGS_HAVE_STACKLESS_EXTENSION | \
@@ -571,7 +621,7 @@
 
 *** WARNING*** The Py_DECREF macro must have a side-effect-free argument
 since it may evaluate its argument multiple times.  (The alternative
-would be to mace it a proper function or assign it to a global temporary
+would be to make it a proper function or assign it to a global temporary
 variable first, both of which are slower; and in a multi-threaded
 environment the global variable trick is not safe.)
 */
@@ -586,28 +636,48 @@
  * #ifdefs (we used to do that -- it was impenetrable).
  */
 #ifdef Py_REF_DEBUG
-PyAPI_DATA(Py_ssize_t) _Py_RefTotal;
-PyAPI_FUNC(void) _Py_NegativeRefcount(const char *fname,
-					    int lineno, PyObject *op);
+PyAPI_DATA(AO_t) _Py_RefTotal;
+PyAPI_FUNC(void) _Py_NegativeRefcount(const char *fname, int lineno,
+	PyObject *op, Py_ssize_t count);
 PyAPI_FUNC(PyObject *) _PyDict_Dummy(void);
 PyAPI_FUNC(PyObject *) _PySet_Dummy(void);
 PyAPI_FUNC(Py_ssize_t) _Py_GetRefTotal(void);
-#define _Py_INC_REFTOTAL	_Py_RefTotal++
-#define _Py_DEC_REFTOTAL	_Py_RefTotal--
-#define _Py_REF_DEBUG_COMMA	,
-#define _Py_CHECK_REFCNT(OP)					\
+//#define _Py_INC_REFTOTAL	_Py_RefTotal++
+static inline void
+_Py_INC_REFTOTAL(void)
+{
+#ifdef Py_REF_DEBUG
+	AO_fetch_and_add1_full(&_Py_RefTotal);
+#endif
+}
+//#define _Py_DEC_REFTOTAL	_Py_RefTotal--
+static inline void
+_Py_DEC_REFTOTAL(void)
+{
+#ifdef Py_REF_DEBUG
+	AO_fetch_and_sub1_full(&_Py_RefTotal);
+#endif
+}
+//#define _Py_REF_DEBUG_COMMA	,
+/*#define _Py_CHECK_REFCNT(OP)					\
 {	if (((PyObject*)OP)->ob_refcnt < 0)				\
 		_Py_NegativeRefcount(__FILE__, __LINE__,	\
 				     (PyObject *)(OP));		\
 }
+*/
 #else
-#define _Py_INC_REFTOTAL
-#define _Py_DEC_REFTOTAL
-#define _Py_REF_DEBUG_COMMA
-#define _Py_CHECK_REFCNT(OP)	/* a semicolon */;
+//#define _Py_INC_REFTOTAL
+#define _Py_INC_REFTOTAL()
+//#define _Py_DEC_REFTOTAL
+#define _Py_DEC_REFTOTAL()
+//#define _Py_REF_DEBUG_COMMA
+//#define _Py_CHECK_REFCNT(OP)	/* a semicolon */;
 #endif /* Py_REF_DEBUG */
 
 #ifdef COUNT_ALLOCS
+#ifdef WITH_FREETHREAD
+#error FIXME
+#endif
 PyAPI_FUNC(void) inc_count(PyTypeObject *);
 PyAPI_FUNC(void) dec_count(PyTypeObject *);
 #define _Py_INC_TPALLOCS(OP)	inc_count(Py_Type(OP))
@@ -623,9 +693,6 @@
 
 #ifdef Py_TRACE_REFS
 /* Py_TRACE_REFS is such major surgery that we call external routines. */
-PyAPI_FUNC(void) _Py_NewReference(PyObject *);
-PyAPI_FUNC(void) _Py_ForgetReference(PyObject *);
-PyAPI_FUNC(void) _Py_Dealloc(PyObject *);
 PyAPI_FUNC(void) _Py_PrintReferences(FILE *);
 PyAPI_FUNC(void) _Py_PrintReferenceAddresses(FILE *);
 PyAPI_FUNC(void) _Py_AddToAllObjects(PyObject *, int force);
@@ -634,28 +701,47 @@
 /* Without Py_TRACE_REFS, there's little enough to do that we expand code
  * inline.
  */
-#define _Py_NewReference(op) (				\
-	_Py_INC_TPALLOCS(op) _Py_COUNT_ALLOCS_COMMA	\
-	_Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA		\
-	Py_Refcnt(op) = 1)
+#endif /* !Py_TRACE_REFS */
 
-#define _Py_ForgetReference(op) _Py_INC_TPFREES(op)
+//PyAPI_FUNC(void) _Py_NewReference(PyObject *);
+//PyAPI_FUNC(void) _Py_ForgetReference(PyObject *);
+PyAPI_FUNC(Py_ssize_t) _Py_RefcntSnoop(PyObject *);
 
-#define _Py_Dealloc(op) (				\
-	_Py_INC_TPFREES(op) _Py_COUNT_ALLOCS_COMMA	\
-	(*Py_Type(op)->tp_dealloc)((PyObject *)(op)))
-#endif /* !Py_TRACE_REFS */
+#ifdef WITH_FREETHREAD
+PyAPI_FUNC(void) _Py_INCREF(PyObject *, PyThreadState *);
+PyAPI_FUNC(void) _Py_DECREF(PyObject *, PyThreadState *);
+PyAPI_FUNC(void) _Py_DECREF_ASYNC(PyObject *, PyThreadState *);
+#define Py_INCREF(op) _Py_INCREF((PyObject *)(op), PyThreadState_Get())
+#define Py_DECREF(op) _Py_DECREF((PyObject *)(op), PyThreadState_Get())
+#define Py_DECREF_ASYNC(op) _Py_DECREF_ASYNC((PyObject *)(op), PyThreadState_Get())
 
-#define Py_INCREF(op) (				\
-	_Py_INC_REFTOTAL  _Py_REF_DEBUG_COMMA	\
-	((PyObject*)(op))->ob_refcnt++)
+#define Py_INCREFTS(op) _Py_INCREF((PyObject *)(op), tstate)
+#define Py_DECREFTS(op) _Py_DECREF((PyObject *)(op), tstate)
+#else
+static inline void
+_Py_INCREF(PyObject *op)
+{
+        _Py_INC_REFTOTAL();
+        op->ob_refcnt++;
+}
 
-#define Py_DECREF(op)					\
-	if (_Py_DEC_REFTOTAL  _Py_REF_DEBUG_COMMA	\
-	    --((PyObject*)(op))->ob_refcnt != 0)		\
-		_Py_CHECK_REFCNT(op)			\
-	else						\
-		_Py_Dealloc((PyObject *)(op))
+static inline void
+_Py_DECREF(PyObject *op)
+{
+        _Py_DEC_REFTOTAL();
+        op->ob_refcnt--;
+        if (op->ob_refcnt == 0)
+                _Py_Dealloc(op);
+#ifdef Py_REF_DEBUG
+        else if (((Py_ssize_t)op->ob_refcnt) < 0)
+                _Py_NegativeRefcount(__FILE__, __LINE__, op, op->ob_refcnt);
+#endif
+}
+#define Py_INCREF(op) _Py_INCREF((PyObject *)(op))
+#define Py_DECREF(op) _Py_DECREF((PyObject *)(op))
+#define Py_INCREFTS Py_INCREF
+#define Py_DECREFTS Py_DECREF
+#endif /* WITH_FREETHREAD */
 
 /* Safely decref `op` and set `op` to NULL, especially useful in tp_clear
  * and tp_dealloc implementatons.
@@ -700,10 +786,22 @@
                 }				\
         } while (0)
 
+#define Py_CLEARTS(op)				\
+        do {                            	\
+                if (op) {			\
+                        PyObject *tmp = (PyObject *)(op);	\
+                        (op) = NULL;		\
+                        Py_DECREFTS(tmp);		\
+                }				\
+        } while (0)
+
 /* Macros to use in case the object pointer may be NULL: */
 #define Py_XINCREF(op) if ((op) == NULL) ; else Py_INCREF(op)
 #define Py_XDECREF(op) if ((op) == NULL) ; else Py_DECREF(op)
 
+#define Py_XINCREFTS(op) if ((op) == NULL) ; else Py_INCREFTS(op)
+#define Py_XDECREFTS(op) if ((op) == NULL) ; else Py_DECREFTS(op)
+
 /*
 These are provided as conveniences to Python runtime embedders, so that
 they can have object code that is not dependent on Python compilation flags.
@@ -796,67 +894,6 @@
 times.
 */
 
-
-/* Trashcan mechanism, thanks to Christian Tismer.
-
-When deallocating a container object, it's possible to trigger an unbounded
-chain of deallocations, as each Py_DECREF in turn drops the refcount on "the
-next" object in the chain to 0.  This can easily lead to stack faults, and
-especially in threads (which typically have less stack space to work with).
-
-A container object that participates in cyclic gc can avoid this by
-bracketing the body of its tp_dealloc function with a pair of macros:
-
-static void
-mytype_dealloc(mytype *p)
-{
-        ... declarations go here ...
-
- 	PyObject_GC_UnTrack(p);	   // must untrack first
-	Py_TRASHCAN_SAFE_BEGIN(p)
-	... The body of the deallocator goes here, including all calls ...
-	... to Py_DECREF on contained objects.                         ...
-	Py_TRASHCAN_SAFE_END(p)
-}
-
-CAUTION:  Never return from the middle of the body!  If the body needs to
-"get out early", put a label immediately before the Py_TRASHCAN_SAFE_END
-call, and goto it.  Else the call-depth counter (see below) will stay
-above 0 forever, and the trashcan will never get emptied.
-
-How it works:  The BEGIN macro increments a call-depth counter.  So long
-as this counter is small, the body of the deallocator is run directly without
-further ado.  But if the counter gets large, it instead adds p to a list of
-objects to be deallocated later, skips the body of the deallocator, and
-resumes execution after the END macro.  The tp_dealloc routine then returns
-without deallocating anything (and so unbounded call-stack depth is avoided).
-
-When the call stack finishes unwinding again, code generated by the END macro
-notices this, and calls another routine to deallocate all the objects that
-may have been added to the list of deferred deallocations.  In effect, a
-chain of N deallocations is broken into N / PyTrash_UNWIND_LEVEL pieces,
-with the call stack never exceeding a depth of PyTrash_UNWIND_LEVEL.
-*/
-
-PyAPI_FUNC(void) _PyTrash_deposit_object(PyObject*);
-PyAPI_FUNC(void) _PyTrash_destroy_chain(void);
-PyAPI_DATA(int) _PyTrash_delete_nesting;
-PyAPI_DATA(PyObject *) _PyTrash_delete_later;
-
-#define PyTrash_UNWIND_LEVEL 50
-
-#define Py_TRASHCAN_SAFE_BEGIN(op) \
-	if (_PyTrash_delete_nesting < PyTrash_UNWIND_LEVEL) { \
-		++_PyTrash_delete_nesting;
-		/* The body of the deallocator is here. */
-#define Py_TRASHCAN_SAFE_END(op) \
-		--_PyTrash_delete_nesting; \
-		if (_PyTrash_delete_later && _PyTrash_delete_nesting <= 0) \
-			_PyTrash_destroy_chain(); \
-	} \
-	else \
-		_PyTrash_deposit_object((PyObject*)op);
-
 #ifdef __cplusplus
 }
 #endif
Index: Include/methodobject.h
===================================================================
--- Include/methodobject.h	(revision 58355)
+++ Include/methodobject.h	(working copy)
@@ -70,6 +70,9 @@
 
 #define METH_COEXIST   0x0040
 
+/* METH_SHARED allows a method to be shared between threads */
+#define METH_SHARED   0x0080
+
 typedef struct PyMethodChain {
     PyMethodDef *methods;		/* Methods of this type */
     struct PyMethodChain *link;	/* NULL or base type */
Index: Include/import.h
===================================================================
--- Include/import.h	(revision 58355)
+++ Include/import.h	(working copy)
@@ -13,6 +13,7 @@
 	char *name, PyObject *co, char *pathname);
 PyAPI_FUNC(PyObject *) PyImport_GetModuleDict(void);
 PyAPI_FUNC(PyObject *) PyImport_AddModule(const char *name);
+PyAPI_FUNC(PyObject *) PyImport_AddModuleEx(const char *name, int shared);
 PyAPI_FUNC(PyObject *) PyImport_ImportModule(const char *name);
 PyAPI_FUNC(PyObject *) PyImport_ImportModuleLevel(char *name,
 	PyObject *globals, PyObject *locals, PyObject *fromlist, int level);
Index: Include/weakrefobject.h
===================================================================
--- Include/weakrefobject.h	(revision 58355)
+++ Include/weakrefobject.h	(working copy)
@@ -7,68 +7,215 @@
 #endif
 
 
+/* Needed for offsetof */
+#include "structmember.h"
+
+#include "pythread.h"
+
+
+/* XXX This should get moved into its own file */
+/* The way PyLinkedList is used is that all objects within a given
+ * linked list have the same layout, allowing you to use
+ * PyLinkedList_Restore to get back the original object.
+ *
+ * The sentinel needs special handling, either by checking for it before
+ * calling PyLinkedList_Restore, or by making it a valid object and
+ * checking after. */
+typedef struct _PyLinkedList PyLinkedList;
+struct _PyLinkedList {
+    PyLinkedList *prev;
+    PyLinkedList *next;
+};
+
+#define PyLinkedList_Restore(type, field, op) \
+    (type *)(((char *)(op)) - offsetof(type, field))
+
+#define PyLinkedList_Append(sentinel, op) PyLinkedList_InsertBefore(sentinel, op)
+static inline void
+PyLinkedList_InsertBefore(PyLinkedList *a, PyLinkedList *b)
+{
+    assert(a->prev != NULL && a->next != NULL);
+    assert(b->prev == NULL && b->next == NULL);
+
+    b->prev = a->prev;
+    a->prev->next = b;
+
+    b->next = a;
+    a->prev = b;
+}
+
+static inline void
+PyLinkedList_Remove(PyLinkedList *op)
+{
+    assert(op->prev != NULL && op->next != NULL);
+    assert(op->prev != op && op->next != op);
+
+    op->prev->next = op->next;
+    op->next->prev = op->prev;
+
+    op->prev = NULL;
+    op->next = NULL;
+}
+
+/*
+ * Iterate over a LinkedList.  Use like so:
+ *
+ *     PyLinkedList *handle_links = &queue->live_links;
+ *
+ *     while (PyLinkedList_Next(&queue->live_links, &handle_links)) {
+ *         handle = PyLinkedList_Restore(PyDeathQueueHandle, queue_links,
+ *             handle_links);
+ *         Py_VISIT(handle);
+ *     }
+ *
+ * CAUTION:  It isn't safe to modify the LinkedList while iterating.
+ */
+static inline int
+PyLinkedList_Next(PyLinkedList *sentinel, PyLinkedList **op)
+{
+    if ((*op)->next == sentinel)
+        return 0;
+    else {
+        *op = (*op)->next;
+        return 1;
+    }
+}
+
+static inline int
+PyLinkedList_Empty(PyLinkedList *sentinel)
+{
+    assert(sentinel->prev != NULL && sentinel->next != NULL);
+
+    if (sentinel->next == sentinel) {
+        assert(sentinel->prev == sentinel);
+        return 1;
+    } else {
+        assert(sentinel->prev != sentinel);
+        return 0;
+    }
+}
+
+static inline int
+PyLinkedList_Detatched(PyLinkedList *op)
+{
+    assert(op->prev != op && op->next != op);
+
+    if (op->next == NULL) {
+        assert(op->prev == NULL);
+        return 1;
+    } else {
+        assert(op->prev != NULL);
+        return 0;
+    }
+}
+
+
 typedef struct _PyWeakReference PyWeakReference;
+typedef struct _PyDeathQueueHandle PyDeathQueueHandle;
+typedef struct _PyDeathQueue PyDeathQueue;
+typedef struct _PyWeakBinding PyWeakBinding;
 
-/* PyWeakReference is the base struct for the Python ReferenceType, ProxyType,
- * and CallableProxyType.
- */
 struct _PyWeakReference {
     PyObject_HEAD
 
+    /* Critical section protecting access to wr_object and our (not yet
+     * implemented) death notice list.  hash is NOT protected */
+    PyCritical *crit;
+
     /* The object to which this is a weak reference, or Py_None if none.
      * Note that this is a stealth reference:  wr_object's refcount is
      * not incremented to reflect this pointer.
      */
+    /* XXX it gets set to NULL now, not Py_None */
     PyObject *wr_object;
 
-    /* A callable to invoke when wr_object dies, or NULL if none. */
-    PyObject *wr_callback;
-
     /* A cache for wr_object's hash code.  As usual for hashes, this is -1
      * if the hash code isn't known yet.
      */
-    long hash;
+    /* XXX I'd much rather remove this, but to detect existing usage
+     * I'd have to make it an error. */
+    AO_t hash;
 
     /* If wr_object is weakly referenced, wr_object has a doubly-linked NULL-
      * terminated list of weak references to it.  These are the list pointers.
      * If wr_object goes away, wr_object is set to Py_None, and these pointers
      * have no meaning then.
      */
-    PyWeakReference *wr_prev;
-    PyWeakReference *wr_next;
+    //PyWeakReference *wr_prev;
+    //PyWeakReference *wr_next;
+    PyLinkedList handle_links;
+
+    PyLinkedList binding_links;
 };
 
-PyAPI_DATA(PyTypeObject) _PyWeakref_RefType;
-PyAPI_DATA(PyTypeObject) _PyWeakref_ProxyType;
-PyAPI_DATA(PyTypeObject) _PyWeakref_CallableProxyType;
+PyAPI_DATA(PyTypeObject) _PyWeakref_Type;
 
-#define PyWeakref_CheckRef(op) PyObject_TypeCheck(op, &_PyWeakref_RefType)
-#define PyWeakref_CheckRefExact(op) \
-        (Py_Type(op) == &_PyWeakref_RefType)
-#define PyWeakref_CheckProxy(op) \
-        ((Py_Type(op) == &_PyWeakref_ProxyType) || \
-         (Py_Type(op) == &_PyWeakref_CallableProxyType))
+#define PyWeakref_Check(op) (Py_Type(op) == &_PyWeakref_Type)
+#define PyWeakref_CheckRefExact PyWeakref_Check
+#define PyWeakref_CheckRef PyWeakref_Check
 
-/* This macro calls PyWeakref_CheckRef() last since that can involve a
-   function call; this makes it more likely that the function call
-   will be avoided. */
-#define PyWeakref_Check(op) \
-        (PyWeakref_CheckRef(op) || PyWeakref_CheckProxy(op))
 
+PyAPI_FUNC(PyObject *) PyWeakref_NewRef(PyObject *ob, PyObject *callback);
+/* Note that this DOES incref the returned object, if not NULL! */
+PyAPI_FUNC(PyObject *) PyWeakref_GetObjectEx(PyObject *ref);
+PyAPI_FUNC(PyObject *) PyWeakref_NewBinding(PyObject *ob, PyObject *value);
+PyAPI_FUNC(PyObject *) PyWeakref_GetBindingObject(PyObject *bind, PyObject **value);
 
-PyAPI_FUNC(PyObject *) PyWeakref_NewRef(PyObject *ob,
-                                              PyObject *callback);
-PyAPI_FUNC(PyObject *) PyWeakref_NewProxy(PyObject *ob,
-                                                PyObject *callback);
-PyAPI_FUNC(PyObject *) PyWeakref_GetObject(PyObject *ref);
+PyAPI_FUNC(void) _PyWeakref_ClearBindings(PyObject *ob, PyWeakReference *ref);
 
-PyAPI_FUNC(Py_ssize_t) _PyWeakref_GetWeakrefCount(PyWeakReference *head);
+#define _PY_GETWEAKREFPTR(o) \
+        ((PyWeakReference **) (((char *) (o)) + Py_Type(o)->tp_weaklistoffset))
 
-PyAPI_FUNC(void) _PyWeakref_ClearRef(PyWeakReference *self);
 
-#define PyWeakref_GET_OBJECT(ref) (((PyWeakReference *)(ref))->wr_object)
+struct _PyDeathQueueHandle {
+    PyObject_HEAD
 
+    PyCritical *crit;
 
+    PyObject *payload;
+
+    PyWeakReference *weakref;
+    PyLinkedList weakref_links;
+
+    PyDeathQueue *queue;
+    PyLinkedList queue_links;
+};
+
+PyAPI_DATA(PyTypeObject) _PyDeathQueueHandle_Type;
+
+#define PyDeathQueueHandle_Check(op) \
+    (Py_Type(op) == &_PyDeathQueueHandle_Type)
+
+
+struct _PyDeathQueue {
+    PyObject_HEAD
+
+    PyCritical *crit;
+    PyThread_type_cond cond;
+
+    PyLinkedList live_links;
+    PyLinkedList dead_links;
+};
+
+PyAPI_DATA(PyTypeObject) _PyDeathQueue_Type;
+
+#define PyDeathQueue_Check(op) (Py_Type(op) == &_PyDeathQueue_Type)
+
+
+struct _PyWeakBinding {
+    PyObject_HEAD
+
+    PyWeakReference *weakref;
+    PyObject *value; /* This is actually owned by weakref->wr_object */
+
+    PyLinkedList weakref_links;
+};
+
+PyAPI_DATA(PyTypeObject) _PyWeakBinding_Type;
+
+#define PyWeakBinding_Check(op) (Py_Type(op) == &_PyWeakBinding_Type)
+
+
 #ifdef __cplusplus
 }
 #endif
Index: Include/tupleobject.h
===================================================================
--- Include/tupleobject.h	(revision 58355)
+++ Include/tupleobject.h	(working copy)
@@ -23,6 +23,7 @@
 
 typedef struct {
     PyObject_VAR_HEAD
+    AO_t shareable;
     PyObject *ob_item[1];
 
     /* ob_item contains space for 'ob_size' elements.
Index: Include/pythread.h
===================================================================
--- Include/pythread.h	(revision 58355)
+++ Include/pythread.h	(working copy)
@@ -2,43 +2,60 @@
 #ifndef Py_PYTHREAD_H
 #define Py_PYTHREAD_H
 
-#define NO_EXIT_PROG		/* don't define PyThread_exit_prog() */
-				/* (the result is no use of signals on SGI) */
-
 typedef void *PyThread_type_lock;
-typedef void *PyThread_type_sema;
+typedef void *PyThread_type_sem;
+typedef void *PyThread_type_cond;
+typedef void *PyThread_type_key;
+typedef struct {
+    /* Notes:
+     *   * We wrap pthread_t in a struct to ensure it's not misused.
+     *   * This is intended to be an opaque struct.
+     *   * No way to compare them is currently provided.  Compare PyThreadStates instead.
+     *   * No "not set" value is provided.  Put a flag beside it if you need one.
+     *   * Currently, the only use is for PyThread_send_signal.
+     */
 
+    /* XXX FIXME this needs to conditionalize the definition to whatever
+     * thread library is in use */
+    pthread_t _value;
+} PyThread_type_handle;
+
 #ifdef __cplusplus
 extern "C" {
 #endif
 
 PyAPI_FUNC(void) PyThread_init_thread(void);
-PyAPI_FUNC(long) PyThread_start_new_thread(void (*)(void *), void *);
-PyAPI_FUNC(void) PyThread_exit_thread(void);
-PyAPI_FUNC(void) PyThread__PyThread_exit_thread(void);
-PyAPI_FUNC(long) PyThread_get_thread_ident(void);
+PyAPI_FUNC(int) PyThread_start_new_thread(PyThread_type_handle *, void (*)(void *), void *);
 
-PyAPI_FUNC(PyThread_type_lock) PyThread_allocate_lock(void);
-PyAPI_FUNC(void) PyThread_free_lock(PyThread_type_lock);
-PyAPI_FUNC(int) PyThread_acquire_lock(PyThread_type_lock, int);
-#define WAIT_LOCK	1
-#define NOWAIT_LOCK	0
-PyAPI_FUNC(void) PyThread_release_lock(PyThread_type_lock);
+PyAPI_FUNC(PyThread_type_handle) PyThread_get_handle(void);
+PyAPI_FUNC(void) PyThread_send_signal(PyThread_type_handle, int signum);
 
 PyAPI_FUNC(size_t) PyThread_get_stacksize(void);
 PyAPI_FUNC(int) PyThread_set_stacksize(size_t);
 
-#ifndef NO_EXIT_PROG
-PyAPI_FUNC(void) PyThread_exit_prog(int);
-PyAPI_FUNC(void) PyThread__PyThread_exit_prog(int);
-#endif
+PyAPI_FUNC(PyThread_type_lock) PyThread_lock_allocate(void);
+PyAPI_FUNC(void) PyThread_lock_free(PyThread_type_lock);
+PyAPI_FUNC(void) PyThread_lock_acquire(PyThread_type_lock);
+PyAPI_FUNC(int) _PyThread_lock_tryacquire(PyThread_type_lock);
+PyAPI_FUNC(void) PyThread_lock_release(PyThread_type_lock);
 
+PyAPI_FUNC(PyThread_type_sem) PyThread_sem_allocate(int);
+PyAPI_FUNC(void) PyThread_sem_free(PyThread_type_sem);
+PyAPI_FUNC(void) PyThread_sem_wait(PyThread_type_sem);
+PyAPI_FUNC(void) PyThread_sem_post(PyThread_type_sem);
+
+PyAPI_FUNC(PyThread_type_cond) PyThread_cond_allocate(void);
+PyAPI_FUNC(void) PyThread_cond_free(PyThread_type_cond);
+PyAPI_FUNC(void) PyThread_cond_wait(PyThread_type_cond, PyThread_type_lock);
+PyAPI_FUNC(void) PyThread_cond_wakeone(PyThread_type_cond);
+PyAPI_FUNC(void) PyThread_cond_wakeall(PyThread_type_cond);
+
 /* Thread Local Storage (TLS) API */
-PyAPI_FUNC(int) PyThread_create_key(void);
-PyAPI_FUNC(void) PyThread_delete_key(int);
-PyAPI_FUNC(int) PyThread_set_key_value(int, void *);
-PyAPI_FUNC(void *) PyThread_get_key_value(int);
-PyAPI_FUNC(void) PyThread_delete_key_value(int key);
+PyAPI_FUNC(PyThread_type_key) PyThread_create_key(void);
+PyAPI_FUNC(void) PyThread_delete_key(PyThread_type_key);
+PyAPI_FUNC(void) PyThread_set_key_value(PyThread_type_key, void *);
+PyAPI_FUNC(void *) PyThread_get_key_value(PyThread_type_key);
+PyAPI_FUNC(void) PyThread_delete_key_value(PyThread_type_key);
 
 #ifdef __cplusplus
 }
Index: Include/pyfpe.h
===================================================================
--- Include/pyfpe.h	(revision 58355)
+++ Include/pyfpe.h	(working copy)
@@ -126,6 +126,7 @@
  */
 
 #ifdef WANT_SIGFPE_HANDLER
+#error FPE currently broken.  Needs to be made thread-safe
 #include <signal.h>
 #include <setjmp.h>
 #include <math.h>
Index: Include/pysignal.h
===================================================================
--- Include/pysignal.h	(revision 0)
+++ Include/pysignal.h	(revision 0)
@@ -0,0 +1,16 @@
+#ifndef Py_PYSIGNAL_H
+#define Py_PYSIGNAL_H
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+typedef void (*PyOS_sighandler_t)(int);
+PyAPI_FUNC(PyOS_sighandler_t) PyOS_getsig(int);
+PyAPI_FUNC(PyOS_sighandler_t) PyOS_setsig(int, PyOS_sighandler_t);
+
+PyAPI_FUNC(void) PyOS_AfterFork(void);
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* !Py_PYSIGNAL_H */
Index: Include/descrobject.h
===================================================================
--- Include/descrobject.h	(revision 58355)
+++ Include/descrobject.h	(working copy)
@@ -67,6 +67,10 @@
 	void *d_wrapped; /* This can be any function pointer */
 } PyWrapperDescrObject;
 
+typedef struct {
+    PyDescr_COMMON;
+} PyFinalizeAttrDescrObject;
+
 PyAPI_DATA(PyTypeObject) PyWrapperDescr_Type;
 
 PyAPI_FUNC(PyObject *) PyDescr_NewMethod(PyTypeObject *, PyMethodDef *);
@@ -77,6 +81,7 @@
 					       struct PyGetSetDef *);
 PyAPI_FUNC(PyObject *) PyDescr_NewWrapper(PyTypeObject *,
 						struct wrapperbase *, void *);
+PyAPI_FUNC(PyObject *) PyDescr_NewFinalizeAttr(PyTypeObject *, PyObject *);
 #define PyDescr_IsData(d) (Py_Type(d)->tp_descr_set != NULL)
 
 PyAPI_FUNC(PyObject *) PyDictProxy_New(PyObject *);
Index: Include/compile.h
===================================================================
--- Include/compile.h	(revision 58355)
+++ Include/compile.h	(working copy)
@@ -24,6 +24,7 @@
 #define FUTURE_DIVISION "division"
 #define FUTURE_ABSOLUTE_IMPORT "absolute_import"
 #define FUTURE_WITH_STATEMENT "with_statement"
+#define FUTURE_SHARED_MODULE "shared_module"
 
 struct _mod; /* Declare the existence of this type */
 PyAPI_FUNC(PyCodeObject *) PyAST_Compile(struct _mod *, const char *,
Index: Include/intrcheck.h
===================================================================
--- Include/intrcheck.h	(revision 58355)
+++ Include/intrcheck.h	(working copy)
@@ -1,15 +0,0 @@
-
-#ifndef Py_INTRCHECK_H
-#define Py_INTRCHECK_H
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-PyAPI_FUNC(int) PyOS_InterruptOccurred(void);
-PyAPI_FUNC(void) PyOS_InitInterrupts(void);
-PyAPI_FUNC(void) PyOS_AfterFork(void);
-
-#ifdef __cplusplus
-}
-#endif
-#endif /* !Py_INTRCHECK_H */
Index: Include/modsupport.h
===================================================================
--- Include/modsupport.h	(revision 58355)
+++ Include/modsupport.h	(working copy)
@@ -41,7 +41,10 @@
 PyAPI_FUNC(int) PyModule_AddIntConstant(PyObject *, const char *, long);
 PyAPI_FUNC(int) PyModule_AddStringConstant(PyObject *, const char *, const char *);
 
+PyAPI_FUNC(int) PyArg_RequireShareable(const char *, PyObject *, PyObject *);
+PyAPI_FUNC(int) PyArg_RequireShareableReturn(const char *funcname, PyObject *innerfunc, PyObject *result);
 
+
 #define PYTHON_API_VERSION 1013
 #define PYTHON_API_STRING "1013"
 /* The API version is maintained (independently from the Python version)
@@ -116,6 +119,9 @@
 PyAPI_FUNC(PyObject *) Py_InitModule4(const char *name, PyMethodDef *methods,
                                       const char *doc, PyObject *self,
                                       int apiver);
+PyAPI_FUNC(PyObject *) Py_InitModule5(const char *name, PyMethodDef *methods,
+                                      const char *doc, PyObject *self,
+                                      int apiver, int shared);
 
 #define Py_InitModule(name, methods) \
 	Py_InitModule4(name, methods, (char *)NULL, (PyObject *)NULL, \
Index: Include/pyerrors.h
===================================================================
--- Include/pyerrors.h	(revision 58355)
+++ Include/pyerrors.h	(working copy)
@@ -69,13 +69,14 @@
 #ifdef Py_DEBUG
 #define _PyErr_OCCURRED() PyErr_Occurred()
 #else
-#define _PyErr_OCCURRED() (_PyThreadState_Current->curexc_type)
+#define _PyErr_OCCURRED() (PyThreadState_Get()->curexc_type)
 #endif
 
 /* Error testing and normalization */
 PyAPI_FUNC(int) PyErr_GivenExceptionMatches(PyObject *, PyObject *);
 PyAPI_FUNC(int) PyErr_ExceptionMatches(PyObject *);
 PyAPI_FUNC(void) PyErr_NormalizeException(PyObject**, PyObject**, PyObject**);
+PyAPI_FUNC(PyObject *) PyErr_SimplifyException(PyObject *, PyObject *, PyObject *);
 
 /* Traceback manipulation (PEP 3134) */
 PyAPI_FUNC(int) PyException_SetTraceback(PyObject *, PyObject *);
@@ -126,6 +127,8 @@
 PyAPI_DATA(PyObject *) PyExc_KeyError;
 PyAPI_DATA(PyObject *) PyExc_KeyboardInterrupt;
 PyAPI_DATA(PyObject *) PyExc_MemoryError;
+PyAPI_DATA(PyObject *) PyExc_MultipleError;
+PyAPI_DATA(PyObject *) PyExc_Interrupted;
 PyAPI_DATA(PyObject *) PyExc_NameError;
 PyAPI_DATA(PyObject *) PyExc_OverflowError;
 PyAPI_DATA(PyObject *) PyExc_RuntimeError;
@@ -222,10 +225,6 @@
 				   const char *, int,
 				   const char *, PyObject *);
 
-/* In sigcheck.c or signalmodule.c */
-PyAPI_FUNC(int) PyErr_CheckSignals(void);
-PyAPI_FUNC(void) PyErr_SetInterrupt(void);
-
 /* Support for adding program text to SyntaxErrors */
 PyAPI_FUNC(void) PyErr_SyntaxLocation(const char *, int);
 PyAPI_FUNC(PyObject *) PyErr_ProgramText(const char *, int);
Index: configure.in
===================================================================
--- configure.in	(revision 58355)
+++ configure.in	(working copy)
@@ -1721,26 +1721,6 @@
 fi
 AC_MSG_RESULT($with_system_ffi)
 
-# Determine if signalmodule should be used.
-AC_SUBST(USE_SIGNAL_MODULE)
-AC_SUBST(SIGNAL_OBJS)
-AC_MSG_CHECKING(for --with-signal-module)
-AC_ARG_WITH(signal-module,
-            AC_HELP_STRING(--with-signal-module, disable/enable signal module))
-
-if test -z "$with_signal_module"
-then with_signal_module="yes"
-fi
-AC_MSG_RESULT($with_signal_module)
-
-if test "${with_signal_module}" = "yes"; then
-	USE_SIGNAL_MODULE=""
-	SIGNAL_OBJS=""
-else
-	USE_SIGNAL_MODULE="#"
-	SIGNAL_OBJS="Parser/intrcheck.o Python/sigcheck.o"
-fi
-
 # This is used to generate Setup.config
 AC_SUBST(USE_THREAD_MODULE)
 USE_THREAD_MODULE=""
@@ -2200,6 +2180,20 @@
 fi],
 [AC_MSG_RESULT(no)])
 
+# Check for --with-freethread
+AC_MSG_CHECKING(for --with-freethread)
+AC_ARG_WITH(freethread,
+            AC_HELP_STRING(--with-freethread, enable free threading),
+[
+if test "$withval" != no
+then
+  AC_DEFINE(WITH_FREETHREAD, 1,
+  [Define if you want to build an interpreter with free (scalable) threading.])
+  AC_MSG_RESULT(yes);
+else AC_MSG_RESULT(no);
+fi],
+[AC_MSG_RESULT(no)])
+
 # -I${DLINCLDIR} is added to the compile rule for importdl.o
 AC_SUBST(DLINCLDIR)
 DLINCLDIR=.
Index: Objects/complexobject.c
===================================================================
--- Objects/complexobject.c	(revision 58355)
+++ Objects/complexobject.c	(working copy)
@@ -188,9 +188,11 @@
 {
 	PyObject *op;
 
-	op = type->tp_alloc(type, 0);
-	if (op != NULL)
-		((PyComplexObject *)op)->cval = cval;
+	op = PyObject_New(type);
+	if (op == NULL)
+		return NULL;
+	((PyComplexObject *)op)->cval = cval;
+	PyObject_Complete(op);
 	return op;
 }
 
@@ -200,11 +202,17 @@
 	register PyComplexObject *op;
 
 	/* Inline PyObject_New */
-	op = (PyComplexObject *) PyObject_MALLOC(sizeof(PyComplexObject));
+	//op = (PyComplexObject *) PyObject_MALLOC(sizeof(PyComplexObject));
+	//op = (PyComplexObject *)_PyObject_GC_Malloc(sizeof(PyComplexObject));
+	/* XXX FIXME _PyObject_GC_Malloc already calls PyErr_NoMemory */
+	//if (op == NULL)
+	//	return PyErr_NoMemory();
+	//PyObject_INIT(op, &PyComplex_Type);
+	op = PyObject_NEW(PyComplexObject, &PyComplex_Type);
 	if (op == NULL)
-		return PyErr_NoMemory();
-	PyObject_INIT(op, &PyComplex_Type);
+		return NULL;
 	op->cval = cval;
+	PyObject_COMPLETE(op);
 	return (PyObject *) op;
 }
 
@@ -272,10 +280,11 @@
 			if (!(complex_str = PyUnicode_FromString("__complex__")))
 				return cv;
 		}
-		complexfunc = _PyType_Lookup(op->ob_type, complex_str);
-		/* complexfunc is a borrowed reference */
+		if (_PyType_LookupEx(op->ob_type, complex_str, &complexfunc) < 0)
+			return cv;
 		if (complexfunc) {
 			newop = PyObject_CallFunctionObjArgs(complexfunc, op, NULL);
+			Py_DECREF(complexfunc);
 			if (!newop)
 				return cv;
 		}
@@ -304,7 +313,7 @@
 static void
 complex_dealloc(PyObject *op)
 {
-	op->ob_type->tp_free(op);
+	PyObject_Del(op);
 }
 
 
@@ -1005,7 +1014,8 @@
 	PyObject_GenericGetAttr,		/* tp_getattro */
 	0,					/* tp_setattro */
 	0,					/* tp_as_buffer */
-	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |
+		Py_TPFLAGS_SHAREABLE | Py_TPFLAGS_SKIPWIPE, /* tp_flags */
 	complex_doc,				/* tp_doc */
 	0,					/* tp_traverse */
 	0,					/* tp_clear */
@@ -1022,9 +1032,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	PyType_GenericAlloc,			/* tp_alloc */
 	complex_new,				/* tp_new */
-	PyObject_Del,           		/* tp_free */
 };
 
 #endif
Index: Objects/codeobject.c
===================================================================
--- Objects/codeobject.c	(revision 58355)
+++ Objects/codeobject.c	(working copy)
@@ -287,7 +287,7 @@
 	Py_XDECREF(co->co_name);
 	Py_XDECREF(co->co_lnotab);
         if (co->co_zombieframe != NULL)
-                PyObject_GC_Del(co->co_zombieframe);
+                PyObject_DEL(co->co_zombieframe);
 	PyObject_DEL(co);
 }
 
@@ -431,7 +431,6 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	0,				/* tp_init */
-	0,				/* tp_alloc */
 	code_new,			/* tp_new */
 };
 
Index: Objects/object.c
===================================================================
--- Objects/object.c	(revision 58355)
+++ Objects/object.c	(working copy)
@@ -3,28 +3,31 @@
 
 #include "Python.h"
 #include "sliceobject.h" /* For PyEllipsis_Type */
+#include "monitorobject.h"
+#include "branchobject.h"
+#include "pythread.h"
 
 #ifdef __cplusplus
 extern "C" {
 #endif
 
 #ifdef Py_REF_DEBUG
-Py_ssize_t _Py_RefTotal;
+AO_t _Py_RefTotal;
 
 Py_ssize_t
 _Py_GetRefTotal(void)
 {
 	PyObject *o;
-	Py_ssize_t total = _Py_RefTotal;
+	Py_ssize_t total = AO_load_full(&_Py_RefTotal);
         /* ignore the references to the dummy object of the dicts and sets
            because they are not reliable and not useful (now that the
            hash table code is well-tested) */
 	o = _PyDict_Dummy();
 	if (o != NULL)
-		total -= o->ob_refcnt;
+		total -= Py_RefcntSnoop(o);
 	o = _PySet_Dummy();
 	if (o != NULL)
-		total -= o->ob_refcnt;
+		total -= Py_RefcntSnoop(o);
 	return total;
 }
 #endif /* Py_REF_DEBUG */
@@ -41,10 +44,11 @@
  * exist only in a Py_TRACE_REFS build.
  */
 static PyObject refchain = {&refchain, &refchain};
+static PyThread_type_lock refchain_lock;
 
 /* Insert op at the front of the list of all objects.  If force is true,
  * op is added even if _ob_prev and _ob_next are non-NULL already.  If
- * force is false amd _ob_prev or _ob_next are non-NULL, do nothing.
+ * force is false and _ob_prev or _ob_next are non-NULL, do nothing.
  * force should be true if and only if op points to freshly allocated,
  * uninitialized memory, or you've unlinked op from the list and are
  * relinking it into the front.
@@ -56,6 +60,7 @@
 void
 _Py_AddToAllObjects(PyObject *op, int force)
 {
+	PyThread_lock_acquire(refchain_lock);
 #ifdef  Py_DEBUG
 	if (!force) {
 		/* If it's initialized memory, op must be in or out of
@@ -70,6 +75,7 @@
 		refchain._ob_next->_ob_prev = op;
 		refchain._ob_next = op;
 	}
+	PyThread_lock_release(refchain_lock);
 }
 #endif	/* Py_TRACE_REFS */
 
@@ -183,75 +189,21 @@
 #ifdef Py_REF_DEBUG
 /* Log a fatal error; doesn't return. */
 void
-_Py_NegativeRefcount(const char *fname, int lineno, PyObject *op)
+_Py_NegativeRefcount(const char *fname, int lineno, PyObject *op,
+	Py_ssize_t count)
 {
 	char buf[300];
 
 	PyOS_snprintf(buf, sizeof(buf),
 		      "%s:%i object at %p has negative ref count "
 		      "%" PY_FORMAT_SIZE_T "d",
-		      fname, lineno, op, op->ob_refcnt);
+		      fname, lineno, op, count);
 	Py_FatalError(buf);
 }
 
 #endif /* Py_REF_DEBUG */
 
-void
-Py_IncRef(PyObject *o)
-{
-    Py_XINCREF(o);
-}
 
-void
-Py_DecRef(PyObject *o)
-{
-    Py_XDECREF(o);
-}
-
-PyObject *
-PyObject_Init(PyObject *op, PyTypeObject *tp)
-{
-	if (op == NULL)
-		return PyErr_NoMemory();
-	/* Any changes should be reflected in PyObject_INIT (objimpl.h) */
-	Py_Type(op) = tp;
-	_Py_NewReference(op);
-	return op;
-}
-
-PyVarObject *
-PyObject_InitVar(PyVarObject *op, PyTypeObject *tp, Py_ssize_t size)
-{
-	if (op == NULL)
-		return (PyVarObject *) PyErr_NoMemory();
-	/* Any changes should be reflected in PyObject_INIT_VAR */
-	op->ob_size = size;
-	Py_Type(op) = tp;
-	_Py_NewReference((PyObject *)op);
-	return op;
-}
-
-PyObject *
-_PyObject_New(PyTypeObject *tp)
-{
-	PyObject *op;
-	op = (PyObject *) PyObject_MALLOC(_PyObject_SIZE(tp));
-	if (op == NULL)
-		return PyErr_NoMemory();
-	return PyObject_INIT(op, tp);
-}
-
-PyVarObject *
-_PyObject_NewVar(PyTypeObject *tp, Py_ssize_t nitems)
-{
-	PyVarObject *op;
-	const size_t size = _PyObject_VAR_SIZE(tp, nitems);
-	op = (PyVarObject *) PyObject_MALLOC(size);
-	if (op == NULL)
-		return (PyVarObject *)PyErr_NoMemory();
-	return PyObject_INIT_VAR(op, tp, nitems);
-}
-
 /* Implementation of PyObject_Print with recursion checking */
 static int
 internal_print(PyObject *op, FILE *fp, int flags, int nesting)
@@ -261,8 +213,6 @@
 		PyErr_SetString(PyExc_RuntimeError, "print recursion");
 		return -1;
 	}
-	if (PyErr_CheckSignals())
-		return -1;
 #ifdef USE_STACKCHECK
 	if (PyOS_CheckStack()) {
 		PyErr_SetString(PyExc_MemoryError, "stack overflow");
@@ -276,14 +226,14 @@
 		Py_END_ALLOW_THREADS
 	}
 	else {
-		if (op->ob_refcnt <= 0)
+		if (Py_RefcntSnoop(op) <= 0) {
 			/* XXX(twouters) cast refcount to long until %zd is
 			   universally available */
 			Py_BEGIN_ALLOW_THREADS
 			fprintf(fp, "<refcnt %ld at %p>",
-				(long)op->ob_refcnt, op);
+				(long)Py_RefcntSnoop(op), op);
 			Py_END_ALLOW_THREADS
-		else {
+		} else {
 			PyObject *s;
 			if (flags & Py_PRINT_RAW)
 				s = PyObject_Str(op);
@@ -345,7 +295,7 @@
 		fprintf(stderr, "NULL\n");
 	else {
 		fprintf(stderr, "object  : ");
-		(void)PyObject_Print(op, stderr, 0);
+		//(void)PyObject_Print(op, stderr, 0);
 		/* XXX(twouters) cast refcount to long until %zd is
 		   universally available */
 		fprintf(stderr, "\n"
@@ -353,7 +303,7 @@
 			"refcount: %ld\n"
 			"address : %p\n",
 			Py_Type(op)==NULL ? "NULL" : Py_Type(op)->tp_name,
-			(long)op->ob_refcnt,
+			(long)Py_RefcntSnoop(op),
 			op);
 	}
 }
@@ -362,8 +312,6 @@
 PyObject_Repr(PyObject *v)
 {
 	PyObject *res;
-	if (PyErr_CheckSignals())
-		return NULL;
 #ifdef USE_STACKCHECK
 	if (PyOS_CheckStack()) {
 		PyErr_SetString(PyExc_MemoryError, "stack overflow");
@@ -958,7 +906,7 @@
 		return err;
 	}
 	Py_DECREF(name);
-	assert(name->ob_refcnt >= 1);
+	assert(Py_RefcntSnoop(name) >= 1);
 	if (tp->tp_getattr == NULL && tp->tp_getattro == NULL)
 		PyErr_Format(PyExc_TypeError,
 			     "'%.100s' object has no attributes "
@@ -981,6 +929,17 @@
 PyObject **
 _PyObject_GetDictPtr(PyObject *obj)
 {
+	if (PyMonitor_Check(obj) &&
+			!PyMonitorSpace_IsCurrent(PyMonitor_GetMonitorSpace(obj))) {
+		return NULL;
+	}
+
+	return _PyObject_GetDictPtr_NoCheck(obj);
+}
+
+PyObject **
+_PyObject_GetDictPtr_NoCheck(PyObject *obj)
+{
 	Py_ssize_t dictoffset;
 	PyTypeObject *tp = Py_Type(obj);
 
@@ -1015,6 +974,7 @@
 PyObject *
 PyObject_GenericGetAttr(PyObject *obj, PyObject *name)
 {
+	PyThreadState *tstate = PyThreadState_Get();
 	PyTypeObject *tp = Py_Type(obj);
 	PyObject *descr = NULL;
 	PyObject *res = NULL;
@@ -1029,14 +989,14 @@
 		return NULL;
 	}
 	else
-		Py_INCREF(name);
+		Py_INCREFTS(name);
 
 	if (tp->tp_dict == NULL) {
 		if (PyType_Ready(tp) < 0)
 			goto done;
 	}
 
-	/* Inline _PyType_Lookup */
+	/* Inline _PyType_LookupEx */
 	{
 		Py_ssize_t i, n;
 		PyObject *mro, *base, *dict;
@@ -1051,27 +1011,27 @@
 			assert(PyType_Check(base));
 			dict = ((PyTypeObject *)base)->tp_dict;
 			assert(dict && PyDict_Check(dict));
-			descr = PyDict_GetItem(dict, name);
+			if (PyDict_GetItemEx(dict, name, &descr) < 0)
+				goto done;
 			if (descr != NULL)
 				break;
 		}
 	}
 
-	Py_XINCREF(descr);
-
 	f = NULL;
 	if (descr != NULL) {
 		f = descr->ob_type->tp_descr_get;
 		if (f != NULL && PyDescr_IsData(descr)) {
 			res = f(descr, obj, (PyObject *)obj->ob_type);
-			Py_DECREF(descr);
+			Py_DECREFTS(descr);
 			goto done;
 		}
 	}
 
 	/* Inline _PyObject_GetDictPtr */
 	dictoffset = tp->tp_dictoffset;
-	if (dictoffset != 0) {
+	if (dictoffset != 0 && !(PyMonitor_Check(obj) &&
+			!PyMonitorSpace_IsCurrent(PyMonitor_GetMonitorSpace(obj)))) {
 		PyObject *dict;
 		if (dictoffset < 0) {
 			Py_ssize_t tsize;
@@ -1089,10 +1049,8 @@
 		dictptr = (PyObject **) ((char *)obj + dictoffset);
 		dict = *dictptr;
 		if (dict != NULL) {
-			res = PyDict_GetItem(dict, name);
-			if (res != NULL) {
-				Py_INCREF(res);
-				Py_XDECREF(descr);
+			if (PyDict_GetItemEx(dict, name, &res) <= 0) {
+				Py_XDECREFTS(descr);
 				goto done;
 			}
 		}
@@ -1100,7 +1058,7 @@
 
 	if (f != NULL) {
 		res = f(descr, obj, (PyObject *)Py_Type(obj));
-		Py_DECREF(descr);
+		Py_DECREFTS(descr);
 		goto done;
 	}
 
@@ -1114,7 +1072,7 @@
 		     "'%.50s' object has no attribute '%.400s'",
 		     tp->tp_name, PyUnicode_AsString(name));
   done:
-	Py_DECREF(name);
+	Py_DECREFTS(name);
 	return res;
 }
 
@@ -1122,7 +1080,7 @@
 PyObject_GenericSetAttr(PyObject *obj, PyObject *name, PyObject *value)
 {
 	PyTypeObject *tp = Py_Type(obj);
-	PyObject *descr;
+	PyObject *descr = NULL;
 	descrsetfunc f;
 	PyObject **dictptr;
 	int res = -1;
@@ -1141,7 +1099,8 @@
 			goto done;
 	}
 
-	descr = _PyType_Lookup(tp, name);
+	if (_PyType_LookupEx(tp, name, &descr) < 0)
+		goto done;
 	f = NULL;
 	if (descr != NULL) {
 		f = descr->ob_type->tp_descr_set;
@@ -1188,6 +1147,7 @@
 		     tp->tp_name, name);
   done:
 	Py_DECREF(name);
+	Py_XDECREF(descr);
 	return res;
 }
 
@@ -1242,6 +1202,16 @@
 	return x->ob_type->tp_call != NULL;
 }
 
+/* Test whether an object is shareable */
+
+int
+PyObject_IsShareable(PyObject *x)
+{
+	if (x->ob_type->tp_isshareable != NULL)
+		return x->ob_type->tp_isshareable(x);
+	return 0;
+}
+
 /* ------------------------- PyObject_Dir() helpers ------------------------- */
 
 /* Helper for PyObject_Dir.
@@ -1509,7 +1479,13 @@
 	Py_FatalError("deallocating None");
 }
 
+static int
+none_isshareable(PyObject *ignore)
+{
+	return 1;
+}
 
+
 static PyTypeObject PyNone_Type = {
 	PyVarObject_HEAD_INIT(&PyType_Type, 0)
 	"NoneType",
@@ -1524,13 +1500,46 @@
 	0,		/*tp_as_number*/
 	0,		/*tp_as_sequence*/
 	0,		/*tp_as_mapping*/
-	0,		/*tp_hash */
+	0,		/*tp_hash*/
+	0,		/*tp_call*/
+	0,		/*tp_str*/
+	0,		/*tp_getattro*/
+	0,		/*tp_setattro*/
+	0,		/*tp_as_buffer*/
+	Py_TPFLAGS_SHAREABLE,	/*tp_flags*/
+	0,		/* tp_doc */
+	0,		/* tp_traverse */
+	0,		/* tp_clear */
+	0,		/* tp_richcompare */
+	0,		/* tp_weaklistoffset */
+	0,		/* tp_iter */
+	0,		/* tp_iternext */
+	0,		/* tp_methods */
+	0,		/* tp_members */
+	0,		/* tp_getset */
+	0,		/* tp_base */
+	0,		/* tp_dict */
+	0,		/* tp_descr_get */
+	0,		/* tp_descr_set */
+	0,		/* tp_dictoffset */
+	0,		/* tp_init */
+	0,		/* tp_new */
+	0,		/* tp_is_gc */
+	0,		/* tp_bases */
+	0,		/* tp_mro */
+	0,		/* tp_cache */
+	0,		/* tp_subclasses */
+	0,		/* tp_weaklist */
+	none_isshareable,	/* tp_isshareable */
 };
 
+/*
 PyObject _Py_NoneStruct = {
   _PyObject_EXTRA_INIT
   1, &PyNone_Type
 };
+*/
+PyObject _Py_NoneStruct = PyObject_HEAD_INIT_NOCOMMA(&PyNone_Type);
 
 /* NotImplemented is an object that can be used to signal that an
    operation is not implemented for the given type combination. */
@@ -1556,22 +1565,64 @@
 	0,		/*tp_as_sequence*/
 	0,		/*tp_as_mapping*/
 	0,		/*tp_hash */
+	0,		/*tp_call*/
+	0,		/*tp_str*/
+	0,		/*tp_getattro*/
+	0,		/*tp_setattro*/
+	0,		/*tp_as_buffer*/
+	Py_TPFLAGS_SHAREABLE,	/*tp_flags*/
+	0,		/* tp_doc */
+	0,		/* tp_traverse */
+	0,		/* tp_clear */
+	0,		/* tp_richcompare */
+	0,		/* tp_weaklistoffset */
+	0,		/* tp_iter */
+	0,		/* tp_iternext */
+	0,		/* tp_methods */
+	0,		/* tp_members */
+	0,		/* tp_getset */
+	0,		/* tp_base */
+	0,		/* tp_dict */
+	0,		/* tp_descr_get */
+	0,		/* tp_descr_set */
+	0,		/* tp_dictoffset */
+	0,		/* tp_init */
+	0,		/* tp_new */
+	0,		/* tp_is_gc */
+	0,		/* tp_bases */
+	0,		/* tp_mro */
+	0,		/* tp_cache */
+	0,		/* tp_subclasses */
+	0,		/* tp_weaklist */
+	none_isshareable,	/* tp_isshareable */
 };
 
+/*
 PyObject _Py_NotImplementedStruct = {
 	_PyObject_EXTRA_INIT
 	1, &PyNotImplemented_Type
 };
+*/
+PyObject _Py_NotImplementedStruct = PyObject_HEAD_INIT_NOCOMMA(&PyNotImplemented_Type);
 
+extern PyTypeObject PyRange_Type;
+extern PyTypeObject PyInterrupt_Type;
+
 void
 _Py_ReadyTypes(void)
 {
 	if (PyType_Ready(&PyType_Type) < 0)
 		Py_FatalError("Can't initialize 'type'");
 
-	if (PyType_Ready(&_PyWeakref_RefType) < 0)
+	if (PyType_Ready(&_PyWeakref_Type) < 0)
 		Py_FatalError("Can't initialize 'weakref'");
 
+	if (PyType_Ready(&_PyDeathQueueHandle_Type) < 0)
+		Py_FatalError("Can't initialize 'deathqueuehandle'");
+
+	if (PyType_Ready(&_PyDeathQueue_Type) < 0)
+		Py_FatalError("Can't initialize 'deathqueue'");
+
 	if (PyType_Ready(&PyBool_Type) < 0)
 		Py_FatalError("Can't initialize 'bool'");
 
@@ -1595,114 +1646,32 @@
 
 	if (PyType_Ready(&PyCode_Type) < 0)
 		Py_FatalError("Can't initialize 'code'");
-}
 
+	if (PyType_Ready(&PyRange_Type) < 0)
+		Py_FatalError("Can't initialize 'range'");
 
-#ifdef Py_TRACE_REFS
+	PySharedDict_Type.tp_base = &PyDict_Type;
+	if (PyType_Ready(&PySharedDict_Type) < 0)
+		Py_FatalError("Can't initialize 'shareddict'");
 
-void
-_Py_NewReference(PyObject *op)
-{
-	_Py_INC_REFTOTAL;
-	op->ob_refcnt = 1;
-	_Py_AddToAllObjects(op, 1);
-	_Py_INC_TPALLOCS(op);
-}
+	PyMonitorMeta_Type.tp_base = &PyType_Type;
+	if (PyType_Ready(&PyMonitorMeta_Type) < 0)
+		Py_FatalError("Can't initialize 'MonitorMeta'");
 
-void
-_Py_ForgetReference(register PyObject *op)
-{
-#ifdef SLOW_UNREF_CHECK
-        register PyObject *p;
-#endif
-	if (op->ob_refcnt < 0)
-		Py_FatalError("UNREF negative refcnt");
-	if (op == &refchain ||
-	    op->_ob_prev->_ob_next != op || op->_ob_next->_ob_prev != op)
-		Py_FatalError("UNREF invalid object");
-#ifdef SLOW_UNREF_CHECK
-	for (p = refchain._ob_next; p != &refchain; p = p->_ob_next) {
-		if (p == op)
-			break;
-	}
-	if (p == &refchain) /* Not found */
-		Py_FatalError("UNREF unknown object");
-#endif
-	op->_ob_next->_ob_prev = op->_ob_prev;
-	op->_ob_prev->_ob_next = op->_ob_next;
-	op->_ob_next = op->_ob_prev = NULL;
-	_Py_INC_TPFREES(op);
-}
+	if (PyType_Ready(&PyMonitor_Type) < 0)
+		Py_FatalError("Can't initialize 'Monitor'");
 
-void
-_Py_Dealloc(PyObject *op)
-{
-	destructor dealloc = Py_Type(op)->tp_dealloc;
-	_Py_ForgetReference(op);
-	(*dealloc)(op);
-}
+	if (PyType_Ready(&PyMonitorSpace_Type) < 0)
+		Py_FatalError("Can't initialize 'MonitorSpace'");
 
-/* Print all live objects.  Because PyObject_Print is called, the
- * interpreter must be in a healthy state.
- */
-void
-_Py_PrintReferences(FILE *fp)
-{
-	PyObject *op;
-	fprintf(fp, "Remaining objects:\n");
-	for (op = refchain._ob_next; op != &refchain; op = op->_ob_next) {
-		fprintf(fp, "%p [%" PY_FORMAT_SIZE_T "d] ", op, op->ob_refcnt);
-		if (PyObject_Print(op, fp, 0) != 0)
-			PyErr_Clear();
-		putc('\n', fp);
-	}
-}
+	if (PyType_Ready(&PyBranch_Type) < 0)
+		Py_FatalError("Can't initialize 'branch'");
 
-/* Print the addresses of all live objects.  Unlike _Py_PrintReferences, this
- * doesn't make any calls to the Python C API, so is always safe to call.
- */
-void
-_Py_PrintReferenceAddresses(FILE *fp)
-{
-	PyObject *op;
-	fprintf(fp, "Remaining object addresses:\n");
-	for (op = refchain._ob_next; op != &refchain; op = op->_ob_next)
-		fprintf(fp, "%p [%" PY_FORMAT_SIZE_T "d] %s\n", op,
-			op->ob_refcnt, Py_Type(op)->tp_name);
+	if (PyType_Ready(&PyInterrupt_Type) < 0)
+		Py_FatalError("Can't initialize 'Interrupt' type");
 }
 
-PyObject *
-_Py_GetObjects(PyObject *self, PyObject *args)
-{
-	int i, n;
-	PyObject *t = NULL;
-	PyObject *res, *op;
 
-	if (!PyArg_ParseTuple(args, "i|O", &n, &t))
-		return NULL;
-	op = refchain._ob_next;
-	res = PyList_New(0);
-	if (res == NULL)
-		return NULL;
-	for (i = 0; (n == 0 || i < n) && op != &refchain; i++) {
-		while (op == self || op == args || op == res || op == t ||
-		       (t != NULL && Py_Type(op) != (PyTypeObject *) t)) {
-			op = op->_ob_next;
-			if (op == &refchain)
-				return res;
-		}
-		if (PyList_Append(res, op) < 0) {
-			Py_DECREF(res);
-			return NULL;
-		}
-		op = op->_ob_next;
-	}
-	return res;
-}
-
-#endif
-
-
 /* Hack to force loading of cobject.o */
 PyTypeObject *_Py_cobject_hack = &PyCObject_Type;
 
@@ -1713,6 +1682,8 @@
 
 /* Python's malloc wrappers (see pymem.h) */
 
+#if 1
+#else
 void *
 PyMem_Malloc(size_t nbytes)
 {
@@ -1730,6 +1701,7 @@
 {
 	PyMem_FREE(p);
 }
+#endif
 
 
 /* These methods are used to control infinite recursion in repr, str, print,
@@ -1797,56 +1769,6 @@
 	}
 }
 
-/* Trashcan support. */
-
-/* Current call-stack depth of tp_dealloc calls. */
-int _PyTrash_delete_nesting = 0;
-
-/* List of objects that still need to be cleaned up, singly linked via their
- * gc headers' gc_prev pointers.
- */
-PyObject *_PyTrash_delete_later = NULL;
-
-/* Add op to the _PyTrash_delete_later list.  Called when the current
- * call-stack depth gets large.  op must be a currently untracked gc'ed
- * object, with refcount 0.  Py_DECREF must already have been called on it.
- */
-void
-_PyTrash_deposit_object(PyObject *op)
-{
-	assert(PyObject_IS_GC(op));
-	assert(_Py_AS_GC(op)->gc.gc_refs == _PyGC_REFS_UNTRACKED);
-	assert(op->ob_refcnt == 0);
-	_Py_AS_GC(op)->gc.gc_prev = (PyGC_Head *)_PyTrash_delete_later;
-	_PyTrash_delete_later = op;
-}
-
-/* Dealloccate all the objects in the _PyTrash_delete_later list.  Called when
- * the call-stack unwinds again.
- */
-void
-_PyTrash_destroy_chain(void)
-{
-	while (_PyTrash_delete_later) {
-		PyObject *op = _PyTrash_delete_later;
-		destructor dealloc = Py_Type(op)->tp_dealloc;
-
-		_PyTrash_delete_later =
-			(PyObject*) _Py_AS_GC(op)->gc.gc_prev;
-
-		/* Call the deallocator directly.  This used to try to
-		 * fool Py_DECREF into calling it indirectly, but
-		 * Py_DECREF was already called on this object, and in
-		 * assorted non-release builds calling Py_DECREF again ends
-		 * up distorting allocation statistics.
-		 */
-		assert(op->ob_refcnt == 0);
-		++_PyTrash_delete_nesting;
-		(*dealloc)(op);
-		--_PyTrash_delete_nesting;
-	}
-}
-
 #ifdef __cplusplus
 }
 #endif
Index: Objects/cellobject.c
===================================================================
--- Objects/cellobject.c	(revision 58355)
+++ Objects/cellobject.c	(working copy)
@@ -7,13 +7,12 @@
 {
 	PyCellObject *op;
 
-	op = (PyCellObject *)PyObject_GC_New(PyCellObject, &PyCell_Type);
+	op = PyObject_NEW(PyCellObject, &PyCell_Type);
 	if (op == NULL)
 		return NULL;
 	op->ob_ref = obj;
 	Py_XINCREF(obj);
-
-	_PyObject_GC_TRACK(op);
+	PyObject_COMPLETE(op);
 	return (PyObject *)op;
 }
 
@@ -44,9 +43,8 @@
 static void
 cell_dealloc(PyCellObject *op)
 {
-	_PyObject_GC_UNTRACK(op);
 	Py_XDECREF(op->ob_ref);
-	PyObject_GC_Del(op);
+	PyObject_DEL(op);
 }
 
 static PyObject *
@@ -106,7 +104,7 @@
 	PyObject_GenericGetAttr,		/* tp_getattro */
 	0,					/* tp_setattro */
 	0,					/* tp_as_buffer */
-	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,/* tp_flags */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_SKIPWIPE, /* tp_flags */
  	0,					/* tp_doc */
  	(traverseproc)cell_traverse,		/* tp_traverse */
  	(inquiry)cell_clear,			/* tp_clear */
Index: Objects/methodobject.c
===================================================================
--- Objects/methodobject.c	(revision 58355)
+++ Objects/methodobject.c	(working copy)
@@ -3,29 +3,40 @@
 
 #include "Python.h"
 #include "structmember.h"
+#include "pythread.h"
 
+#ifdef USE_METHOD_FREELIST
 static PyCFunctionObject *free_list = NULL;
+static PyThread_type_lock free_list_lock;
+#endif
 
 PyObject *
 PyCFunction_NewEx(PyMethodDef *ml, PyObject *self, PyObject *module)
 {
 	PyCFunctionObject *op;
+#ifdef USE_METHOD_FREELIST
+	PyThread_lock_acquire(free_list_lock);
 	op = free_list;
 	if (op != NULL) {
 		free_list = (PyCFunctionObject *)(op->m_self);
+		PyThread_lock_release(free_list_lock);
 		PyObject_INIT(op, &PyCFunction_Type);
+		_PyObject_GC_TRACK(op);
 	}
 	else {
-		op = PyObject_GC_New(PyCFunctionObject, &PyCFunction_Type);
+		PyThread_lock_release(free_list_lock);
+#endif
+		op = PyObject_NEW(PyCFunctionObject, &PyCFunction_Type);
 		if (op == NULL)
 			return NULL;
+#ifdef USE_METHOD_FREELIST
 	}
+#endif
 	op->m_ml = ml;
 	Py_XINCREF(self);
 	op->m_self = self;
 	Py_XINCREF(module);
 	op->m_module = module;
-	_PyObject_GC_TRACK(op);
 	return (PyObject *)op;
 }
 
@@ -67,7 +78,8 @@
 	PyObject *self = PyCFunction_GET_SELF(func);
 	Py_ssize_t size;
 
-	switch (PyCFunction_GET_FLAGS(func) & ~(METH_CLASS | METH_STATIC | METH_COEXIST)) {
+	switch (PyCFunction_GET_FLAGS(func) & ~(METH_CLASS | METH_STATIC |
+			METH_COEXIST | METH_SHARED)) {
 	case METH_VARARGS:
 		if (kw == NULL || PyDict_Size(kw) == 0)
 			return (*meth)(self, arg);
@@ -113,11 +125,16 @@
 static void
 meth_dealloc(PyCFunctionObject *m)
 {
-	_PyObject_GC_UNTRACK(m);
 	Py_XDECREF(m->m_self);
 	Py_XDECREF(m->m_module);
+#ifdef USE_METHOD_FREELIST
+	PyThread_lock_acquire(free_list_lock);
 	m->m_self = (PyObject *)free_list;
 	free_list = m;
+	PyThread_lock_release(free_list_lock);
+#else
+	PyObject_DEL(m);
+#endif
 }
 
 static PyObject *
@@ -230,7 +247,15 @@
 	return x;
 }
 
+static int
+meth_isshareable(PyCFunctionObject *a)
+{
+	if (a->m_ml->ml_flags & METH_SHARED)
+		return 1;
+	return 0;
+}
 
+
 PyTypeObject PyCFunction_Type = {
 	PyVarObject_HEAD_INIT(&PyType_Type, 0)
 	"builtin_function_or_method",
@@ -264,6 +289,18 @@
 	meth_getsets,				/* tp_getset */
 	0,					/* tp_base */
 	0,					/* tp_dict */
+	0,					/* tp_descr_get */
+	0,					/* tp_descr_set */
+	0,					/* tp_dictoffset */
+	0,					/* tp_init */
+	0,					/* tp_new */
+	0,					/* tp_is_gc */
+	0,					/* tp_bases */
+	0,					/* tp_mro */
+	0,					/* tp_cache */
+	0,					/* tp_subclasses */
+	0,					/* tp_weaklist */
+	(isshareablefunc)meth_isshareable,	/* tp_isshareable */
 };
 
 /* Find a method in a method chain */
@@ -303,16 +340,31 @@
 	return Py_FindMethodInChain(&chain, self, name);
 }
 
+void
+_PyCFunction_Init(void)
+{
+#ifdef USE_METHOD_FREELIST
+	free_list_lock = PyThread_lock_allocate();
+	if (!free_list_lock)
+		Py_FatalError("unable to allocate lock");
+#endif
+}
+
 /* Clear out the free list */
 
 void
 PyCFunction_Fini(void)
 {
+#ifdef USE_METHOD_FREELIST
 	while (free_list) {
 		PyCFunctionObject *v = free_list;
 		free_list = (PyCFunctionObject *)(v->m_self);
-		PyObject_GC_Del(v);
+		PyObject_DEL(v);
 	}
+
+	PyThread_lock_free(free_list_lock);
+	free_list_lock = NULL;
+#endif
 }
 
 /* PyCFunction_New() is now just a macro that calls PyCFunction_NewEx(),
Index: Objects/typeobject.c
===================================================================
--- Objects/typeobject.c	(revision 58355)
+++ Objects/typeobject.c	(working copy)
@@ -3,6 +3,7 @@
 #include "Python.h"
 #include "frameobject.h"
 #include "structmember.h"
+#include "monitorobject.h"
 
 #include <ctype.h>
 
@@ -90,15 +91,14 @@
 	char *s;
 
 	if (type->tp_flags & Py_TPFLAGS_HEAPTYPE) {
-		mod = PyDict_GetItemString(type->tp_dict, "__module__");
-		if (!mod) { 
+		if (PyDict_GetItemStringEx(type->tp_dict, "__module__", &mod) < 0)
+			return NULL;
+		if (mod == NULL) {
 			PyErr_Format(PyExc_AttributeError, "__module__");
-			return 0;
+			return NULL;
 		}
-		Py_XINCREF(mod);
 		return mod;
-	}
-	else {
+	} else {
 		s = strrchr(type->tp_name, '.');
 		if (s != NULL)
 			return PyUnicode_FromStringAndSize(
@@ -150,7 +150,7 @@
 	PyTypeObject *subclass;
 	PyObject *ref, *subclasses, *old_mro;
 	Py_ssize_t i, n;
-
+#if 0
 	subclasses = type->tp_subclasses;
 	if (subclasses == NULL)
 		return 0;
@@ -182,6 +182,7 @@
 		if (mro_subclasses(subclass, temp) < 0)
 			return -1;
 	}
+#endif
 	return 0;
 }
 
@@ -342,18 +343,19 @@
 	PyObject *result;
 	if (!(type->tp_flags & Py_TPFLAGS_HEAPTYPE) && type->tp_doc != NULL)
 		return PyUnicode_FromString(type->tp_doc);
-	result = PyDict_GetItemString(type->tp_dict, "__doc__");
+	if (PyDict_GetItemStringEx(type->tp_dict, "__doc--", &result) < 0)
+		return NULL;
 	if (result == NULL) {
-		result = Py_None;
-		Py_INCREF(result);
+		Py_INCREF(Py_None);
+		return Py_None;
 	}
-	else if (Py_Type(result)->tp_descr_get) {
-		result = Py_Type(result)->tp_descr_get(result, NULL,
-						       (PyObject *)type);
+	
+	if (Py_Type(result)->tp_descr_get) {
+		PyObject *tmp = Py_Type(result)->tp_descr_get(result,
+			NULL, (PyObject *)type);
+		Py_DECREF(result);
+		result = tmp;
 	}
-	else {
-		Py_INCREF(result);
-	}
 	return result;
 }
 
@@ -419,10 +421,49 @@
 		    (kwds == NULL ||
 		     (PyDict_Check(kwds) && PyDict_Size(kwds) == 0)))
 			return obj;
+
 		/* If the returned object is not an instance of type,
 		   it won't be initialized. */
 		if (!PyType_IsSubtype(Py_Type(obj), type))
 			return obj;
+
+		if (PyType_HasFeature(type, Py_TPFLAGS_HAVE_FINALIZE)) {
+			PyObject *queue, *handle;
+			PyObject *core = type->tp_new(type, args, kwds);
+			if (core == NULL) {
+				Py_DECREF(obj);
+				return NULL;
+			}
+			if (PyObject_SetAttrString(obj, "__finalizecore__", core) == -1) {
+				Py_DECREF(obj);
+				Py_DECREF(core);
+				return NULL;
+			}
+
+			queue = PySys_GetObject("finalizequeue");
+			if (queue == NULL) {
+				PyErr_SetString(PyExc_RuntimeError, "lost sys.finalizequeue");
+				Py_DECREF(obj);
+				Py_DECREF(core);
+				return NULL;
+			}
+			handle = PyObject_CallMethod(queue, "watch", "OO", obj, core);
+			//Py_DECREF(queue); // PySys_GetObject returns a borrowed reference
+			if (handle == NULL) {
+				Py_DECREF(obj);
+				Py_DECREF(core);
+				return NULL;
+			}
+			if (PyObject_SetAttrString(obj, "__finalizehandle__", handle) == -1) {
+				Py_DECREF(handle);
+				Py_DECREF(obj);
+				Py_DECREF(core);
+				return NULL;
+			}
+			Py_DECREF(handle);
+			Py_DECREF(core);
+		}
+
 		type = Py_Type(obj);
 		if (type->tp_init != NULL &&
 		    type->tp_init(obj, args, kwds) < 0) {
@@ -434,39 +475,9 @@
 }
 
 PyObject *
-PyType_GenericAlloc(PyTypeObject *type, Py_ssize_t nitems)
-{
-	PyObject *obj;
-	const size_t size = _PyObject_VAR_SIZE(type, nitems+1);
-	/* note that we need to add one, for the sentinel */
-
-	if (PyType_IS_GC(type))
-		obj = _PyObject_GC_Malloc(size);
-	else
-		obj = (PyObject *)PyObject_MALLOC(size);
-
-	if (obj == NULL)
-		return PyErr_NoMemory();
-
-	memset(obj, '\0', size);
-
-	if (type->tp_flags & Py_TPFLAGS_HEAPTYPE)
-		Py_INCREF(type);
-
-	if (type->tp_itemsize == 0)
-		PyObject_INIT(obj, type);
-	else
-		(void) PyObject_INIT_VAR((PyVarObject *)obj, type, nitems);
-
-	if (PyType_IS_GC(type))
-		_PyObject_GC_TRACK(obj);
-	return obj;
-}
-
-PyObject *
 PyType_GenericNew(PyTypeObject *type, PyObject *args, PyObject *kwds)
 {
-	return type->tp_alloc(type, 0);
+	return PyObject_New(type);
 }
 
 /* Helpers for subtyping */
@@ -514,16 +525,19 @@
 	}
 
 	if (type->tp_dictoffset != base->tp_dictoffset) {
-		PyObject **dictptr = _PyObject_GetDictPtr(self);
+		PyObject **dictptr = _PyObject_GetDictPtr_NoCheck(self);
 		if (dictptr && *dictptr)
 			Py_VISIT(*dictptr);
 	}
 
+#if 0
+	/* XXX gc_traverse does this directly now */
 	if (type->tp_flags & Py_TPFLAGS_HEAPTYPE)
 		/* For a heaptype, the instances count as references
-		   to the type.	 Traverse the type so the collector
+		   to the type.  Traverse the type so the collector
 		   can find cycles involving this link. */
 		Py_VISIT(type);
+#endif
 
 	if (basetraverse)
 		return basetraverse(self, visit, arg);
@@ -585,93 +599,11 @@
 	type = Py_Type(self);
 	assert(type->tp_flags & Py_TPFLAGS_HEAPTYPE);
 
-	/* Test whether the type has GC exactly once */
-
-	if (!PyType_IS_GC(type)) {
-		/* It's really rare to find a dynamic type that doesn't have
-		   GC; it can only happen when deriving from 'object' and not
-		   adding any slots or instance variables.  This allows
-		   certain simplifications: there's no need to call
-		   clear_slots(), or DECREF the dict, or clear weakrefs. */
-
-		/* Maybe call finalizer; exit early if resurrected */
-		if (type->tp_del) {
-			type->tp_del(self);
-			if (self->ob_refcnt > 0)
-				return;
-		}
-
-		/* Find the nearest base with a different tp_dealloc */
-		base = type;
-		while ((basedealloc = base->tp_dealloc) == subtype_dealloc) {
-			assert(Py_Size(base) == 0);
-			base = base->tp_base;
-			assert(base);
-		}
-
-		/* Call the base tp_dealloc() */
-		assert(basedealloc);
-		basedealloc(self);
-
-		/* Can't reference self beyond this point */
-		Py_DECREF(type);
-
-		/* Done */
-		return;
-	}
-
-	/* We get here only if the type has GC */
-
-	/* UnTrack and re-Track around the trashcan macro, alas */
-	/* See explanation at end of function for full disclosure */
-	PyObject_GC_UnTrack(self);
-	++_PyTrash_delete_nesting;
-	Py_TRASHCAN_SAFE_BEGIN(self);
-	--_PyTrash_delete_nesting;
-	/* DO NOT restore GC tracking at this point.  weakref callbacks
-	 * (if any, and whether directly here or indirectly in something we
-	 * call) may trigger GC, and if self is tracked at that point, it
-	 * will look like trash to GC and GC will try to delete self again.
+	/* Find the nearest base with a different tp_dealloc
+	 * Clear slots up to the nearest base with a different tp_dealloc
 	 */
-
-	/* Find the nearest base with a different tp_dealloc */
 	base = type;
 	while ((basedealloc = base->tp_dealloc) == subtype_dealloc) {
-		base = base->tp_base;
-		assert(base);
-	}
-
-	/* If we added a weaklist, we clear it.	 Do this *before* calling
-	   the finalizer (__del__), clearing slots, or clearing the instance
-	   dict. */
-
-	if (type->tp_weaklistoffset && !base->tp_weaklistoffset)
-		PyObject_ClearWeakRefs(self);
-
-	/* Maybe call finalizer; exit early if resurrected */
-	if (type->tp_del) {
-		_PyObject_GC_TRACK(self);
-		type->tp_del(self);
-		if (self->ob_refcnt > 0)
-			goto endlabel;	/* resurrected */
-		else
-			_PyObject_GC_UNTRACK(self);
-		/* New weakrefs could be created during the finalizer call.
-		    If this occurs, clear them out without calling their
-		    finalizers since they might rely on part of the object
-		    being finalized that has already been destroyed. */
-		if (type->tp_weaklistoffset && !base->tp_weaklistoffset) {
-			/* Modeled after GET_WEAKREFS_LISTPTR() */
-			PyWeakReference **list = (PyWeakReference **) \
-				PyObject_GET_WEAKREFS_LISTPTR(self);
-			while (*list)
-				_PyWeakref_ClearRef(*list);
-		}
-	}
-
-	/*  Clear slots up to the nearest base with a different tp_dealloc */
-	base = type;
-	while ((basedealloc = base->tp_dealloc) == subtype_dealloc) {
 		if (Py_Size(base))
 			clear_slots(base, self);
 		base = base->tp_base;
@@ -680,7 +612,7 @@
 
 	/* If we added a dict, DECREF it */
 	if (type->tp_dictoffset && !base->tp_dictoffset) {
-		PyObject **dictptr = _PyObject_GetDictPtr(self);
+		PyObject **dictptr = _PyObject_GetDictPtr_NoCheck(self);
 		if (dictptr != NULL) {
 			PyObject *dict = *dictptr;
 			if (dict != NULL) {
@@ -690,119 +622,9 @@
 		}
 	}
 
-	/* Call the base tp_dealloc(); first retrack self if
-	 * basedealloc knows about gc.
-	 */
-	if (PyType_IS_GC(base))
-		_PyObject_GC_TRACK(self);
+	/* Call the base tp_dealloc() */
 	assert(basedealloc);
 	basedealloc(self);
-
-	/* Can't reference self beyond this point */
-	Py_DECREF(type);
-
-  endlabel:
-	++_PyTrash_delete_nesting;
-	Py_TRASHCAN_SAFE_END(self);
-	--_PyTrash_delete_nesting;
-
-	/* Explanation of the weirdness around the trashcan macros:
-
-	   Q. What do the trashcan macros do?
-
-	   A. Read the comment titled "Trashcan mechanism" in object.h.
-	      For one, this explains why there must be a call to GC-untrack
-	      before the trashcan begin macro.	Without understanding the
-	      trashcan code, the answers to the following questions don't make
-	      sense.
-
-	   Q. Why do we GC-untrack before the trashcan and then immediately
-	      GC-track again afterward?
-
-	   A. In the case that the base class is GC-aware, the base class
-	      probably GC-untracks the object.	If it does that using the
-	      UNTRACK macro, this will crash when the object is already
-	      untracked.  Because we don't know what the base class does, the
-	      only safe thing is to make sure the object is tracked when we
-	      call the base class dealloc.  But...  The trashcan begin macro
-	      requires that the object is *untracked* before it is called.  So
-	      the dance becomes:
-
-		 GC untrack
-		 trashcan begin
-		 GC track
-
-	   Q. Why did the last question say "immediately GC-track again"?
-	      It's nowhere near immediately.
-
-	   A. Because the code *used* to re-track immediately.	Bad Idea.
-	      self has a refcount of 0, and if gc ever gets its hands on it
-	      (which can happen if any weakref callback gets invoked), it
-	      looks like trash to gc too, and gc also tries to delete self
-	      then.  But we're already deleting self.  Double dealloction is
-	      a subtle disaster.
-
-	   Q. Why the bizarre (net-zero) manipulation of
-	      _PyTrash_delete_nesting around the trashcan macros?
-
-	   A. Some base classes (e.g. list) also use the trashcan mechanism.
-	      The following scenario used to be possible:
-
-	      - suppose the trashcan level is one below the trashcan limit
-
-	      - subtype_dealloc() is called
-
-	      - the trashcan limit is not yet reached, so the trashcan level
-		is incremented and the code between trashcan begin and end is
-		executed
-
-	      - this destroys much of the object's contents, including its
-		slots and __dict__
-
-	      - basedealloc() is called; this is really list_dealloc(), or
-		some other type which also uses the trashcan macros
-
-	      - the trashcan limit is now reached, so the object is put on the
-		trashcan's to-be-deleted-later list
-
-	      - basedealloc() returns
-
-	      - subtype_dealloc() decrefs the object's type
-
-	      - subtype_dealloc() returns
-
-	      - later, the trashcan code starts deleting the objects from its
-		to-be-deleted-later list
-
-	      - subtype_dealloc() is called *AGAIN* for the same object
-
-	      - at the very least (if the destroyed slots and __dict__ don't
-		cause problems) the object's type gets decref'ed a second
-		time, which is *BAD*!!!
-
-	      The remedy is to make sure that if the code between trashcan
-	      begin and end in subtype_dealloc() is called, the code between
-	      trashcan begin and end in basedealloc() will also be called.
-	      This is done by decrementing the level after passing into the
-	      trashcan block, and incrementing it just before leaving the
-	      block.
-
-	      But now it's possible that a chain of objects consisting solely
-	      of objects whose deallocator is subtype_dealloc() will defeat
-	      the trashcan mechanism completely: the decremented level means
-	      that the effective level never reaches the limit.	 Therefore, we
-	      *increment* the level *before* entering the trashcan block, and
-	      matchingly decrement it after leaving.  This means the trashcan
-	      code will trigger a little early, but that's no big deal.
-
-	   Q. Are there any live examples of code in need of all this
-	      complexity?
-
-	   A. Yes.  See SF bug 668433 for code that crashed (when Python was
-	      compiled in debug mode) before the trashcan level manipulations
-	      were added.  For more discussion, see SF patches 581742, 575073
-	      and bug 574207.
-	*/
 }
 
 static PyTypeObject *solid_base(PyTypeObject *type);
@@ -841,14 +663,14 @@
 /* Internal routines to do a method lookup in the type
    without looking in the instance dictionary
    (so we can't use PyObject_GetAttr) but still binding
-   it to the instance.	The arguments are the object,
+   it to the instance.  The arguments are the object,
    the method name as a C string, and the address of a
    static variable used to cache the interned Python string.
 
    Two variants:
 
    - lookup_maybe() returns NULL without raising an exception
-     when the _PyType_Lookup() call fails;
+     when the _PyType_LookupEx() call fails;
 
    - lookup_method() always raises an exception upon errors.
 */
@@ -863,13 +685,15 @@
 		if (*attrobj == NULL)
 			return NULL;
 	}
-	res = _PyType_Lookup(Py_Type(self), *attrobj);
+	if (_PyType_LookupEx(Py_Type(self), *attrobj, &res) < 0)
+		return NULL;
 	if (res != NULL) {
 		descrgetfunc f;
-		if ((f = Py_Type(res)->tp_descr_get) == NULL)
-			Py_INCREF(res);
-		else
-			res = f(res, self, (PyObject *)(Py_Type(self)));
+		if ((f = Py_Type(res)->tp_descr_get) != NULL) {
+			PyObject *tmp = f(res, self, (PyObject *)(Py_Type(self)));
+			Py_DECREF(res);
+			res = tmp;
+		}
 	}
 	return res;
 }
@@ -1419,9 +1243,15 @@
 		if (dict_str == NULL)
 			return NULL;
 	}
-	descr = _PyType_Lookup(type, dict_str);
-	if (descr == NULL || !PyDescr_IsData(descr))
+
+	if (_PyType_LookupEx(type, dict_str, &descr) < 0)
 		return NULL;
+	if (descr == NULL)
+		return NULL;
+	if (!PyDescr_IsData(descr)) {
+		Py_DECREF(descr);
+		return NULL;
+	}
 
 	return descr;
 }
@@ -1559,17 +1389,17 @@
 };
 
 static int
-valid_identifier(PyObject *s)
+valid_identifier(PyObject *s, const char *name)
 {
 	if (!PyUnicode_Check(s)) {
 		PyErr_Format(PyExc_TypeError,
-			     "__slots__ items must be strings, not '%.200s'",
-			     Py_Type(s)->tp_name);
+			     "%s items must be strings, not '%.200s'",
+			     name, Py_Type(s)->tp_name);
 		return 0;
 	}
 	if (!PyUnicode_IsIdentifier(s)) {
-		PyErr_SetString(PyExc_TypeError,
-				"__slots__ must be identifiers");
+		PyErr_Format(PyExc_TypeError,
+				"%s must be identifiers", name);
 		return 0;
 	}
 	return 1;
@@ -1613,12 +1443,13 @@
 {
 	PyObject *name, *bases, *dict;
 	static char *kwlist[] = {"name", "bases", "dict", 0};
-	PyObject *slots, *tmp, *newslots;
+	PyObject *slots, *tmp, *newslots, *finalizeattrs;
 	PyTypeObject *type, *base, *tmptype, *winner;
 	PyHeapTypeObject *et;
 	PyMemberDef *mp;
 	Py_ssize_t i, nbases, nslots, slotoffset, add_dict, add_weak;
 	int j, may_add_dict, may_add_weak;
+	int shared, status;
 
 	assert(args != NULL && PyTuple_Check(args));
 	assert(kwds == NULL || PyDict_Check(kwds));
@@ -1705,8 +1536,29 @@
 		return NULL;
 	}
 
+	/* Check for a __shared__ attribute */
+	shared = 0;
+	if (PyDict_GetItemStringEx(dict, "__shared__", &tmp) < 0) {
+		Py_DECREF(bases);
+		return NULL;
+	}
+	if (tmp != NULL) {
+		shared = PyObject_IsTrue(tmp);
+		Py_DECREF(tmp);
+		if (shared == -1) {
+			Py_DECREF(bases);
+			return NULL;
+		}
+	}
+	/* XXX FIXME do an audit, ensure all possible attributes are
+	 * checked for shareability.  For now I'm going to be lazy and
+	 * just check the most obvious ones. */
+
 	/* Check for a __slots__ sequence variable in dict, and count it */
-	slots = PyDict_GetItemString(dict, "__slots__");
+	if (PyDict_GetItemStringEx(dict, "__slots__", &slots) < 0) {
+		Py_DECREF(bases);
+		return NULL;
+	}
 	nslots = 0;
 	add_dict = 0;
 	add_weak = 0;
@@ -1725,9 +1577,11 @@
 
 		/* Make it into a tuple */
 		if (PyUnicode_Check(slots))
-			slots = PyTuple_Pack(1, slots);
+			tmp = PyTuple_Pack(1, slots);
 		else
-			slots = PySequence_Tuple(slots);
+			tmp = PySequence_Tuple(slots);
+		Py_DECREF(slots);
+		slots = tmp;
 		if (slots == NULL) {
 			Py_DECREF(bases);
 			return NULL;
@@ -1750,7 +1604,7 @@
 		/* Check for valid slot names and two special cases */
 		for (i = 0; i < nslots; i++) {
 			PyObject *tmp = PyTuple_GET_ITEM(slots, i);
-			if (!valid_identifier(tmp))
+			if (!valid_identifier(tmp, "__slots__"))
 				goto bad_slots;
 			assert(PyUnicode_Check(tmp));
 			if (PyUnicode_CompareWithASCIIString(tmp, "__dict__") == 0) {
@@ -1839,7 +1693,9 @@
 	   "return NULL" may leak slots! */
 
 	/* Allocate the type object */
-	type = (PyTypeObject *)metatype->tp_alloc(metatype, nslots);
+	/* XXX This assumes the allocator will allocate one extra slot
+	 * for the sentinal. */
+	type = PyObject_NEWVAR(PyTypeObject, metatype, nslots);
 	if (type == NULL) {
 		Py_XDECREF(slots);
 		Py_DECREF(bases);
@@ -1875,62 +1731,87 @@
 	type->tp_base = base;
 
 	/* Initialize tp_dict from passed-in dict */
-	type->tp_dict = dict = PyDict_Copy(dict);
+	if (shared)
+		type->tp_dict = dict = PyObject_CallFunction(
+			(PyObject *)&PySharedDict_Type, "(O)", dict);
+	else
+		type->tp_dict = dict = PyDict_Copy(dict);
 	if (dict == NULL) {
 		Py_DECREF(type);
 		return NULL;
 	}
 
 	/* Set __module__ in the dict */
-	if (PyDict_GetItemString(dict, "__module__") == NULL) {
-		tmp = PyEval_GetGlobals();
-		if (tmp != NULL) {
-			tmp = PyDict_GetItemString(tmp, "__name__");
+	if (PyDict_GetItemStringEx(dict, "__module__", &tmp) < 0) {
+		Py_DECREF(type);
+		return NULL;
+	}
+	if (tmp == NULL) {
+		PyObject *globals = PyEval_GetGlobals();
+		if (globals != NULL) {
+			if (PyDict_GetItemStringEx(globals, "__name__", &tmp) < 0)
+				return NULL;
 			if (tmp != NULL) {
 				if (PyDict_SetItemString(dict, "__module__",
-							 tmp) < 0)
+							 tmp) < 0) {
+					Py_DECREF(tmp);
 					return NULL;
+				}
+				Py_DECREF(tmp);
 			}
 		}
-	}
+	} else
+		Py_DECREF(tmp);
 
 	/* Set tp_doc to a copy of dict['__doc__'], if the latter is there
 	   and is a string.  The __doc__ accessor will first look for tp_doc;
 	   if that fails, it will still look into __dict__.
 	*/
 	{
-		PyObject *doc = PyDict_GetItemString(dict, "__doc__");
+		PyObject *doc;
+		if (PyDict_GetItemStringEx(dict, "__doc__", &doc) < 0) {
+			Py_DECREF(type);
+			return NULL;
+		}
 		if (doc != NULL && PyUnicode_Check(doc)) {
 			size_t n;
 			char *tp_doc;
 			const char *str = PyUnicode_AsString(doc);
 			if (str == NULL) {
 				Py_DECREF(type);
+				Py_DECREF(doc);
 				return NULL;
 			}
 			n = strlen(str);
 			tp_doc = (char *)PyObject_MALLOC(n+1);
 			if (tp_doc == NULL) {
 				Py_DECREF(type);
+				Py_DECREF(doc);
 				return NULL;
 			}
 			memcpy(tp_doc, str, n+1);
 			type->tp_doc = tp_doc;
 		}
+		Py_XDECREF(doc);
 	}
 
 	/* Special-case __new__: if it's a plain function,
 	   make it a static function */
-	tmp = PyDict_GetItemString(dict, "__new__");
+	if (PyDict_GetItemStringEx(dict, "__new__", &tmp) < 0) {
+		Py_DECREF(type);
+		return NULL;
+	}
 	if (tmp != NULL && PyFunction_Check(tmp)) {
-		tmp = PyStaticMethod_New(tmp);
-		if (tmp == NULL) {
+		PyObject *tmp2 = PyStaticMethod_New(tmp);
+		Py_DECREF(tmp);
+		if (tmp2 == NULL) {
 			Py_DECREF(type);
 			return NULL;
 		}
-		PyDict_SetItemString(dict, "__new__", tmp);
-		Py_DECREF(tmp);
-	}
+		PyDict_SetItemString(dict, "__new__", tmp2);
+		Py_DECREF(tmp2);
+	} else
+		Py_XDECREF(tmp);
 
 	/* Add descriptors for custom slots from __slots__, or for __dict__ */
 	mp = PyHeapType_GET_MEMBERS(et);
@@ -1989,15 +1870,43 @@
 		type->tp_flags |= Py_TPFLAGS_HAVE_GC;
 
 	/* Always override allocation strategy to use regular heap */
-	type->tp_alloc = PyType_GenericAlloc;
+	/* XXX This comment needs updating */
 	if (type->tp_flags & Py_TPFLAGS_HAVE_GC) {
-		type->tp_free = PyObject_GC_Del;
 		type->tp_traverse = subtype_traverse;
 		type->tp_clear = subtype_clear;
 	}
-	else
-		type->tp_free = PyObject_Del;
 
+	/* Activate sharing, check that the contents are shareable too */
+	if (shared) {
+		type->tp_flags |= Py_TPFLAGS_SHAREABLE;
+
+		for (i = 0; i < nbases; i++) {
+			tmp = PyTuple_GET_ITEM(bases, i);
+			if (!PyObject_IsShareable(tmp)) {
+				PyErr_SetString(PyExc_TypeError,
+					"Shared type given unshareable base");
+				Py_DECREF(type);
+				return NULL;
+			}
+		}
+	}
+
+	status = PyDict_ContainsString(dict, "__finalize__");
+	if (status < 0) {
+		Py_DECREF(type);
+		return NULL;
+	} else if (status > 0)
+		type->tp_flags |= Py_TPFLAGS_HAVE_FINALIZE;
+	else {
+		for (i = 0; i < nbases; i++) {
+			tmp = PyTuple_GET_ITEM(bases, i);
+			if (((PyTypeObject *)tmp)->tp_flags & Py_TPFLAGS_HAVE_FINALIZE) {
+				type->tp_flags |= Py_TPFLAGS_HAVE_FINALIZE;
+				break;
+			}
+		}
+	}
+
 	/* Initialize the rest */
 	if (PyType_Ready(type) < 0) {
 		Py_DECREF(type);
@@ -2007,16 +1916,63 @@
 	/* Put the proper slots in place */
 	fixup_slot_dispatchers(type);
 
+	/* Add __finalizeattrs__ */
+	if (PyDict_GetItemStringEx(dict, "__finalizeattrs__", &finalizeattrs) < 0) {
+		Py_DECREF(type);
+		return NULL;
+	}
+	if (finalizeattrs != NULL) {
+		/* Make it into a tuple */
+		if (PyUnicode_Check(finalizeattrs))
+			tmp = PyTuple_Pack(1, finalizeattrs);
+		else
+			tmp = PySequence_Tuple(finalizeattrs);
+		Py_DECREF(finalizeattrs);
+		finalizeattrs = tmp;
+		if (finalizeattrs == NULL) {
+			Py_DECREF(type);
+			return NULL;
+		}
+		assert(PyTuple_Check(finalizeattrs));
+
+		for (i = 0; i < PyTuple_GET_SIZE(finalizeattrs); i++) {
+			PyObject *descr;
+			PyObject *tmp = PyTuple_GET_ITEM(finalizeattrs, i);
+
+			if (!valid_identifier(tmp, "__finalizeattrs__")) {
+				Py_DECREF(type);
+				return NULL;
+			}
+
+			descr = PyDescr_NewFinalizeAttr(type, tmp);
+			if (descr == NULL) {
+				Py_DECREF(type);
+				return NULL;
+			}
+
+			if (PyDict_SetItem(type->tp_dict, tmp, descr) < 0) {
+				Py_DECREF(finalizeattrs);
+				Py_DECREF(descr);
+				Py_DECREF(type);
+				return NULL;
+			}
+		}
+		Py_DECREF(finalizeattrs);
+	}
+
 	return (PyObject *)type;
 }
 
-/* Internal API to look for a name through the MRO.
-   This returns a borrowed reference, and doesn't set an exception! */
-PyObject *
-_PyType_Lookup(PyTypeObject *type, PyObject *name)
+/* Internal API to look for a name through the MRO.  Return values:
+ * -1 Error, exception set (result set to NULL)
+ *  0 Success (result filled in with *NEW* reference)
+ * +1 Not found, no exception set (result set to NULL)
+ */
+int
+_PyType_LookupEx(PyTypeObject *type, PyObject *name, PyObject **result)
 {
 	Py_ssize_t i, n;
-	PyObject *mro, *res, *base, *dict;
+	PyObject *mro, *base, *dict;
 
 	/* Look in tp_dict of types in MRO */
 	mro = type->tp_mro;
@@ -2024,25 +1980,32 @@
 	/* If mro is NULL, the type is either not yet initialized
 	   by PyType_Ready(), or already cleared by type_clear().
 	   Either way the safest thing to do is to return NULL. */
-	if (mro == NULL)
-		return NULL;
+	if (mro == NULL) {
+		*result = NULL;
+		return 1;  /* XXX should this be -1 with an exception instead? */
+	}
 
 	assert(PyTuple_Check(mro));
 	n = PyTuple_GET_SIZE(mro);
 	for (i = 0; i < n; i++) {
 		base = PyTuple_GET_ITEM(mro, i);
 		assert(PyType_Check(base));
+
 		dict = ((PyTypeObject *)base)->tp_dict;
 		assert(dict && PyDict_Check(dict));
-		res = PyDict_GetItem(dict, name);
-		if (res != NULL)
-			return res;
+
+		if (PyDict_GetItemEx(dict, name, result) < 0)
+			return -1;
+		if (*result != NULL)
+			return 0;
 	}
-	return NULL;
+
+	*result = NULL;
+	return 1;
 }
 
 /* This is similar to PyObject_GenericGetAttr(),
-   but uses _PyType_Lookup() instead of just looking in type->tp_dict. */
+   but uses _PyType_LookupEx() instead of just looking in type->tp_dict. */
 static PyObject *
 type_getattro(PyTypeObject *type, PyObject *name)
 {
@@ -2060,7 +2023,8 @@
 	meta_get = NULL;
 
 	/* Look for the attribute in the metatype */
-	meta_attribute = _PyType_Lookup(metatype, name);
+	if (_PyType_LookupEx(metatype, name, &meta_attribute) < 0)
+		return NULL;
 
 	if (meta_attribute != NULL) {
 		meta_get = Py_Type(meta_attribute)->tp_descr_get;
@@ -2070,15 +2034,19 @@
 			 * writes. Assume the attribute is not overridden in
 			 * type's tp_dict (and bases): call the descriptor now.
 			 */
-			return meta_get(meta_attribute, (PyObject *)type,
-					(PyObject *)metatype);
+			attribute = meta_get(meta_attribute, (PyObject *)type,
+				(PyObject *)metatype);
+			Py_DECREF(meta_attribute);
+			return attribute;
 		}
-		Py_INCREF(meta_attribute);
 	}
 
 	/* No data descriptor found on metatype. Look in tp_dict of this
 	 * type and its bases */
-	attribute = _PyType_Lookup(type, name);
+	if (_PyType_LookupEx(type, name, &attribute) < 0) {
+		Py_XDECREF(meta_attribute);
+		return NULL;
+	}
 	if (attribute != NULL) {
 		/* Implement descriptor functionality, if any */
 		descrgetfunc local_get = Py_Type(attribute)->tp_descr_get;
@@ -2086,13 +2054,15 @@
 		Py_XDECREF(meta_attribute);
 
 		if (local_get != NULL) {
+			PyObject *tmp;
 			/* NULL 2nd argument indicates the descriptor was
 			 * found on the target object itself (or a base)  */
-			return local_get(attribute, (PyObject *)NULL,
-					 (PyObject *)type);
+			tmp = local_get(attribute, (PyObject *)NULL,
+				(PyObject *)type);
+			Py_DECREF(attribute);
+			return tmp;
 		}
 
-		Py_INCREF(attribute);
 		return attribute;
 	}
 
@@ -2142,10 +2112,9 @@
 {
 	PyHeapTypeObject *et;
 
+	printf("type_dealloc %s\n", type->tp_name);
 	/* Assert this is a heap-allocated type object */
 	assert(type->tp_flags & Py_TPFLAGS_HEAPTYPE);
-	_PyObject_GC_UNTRACK(type);
-	PyObject_ClearWeakRefs((PyObject *)type);
 	et = (PyHeapTypeObject *)type;
 	Py_XDECREF(type->tp_base);
 	Py_XDECREF(type->tp_dict);
@@ -2159,7 +2128,7 @@
 	PyObject_Free((char *)type->tp_doc);
 	Py_XDECREF(et->ht_name);
 	Py_XDECREF(et->ht_slots);
-	Py_Type(type)->tp_free((PyObject *)type);
+	PyObject_DEL(type);
 }
 
 static PyObject *
@@ -2171,6 +2140,7 @@
 	list = PyList_New(0);
 	if (list == NULL)
 		return NULL;
+#if 0
 	raw = type->tp_subclasses;
 	if (raw == NULL)
 		return list;
@@ -2187,6 +2157,7 @@
 			}
 		}
 	}
+#endif
 	return list;
 }
 
@@ -2240,6 +2211,7 @@
 	   for heaptypes. */
 	assert(type->tp_flags & Py_TPFLAGS_HEAPTYPE);
 
+#warning XXX FIXME this should check for subtypes of type and change ob_type to a known-safe value for HEAPTYPEs
 	/* The only field we need to clear is tp_mro, which is part of a
 	   hard cycle (its first element is the class itself) that won't
 	   be broken otherwise (it's a tuple and tuples don't have a
@@ -2276,6 +2248,12 @@
 	return type->tp_flags & Py_TPFLAGS_HEAPTYPE;
 }
 
+static int
+type_isshareable (PyTypeObject *type)
+{
+	return PyType_HasFeature(type, Py_TPFLAGS_SHAREABLE);
+}
+
 PyTypeObject PyType_Type = {
 	PyVarObject_HEAD_INIT(&PyType_Type, 0)
 	"type",					/* tp_name */
@@ -2297,7 +2275,8 @@
 	(setattrofunc)type_setattro,		/* tp_setattro */
 	0,					/* tp_as_buffer */
 	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
-		Py_TPFLAGS_BASETYPE | Py_TPFLAGS_TYPE_SUBCLASS,	/* tp_flags */
+		Py_TPFLAGS_BASETYPE | Py_TPFLAGS_TYPE_SUBCLASS |
+		Py_TPFLAGS_SHAREABLE,		/* tp_flags */
 	type_doc,				/* tp_doc */
 	(traverseproc)type_traverse,		/* tp_traverse */
 	(inquiry)type_clear,			/* tp_clear */
@@ -2314,10 +2293,14 @@
 	0,					/* tp_descr_set */
 	offsetof(PyTypeObject, tp_dict),	/* tp_dictoffset */
 	type_init,				/* tp_init */
-	0,					/* tp_alloc */
 	type_new,				/* tp_new */
-	PyObject_GC_Del,			/* tp_free */
 	(inquiry)type_is_gc,			/* tp_is_gc */
+	0,					/* tp_bases */
+	0,					/* tp_mro */
+	0,					/* tp_cache */
+	0,					/* tp_subclasses */
+	0,					/* tp_weaklist */
+	(isshareablefunc)type_isshareable,	/* tp_isshareable */
 };
 
 
@@ -2356,6 +2339,13 @@
    __init__() is overridden and __new__() is not overridden
    (IOW, if __new__() is overridden or __init__() is not overridden).
 
+       __new__     __init__    __new__     __init__
+      overridden  overridden  complains   complains
+   a.     no          no         yes         yes
+   b.     no         yes          no         yes
+   c.    yes          no         yes          no
+   d.    yes         yes         yes         yes
+
    However, for backwards compatibility, this breaks too much code.
    Therefore, in 2.6, we'll *warn* about excess arguments when both
    methods are overridden; for all other cases we'll use the above
@@ -2381,14 +2371,14 @@
 	if (excess_args(args, kwds)) {
 		PyTypeObject *type = Py_Type(self);
 		if (type->tp_init != object_init &&
-		    type->tp_new != object_new)
+		    type->tp_new != object_new) /* Condition d */
 		{
 			err = PyErr_WarnEx(PyExc_DeprecationWarning,
 				   "object.__init__() takes no parameters",
 				   1);
 		}
-		else if (type->tp_init != object_init ||
-			 type->tp_new == object_new)
+		else if (type->tp_init != object_init || /* Conditions b, d */
+			 type->tp_new == object_new) /* Conditions a, b */
 		{
 			PyErr_SetString(PyExc_TypeError,
 				"object.__init__() takes no parameters");
@@ -2404,14 +2394,14 @@
 	int err = 0;
 	if (excess_args(args, kwds)) {
 		if (type->tp_new != object_new &&
-		    type->tp_init != object_init)
+		    type->tp_init != object_init) /* Condition d */
 		{
 			err = PyErr_WarnEx(PyExc_DeprecationWarning,
 				   "object.__new__() takes no parameters",
 				   1);
 		}
-		else if (type->tp_new != object_new ||
-			 type->tp_init == object_init)
+		else if (type->tp_new != object_new || /* Conditions c, d */
+			 type->tp_init == object_init) /* Conditions a, c */
 		{
 			PyErr_SetString(PyExc_TypeError,
 				"object.__new__() takes no parameters");
@@ -2420,13 +2410,13 @@
 	}
 	if (err < 0)
 		return NULL;
-	return type->tp_alloc(type, 0);
+	return PyObject_New(type);
 }
 
 static void
 object_dealloc(PyObject *self)
 {
-	Py_Type(self)->tp_free(self);
+	PyObject_Del(self);
 }
 
 static PyObject *
@@ -2561,9 +2551,7 @@
 {
 	PyTypeObject *newbase, *oldbase;
 
-	if (newto->tp_dealloc != oldto->tp_dealloc ||
-	    newto->tp_free != oldto->tp_free)
-	{
+	if (newto->tp_dealloc != oldto->tp_dealloc) {
 		PyErr_Format(PyExc_TypeError,
 			     "%s assignment: "
 			     "'%s' deallocator differs from '%s'",
@@ -2670,10 +2658,12 @@
 	}
 
 	clsdict = ((PyTypeObject *)cls)->tp_dict;
-	slotnames = PyDict_GetItemString(clsdict, "__slotnames__");
-	if (slotnames != NULL && PyList_Check(slotnames)) {
-		Py_INCREF(slotnames);
-		return slotnames;
+	if (PyDict_GetItemStringEx(clsdict, "__slotnames__", &slotnames) < 0)
+		return NULL;
+	if (slotnames != NULL) {
+		if (PyList_Check(slotnames))
+			return slotnames;
+		Py_DECREF(slotnames);
 	}
 
 	copy_reg = import_copy_reg();
@@ -2906,10 +2896,14 @@
 			Py_DECREF(reduce);
 			return NULL;
 		}
-		objreduce = PyDict_GetItemString(PyBaseObject_Type.tp_dict,
-						 "__reduce__");
+		if (PyDict_GetItemStringEx(PyBaseObject_Type.tp_dict,
+				"__reduce__", &objreduce) < 0) {
+			Py_DECREF(reduce);
+			return NULL;
+		}
 		override = (clsreduce != objreduce);
 		Py_DECREF(clsreduce);
+		Py_XDECREF(objreduce);
 		if (override) {
 			res = PyObject_CallObject(reduce, NULL);
 			Py_DECREF(reduce);
@@ -2961,6 +2955,31 @@
         return result;
 }
 
+static PyObject *
+object_finalize(PyObject *self, PyObject *args)
+{
+    PyObject *handle, *queue, *res;
+
+    handle = PyObject_GetAttrString(self, "__finalizehandle__");
+    if (handle == NULL && PyErr_ExceptionMatches(PyExc_AttributeError)) {
+        PyErr_Clear();
+        Py_INCREF(Py_None);
+        return Py_None;
+    } else if (handle == NULL)
+        return NULL;
+
+    queue = PySys_GetObject("finalizequeue");
+    if (queue == NULL) {
+        PyErr_SetString(PyExc_RuntimeError, "lost sys.finalizequeue");
+        Py_DECREF(handle);
+        return NULL;
+    }
+
+    res = PyObject_CallMethod(queue, "cancel", "O", handle);
+    //Py_DECREF(queue); // PySys_GetObject returns a borrowed reference
+    return res;
+}
+
 static PyMethodDef object_methods[] = {
 	{"__reduce_ex__", object_reduce_ex, METH_VARARGS,
 	 PyDoc_STR("helper for pickle")},
@@ -2968,6 +2987,8 @@
 	 PyDoc_STR("helper for pickle")},
         {"__format__", object_format, METH_VARARGS,
          PyDoc_STR("default object formatter")},
+        {"__finalize__", object_finalize, METH_NOARGS,
+         PyDoc_STR("base finalize method")},
 	{0}
 };
 
@@ -2992,7 +3013,8 @@
 	PyObject_GenericGetAttr,		/* tp_getattro */
 	PyObject_GenericSetAttr,		/* tp_setattro */
 	0,					/* tp_as_buffer */
-	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |
+		Py_TPFLAGS_SHAREABLE,		/* tp_flags */
 	PyDoc_STR("The most base type"),	/* tp_doc */
 	0,					/* tp_traverse */
 	0,					/* tp_clear */
@@ -3009,9 +3031,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	object_init,				/* tp_init */
-	PyType_GenericAlloc,			/* tp_alloc */
 	object_new,				/* tp_new */
-	PyObject_Del,				/* tp_free */
 };
 
 
@@ -3024,9 +3044,14 @@
 
 	for (; meth->ml_name != NULL; meth++) {
 		PyObject *descr;
-		if (PyDict_GetItemString(dict, meth->ml_name) &&
-			!(meth->ml_flags & METH_COEXIST))
+		int status;
+
+		if ((status = PyDict_ContainsString(dict, meth->ml_name))) {
+			if (status < 0)
+				return -1;
+			if (!(meth->ml_flags & METH_COEXIST))
 				continue;
+		}
 		if (meth->ml_flags & METH_CLASS) {
 			if (meth->ml_flags & METH_STATIC) {
 				PyErr_SetString(PyExc_ValueError,
@@ -3061,8 +3086,12 @@
 
 	for (; memb->name != NULL; memb++) {
 		PyObject *descr;
-		if (PyDict_GetItemString(dict, memb->name))
+		if (PyDict_GetItemStringEx(dict, memb->name, &descr) < 0)
+			return -1;
+		if (descr != NULL) {
+			Py_DECREF(descr);
 			continue;
+		}
 		descr = PyDescr_NewMember(type, memb);
 		if (descr == NULL)
 			return -1;
@@ -3080,8 +3109,12 @@
 
 	for (; gsp->name != NULL; gsp++) {
 		PyObject *descr;
-		if (PyDict_GetItemString(dict, gsp->name))
+		if (PyDict_GetItemStringEx(dict, gsp->name, &descr) < 0)
+			return -1;
+		if (descr != NULL) {
+			Py_DECREF(descr);
 			continue;
+		}
 		descr = PyDescr_NewGetSet(type, gsp);
 
 		if (descr == NULL)
@@ -3156,6 +3189,8 @@
 		type->tp_flags |= Py_TPFLAGS_LIST_SUBCLASS;
 	else if (PyType_IsSubtype(base, &PyDict_Type))
 		type->tp_flags |= Py_TPFLAGS_DICT_SUBCLASS;
+	else if (PyType_IsSubtype(base, &PyMonitor_Type))
+		type->tp_flags |= Py_TPFLAGS_MONITOR_SUBCLASS;
 }
 
 /* Map rich comparison operators to their __xx__ namesakes */
@@ -3171,21 +3206,27 @@
 	"__hash__",
 };
 
+/* 1 is returned if a method is found, 0 if none are found, and -1 on error */
 static int
 overrides_cmp_or_hash(PyTypeObject *type)
 {
 	int i;
+	PyObject *tmp;
 	PyObject *dict = type->tp_dict;
 
 	assert(dict != NULL);
 	for (i = 0; i < 8; i++) {
-		if (PyDict_GetItemString(dict, name_op[i]) != NULL)
+		if (PyDict_GetItemStringEx(dict, name_op[i], &tmp) < 0)
+			return -1;
+		if (tmp != NULL) {
+			Py_DECREF(tmp);
 			return 1;
+		}
 	}
 	return 0;
 }
 
-static void
+static int
 inherit_slots(PyTypeObject *type, PyTypeObject *base)
 {
 	PyTypeObject *basebase;
@@ -3299,19 +3340,21 @@
 	/* tp_hash see tp_richcompare */
 	COPYSLOT(tp_call);
 	COPYSLOT(tp_str);
-	{
-		/* Copy comparison-related slots only when
-		   not overriding them anywhere */
-		if (type->tp_compare == NULL &&
-		    type->tp_richcompare == NULL &&
-		    type->tp_hash == NULL &&
-		    !overrides_cmp_or_hash(type))
-		{
+
+	/* Copy comparison-related slots only when
+	   not overriding them anywhere */
+	if (type->tp_compare == NULL && type->tp_richcompare == NULL &&
+			type->tp_hash == NULL) {
+		int status = overrides_cmp_or_hash(type);
+		if (status < 0)
+			return -1;
+		else if (status == 0) {
 			type->tp_compare = base->tp_compare;
 			type->tp_richcompare = base->tp_richcompare;
 			type->tp_hash = base->tp_hash;
 		}
 	}
+
 	{
 		COPYSLOT(tp_iter);
 		COPYSLOT(tp_iternext);
@@ -3320,28 +3363,12 @@
 		COPYSLOT(tp_descr_get);
 		COPYSLOT(tp_descr_set);
 		COPYSLOT(tp_dictoffset);
+		COPYSLOT(tp_isshareable);
 		COPYSLOT(tp_init);
-		COPYSLOT(tp_alloc);
 		COPYSLOT(tp_is_gc);
-		if ((type->tp_flags & Py_TPFLAGS_HAVE_GC) ==
-		    (base->tp_flags & Py_TPFLAGS_HAVE_GC)) {
-			/* They agree about gc. */
-			COPYSLOT(tp_free);
-		}
-		else if ((type->tp_flags & Py_TPFLAGS_HAVE_GC) &&
-			 type->tp_free == NULL &&
-			 base->tp_free == PyObject_Free) {
-			/* A bit of magic to plug in the correct default
-			 * tp_free function when a derived class adds gc,
-			 * didn't define tp_free, and the base uses the
-			 * default non-gc tp_free.
-			 */
-			type->tp_free = PyObject_GC_Del;
-		}
-		/* else they didn't agree about gc, and there isn't something
-		 * obvious to be done -- the type is on its own.
-		 */
 	}
+
+	return 0;
 }
 
 static int add_operators(PyTypeObject *);
@@ -3349,7 +3376,7 @@
 int
 PyType_Ready(PyTypeObject *type)
 {
-	PyObject *dict, *bases;
+	PyObject *dict, *bases, *doc;
 	PyTypeObject *base;
 	Py_ssize_t i, n;
 
@@ -3360,6 +3387,7 @@
 	assert((type->tp_flags & Py_TPFLAGS_READYING) == 0);
 
 	type->tp_flags |= Py_TPFLAGS_READYING;
+//	printf("Readying %s\n", type->tp_name);
 
 #ifdef Py_TRACE_REFS
 	/* PyType_Ready is the closest thing we have to a choke point
@@ -3387,12 +3415,12 @@
 			goto error;
 	}
 
-	/* Initialize ob_type if NULL.	This means extensions that want to be
+	/* Initialize ob_type if NULL.  This means extensions that want to be
 	   compilable separately on Windows can call PyType_Ready() instead of
 	   initializing the ob_type field of their type objects. */
 	/* The test for base != NULL is really unnecessary, since base is only
 	   NULL when type is &PyBaseObject_Type, and we know its ob_type is
-	   not NULL (it's initialized to &PyType_Type).	 But coverity doesn't
+	   not NULL (it's initialized to &PyType_Type).  But coverity doesn't
 	   know that. */
 	if (Py_Type(type) == NULL && base != NULL)
 		Py_Type(type) = Py_Type(base);
@@ -3450,29 +3478,20 @@
 	n = PyTuple_GET_SIZE(bases);
 	for (i = 1; i < n; i++) {
 		PyObject *b = PyTuple_GET_ITEM(bases, i);
-		if (PyType_Check(b))
-			inherit_slots(type, (PyTypeObject *)b);
+		if (PyType_Check(b)) {
+			if (inherit_slots(type, (PyTypeObject *)b))
+				goto error;
+		}
 	}
 
-	/* Sanity check for tp_free. */
-	if (PyType_IS_GC(type) && (type->tp_flags & Py_TPFLAGS_BASETYPE) &&
-	    (type->tp_free == NULL || type->tp_free == PyObject_Del)) {
-		/* This base class needs to call tp_free, but doesn't have
-		 * one, or its tp_free is for non-gc'ed objects.
-		 */
-		PyErr_Format(PyExc_TypeError, "type '%.100s' participates in "
-			     "gc and is a base type but has inappropriate "
-			     "tp_free slot",
-			     type->tp_name);
-		goto error;
-	}
-
 	/* if the type dictionary doesn't contain a __doc__, set it from
 	   the tp_doc slot.
 	 */
-	if (PyDict_GetItemString(type->tp_dict, "__doc__") == NULL) {
+	if (PyDict_GetItemStringEx(type->tp_dict, "__doc__", &doc) < 0)
+		goto error;
+	if (doc == NULL) {
 		if (type->tp_doc != NULL) {
-			PyObject *doc = PyUnicode_FromString(type->tp_doc);
+			doc = PyUnicode_FromString(type->tp_doc);
 			if (doc == NULL)
 				goto error;
 			PyDict_SetItemString(type->tp_dict, "__doc__", doc);
@@ -3481,7 +3500,8 @@
 			PyDict_SetItemString(type->tp_dict,
 					     "__doc__", Py_None);
 		}
-	}
+	} else
+		Py_DECREF(doc);
 
 	/* Hack for tp_hash and __hash__.
 	   If after all that, tp_hash is still NULL, and __hash__ is not in
@@ -3489,10 +3509,14 @@
 	   This signals that __hash__ is not inherited.
 	 */
 	if (type->tp_hash == NULL) {
-		if (PyDict_GetItemString(type->tp_dict, "__hash__") == NULL) {
+		PyObject *hash;
+		if (PyDict_GetItemStringEx(type->tp_dict, "__hash__", &hash) < 0)
+			goto error;
+		if (hash == NULL) {
 			if (PyDict_SetItemString(type->tp_dict, "__hash__", Py_None) < 0)
 				goto error;
-		}
+		} else
+			Py_DECREF(hash);
 	}
 
 	/* Some more special stuff */
@@ -3536,6 +3560,8 @@
 	int result;
 	PyObject *list, *ref, *newobj;
 
+        return 0; /* XXX FIXME brutal hack! */
+#if 0
 	list = base->tp_subclasses;
 	if (list == NULL) {
 		base->tp_subclasses = list = PyList_New(0);
@@ -3554,6 +3580,7 @@
 	result = PyList_Append(list, newobj);
 	Py_DECREF(newobj);
 	return result;
+#endif
 }
 
 static void
@@ -3562,6 +3589,8 @@
 	Py_ssize_t i;
 	PyObject *list, *ref;
 
+        return; /* XXX FIXME brutal hack! */
+#if 0
 	list = base->tp_subclasses;
 	if (list == NULL) {
 		return;
@@ -3577,6 +3606,7 @@
 			return;
 		}
 	}
+#endif
 }
 
 static int
@@ -4136,8 +4166,12 @@
 add_tp_new_wrapper(PyTypeObject *type)
 {
 	PyObject *func;
+	int status;
 
-	if (PyDict_GetItemString(type->tp_dict, "__new__") != NULL)
+	status = PyDict_ContainsString(type->tp_dict, "__new__");
+	if (status < 0)
+		return -1;
+	if (status > 0)
 		return 0;
 	func = PyCFunction_New(tp_new_methoddef, (PyObject *)type);
 	if (func == NULL)
@@ -4286,12 +4320,14 @@
 		if (getitem_str == NULL)
 			return NULL;
 	}
-	func = _PyType_Lookup(Py_Type(self), getitem_str);
+
+	if (_PyType_LookupEx(Py_Type(self), getitem_str, &func) < 0)
+		return NULL;
 	if (func != NULL) {
-		if ((f = Py_Type(func)->tp_descr_get) == NULL)
-			Py_INCREF(func);
-		else {
-			func = f(func, self, (PyObject *)(Py_Type(self)));
+		if ((f = Py_Type(func)->tp_descr_get) != NULL) {
+			PyObject *tmp = f(func, self, (PyObject *)(Py_Type(self)));
+			Py_DECREF(func);
+			func = tmp;
 			if (func == NULL) {
 				return NULL;
 			}
@@ -4307,10 +4343,9 @@
 				return retval;
 			}
 		}
-	}
-	else {
+	} else
 		PyErr_SetObject(PyExc_AttributeError, getitem_str);
-	}
+
 	Py_XDECREF(args);
 	Py_XDECREF(ival);
 	Py_XDECREF(func);
@@ -4691,13 +4726,19 @@
 		if (getattribute_str == NULL)
 			return NULL;
 	}
-	getattr = _PyType_Lookup(tp, getattr_str);
+
+	if (_PyType_LookupEx(tp, getattr_str, &getattr) < 0)
+		return NULL;
 	if (getattr == NULL) {
 		/* No __getattr__ hook: use a simpler dispatcher */
 		tp->tp_getattro = slot_tp_getattro;
 		return slot_tp_getattro(self, name);
 	}
-	getattribute = _PyType_Lookup(tp, getattribute_str);
+
+	if (_PyType_LookupEx(tp, getattribute_str, &getattribute) < 0) {
+		Py_DECREF(getattr);
+		return NULL;
+	}
 	if (getattribute == NULL ||
 	    (Py_Type(getattribute) == &PyWrapperDescr_Type &&
 	     ((PyWrapperDescrObject *)getattribute)->d_wrapped ==
@@ -4705,10 +4746,14 @@
 		res = PyObject_GenericGetAttr(self, name);
 	else
 		res = PyObject_CallFunctionObjArgs(getattribute, self, name, NULL);
+	Py_XDECREF(getattribute);
+
 	if (res == NULL && PyErr_ExceptionMatches(PyExc_AttributeError)) {
 		PyErr_Clear();
 		res = PyObject_CallFunctionObjArgs(getattr, self, name, NULL);
 	}
+
+	Py_DECREF(getattr);
 	return res;
 }
 
@@ -4815,7 +4860,7 @@
 slot_tp_descr_get(PyObject *self, PyObject *obj, PyObject *type)
 {
 	PyTypeObject *tp = Py_Type(self);
-	PyObject *get;
+	PyObject *get, *res;
 	static PyObject *get_str = NULL;
 
 	if (get_str == NULL) {
@@ -4823,7 +4868,9 @@
 		if (get_str == NULL)
 			return NULL;
 	}
-	get = _PyType_Lookup(tp, get_str);
+
+	if (_PyType_LookupEx(tp, get_str, &get) < 0)
+		return NULL;
 	if (get == NULL) {
 		/* Avoid further slowdowns */
 		if (tp->tp_descr_get == slot_tp_descr_get)
@@ -4831,11 +4878,15 @@
 		Py_INCREF(self);
 		return self;
 	}
+
 	if (obj == NULL)
 		obj = Py_None;
 	if (type == NULL)
 		type = Py_None;
-	return PyObject_CallFunctionObjArgs(get, self, obj, type, NULL);
+
+	res = PyObject_CallFunctionObjArgs(get, self, obj, type, NULL);
+	Py_DECREF(get);
+	return res;
 }
 
 static int
@@ -4914,67 +4965,7 @@
 	return x;
 }
 
-static void
-slot_tp_del(PyObject *self)
-{
-	static PyObject *del_str = NULL;
-	PyObject *del, *res;
-	PyObject *error_type, *error_value, *error_traceback;
 
-	/* Temporarily resurrect the object. */
-	assert(self->ob_refcnt == 0);
-	self->ob_refcnt = 1;
-
-	/* Save the current exception, if any. */
-	PyErr_Fetch(&error_type, &error_value, &error_traceback);
-
-	/* Execute __del__ method, if any. */
-	del = lookup_maybe(self, "__del__", &del_str);
-	if (del != NULL) {
-		res = PyEval_CallObject(del, NULL);
-		if (res == NULL)
-			PyErr_WriteUnraisable(del);
-		else
-			Py_DECREF(res);
-		Py_DECREF(del);
-	}
-
-	/* Restore the saved exception. */
-	PyErr_Restore(error_type, error_value, error_traceback);
-
-	/* Undo the temporary resurrection; can't use DECREF here, it would
-	 * cause a recursive call.
-	 */
-	assert(self->ob_refcnt > 0);
-	if (--self->ob_refcnt == 0)
-		return;	/* this is the normal path out */
-
-	/* __del__ resurrected it!  Make it look like the original Py_DECREF
-	 * never happened.
-	 */
-	{
-		Py_ssize_t refcnt = self->ob_refcnt;
-		_Py_NewReference(self);
-		self->ob_refcnt = refcnt;
-	}
-	assert(!PyType_IS_GC(Py_Type(self)) ||
-	       _Py_AS_GC(self)->gc.gc_refs != _PyGC_REFS_UNTRACKED);
-	/* If Py_REF_DEBUG, _Py_NewReference bumped _Py_RefTotal, so
-	 * we need to undo that. */
-	_Py_DEC_REFTOTAL;
-	/* If Py_TRACE_REFS, _Py_NewReference re-added self to the object
-	 * chain, so no more to do there.
-	 * If COUNT_ALLOCS, the original decref bumped tp_frees, and
-	 * _Py_NewReference bumped tp_allocs:  both of those need to be
-	 * undone.
-	 */
-#ifdef COUNT_ALLOCS
-	--Py_Type(self)->tp_frees;
-	--Py_Type(self)->tp_allocs;
-#endif
-}
-
-
 /* Table mapping __foo__ names to tp_foo offsets and slot_tp_foo wrapper
    functions.  The offsets here are relative to the 'PyHeapTypeObject'
    structure, which incorporates the additional structures used for numbers,
@@ -5197,7 +5188,6 @@
 	       "see x.__class__.__doc__ for signature",
 	       PyWrapperFlag_KEYWORDS),
 	TPSLOT("__new__", tp_new, slot_tp_new, NULL, ""),
-	TPSLOT("__del__", tp_del, slot_tp_del, NULL, ""),
 	{NULL}
 };
 
@@ -5302,29 +5292,30 @@
 		return p;
 	}
 	do {
-		descr = _PyType_Lookup(type, p->name_strobj);
+		if (_PyType_LookupEx(type, p->name_strobj, &descr) < 0)
+			Py_FatalError("Lookup failed in update_one_slot.  FIXME: propagate error");
 		if (descr == NULL)
 			continue;
+
 		if (Py_Type(descr) == &PyWrapperDescr_Type) {
 			void **tptr = resolve_slotdups(type, p->name_strobj);
+
 			if (tptr == NULL || tptr == ptr)
 				generic = p->function;
 			d = (PyWrapperDescrObject *)descr;
+
 			if (d->d_base->wrapper == p->wrapper &&
-			    PyType_IsSubtype(type, d->d_type))
-			{
+			    PyType_IsSubtype(type, d->d_type)) {
 				if (specific == NULL ||
 				    specific == d->d_wrapped)
 					specific = d->d_wrapped;
 				else
 					use_generic = 1;
 			}
-		}
-		else if (Py_Type(descr) == &PyCFunction_Type &&
+		} else if (Py_Type(descr) == &PyCFunction_Type &&
 			 PyCFunction_GET_FUNCTION(descr) ==
 			 (PyCFunction)tp_new_wrapper &&
-			 strcmp(p->name, "__new__") == 0)
-		{
+			 strcmp(p->name, "__new__") == 0) {
 			/* The __new__ wrapper is not a wrapper descriptor,
 			   so must be special-cased differently.
 			   If we don't do this, creating an instance will
@@ -5341,11 +5332,12 @@
 			   in this reasoning that requires additional
 			   sanity checks.  I'll buy the first person to
 			   point out a bug in this reasoning a beer. */
-		}
-		else {
+		} else {
 			use_generic = 1;
 			generic = p->function;
 		}
+
+		Py_DECREF(descr);
 	} while ((++p)->offset == offset);
 	if (specific && !use_generic)
 		*ptr = specific;
@@ -5477,6 +5469,7 @@
 	PyObject *ref, *subclasses, *dict;
 	Py_ssize_t i, n;
 
+#if 0
 	subclasses = type->tp_subclasses;
 	if (subclasses == NULL)
 		return 0;
@@ -5492,12 +5485,17 @@
 		assert(PyType_Check(subclass));
 		/* Avoid recursing down into unaffected classes */
 		dict = subclass->tp_dict;
-		if (dict != NULL && PyDict_Check(dict) &&
-		    PyDict_GetItem(dict, name) != NULL)
-			continue;
+		if (dict != NULL && PyDict_Check(dict)) {
+			int status = PyDict_Contains(dict, name);
+			if (status < 0)
+				return -1;
+			if (status > 0)
+				continue;
+		}
 		if (update_subclasses(subclass, name, callback, data) < 0)
 			return -1;
 	}
+#endif
 	return 0;
 }
 
@@ -5505,13 +5503,13 @@
    dictionary with method descriptors for function slots.  For each
    function slot (like tp_repr) that's defined in the type, one or more
    corresponding descriptors are added in the type's tp_dict dictionary
-   under the appropriate name (like __repr__).	Some function slots
+   under the appropriate name (like __repr__).  Some function slots
    cause more than one descriptor to be added (for example, the nb_add
    slot adds both __add__ and __radd__ descriptors) and some function
    slots compete for the same descriptor (for example both sq_item and
    mp_subscript generate a __getitem__ descriptor).
 
-   In the latter case, the first slotdef entry encoutered wins.	 Since
+   In the latter case, the first slotdef entry encoutered wins.  Since
    slotdef entries are sorted by the offset of the slot in the
    PyHeapTypeObject, this gives us some control over disambiguating
    between competing slots: the members of PyHeapTypeObject are listed
@@ -5536,6 +5534,7 @@
 {
 	PyObject *dict = type->tp_dict;
 	slotdef *p;
+	int status;
 	PyObject *descr;
 	void **ptr;
 
@@ -5546,7 +5545,10 @@
 		ptr = slotptr(type, p->offset);
 		if (!ptr || !*ptr)
 			continue;
-		if (PyDict_GetItem(dict, p->name_strobj))
+		status = PyDict_Contains(dict, p->name_strobj);
+		if (status < 0)
+			return -1;
+		if (status > 0)
 			continue;
 		descr = PyDescr_NewWrapper(type, p, *ptr);
 		if (descr == NULL)
@@ -5587,11 +5589,10 @@
 {
 	superobject *su = (superobject *)self;
 
-	_PyObject_GC_UNTRACK(self);
 	Py_XDECREF(su->obj);
 	Py_XDECREF(su->type);
 	Py_XDECREF(su->obj_type);
-	Py_Type(self)->tp_free(self);
+	PyObject_Del(self);
 }
 
 static PyObject *
@@ -5651,9 +5652,9 @@
 				dict = ((PyTypeObject *)tmp)->tp_dict;
 			else
 				continue;
-			res = PyDict_GetItem(dict, name);
+			if (PyDict_GetItemEx(dict, name, &res) < 0)
+				return NULL;
 			if (res != NULL) {
-				Py_INCREF(res);
 				f = Py_Type(res)->tp_descr_get;
 				if (f != NULL) {
 					tmp = f(res,
@@ -5790,7 +5791,7 @@
         if (type == NULL) {
 		/* Call super(), without args -- fill in from __class__
 		   and first local variable on the stack. */
-		PyFrameObject *f = PyThreadState_GET()->frame;
+		PyFrameObject *f = PyThreadState_Get()->frame;
 		PyCodeObject *co = f->f_code;
 		int i, n;
 		if (co == NULL) {
@@ -5913,7 +5914,7 @@
 	0,					/* tp_setattro */
 	0,					/* tp_as_buffer */
 	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
-		Py_TPFLAGS_BASETYPE,		/* tp_flags */
+		Py_TPFLAGS_BASETYPE | Py_TPFLAGS_SHAREABLE,	/* tp_flags */
 	super_doc,				/* tp_doc */
 	super_traverse,				/* tp_traverse */
 	0,					/* tp_clear */
@@ -5930,7 +5931,5 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	super_init,				/* tp_init */
-	PyType_GenericAlloc,			/* tp_alloc */
 	PyType_GenericNew,			/* tp_new */
-	PyObject_GC_Del,			/* tp_free */
 };
Index: Objects/dictobject.c
===================================================================
--- Objects/dictobject.c	(revision 58355)
+++ Objects/dictobject.c	(working copy)
@@ -8,6 +8,8 @@
 */
 
 #include "Python.h"
+#include "pystate.h"
+#include "pythread.h"
 
 typedef PyDictEntry dictentry;
 typedef PyDictObject dictobject;
@@ -26,6 +28,132 @@
 	Py_DECREF(tup);
 }
 
+static inline int
+block_unshareable_keyvalue(PyObject *mp, PyObject *key, PyObject *value)
+{
+	if (PySharedDict_Check(mp) && !PyObject_IsShareable(key)) {
+		PyErr_Format(PyExc_TypeError,
+			"%.200s key must be shareable, "
+			"'%s' object is not",
+			mp->ob_type->tp_name, key->ob_type->tp_name);
+		return 1;
+	}
+	if (PySharedDict_Check(mp) && !PyObject_IsShareable(value)) {
+		PyErr_Format(PyExc_TypeError,
+			"%.200s value must be shareable, "
+			"'%s' object is not",
+			mp->ob_type->tp_name, value->ob_type->tp_name);
+		return 1;
+	}
+	return 0;
+}
+
+void
+_pydictlock_initstate_read(PyDict_LockState *lockstate)
+{
+    lockstate->doing_write = 0;
+    lockstate->skipped_lock = 0;
+}
+
+void
+_pydictlock_initstate_write(PyDict_LockState *lockstate)
+{
+    lockstate->doing_write = 1;
+    lockstate->skipped_lock = 0;
+}
+
+void
+_pydictlock_initstate_notshared(PyDict_LockState *lockstate)
+{
+    lockstate->doing_write = -1;
+    lockstate->skipped_lock = -1;
+}
+
+void
+_pydictlock_acquire(PyDictObject *mp, PyDict_LockState *lockstate)
+{
+    /* XXX FIXME this should allow a NULL lockstate if mp isn't a shareddict */
+    assert(lockstate);
+
+    if (PySharedDict_Check(mp)) {
+        PySharedDictObject *sd = (PySharedDictObject *)mp;
+        assert(lockstate->doing_write == 0 || lockstate->doing_write == 1);
+        assert(lockstate->skipped_lock == 0 || lockstate->skipped_lock == 1);
+
+        if (lockstate->doing_write) {
+            assert(!lockstate->skipped_lock);
+            PyCritical_Enter(sd->crit);
+
+            /* If the shareddict has entered readonly mode we use this
+             * expensive fallback to reset it.  This *should* be fairly
+             * rare. */
+            while (AO_load_acquire(&sd->readonly_mode)) {
+                PyCritical_Exit(sd->crit);
+                PyState_StopTheWorld();
+                AO_store_full(&sd->readonly_mode, 0);
+                sd->read_count = 0;
+                PyState_StartTheWorld();
+                PyCritical_Enter(sd->crit);
+            }
+
+            sd->read_count = 0;
+        } else {
+            /* XXX FIXME this should use a stack-allocated critical
+             * section if not using a real one */
+            if (AO_load_acquire(&sd->readonly_mode))
+                lockstate->skipped_lock = 1;
+            else {
+                PyCritical_Enter(sd->crit);
+                if (AO_load_acquire(&sd->readonly_mode)) {
+                    lockstate->skipped_lock = 1;
+                    PyCritical_Exit(sd->crit);
+                } else {
+                    sd->read_count++;
+                    //printf("Read count %d\n", sd->read_count);
+                    sd->read_count = 1;  /* XXX FIXME currently disabled */
+                    if (sd->read_count >= 10000) {
+                        /* Enter read-only mode */
+                        printf("Entering read-only mode%d\n", sd->read_count);
+                        AO_store_full(&sd->readonly_mode, 1);
+                        PyCritical_Exit(sd->crit);
+                        lockstate->skipped_lock = 1;
+                    } else
+                        lockstate->skipped_lock = 0;
+                }
+            }
+        }
+    }
+
+    /* It is an invariant that acquire/release are not called while the
+     * dict would need to be resized. */
+    assert(!(mp->ma_fill*3 >= (mp->ma_mask+1)*2));
+}
+
+void
+_pydictlock_release(PyDictObject *mp, PyDict_LockState *lockstate)
+{
+    assert(lockstate);
+
+    /* It is an invariant that acquire/release are not called while the
+     * dict would need to be resized. */
+    assert(!(mp->ma_fill*3 >= (mp->ma_mask+1)*2));
+
+    if (PySharedDict_Check(mp)) {
+        PySharedDictObject *sd = (PySharedDictObject *)mp;
+        assert(lockstate->doing_write == 0 || lockstate->doing_write == 1);
+        assert(lockstate->skipped_lock == 0 || lockstate->skipped_lock == 1);
+
+        if (lockstate->doing_write) {
+            assert(!lockstate->skipped_lock);
+            PyCritical_Exit(sd->crit);
+        } else {
+            /* XXX FIXME exit stack-allocated critical */
+            if (!lockstate->skipped_lock)
+                PyCritical_Exit(sd->crit);
+        }
+    }
+}
+
 /* Define this out if you don't want conversion statistics on exit. */
 #undef SHOW_CONVERSION_COUNTS
 
@@ -149,7 +277,8 @@
 
 /* forward declarations */
 static dictentry *
-lookdict_unicode(dictobject *mp, PyObject *key, long hash);
+lookdict_unicode(dictobject *mp, PyObject *key, long hash,
+    PyDict_LockState *lockstate);
 
 #ifdef SHOW_CONVERSION_COUNTS
 static long created = 0L;
@@ -181,13 +310,20 @@
 #define EMPTY_TO_MINSIZE(mp) do {					\
 	memset((mp)->ma_smalltable, 0, sizeof((mp)->ma_smalltable));	\
 	(mp)->ma_used = (mp)->ma_fill = 0;				\
+	(mp)->ma_rebuilds = 0;						\
 	INIT_NONZERO_DICT_SLOTS(mp);					\
     } while(0)
 
+//#define USE_DICT_FREELIST
+
+#ifdef USE_DICT_FREELIST
 /* Dictionary reuse scheme to save calls to malloc, free, and memset */
 #define MAXFREEDICTS 80
 static PyDictObject *free_dicts[MAXFREEDICTS];
 static int num_free_dicts = 0;
+/* This lock is only used while the GIL is already held */
+static PyThread_type_lock free_dicts_lock;
+#endif
 
 PyObject *
 PyDict_New(void)
@@ -201,8 +337,11 @@
 		Py_AtExit(show_counts);
 #endif
 	}
+#ifdef USE_DICT_FREELIST
+	PyThread_lock_acquire(free_dicts_lock);
 	if (num_free_dicts) {
 		mp = free_dicts[--num_free_dicts];
+		PyThread_lock_release(free_dicts_lock);
 		assert (mp != NULL);
 		assert (Py_Type(mp) == &PyDict_Type);
 		_Py_NewReference((PyObject *)mp);
@@ -213,16 +352,19 @@
 		assert (mp->ma_table == mp->ma_smalltable);
 		assert (mp->ma_mask == PyDict_MINSIZE - 1);
 	} else {
-		mp = PyObject_GC_New(dictobject, &PyDict_Type);
+		PyThread_lock_release(free_dicts_lock);
+#endif
+		mp = PyObject_NEW(dictobject, &PyDict_Type);
 		if (mp == NULL)
 			return NULL;
 		EMPTY_TO_MINSIZE(mp);
+#ifdef USE_DICT_FREELIST
 	}
+#endif
 	mp->ma_lookup = lookdict_unicode;
 #ifdef SHOW_CONVERSION_COUNTS
 	++created;
 #endif
-	_PyObject_GC_TRACK(mp);
 	return (PyObject *)mp;
 }
 
@@ -251,17 +393,23 @@
 dictentry*.
 */
 static dictentry *
-lookdict(dictobject *mp, PyObject *key, register long hash)
+lookdict(dictobject *mp, PyObject *key, register long hash,
+		PyDict_LockState *lockstate)
 {
 	register size_t i;
 	register size_t perturb;
 	register dictentry *freeslot;
-	register size_t mask = (size_t)mp->ma_mask;
-	dictentry *ep0 = mp->ma_table;
+	register size_t mask;
+	dictentry *ep0;
 	register dictentry *ep;
 	register int cmp;
 	PyObject *startkey;
+	unsigned long long rebuilds;
 
+start:
+	mask = (size_t)mp->ma_mask;
+	ep0 = mp->ma_table;
+	rebuilds = mp->ma_rebuilds;
 	i = (size_t)hash & mask;
 	ep = &ep0[i];
 	if (ep->me_key == NULL || ep->me_key == key)
@@ -272,21 +420,33 @@
 	else {
 		if (ep->me_hash == hash) {
 			startkey = ep->me_key;
+			Py_INCREF(startkey);
+			_pydictlock_release(mp, lockstate);
 			cmp = PyObject_RichCompareBool(startkey, key, Py_EQ);
-			if (cmp < 0)
+			_pydictlock_acquire(mp, lockstate);
+			if (cmp < 0) {
+				_pydictlock_release(mp, lockstate);
+				Py_DECREF(startkey);
+				_pydictlock_acquire(mp, lockstate);
 				return NULL;
-			if (ep0 == mp->ma_table && ep->me_key == startkey) {
-				if (cmp > 0)
-					return ep;
 			}
-			else {
+			/* XXX use branch hinting? */
+			if (rebuilds != mp->ma_rebuilds || ep->me_key != startkey) {
 				/* The compare did major nasty stuff to the
 				 * dict:  start over.
 				 * XXX A clever adversary could prevent this
 				 * XXX from terminating.
- 				 */
- 				return lookdict(mp, key, hash);
- 			}
+				 */
+				_pydictlock_release(mp, lockstate);
+				Py_DECREF(startkey);
+				_pydictlock_acquire(mp, lockstate);
+				goto start;
+			}
+			assert(ep0 == mp->ma_table);
+			assert(mask == (size_t)mp->ma_mask);
+			Py_DECREF(startkey);
+			if (cmp > 0)
+				return ep;
 		}
 		freeslot = NULL;
 	}
@@ -302,21 +462,33 @@
 			return ep;
 		if (ep->me_hash == hash && ep->me_key != dummy) {
 			startkey = ep->me_key;
+			Py_INCREF(startkey);
+			_pydictlock_release(mp, lockstate);
 			cmp = PyObject_RichCompareBool(startkey, key, Py_EQ);
-			if (cmp < 0)
+			_pydictlock_acquire(mp, lockstate);
+			if (cmp < 0) {
+				_pydictlock_release(mp, lockstate);
+				Py_DECREF(startkey);
+				_pydictlock_acquire(mp, lockstate);
 				return NULL;
-			if (ep0 == mp->ma_table && ep->me_key == startkey) {
-				if (cmp > 0)
-					return ep;
 			}
-			else {
+			/* XXX use branch hinting? */
+			if (rebuilds != mp->ma_rebuilds || ep->me_key != startkey) {
 				/* The compare did major nasty stuff to the
 				 * dict:  start over.
 				 * XXX A clever adversary could prevent this
 				 * XXX from terminating.
  				 */
- 				return lookdict(mp, key, hash);
- 			}
+				_pydictlock_release(mp, lockstate);
+				Py_DECREF(startkey);
+				_pydictlock_acquire(mp, lockstate);
+				goto start;
+			}
+			Py_DECREF(startkey);
+			assert(ep0 == mp->ma_table);
+			assert(mask == (size_t)mp->ma_mask);
+			if (cmp > 0)
+				return ep;
 		}
 		else if (ep->me_key == dummy && freeslot == NULL)
 			freeslot = ep;
@@ -355,7 +527,8 @@
  * This is valuable because dicts with only unicode keys are very common.
  */
 static dictentry *
-lookdict_unicode(dictobject *mp, PyObject *key, register long hash)
+lookdict_unicode(dictobject *mp, PyObject *key, register long hash,
+		PyDict_LockState *lockstate)
 {
 	register size_t i;
 	register size_t perturb;
@@ -364,6 +537,8 @@
 	dictentry *ep0 = mp->ma_table;
 	register dictentry *ep;
 
+	assert(lockstate);
+
 	/* Make sure this function doesn't have to handle non-unicode keys,
 	   including subclasses of str; e.g., one reason to subclass
 	   unicodes is to override __eq__, and for speed we don't cater to
@@ -373,7 +548,7 @@
 		++converted;
 #endif
 		mp->ma_lookup = lookdict;
-		return lookdict(mp, key, hash);
+		return lookdict(mp, key, hash, lockstate);
 	}
 	i = hash & mask;
 	ep = &ep0[i];
@@ -413,26 +588,31 @@
 Returns -1 if an error occurred, or 0 on success.
 */
 static int
-insertdict(register dictobject *mp, PyObject *key, long hash, PyObject *value)
+insertdict(register dictobject *mp, PyObject *key, long hash,
+		PyObject *value, PyDict_LockState *lockstate)
 {
 	PyObject *old_value;
 	register dictentry *ep;
 	typedef PyDictEntry *(*lookupfunc)(PyDictObject *, PyObject *, long);
 
 	assert(mp->ma_lookup != NULL);
-	ep = mp->ma_lookup(mp, key, hash);
+	ep = mp->ma_lookup(mp, key, hash, lockstate);
 	if (ep == NULL) {
+		_pydictlock_release(mp, lockstate);
 		Py_DECREF(key);
 		Py_DECREF(value);
+		_pydictlock_acquire(mp, lockstate);
 		return -1;
 	}
+
 	if (ep->me_value != NULL) {
 		old_value = ep->me_value;
 		ep->me_value = value;
+		_pydictlock_release(mp, lockstate);
 		Py_DECREF(old_value); /* which **CAN** re-enter */
 		Py_DECREF(key);
-	}
-	else {
+		_pydictlock_acquire(mp, lockstate);
+	} else {
 		if (ep->me_key == NULL)
 			mp->ma_fill++;
 		else {
@@ -545,6 +725,7 @@
 	mp->ma_used = 0;
 	i = mp->ma_fill;
 	mp->ma_fill = 0;
+	mp->ma_rebuilds++;
 
 	/* Copy the data over; this is refcount-neutral for active entries;
 	   dummy entries aren't copied over, of course */
@@ -580,10 +761,12 @@
 PyObject *
 PyDict_GetItem(PyObject *op, PyObject *key)
 {
+	PyThreadState *tstate = PyThreadState_Get();
 	long hash;
 	dictobject *mp = (dictobject *)op;
 	dictentry *ep;
-	PyThreadState *tstate;
+	PyDict_LockState lockstate;
+
 	if (!PyDict_Check(op))
 		return NULL;
 	if (!PyUnicode_CheckExact(key) ||
@@ -596,22 +779,24 @@
 		}
 	}
 
+	_pydictlock_initstate_notshared(&lockstate);
+
 	/* We can arrive here with a NULL tstate during initialization:
 	   try running "python -Wi" for an example related to string
 	   interning.  Let's just hope that no exception occurs then... */
-	tstate = _PyThreadState_Current;
+	/* XXX It's now impossible to have a NULL tstate */
 	if (tstate != NULL && tstate->curexc_type != NULL) {
 		/* preserve the existing exception */
 		PyObject *err_type, *err_value, *err_tb;
 		PyErr_Fetch(&err_type, &err_value, &err_tb);
-		ep = (mp->ma_lookup)(mp, key, hash);
+		ep = (mp->ma_lookup)(mp, key, hash, &lockstate);
 		/* ignore errors */
 		PyErr_Restore(err_type, err_value, err_tb);
 		if (ep == NULL)
 			return NULL;
 	}
 	else {
-		ep = (mp->ma_lookup)(mp, key, hash);
+		ep = (mp->ma_lookup)(mp, key, hash, &lockstate);
 		if (ep == NULL) {
 			PyErr_Clear();
 			return NULL;
@@ -630,6 +815,7 @@
 	long hash;
 	dictobject *mp = (dictobject *)op;
 	dictentry *ep;
+	PyDict_LockState lockstate;
 
 	if (!PyDict_Check(op)) {
 		PyErr_BadInternalCall();
@@ -644,12 +830,60 @@
 		}
 	}
 
-	ep = (mp->ma_lookup)(mp, key, hash);
+	_pydictlock_initstate_notshared(&lockstate);
+
+	ep = (mp->ma_lookup)(mp, key, hash, &lockstate);
 	if (ep == NULL)
 		return NULL;
 	return ep->me_value;
 }
 
+/* Yet another variant of PyDict_GetItem().  Return values:
+ * -1 Error, exception set (value set to NULL)
+ *  0 Success (value filled in with *NEW* reference)
+ * +1 Not found, no exception set (value set to NULL)
+ */
+int
+PyDict_GetItemEx(PyObject *op, PyObject *key, PyObject **value)
+{
+    long hash;
+    dictobject *mp = (dictobject *)op;
+    dictentry *ep;
+    PyDict_LockState lockstate;
+
+    *value = NULL;
+
+    if (!PyDict_Check(op)) {
+        PyErr_BadInternalCall();
+        return -1;
+    }
+    if (!PyUnicode_CheckExact(key) ||
+            (hash = ((PyUnicodeObject *) key)->hash) == -1) {
+        hash = PyObject_Hash(key);
+        if (hash == -1) {
+            return -1;
+        }
+    }
+
+    _pydictlock_initstate_read(&lockstate);
+
+    _pydictlock_acquire(mp, &lockstate);
+    ep = (mp->ma_lookup)(mp, key, hash, &lockstate);
+    if (ep == NULL) {
+        _pydictlock_release(mp, &lockstate);
+        return -1;
+    }
+
+    *value = ep->me_value;
+    Py_XINCREF(*value);
+    _pydictlock_release(mp, &lockstate);
+
+    if (*value)
+        return 0;
+    else
+        return 1;
+}
+
 /* CAUTION: PyDict_SetItem() must guarantee that it won't resize the
  * dictionary if it's merely replacing the value for an existing key.
  * This means that it's safe to loop over a dictionary with PyDict_Next()
@@ -659,9 +893,12 @@
 int
 PyDict_SetItem(register PyObject *op, PyObject *key, PyObject *value)
 {
+	PyThreadState *tstate = PyThreadState_Get();
 	register dictobject *mp;
 	register long hash;
 	register Py_ssize_t n_used;
+	PyDict_LockState lockstate;
+	int result;
 
 	if (!PyDict_Check(op)) {
 		PyErr_BadInternalCall();
@@ -670,19 +907,26 @@
 	assert(key);
 	assert(value);
 	mp = (dictobject *)op;
+	if (block_unshareable_keyvalue(op, key, value))
+		return -1;
 	if (!PyUnicode_CheckExact(key) ||
-	    (hash = ((PyUnicodeObject *) key)->hash) == -1)
-	{
+			(hash = ((PyUnicodeObject *) key)->hash) == -1) {
 		hash = PyObject_Hash(key);
 		if (hash == -1)
 			return -1;
 	}
+	_pydictlock_initstate_write(&lockstate);
+
+	_pydictlock_acquire(mp, &lockstate);
 	assert(mp->ma_fill <= mp->ma_mask);  /* at least one empty slot */
 	n_used = mp->ma_used;
-	Py_INCREF(value);
-	Py_INCREF(key);
-	if (insertdict(mp, key, hash, value) != 0)
+	Py_INCREFTS(value);
+	Py_INCREFTS(key);
+	if (insertdict(mp, key, hash, value, &lockstate) != 0) {
+		_pydictlock_release(mp, &lockstate);
 		return -1;
+	}
+
 	/* If we added a key, we can safely resize.  Otherwise just return!
 	 * If fill >= 2/3 size, adjust size.  Normally, this doubles or
 	 * quaduples the size, but it's also possible for the dict to shrink
@@ -697,9 +941,13 @@
 	 * Very large dictionaries (over 50K items) use doubling instead.
 	 * This may help applications with severe memory constraints.
 	 */
-	if (!(mp->ma_used > n_used && mp->ma_fill*3 >= (mp->ma_mask+1)*2))
+	if (!(mp->ma_used > n_used && mp->ma_fill*3 >= (mp->ma_mask+1)*2)) {
+		_pydictlock_release(mp, &lockstate);
 		return 0;
-	return dictresize(mp, (mp->ma_used > 50000 ? 2 : 4) * mp->ma_used);
+	}
+	result = dictresize(mp, (mp->ma_used > 50000 ? 2 : 4) * mp->ma_used);
+	_pydictlock_release(mp, &lockstate);
+	return result;
 }
 
 int
@@ -709,6 +957,7 @@
 	register long hash;
 	register dictentry *ep;
 	PyObject *old_value, *old_key;
+	PyDict_LockState lockstate;
 
 	if (!PyDict_Check(op)) {
 		PyErr_BadInternalCall();
@@ -722,10 +971,16 @@
 			return -1;
 	}
 	mp = (dictobject *)op;
-	ep = (mp->ma_lookup)(mp, key, hash);
-	if (ep == NULL)
+	_pydictlock_initstate_write(&lockstate);
+
+	_pydictlock_acquire(mp, &lockstate);
+	ep = (mp->ma_lookup)(mp, key, hash, &lockstate);
+	if (ep == NULL) {
+		_pydictlock_release(mp, &lockstate);
 		return -1;
+	}
 	if (ep->me_value == NULL) {
+		_pydictlock_release(mp, &lockstate);
 		set_key_error(key);
 		return -1;
 	}
@@ -735,6 +990,7 @@
 	old_value = ep->me_value;
 	ep->me_value = NULL;
 	mp->ma_used--;
+	_pydictlock_release(mp, &lockstate);
 	Py_DECREF(old_value);
 	Py_DECREF(old_key);
 	return 0;
@@ -751,10 +1007,14 @@
 #ifdef Py_DEBUG
 	Py_ssize_t i, n;
 #endif
+	PyDict_LockState lockstate;
 
 	if (!PyDict_Check(op))
 		return;
 	mp = (dictobject *)op;
+	_pydictlock_initstate_write(&lockstate);
+
+	_pydictlock_acquire(mp, &lockstate);
 #ifdef Py_DEBUG
 	n = mp->ma_mask + 1;
 	i = 0;
@@ -784,6 +1044,7 @@
 		EMPTY_TO_MINSIZE(mp);
 	}
 	/* else it's a small table that's already empty */
+	_pydictlock_release(mp, &lockstate);
 
 	/* Now we can finally clear things.  If C had refcounts, we could
 	 * assert that the refcount on table is 1 now, i.e. that this function
@@ -830,12 +1091,18 @@
 	register Py_ssize_t i;
 	register Py_ssize_t mask;
 	register dictentry *ep;
+	PyDict_LockState lockstate;
 
 	if (!PyDict_Check(op))
 		return 0;
 	i = *ppos;
 	if (i < 0)
 		return 0;
+
+	_pydictlock_initstate_notshared(&lockstate);
+	_pydictlock_acquire((dictobject *)op, &lockstate);
+	_pydictlock_release((dictobject *)op, &lockstate);
+
 	ep = ((dictobject *)op)->ma_table;
 	mask = ((dictobject *)op)->ma_mask;
 	while (i <= mask && ep[i].me_value == NULL)
@@ -857,12 +1124,18 @@
 	register Py_ssize_t i;
 	register Py_ssize_t mask;
 	register dictentry *ep;
+	PyDict_LockState lockstate;
 
 	if (!PyDict_Check(op))
 		return 0;
 	i = *ppos;
 	if (i < 0)
 		return 0;
+
+	_pydictlock_initstate_notshared(&lockstate);
+	_pydictlock_acquire((dictobject *)op, &lockstate);
+	_pydictlock_release((dictobject *)op, &lockstate);
+
 	ep = ((dictobject *)op)->ma_table;
 	mask = ((dictobject *)op)->ma_mask;
 	while (i <= mask && ep[i].me_value == NULL)
@@ -878,6 +1151,47 @@
 	return 1;
 }
 
+/* Variant of PyDict_Next that provides *NEW* references to key and value */
+int
+PyDict_NextEx(PyObject *op, Py_ssize_t *ppos, PyObject **pkey, PyObject **pvalue)
+{
+	register Py_ssize_t i;
+	register Py_ssize_t mask;
+	register dictentry *ep;
+	PyDict_LockState lockstate;
+
+	if (!PyDict_Check(op))
+		return 0;
+	i = *ppos;
+	if (i < 0)
+		return 0;
+
+	_pydictlock_initstate_read(&lockstate);
+
+	_pydictlock_acquire((dictobject *)op, &lockstate);
+	ep = ((dictobject *)op)->ma_table;
+	mask = ((dictobject *)op)->ma_mask;
+	while (i <= mask && ep[i].me_value == NULL)
+		i++;
+	*ppos = i+1;
+	if (i > mask) {
+		_pydictlock_release((dictobject *)op, &lockstate);
+		return 0;
+	}
+
+	if (pkey) {
+		*pkey = ep[i].me_key;
+		Py_INCREF(*pkey);
+	}
+	if (pvalue) {
+		*pvalue = ep[i].me_value;
+		Py_INCREF(*pvalue);
+	}
+
+	_pydictlock_release((dictobject *)op, &lockstate);
+	return 1;
+}
+
 /* Methods */
 
 static void
@@ -885,8 +1199,6 @@
 {
 	register dictentry *ep;
 	Py_ssize_t fill = mp->ma_fill;
- 	PyObject_GC_UnTrack(mp);
-	Py_TRASHCAN_SAFE_BEGIN(mp)
 	for (ep = mp->ma_table; fill > 0; ep++) {
 		if (ep->me_key) {
 			--fill;
@@ -896,13 +1208,27 @@
 	}
 	if (mp->ma_table != mp->ma_smalltable)
 		PyMem_DEL(mp->ma_table);
-	if (num_free_dicts < MAXFREEDICTS && Py_Type(mp) == &PyDict_Type)
+#ifdef USE_DICT_FREELIST
+	PyThread_lock_acquire(free_dicts_lock);
+	if (num_free_dicts < MAXFREEDICTS && Py_Type(mp) == &PyDict_Type) {
 		free_dicts[num_free_dicts++] = mp;
-	else
-		Py_Type(mp)->tp_free((PyObject *)mp);
-	Py_TRASHCAN_SAFE_END(mp)
+		PyThread_lock_release(free_dicts_lock);
+	} else {
+		PyThread_lock_release(free_dicts_lock);
+#endif
+		PyObject_DEL(mp);
+#ifdef USE_DICT_FREELIST
+	}
+#endif
 }
 
+static void
+shareddict_dealloc(PySharedDictObject *mp)
+{
+    PyCritical_Free(mp->crit);
+    dict_dealloc((PyDictObject *)mp);
+}
+
 static PyObject *
 dict_repr(dictobject *mp)
 {
@@ -932,13 +1258,12 @@
 	/* Do repr() on each key+value pair, and insert ": " between them.
 	   Note that repr may mutate the dict. */
 	i = 0;
-	while (PyDict_Next((PyObject *)mp, &i, &key, &value)) {
+	while (PyDict_NextEx((PyObject *)mp, &i, &key, &value)) {
 		int status;
-		/* Prevent repr from deleting value during key format. */
-		Py_INCREF(value);
 		s = PyObject_Repr(key);
 		PyUnicode_Append(&s, colon);
 		PyUnicode_AppendAndDel(&s, PyObject_Repr(value));
+		Py_DECREF(key);
 		Py_DECREF(value);
 		if (s == NULL)
 			goto Done;
@@ -982,10 +1307,54 @@
 	return result;
 }
 
+static PyObject *
+shareddict_repr(dictobject *mp)
+{
+	PyObject *s = NULL, *inner = NULL, *name = NULL, *format = NULL;
+	PyObject *t = NULL;
+
+	format = PyString_FromString("%s(%s)");
+	if (format == NULL)
+		goto Done;
+
+	name = PyObject_GetAttrString((PyObject *)Py_Type(mp), "__name__");
+	if (name == NULL)
+		goto Done;
+
+	inner = dict_repr(mp);
+	if (inner == NULL)
+		goto Done;
+
+	t = PyTuple_New(2);
+	if (t == NULL)
+		goto Done;
+	PyTuple_SET_ITEM(t, 0, name);
+	name = NULL;
+	PyTuple_SET_ITEM(t, 1, inner);
+	inner = NULL;
+
+	s = PyString_Format(format, t);
+
+Done:
+	Py_XDECREF(format);
+	Py_XDECREF(name);
+	Py_XDECREF(inner);
+	Py_XDECREF(t);
+	return s;
+}
+
 static Py_ssize_t
 dict_length(dictobject *mp)
 {
-	return mp->ma_used;
+    Py_ssize_t len;
+    PyDict_LockState lockstate;
+
+    _pydictlock_initstate_read(&lockstate);
+    _pydictlock_acquire(mp, &lockstate);
+    len = mp->ma_used;
+    _pydictlock_release(mp, &lockstate);
+
+    return len;
 }
 
 static PyObject *
@@ -994,35 +1363,51 @@
 	PyObject *v;
 	long hash;
 	dictentry *ep;
-	assert(mp->ma_table != NULL);
+	PyDict_LockState lockstate;
+
 	if (!PyUnicode_CheckExact(key) ||
 	    (hash = ((PyUnicodeObject *) key)->hash) == -1) {
 		hash = PyObject_Hash(key);
 		if (hash == -1)
 			return NULL;
 	}
-	ep = (mp->ma_lookup)(mp, key, hash);
-	if (ep == NULL)
+
+	_pydictlock_initstate_read(&lockstate);
+
+	_pydictlock_acquire(mp, &lockstate);
+	assert(mp->ma_table != NULL);
+	ep = (mp->ma_lookup)(mp, key, hash, &lockstate);
+	if (ep == NULL) {
+		_pydictlock_release(mp, &lockstate);
 		return NULL;
+	}
 	v = ep->me_value;
 	if (v == NULL) {
+		_pydictlock_release(mp, &lockstate);
 		if (!PyDict_CheckExact(mp)) {
 			/* Look up __missing__ method if we're a subclass. */
-		    	PyObject *missing;
+			PyObject *missing;
 			static PyObject *missing_str = NULL;
+
 			if (missing_str == NULL)
 				missing_str =
 				  PyUnicode_InternFromString("__missing__");
-			missing = _PyType_Lookup(Py_Type(mp), missing_str);
-			if (missing != NULL)
-				return PyObject_CallFunctionObjArgs(missing,
+
+			if (_PyType_LookupEx(Py_Type(mp), missing_str, &missing) < 0)
+				return NULL;
+			if (missing != NULL) {
+				v = PyObject_CallFunctionObjArgs(missing,
 					(PyObject *)mp, key, NULL);
+				Py_DECREF(missing);
+				return v;
+			}
 		}
 		set_key_error(key);
 		return NULL;
+	} else {
+		Py_INCREF(v);
+		_pydictlock_release(mp, &lockstate);
 	}
-	else
-		Py_INCREF(v);
 	return v;
 }
 
@@ -1048,19 +1433,29 @@
 	register Py_ssize_t i, j;
 	dictentry *ep;
 	Py_ssize_t mask, n;
+	PyDict_LockState lockstate;
+	unsigned long long rebuilds;
 
   again:
+	_pydictlock_initstate_read(&lockstate);
+
+	_pydictlock_acquire(mp, &lockstate);
 	n = mp->ma_used;
+	rebuilds = mp->ma_rebuilds;
+	_pydictlock_release(mp, &lockstate);
 	v = PyList_New(n);
 	if (v == NULL)
 		return NULL;
-	if (n != mp->ma_used) {
+	_pydictlock_acquire(mp, &lockstate);
+	if (rebuilds != mp->ma_rebuilds) {
+		_pydictlock_release(mp, &lockstate);
 		/* Durnit.  The allocations caused the dict to resize.
 		 * Just start over, this shouldn't normally happen.
 		 */
 		Py_DECREF(v);
 		goto again;
 	}
+	assert(n == mp->ma_used);
 	ep = mp->ma_table;
 	mask = mp->ma_mask;
 	for (i = 0, j = 0; i <= mask; i++) {
@@ -1072,6 +1467,7 @@
 		}
 	}
 	assert(j == n);
+	_pydictlock_release(mp, &lockstate);
 	return v;
 }
 
@@ -1082,19 +1478,29 @@
 	register Py_ssize_t i, j;
 	dictentry *ep;
 	Py_ssize_t mask, n;
+	PyDict_LockState lockstate;
+	unsigned long long rebuilds;
 
   again:
+	_pydictlock_initstate_read(&lockstate);
+
+	_pydictlock_acquire(mp, &lockstate);
 	n = mp->ma_used;
+	rebuilds = mp->ma_rebuilds;
+	_pydictlock_release(mp, &lockstate);
 	v = PyList_New(n);
 	if (v == NULL)
 		return NULL;
-	if (n != mp->ma_used) {
+	_pydictlock_acquire(mp, &lockstate);
+	if (rebuilds != mp->ma_rebuilds) {
+		_pydictlock_release(mp, &lockstate);
 		/* Durnit.  The allocations caused the dict to resize.
 		 * Just start over, this shouldn't normally happen.
 		 */
 		Py_DECREF(v);
 		goto again;
 	}
+	assert(n == mp->ma_used);
 	ep = mp->ma_table;
 	mask = mp->ma_mask;
 	for (i = 0, j = 0; i <= mask; i++) {
@@ -1106,6 +1512,7 @@
 		}
 	}
 	assert(j == n);
+	_pydictlock_release(mp, &lockstate);
 	return v;
 }
 
@@ -1117,13 +1524,20 @@
 	Py_ssize_t mask;
 	PyObject *item, *key, *value;
 	dictentry *ep;
+	PyDict_LockState lockstate;
+	unsigned long long rebuilds;
 
+  again:
+	_pydictlock_initstate_read(&lockstate);
+
 	/* Preallocate the list of tuples, to avoid allocations during
 	 * the loop over the items, which could trigger GC, which
 	 * could resize the dict. :-(
 	 */
-  again:
+	_pydictlock_acquire(mp, &lockstate);
 	n = mp->ma_used;
+	rebuilds = mp->ma_rebuilds;
+	_pydictlock_release(mp, &lockstate);
 	v = PyList_New(n);
 	if (v == NULL)
 		return NULL;
@@ -1135,7 +1549,9 @@
 		}
 		PyList_SET_ITEM(v, i, item);
 	}
-	if (n != mp->ma_used) {
+	_pydictlock_acquire(mp, &lockstate);
+	if (rebuilds != mp->ma_rebuilds) {
+		_pydictlock_release(mp, &lockstate);
 		/* Durnit.  The allocations caused the dict to resize.
 		 * Just start over, this shouldn't normally happen.
 		 */
@@ -1143,6 +1559,7 @@
 		goto again;
 	}
 	/* Nothing we do below makes any function calls. */
+	assert(n == mp->ma_used);
 	ep = mp->ma_table;
 	mask = mp->ma_mask;
 	for (i = 0, j = 0; i <= mask; i++) {
@@ -1157,6 +1574,7 @@
 		}
 	}
 	assert(j == n);
+	_pydictlock_release(mp, &lockstate);
 	return v;
 }
 
@@ -1173,6 +1591,8 @@
 	if (!PyArg_UnpackTuple(args, "fromkeys", 1, 2, &seq, &value))
 		return NULL;
 
+	assert(PyType_Check(cls));
+
 	d = PyObject_CallObject(cls, NULL);
 	if (d == NULL)
 		return NULL;
@@ -1182,15 +1602,20 @@
 		Py_ssize_t pos = 0;
 		PyObject *key;
 		long hash;
+		PyDict_LockState lockstate;
 
+		_pydictlock_initstate_notshared(&lockstate);
+
 		if (dictresize(mp, PySet_GET_SIZE(seq)))
 			return NULL;
 
 		while (_PySet_NextEntry(seq, &pos, &key, &hash)) {
 			Py_INCREF(key);
 			Py_INCREF(value);
-			if (insertdict(mp, key, hash, value))
+			if (insertdict(mp, key, hash, value, &lockstate)) {
+				Py_DECREF(d);
 				return NULL;
+			}
 		}
 		return d;
 	}
@@ -1224,7 +1649,8 @@
 }
 
 static int
-dict_update_common(PyObject *self, PyObject *args, PyObject *kwds, char *methname)
+dict_update_common(PyObject *self, PyObject *args, PyObject *kwds,
+		char *methname)
 {
 	PyObject *arg = NULL;
 	int result = 0;
@@ -1258,7 +1684,7 @@
    PyDict_{Update,Merge} update/merge from a mapping object.
 
    PyDict_MergeFromSeq2 updates/merges from any iterable object
-   producing iterable objects of length 2.
+   that produces iterable objects of length 2.
 */
 
 int
@@ -1280,6 +1706,7 @@
 	for (i = 0; ; ++i) {
 		PyObject *key, *value;
 		Py_ssize_t n;
+		int status;
 
 		fast = NULL;
 		item = PyIter_Next(it);
@@ -1311,10 +1738,16 @@
 		/* Update/merge with this (key, value) pair. */
 		key = PySequence_Fast_GET_ITEM(fast, 0);
 		value = PySequence_Fast_GET_ITEM(fast, 1);
-		if (override || PyDict_GetItem(d, key) == NULL) {
-			int status = PyDict_SetItem(d, key, value);
+		if (override) {
+			status = PyDict_SetItem(d, key, value);
 			if (status < 0)
 				goto Fail;
+		} else if ((status = PyDict_Contains(d, key))) {
+			if (status < 0)
+				goto Fail;
+			status = PyDict_SetItem(d, key, value);
+			if (status < 0)
+				goto Fail;
 		}
 		Py_DECREF(fast);
 		Py_DECREF(item);
@@ -1340,10 +1773,6 @@
 int
 PyDict_Merge(PyObject *a, PyObject *b, int override)
 {
-	register PyDictObject *mp, *other;
-	register Py_ssize_t i;
-	dictentry *entry;
-
 	/* We accept for the argument either a concrete dictionary object,
 	 * or an abstract "mapping" object.  For the former, we can do
 	 * things quite efficiently.  For the latter, we only require that
@@ -1353,9 +1782,17 @@
 		PyErr_BadInternalCall();
 		return -1;
 	}
-	mp = (dictobject*)a;
-	if (PyDict_CheckExact(b)) {
-		other = (dictobject*)b;
+	if (PyDict_CheckExact(b) && !PySharedDict_Check(a)) {
+		register PyDictObject *mp = (PyDictObject *)a;
+		register PyDictObject *other = (PyDictObject *)b;
+		register Py_ssize_t i;
+		dictentry *entry;
+		PyDict_LockState lockstate;
+
+		/* This branch is only used for normal dicts, so no
+		 * locking is necessary */
+		_pydictlock_initstate_notshared(&lockstate);
+
 		if (other == mp || other->ma_used == 0)
 			/* a.update(a) or a.update({}); nothing to do */
 			return 0;
@@ -1378,16 +1815,18 @@
 			if (entry->me_value != NULL &&
 			    (override ||
 			     PyDict_GetItem(a, entry->me_key) == NULL)) {
+				if (block_unshareable_keyvalue(a, entry->me_key,
+						entry->me_value))
+					return -1;
 				Py_INCREF(entry->me_key);
 				Py_INCREF(entry->me_value);
 				if (insertdict(mp, entry->me_key,
 					       (long)entry->me_hash,
-					       entry->me_value) != 0)
+					       entry->me_value, &lockstate) != 0)
 					return -1;
 			}
 		}
-	}
-	else {
+	} else {
 		/* Do it the generic, slower way */
 		PyObject *keys = PyMapping_Keys(b);
 		PyObject *iter;
@@ -1408,7 +1847,11 @@
 			return -1;
 
 		for (key = PyIter_Next(iter); key; key = PyIter_Next(iter)) {
-			if (!override && PyDict_GetItem(a, key) != NULL) {
+			if (!override && (status = PyDict_Contains(a, key))) {
+				if (status < 0) {
+					Py_DECREF(iter);
+					return -1;
+				}
 				Py_DECREF(key);
 				continue;
 			}
@@ -1465,7 +1908,7 @@
 		PyErr_BadInternalCall();
 		return -1;
 	}
-	return ((dictobject *)mp)->ma_used;
+	return dict_length((dictobject *)mp);
 }
 
 PyObject *
@@ -1503,41 +1946,41 @@
  * Uses only Py_EQ comparison.
  */
 static int
-dict_equal(dictobject *a, dictobject *b)
+dict_equal(PyObject *a, PyObject *b)
 {
-	Py_ssize_t i;
+    PyObject *key, *value;
+    Py_ssize_t i;
 
-	if (a->ma_used != b->ma_used)
-		/* can't be equal if # of entries differ */
-		return 0;
+    if (PyDict_Size(a) != PyDict_Size(b))
+        /* can't be equal if # of entries differ */
+        return 0;
 
-	/* Same # of entries -- check all of 'em.  Exit early on any diff. */
-	for (i = 0; i <= a->ma_mask; i++) {
-		PyObject *aval = a->ma_table[i].me_value;
-		if (aval != NULL) {
-			int cmp;
-			PyObject *bval;
-			PyObject *key = a->ma_table[i].me_key;
-			/* temporarily bump aval's refcount to ensure it stays
-			   alive until we're done with it */
-			Py_INCREF(aval);
-			/* ditto for key */
-			Py_INCREF(key);
-			bval = PyDict_GetItemWithError((PyObject *)b, key);
-			Py_DECREF(key);
-			if (bval == NULL) {
-				Py_DECREF(aval);
-				if (PyErr_Occurred())
-					return -1;
-				return 0;
-			}
-			cmp = PyObject_RichCompareBool(aval, bval, Py_EQ);
-			Py_DECREF(aval);
-			if (cmp <= 0)  /* error or not equal */
-				return cmp;
- 		}
-	}
-	return 1;
+    /* Same # of entries -- check all of 'em.  Exit early on any diff. */
+    i = 0;
+    while (PyDict_NextEx(a, &i, &key, &value)) {
+        PyObject *bvalue;
+        int cmp;
+
+        if (PyDict_GetItemEx(b, key, &bvalue) < 0) {
+            Py_DECREF(key);
+            Py_DECREF(value);
+            return -1;
+        }
+        if (bvalue == NULL) {
+            Py_DECREF(key);
+            Py_DECREF(value);
+            return 0;
+        }
+
+        cmp = PyObject_RichCompareBool(value, bvalue, Py_EQ);
+        Py_DECREF(key);
+        Py_DECREF(value);
+        Py_DECREF(bvalue);
+        if (cmp <= 0)  /* error or not equal */
+            return cmp;
+    }
+
+    return 1;
  }
 
 static PyObject *
@@ -1550,7 +1993,7 @@
 		res = Py_NotImplemented;
 	}
 	else if (op == Py_EQ || op == Py_NE) {
-		cmp = dict_equal((dictobject *)v, (dictobject *)w);
+		cmp = dict_equal(v, w);
 		if (cmp < 0)
 			return NULL;
 		res = (cmp == (op == Py_EQ)) ? Py_True : Py_False;
@@ -1564,47 +2007,37 @@
 static PyObject *
 dict_contains(register dictobject *mp, PyObject *key)
 {
-	long hash;
-	dictentry *ep;
+    PyObject *value;
 
-	if (!PyUnicode_CheckExact(key) ||
-	    (hash = ((PyUnicodeObject *) key)->hash) == -1) {
-		hash = PyObject_Hash(key);
-		if (hash == -1)
-			return NULL;
-	}
-	ep = (mp->ma_lookup)(mp, key, hash);
-	if (ep == NULL)
-		return NULL;
-	return PyBool_FromLong(ep->me_value != NULL);
+    if (PyDict_GetItemEx((PyObject *)mp, key, &value) < 0)
+        return NULL;
+
+    if (value == NULL)
+        return PyBool_FromLong(0);
+    else {
+        Py_DECREF(value);
+        return PyBool_FromLong(1);
+    }
 }
 
 static PyObject *
 dict_get(register dictobject *mp, PyObject *args)
 {
-	PyObject *key;
-	PyObject *failobj = Py_None;
-	PyObject *val = NULL;
-	long hash;
-	dictentry *ep;
+    PyObject *key;
+    PyObject *failobj = Py_None;
+    PyObject *val;
 
-	if (!PyArg_UnpackTuple(args, "get", 1, 2, &key, &failobj))
-		return NULL;
+    if (!PyArg_UnpackTuple(args, "get", 1, 2, &key, &failobj))
+        return NULL;
 
-	if (!PyUnicode_CheckExact(key) ||
-	    (hash = ((PyUnicodeObject *) key)->hash) == -1) {
-		hash = PyObject_Hash(key);
-		if (hash == -1)
-			return NULL;
-	}
-	ep = (mp->ma_lookup)(mp, key, hash);
-	if (ep == NULL)
-		return NULL;
-	val = ep->me_value;
-	if (val == NULL)
-		val = failobj;
-	Py_INCREF(val);
-	return val;
+    if (PyDict_GetItemEx((PyObject *)mp, key, &val) < 0)
+        return NULL;
+
+    if (val == NULL) {
+        Py_INCREF(failobj);
+        return failobj;
+    } else
+        return val;
 }
 
 
@@ -1616,6 +2049,7 @@
 	PyObject *val = NULL;
 	long hash;
 	dictentry *ep;
+	PyDict_LockState lockstate;
 
 	if (!PyArg_UnpackTuple(args, "setdefault", 1, 2, &key, &failobj))
 		return NULL;
@@ -1626,16 +2060,32 @@
 		if (hash == -1)
 			return NULL;
 	}
-	ep = (mp->ma_lookup)(mp, key, hash);
-	if (ep == NULL)
+	if (block_unshareable_keyvalue((PyObject *)mp, key, val))
 		return NULL;
+
+	_pydictlock_initstate_write(&lockstate);
+
+	_pydictlock_acquire(mp, &lockstate);
+	ep = (mp->ma_lookup)(mp, key, hash, &lockstate);
+	if (ep == NULL) {
+		_pydictlock_release(mp, &lockstate);
+		return NULL;
+	}
 	val = ep->me_value;
-	if (val == NULL) {
+	if (val != NULL) {
+		Py_INCREF(val);
+		_pydictlock_release(mp, &lockstate);
+	} else {
+		_pydictlock_release(mp, &lockstate);
+		/* XXX FIXME: This uses two separate operations, meaning
+		 * it's not atomic.  This is wrong, but is it important
+		 * enough to fix? */
 		val = failobj;
 		if (PyDict_SetItem((PyObject*)mp, key, failobj))
 			val = NULL;
+		else
+			Py_INCREF(failobj);
 	}
-	Py_XINCREF(val);
 	return val;
 }
 
@@ -1654,10 +2104,23 @@
 	dictentry *ep;
 	PyObject *old_value, *old_key;
 	PyObject *key, *deflt = NULL;
+	PyDict_LockState lockstate;
 
 	if(!PyArg_UnpackTuple(args, "pop", 1, 2, &key, &deflt))
 		return NULL;
+
+	if (!PyUnicode_CheckExact(key) ||
+	    (hash = ((PyUnicodeObject *) key)->hash) == -1) {
+		hash = PyObject_Hash(key);
+		if (hash == -1)
+			return NULL;
+	}
+
+	_pydictlock_initstate_write(&lockstate);
+
+	_pydictlock_acquire(mp, &lockstate);
 	if (mp->ma_used == 0) {
+		_pydictlock_release(mp, &lockstate);
 		if (deflt) {
 			Py_INCREF(deflt);
 			return deflt;
@@ -1666,16 +2129,13 @@
 				"pop(): dictionary is empty");
 		return NULL;
 	}
-	if (!PyUnicode_CheckExact(key) ||
-	    (hash = ((PyUnicodeObject *) key)->hash) == -1) {
-		hash = PyObject_Hash(key);
-		if (hash == -1)
-			return NULL;
+	ep = (mp->ma_lookup)(mp, key, hash, &lockstate);
+	if (ep == NULL) {
+		_pydictlock_release(mp, &lockstate);
+		return NULL;
 	}
-	ep = (mp->ma_lookup)(mp, key, hash);
-	if (ep == NULL)
-		return NULL;
 	if (ep->me_value == NULL) {
+		_pydictlock_release(mp, &lockstate);
 		if (deflt) {
 			Py_INCREF(deflt);
 			return deflt;
@@ -1689,6 +2149,7 @@
 	old_value = ep->me_value;
 	ep->me_value = NULL;
 	mp->ma_used--;
+	_pydictlock_release(mp, &lockstate);
 	Py_DECREF(old_key);
 	return old_value;
 }
@@ -1699,6 +2160,7 @@
 	Py_ssize_t i = 0;
 	dictentry *ep;
 	PyObject *res;
+	PyDict_LockState lockstate;
 
 	/* Allocate the result tuple before checking the size.  Believe it
 	 * or not, this allocation could trigger a garbage collection which
@@ -1712,7 +2174,12 @@
 	res = PyTuple_New(2);
 	if (res == NULL)
 		return NULL;
+
+	_pydictlock_initstate_write(&lockstate);
+
+	_pydictlock_acquire(mp, &lockstate);
 	if (mp->ma_used == 0) {
+		_pydictlock_release(mp, &lockstate);
 		Py_DECREF(res);
 		PyErr_SetString(PyExc_KeyError,
 				"popitem(): dictionary is empty");
@@ -1748,6 +2215,7 @@
 	mp->ma_used--;
 	assert(mp->ma_table[0].me_value == NULL);
 	mp->ma_table[0].me_hash = i + 1;  /* next place to start */
+	_pydictlock_release(mp, &lockstate);
 	return res;
 }
 
@@ -1861,6 +2329,8 @@
 	long hash;
 	dictobject *mp = (dictobject *)op;
 	dictentry *ep;
+	int res;
+	PyDict_LockState lockstate;
 
 	if (!PyUnicode_CheckExact(key) ||
 	    (hash = ((PyUnicodeObject *) key)->hash) == -1) {
@@ -1868,8 +2338,14 @@
 		if (hash == -1)
 			return -1;
 	}
-	ep = (mp->ma_lookup)(mp, key, hash);
-	return ep == NULL ? -1 : (ep->me_value != NULL);
+
+	_pydictlock_initstate_read(&lockstate);
+
+	_pydictlock_acquire(mp, &lockstate);
+	ep = (mp->ma_lookup)(mp, key, hash, &lockstate);
+	res = ep == NULL ? -1 : (ep->me_value != NULL);
+	_pydictlock_release(mp, &lockstate);
+	return res;
 }
 
 /* Internal version of PyDict_Contains used when the hash value is already known */
@@ -1878,9 +2354,16 @@
 {
 	dictobject *mp = (dictobject *)op;
 	dictentry *ep;
+	int res;
+	PyDict_LockState lockstate;
 
-	ep = (mp->ma_lookup)(mp, key, hash);
-	return ep == NULL ? -1 : (ep->me_value != NULL);
+	_pydictlock_initstate_read(&lockstate);
+
+	_pydictlock_acquire(mp, &lockstate);
+	ep = (mp->ma_lookup)(mp, key, hash, &lockstate);
+	res = ep == NULL ? -1 : (ep->me_value != NULL);
+	_pydictlock_release(mp, &lockstate);
+	return res;
 }
 
 /* Hack to implement "key in dict" */
@@ -1902,12 +2385,11 @@
 {
 	PyObject *self;
 
-	assert(type != NULL && type->tp_alloc != NULL);
-	self = type->tp_alloc(type, 0);
+	assert(type != NULL);
+	self = PyObject_New(type);
 	if (self != NULL) {
+		const size_t size = _PyObject_SIZE(type);
 		PyDictObject *d = (PyDictObject *)self;
-		/* It's guaranteed that tp->alloc zeroed out the struct. */
-		assert(d->ma_table == NULL && d->ma_fill == 0 && d->ma_used == 0);
 		INIT_NONZERO_DICT_SLOTS(d);
 		d->ma_lookup = lookdict_unicode;
 #ifdef SHOW_CONVERSION_COUNTS
@@ -1917,6 +2399,27 @@
 	return self;
 }
 
+static PyObject *
+shareddict_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
+{
+    PySharedDictObject *self = (PySharedDictObject *)dict_new(
+        type, args, kwds);
+
+    if (self == NULL)
+        return NULL;
+
+    self->readonly_mode = 0;
+    self->read_count = 0;
+    self->crit = PyCritical_Allocate(PyCRITICAL_NORMAL);
+    if (self->crit == NULL) {
+        Py_DECREF(self);
+        PyErr_NoMemory();
+        return NULL;
+    }
+
+    return (PyObject *)self;
+}
+
 static int
 dict_init(PyObject *self, PyObject *args, PyObject *kwds)
 {
@@ -1929,6 +2432,12 @@
 	return dictiter_new(dict, &PyDictIterKey_Type);
 }
 
+static int
+shareddict_isshareable (PyObject *self)
+{
+	return 1;
+}
+
 PyDoc_STRVAR(dictionary_doc,
 "dict() -> new empty dictionary.\n"
 "dict(mapping) -> new dictionary initialized from a mapping object's\n"
@@ -1961,7 +2470,8 @@
 	0,					/* tp_setattro */
 	0,					/* tp_as_buffer */
 	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
-		Py_TPFLAGS_BASETYPE | Py_TPFLAGS_DICT_SUBCLASS,	/* tp_flags */
+		Py_TPFLAGS_BASETYPE | Py_TPFLAGS_DICT_SUBCLASS |
+		Py_TPFLAGS_SHAREABLE, /* tp_flags */
 	dictionary_doc,				/* tp_doc */
 	dict_traverse,				/* tp_traverse */
 	dict_tp_clear,				/* tp_clear */
@@ -1978,11 +2488,58 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	dict_init,				/* tp_init */
-	PyType_GenericAlloc,			/* tp_alloc */
 	dict_new,				/* tp_new */
-	PyObject_GC_Del,        		/* tp_free */
 };
 
+PyTypeObject PySharedDict_Type = {
+	PyVarObject_HEAD_INIT(&PyType_Type, 0)
+	"shareddict",
+	sizeof(PySharedDictObject),
+	0,
+	(destructor)shareddict_dealloc,		/* tp_dealloc */
+	0,					/* tp_print */
+	0,					/* tp_getattr */
+	0,					/* tp_setattr */
+	0,					/* tp_compare */
+	(reprfunc)shareddict_repr,		/* tp_repr */
+	0,					/* tp_as_number */
+	0,					/* tp_as_sequence */
+	0,					/* tp_as_mapping */
+	0,					/* tp_hash */
+	0,					/* tp_call */
+	0,					/* tp_str */
+	0,					/* tp_getattro */
+	0,					/* tp_setattro */
+	0,					/* tp_as_buffer */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
+		Py_TPFLAGS_DICT_SUBCLASS |
+		Py_TPFLAGS_SHAREABLE,		/* tp_flags */
+	dictionary_doc,				/* tp_doc */
+	dict_traverse,				/* tp_traverse */
+	dict_tp_clear,				/* tp_clear */
+	0,					/* tp_richcompare */
+	0,					/* tp_weaklistoffset */
+	0,					/* tp_iter */
+	0,					/* tp_iternext */
+	0,					/* tp_methods */
+	0,					/* tp_members */
+	0,					/* tp_getset */
+	0,					/* tp_base */
+	0,					/* tp_dict */
+	0,					/* tp_descr_get */
+	0,					/* tp_descr_set */
+	0,					/* tp_dictoffset */
+	dict_init,				/* tp_init */
+	shareddict_new,				/* tp_new */
+	0,					/* tp_is_gc */
+	0,					/* tp_bases */
+	0,					/* tp_mro */
+	0,					/* tp_cache */
+	0,					/* tp_subclasses */
+	0,					/* tp_weaklist */
+	shareddict_isshareable,			/* tp_isshareable */
+};
+
 /* For backward compatibility with old dictionary interface */
 
 PyObject *
@@ -1998,6 +2555,19 @@
 }
 
 int
+PyDict_GetItemStringEx(PyObject *d, const char *key, PyObject **value)
+{
+	PyObject *keyobj;
+	int retvalue;
+	keyobj = PyUnicode_FromString(key);
+	if (keyobj == NULL)
+		return -1;
+	retvalue = PyDict_GetItemEx(d, keyobj, value);
+	Py_DECREF(keyobj);
+	return retvalue;
+}
+
+int
 PyDict_SetItemString(PyObject *v, const char *key, PyObject *item)
 {
 	PyObject *kv;
@@ -2024,6 +2594,19 @@
 	return err;
 }
 
+int
+PyDict_ContainsString(PyObject *d, const char *key)
+{
+	PyObject *keyobj;
+	int retvalue;
+	keyobj = PyUnicode_FromString(key);
+	if (keyobj == NULL)
+		return -1;
+	retvalue = PyDict_Contains(d, keyobj);
+	Py_DECREF(keyobj);
+	return retvalue;
+}
+
 /* Dictionary iterator types */
 
 typedef struct {
@@ -2039,14 +2622,14 @@
 dictiter_new(dictobject *dict, PyTypeObject *itertype)
 {
 	dictiterobject *di;
-	di = PyObject_New(dictiterobject, itertype);
+	di = PyObject_NEW(dictiterobject, itertype);
 	if (di == NULL)
 		return NULL;
 	Py_INCREF(dict);
 	di->di_dict = dict;
-	di->di_used = dict->ma_used;
+	di->di_used = dict_length(dict);
 	di->di_pos = 0;
-	di->len = dict->ma_used;
+	di->len = di->di_used;
 	if (itertype == &PyDictIterItem_Type) {
 		di->di_result = PyTuple_Pack(2, Py_None, Py_None);
 		if (di->di_result == NULL) {
@@ -2064,14 +2647,14 @@
 {
 	Py_XDECREF(di->di_dict);
 	Py_XDECREF(di->di_result);
-	PyObject_Del(di);
+	PyObject_DEL(di);
 }
 
 static PyObject *
 dictiter_len(dictiterobject *di)
 {
 	Py_ssize_t len = 0;
-	if (di->di_dict != NULL && di->di_used == di->di_dict->ma_used)
+	if (di->di_dict != NULL && di->di_used == dict_length(di->di_dict))
 		len = di->len;
 	return PyInt_FromSize_t(len);
 }
@@ -2085,45 +2668,70 @@
  	{NULL,		NULL}		/* sentinel */
 };
 
-static PyObject *dictiter_iternextkey(dictiterobject *di)
+/* On success, returns 0 and sets key and value (with NEW references)
+ * On failure, returns -1, sets neither, and invalidates di */
+static int
+dictiter_iternext_common(dictiterobject *di, PyObject **key, PyObject **value)
 {
-	PyObject *key;
-	register Py_ssize_t i, mask;
-	register dictentry *ep;
-	dictobject *d = di->di_dict;
+    register Py_ssize_t i, mask;
+    register dictentry *ep;
+    dictobject *d = di->di_dict;
+    PyDict_LockState lockstate;
 
-	if (d == NULL)
-		return NULL;
-	assert (PyDict_Check(d));
+    if (d == NULL)
+        return -1;
+    assert (PyDict_Check(d));
 
-	if (di->di_used != d->ma_used) {
-		PyErr_SetString(PyExc_RuntimeError,
-				"dictionary changed size during iteration");
-		di->di_used = -1; /* Make this state sticky */
-		return NULL;
-	}
+    _pydictlock_initstate_read(&lockstate);
 
-	i = di->di_pos;
-	if (i < 0)
-		goto fail;
-	ep = d->ma_table;
-	mask = d->ma_mask;
-	while (i <= mask && ep[i].me_value == NULL)
-		i++;
-	di->di_pos = i+1;
-	if (i > mask)
-		goto fail;
-	di->len--;
-	key = ep[i].me_key;
-	Py_INCREF(key);
-	return key;
+    _pydictlock_acquire(d, &lockstate);
+    /* We don't bother to check ma_rebuilds here.  We're not caching
+     * ma_table or ma_mask, so ma_used is good enough. */
+    if (di->di_used != d->ma_used) {
+        _pydictlock_release(d, &lockstate);
+        PyErr_SetString(PyExc_RuntimeError,
+                        "dictionary changed size during iteration");
+        di->di_used = -1; /* Make this state sticky */
+        return -1;
+    }
 
+    i = di->di_pos;
+    if (i < 0)
+        goto fail;
+    ep = d->ma_table;
+    mask = d->ma_mask;
+    while (i <= mask && ep[i].me_value == NULL)
+        i++;
+    di->di_pos = i+1;
+    if (i > mask)
+        goto fail;
+
+    di->len--;
+    *key = ep[i].me_key;
+    *value = ep[i].me_value;
+    Py_INCREF(*key);
+    Py_INCREF(*value);
+
+    _pydictlock_release(d, &lockstate);
+    return 0;
+
 fail:
-	Py_DECREF(d);
-	di->di_dict = NULL;
-	return NULL;
+    _pydictlock_release(d, &lockstate);
+    Py_DECREF(d);
+    di->di_dict = NULL;
+    return -1;
 }
 
+static PyObject *dictiter_iternextkey(dictiterobject *di)
+{
+    PyObject *key, *value;
+
+    if (dictiter_iternext_common(di, &key, &value))
+        return NULL;
+    Py_DECREF(value);
+    return key;
+}
+
 PyTypeObject PyDictIterKey_Type = {
 	PyVarObject_HEAD_INIT(&PyType_Type, 0)
 	"dictionary-keyiterator",		/* tp_name */
@@ -2157,43 +2765,15 @@
 	0,
 };
 
-static PyObject *dictiter_iternextvalue(dictiterobject *di)
+static PyObject *
+dictiter_iternextvalue(dictiterobject *di)
 {
-	PyObject *value;
-	register Py_ssize_t i, mask;
-	register dictentry *ep;
-	dictobject *d = di->di_dict;
+    PyObject *key, *value;
 
-	if (d == NULL)
-		return NULL;
-	assert (PyDict_Check(d));
-
-	if (di->di_used != d->ma_used) {
-		PyErr_SetString(PyExc_RuntimeError,
-				"dictionary changed size during iteration");
-		di->di_used = -1; /* Make this state sticky */
-		return NULL;
-	}
-
-	i = di->di_pos;
-	mask = d->ma_mask;
-	if (i < 0 || i > mask)
-		goto fail;
-	ep = d->ma_table;
-	while ((value=ep[i].me_value) == NULL) {
-		i++;
-		if (i > mask)
-			goto fail;
-	}
-	di->di_pos = i+1;
-	di->len--;
-	Py_INCREF(value);
-	return value;
-
-fail:
-	Py_DECREF(d);
-	di->di_dict = NULL;
-	return NULL;
+    if (dictiter_iternext_common(di, &key, &value))
+        return NULL;
+    Py_DECREF(key);
+    return value;
 }
 
 PyTypeObject PyDictIterValue_Type = {
@@ -2231,55 +2811,25 @@
 
 static PyObject *dictiter_iternextitem(dictiterobject *di)
 {
-	PyObject *key, *value, *result = di->di_result;
-	register Py_ssize_t i, mask;
-	register dictentry *ep;
-	dictobject *d = di->di_dict;
+    PyObject *key, *value;
+    PyObject *result = di->di_result;
 
-	if (d == NULL)
-		return NULL;
-	assert (PyDict_Check(d));
+    if (dictiter_iternext_common(di, &key, &value))
+        return NULL;
 
-	if (di->di_used != d->ma_used) {
-		PyErr_SetString(PyExc_RuntimeError,
-				"dictionary changed size during iteration");
-		di->di_used = -1; /* Make this state sticky */
-		return NULL;
-	}
+    if (Py_RefcntMatches(result, 1)) {
+        Py_INCREF(result);
+        Py_DECREF(PyTuple_GET_ITEM(result, 0));
+        Py_DECREF(PyTuple_GET_ITEM(result, 1));
+    } else {
+        result = PyTuple_New(2);
+        if (result == NULL)
+            return NULL;
+    }
 
-	i = di->di_pos;
-	if (i < 0)
-		goto fail;
-	ep = d->ma_table;
-	mask = d->ma_mask;
-	while (i <= mask && ep[i].me_value == NULL)
-		i++;
-	di->di_pos = i+1;
-	if (i > mask)
-		goto fail;
-
-	if (result->ob_refcnt == 1) {
-		Py_INCREF(result);
-		Py_DECREF(PyTuple_GET_ITEM(result, 0));
-		Py_DECREF(PyTuple_GET_ITEM(result, 1));
-	} else {
-		result = PyTuple_New(2);
-		if (result == NULL)
-			return NULL;
-	}
-	di->len--;
-	key = ep[i].me_key;
-	value = ep[i].me_value;
-	Py_INCREF(key);
-	Py_INCREF(value);
-	PyTuple_SET_ITEM(result, 0, key);
-	PyTuple_SET_ITEM(result, 1, value);
-	return result;
-
-fail:
-	Py_DECREF(d);
-	di->di_dict = NULL;
-	return NULL;
+    PyTuple_SET_ITEM(result, 0, key);
+    PyTuple_SET_ITEM(result, 1, value);
+    return result;
 }
 
 PyTypeObject PyDictIterItem_Type = {
@@ -2332,7 +2882,7 @@
 dictview_dealloc(dictviewobject *dv)
 {
 	Py_XDECREF(dv->dv_dict);
-	PyObject_Del(dv);
+	PyObject_DEL(dv);
 }
 
 static Py_ssize_t
@@ -2340,7 +2890,7 @@
 {
 	Py_ssize_t len = 0;
 	if (dv->dv_dict != NULL)
-		len = dv->dv_dict->ma_used;
+		len = dict_length(dv->dv_dict);
 	return len;
 }
 
@@ -2359,7 +2909,7 @@
 			     type->tp_name, dict->ob_type->tp_name);
 		return NULL;
 	}
-	dv = PyObject_New(dictviewobject, type);
+	dv = PyObject_NEW(dictviewobject, type);
 	if (dv == NULL)
 		return NULL;
 	Py_INCREF(dict);
@@ -2656,19 +3206,22 @@
 dictitems_contains(dictviewobject *dv, PyObject *obj)
 {
 	PyObject *key, *value, *found;
+	int res;
+
 	if (dv->dv_dict == NULL)
 		return 0;
 	if (!PyTuple_Check(obj) || PyTuple_GET_SIZE(obj) != 2)
 		return 0;
+
 	key = PyTuple_GET_ITEM(obj, 0);
 	value = PyTuple_GET_ITEM(obj, 1);
-	found = PyDict_GetItem((PyObject *)dv->dv_dict, key);
-	if (found == NULL) {
-		if (PyErr_Occurred())
-			return -1;
+	if (PyDict_GetItemEx((PyObject *)dv->dv_dict, key, &found) < 0)
+		return -1;
+	if (found == NULL)
 		return 0;
-	}
-	return PyObject_RichCompareBool(value, found, Py_EQ);
+	res = PyObject_RichCompareBool(value, found, Py_EQ);
+	Py_DECREF(found);
+	return res;
 }
 
 static PySequenceMethods dictitems_as_sequence = {
@@ -2789,3 +3342,24 @@
 {
 	return dictview_new(dict, &PyDictValues_Type);
 }
+
+/* Even type and object's initialization calls us, so we need a bare
+ * minimum of functionality to be ready even before them. */
+void
+_PyDict_PreInit(void)
+{
+#ifdef USE_DICT_FREELIST
+	free_dicts_lock = PyThread_lock_allocate();
+	if (!free_dicts_lock)
+		Py_FatalError("unable to allocate lock");
+#endif
+}
+
+void
+PyDict_Fini(void)
+{
+#ifdef USE_DICT_FREELIST
+	PyThread_lock_free(free_dicts_lock);
+	free_dicts_lock = NULL;
+#endif
+}
Index: Objects/weakrefobject.c
===================================================================
--- Objects/weakrefobject.c	(revision 58355)
+++ Objects/weakrefobject.c	(working copy)
@@ -2,181 +2,90 @@
 #include "structmember.h"
 
 
-#define GET_WEAKREFS_LISTPTR(o) \
-        ((PyWeakReference **) PyObject_GET_WEAKREFS_LISTPTR(o))
+static int deathqueue_clear(PyDeathQueue *self);
+static int PyDeathQueue_Cancel(PyDeathQueue *queue, PyDeathQueueHandle *handle);
+static PyObject *deathqueue_wait(PyDeathQueue *queue);
 
 
-Py_ssize_t
-_PyWeakref_GetWeakrefCount(PyWeakReference *head)
-{
-    Py_ssize_t count = 0;
-
-    while (head != NULL) {
-        ++count;
-        head = head->wr_next;
-    }
-    return count;
-}
-
-
 static void
-init_weakref(PyWeakReference *self, PyObject *ob, PyObject *callback)
+weakref_dealloc(PyWeakReference *self)
 {
-    self->hash = -1;
-    self->wr_object = ob;
-    Py_XINCREF(callback);
-    self->wr_callback = callback;
+    if (self->wr_object != NULL)
+        Py_FatalError("Still-valid weakref deleted!");
+    PyCritical_Free(self->crit);
+    PyObject_DEL(self);
 }
 
-static PyWeakReference *
-new_weakref(PyObject *ob, PyObject *callback)
-{
-    PyWeakReference *result;
-
-    result = PyObject_GC_New(PyWeakReference, &_PyWeakref_RefType);
-    if (result) {
-        init_weakref(result, ob, callback);
-        PyObject_GC_Track(result);
-    }
-    return result;
-}
-
-
-/* This function clears the passed-in reference and removes it from the
- * list of weak references for the referent.  This is the only code that
- * removes an item from the doubly-linked list of weak references for an
- * object; it is also responsible for clearing the callback slot.
- */
-static void
-clear_weakref(PyWeakReference *self)
-{
-    PyObject *callback = self->wr_callback;
-
-    if (PyWeakref_GET_OBJECT(self) != Py_None) {
-        PyWeakReference **list = GET_WEAKREFS_LISTPTR(
-            PyWeakref_GET_OBJECT(self));
-
-        if (*list == self)
-	    /* If 'self' is the end of the list (and thus self->wr_next == NULL)
-	       then the weakref list itself (and thus the value of *list) will
-	       end up being set to NULL. */
-            *list = self->wr_next;
-        self->wr_object = Py_None;
-        if (self->wr_prev != NULL)
-            self->wr_prev->wr_next = self->wr_next;
-        if (self->wr_next != NULL)
-            self->wr_next->wr_prev = self->wr_prev;
-        self->wr_prev = NULL;
-        self->wr_next = NULL;
-    }
-    if (callback != NULL) {
-        Py_DECREF(callback);
-        self->wr_callback = NULL;
-    }
-}
-
-/* Cyclic gc uses this to *just* clear the passed-in reference, leaving
- * the callback intact and uncalled.  It must be possible to call self's
- * tp_dealloc() after calling this, so self has to be left in a sane enough
- * state for that to work.  We expect tp_dealloc to decref the callback
- * then.  The reason for not letting clear_weakref() decref the callback
- * right now is that if the callback goes away, that may in turn trigger
- * another callback (if a weak reference to the callback exists) -- running
- * arbitrary Python code in the middle of gc is a disaster.  The convolution
- * here allows gc to delay triggering such callbacks until the world is in
- * a sane state again.
- */
-void
-_PyWeakref_ClearRef(PyWeakReference *self)
-{
-    PyObject *callback;
-
-    assert(self != NULL);
-    assert(PyWeakref_Check(self));
-    /* Preserve and restore the callback around clear_weakref. */
-    callback = self->wr_callback;
-    self->wr_callback = NULL;
-    clear_weakref(self);
-    self->wr_callback = callback;
-}
-
-static void
-weakref_dealloc(PyObject *self)
-{
-    PyObject_GC_UnTrack(self);
-    clear_weakref((PyWeakReference *) self);
-    Py_Type(self)->tp_free(self);
-}
-
-
 static int
-gc_traverse(PyWeakReference *self, visitproc visit, void *arg)
+weakref_traverse(PyWeakReference *self, visitproc visit, void *arg)
 {
-    Py_VISIT(self->wr_callback);
     return 0;
 }
 
-
-static int
-gc_clear(PyWeakReference *self)
-{
-    clear_weakref(self);
-    return 0;
-}
-
-
 static PyObject *
-weakref_call(PyWeakReference *self, PyObject *args, PyObject *kw)
+weakref_call(PyObject *self, PyObject *args, PyObject *kw)
 {
     static char *kwlist[] = {NULL};
+    PyObject *ob;
 
-    if (PyArg_ParseTupleAndKeywords(args, kw, ":__call__", kwlist)) {
-        PyObject *object = PyWeakref_GET_OBJECT(self);
-        Py_INCREF(object);
-        return (object);
+    if (!PyArg_ParseTupleAndKeywords(args, kw, ":__call__", kwlist))
+        return NULL;
+
+    ob = PyWeakref_GetObjectEx(self);
+    if (ob == NULL) {
+        Py_INCREF(Py_None);
+        ob = Py_None;
     }
-    return NULL;
+
+    return ob;
 }
 
-
 static long
 weakref_hash(PyWeakReference *self)
 {
-    if (self->hash != -1)
-        return self->hash;
-    if (PyWeakref_GET_OBJECT(self) == Py_None) {
+    PyObject *ob;
+    AO_t hash = AO_load_full(&self->hash);
+    if (hash != (AO_t)-1)
+        return (long)hash;
+
+    ob = PyWeakref_GetObjectEx((PyObject *)self);
+    if (ob == NULL) {
         PyErr_SetString(PyExc_TypeError, "weak object has gone away");
         return -1;
     }
-    self->hash = PyObject_Hash(PyWeakref_GET_OBJECT(self));
-    return self->hash;
+
+    hash = PyObject_Hash(ob);
+    Py_DECREF(ob);
+
+    AO_compare_and_swap(&self->hash, (AO_t)-1, hash);
+    return (long)AO_load_full(&self->hash);
 }
 
-
 static PyObject *
 weakref_repr(PyWeakReference *self)
 {
     char buffer[256];
-    if (PyWeakref_GET_OBJECT(self) == Py_None) {
+    PyObject *ob = PyWeakref_GetObjectEx((PyObject *)self);
+
+    if (ob == NULL)
         PyOS_snprintf(buffer, sizeof(buffer), "<weakref at %p; dead>", self);
-    }
     else {
-	char *name = NULL;
-	PyObject *nameobj = PyObject_GetAttrString(PyWeakref_GET_OBJECT(self),
-						   "__name__");
-	if (nameobj == NULL)
-		PyErr_Clear();
-	else if (PyUnicode_Check(nameobj))
-		name = PyUnicode_AsString(nameobj);
+        char *name = NULL;
+        PyObject *nameobj = PyObject_GetAttrString(ob, "__name__");
+
+        if (nameobj == NULL)
+            PyErr_Clear();
+        else if (PyUnicode_Check(nameobj))
+            name = PyUnicode_AsString(nameobj);
+
         PyOS_snprintf(buffer, sizeof(buffer),
-		      name ? "<weakref at %p; to '%.50s' at %p (%s)>"
-		           : "<weakref at %p; to '%.50s' at %p>",
-		      self,
-		      Py_Type(PyWeakref_GET_OBJECT(self))->tp_name,
-		      PyWeakref_GET_OBJECT(self),
-		      name);
-	Py_XDECREF(nameobj);
+                      name ? "<weakref at %p; to '%.50s' at %p (%s)>"
+                           : "<weakref at %p; to '%.50s' at %p>",
+                      self, Py_Type(ob)->tp_name, ob, name);
+        Py_XDECREF(nameobj);
+        Py_DECREF(ob);
     }
+
     return PyUnicode_FromString(buffer);
 }
 
@@ -185,147 +94,62 @@
    gone away, they are equal if they are identical. */
 
 static PyObject *
-weakref_richcompare(PyWeakReference* self, PyWeakReference* other, int op)
+weakref_richcompare(PyWeakReference *self, PyWeakReference *other, int op)
 {
+    PyObject *self_ob, *other_ob;
+    PyObject *res;
+
     if ((op != Py_EQ && op != Py_NE) ||
-	!PyWeakref_Check(self) ||
-	!PyWeakref_Check(other)) {
+            !PyWeakref_Check(self) ||
+            !PyWeakref_Check(other)) {
         Py_INCREF(Py_NotImplemented);
         return Py_NotImplemented;
     }
-    if (PyWeakref_GET_OBJECT(self) == Py_None
-        || PyWeakref_GET_OBJECT(other) == Py_None) {
-        PyObject *res = self==other ? Py_True : Py_False;
-        Py_INCREF(res);
-        return res;
-    }
-    return PyObject_RichCompare(PyWeakref_GET_OBJECT(self),
-                                PyWeakref_GET_OBJECT(other), op);
-}
 
-/* Given the head of an object's list of weak references, extract the
- * two callback-less refs (ref and proxy).  Used to determine if the
- * shared references exist and to determine the back link for newly
- * inserted references.
- */
-static void
-get_basic_refs(PyWeakReference *head,
-               PyWeakReference **refp, PyWeakReference **proxyp)
-{
-    *refp = NULL;
-    *proxyp = NULL;
-
-    if (head != NULL && head->wr_callback == NULL) {
-        /* We need to be careful that the "basic refs" aren't
-           subclasses of the main types.  That complicates this a
-           little. */
-        if (PyWeakref_CheckRefExact(head)) {
-            *refp = head;
-            head = head->wr_next;
-        }
-        if (head != NULL
-            && head->wr_callback == NULL
-            && PyWeakref_CheckProxy(head)) {
-            *proxyp = head;
-            /* head = head->wr_next; */
-        }
+    if (self == other) {
+        Py_INCREF(Py_True);
+        return Py_True;
     }
-}
 
-/* Insert 'newref' in the list after 'prev'.  Both must be non-NULL. */
-static void
-insert_after(PyWeakReference *newref, PyWeakReference *prev)
-{
-    newref->wr_prev = prev;
-    newref->wr_next = prev->wr_next;
-    if (prev->wr_next != NULL)
-        prev->wr_next->wr_prev = newref;
-    prev->wr_next = newref;
-}
+    self_ob = PyWeakref_GetObjectEx((PyObject *)self);
+    other_ob = PyWeakref_GetObjectEx((PyObject *)other);
 
-/* Insert 'newref' at the head of the list; 'list' points to the variable
- * that stores the head.
- */
-static void
-insert_head(PyWeakReference *newref, PyWeakReference **list)
-{
-    PyWeakReference *next = *list;
+    if (self_ob == NULL || other_ob == NULL) {
+        res = Py_False;
+        Py_INCREF(res);
+    } else
+        res = PyObject_RichCompare(self_ob, other_ob, op);
 
-    newref->wr_prev = NULL;
-    newref->wr_next = next;
-    if (next != NULL)
-        next->wr_prev = newref;
-    *list = newref;
+    Py_XDECREF(self_ob);
+    Py_XDECREF(other_ob);
+    return res;
 }
 
 static int
 parse_weakref_init_args(char *funcname, PyObject *args, PyObject *kwargs,
-                        PyObject **obp, PyObject **callbackp)
+                        PyObject **obp)
 {
     /* XXX Should check that kwargs == NULL or is empty. */
-    return PyArg_UnpackTuple(args, funcname, 1, 2, obp, callbackp);
+    return PyArg_UnpackTuple(args, funcname, 1, 1, obp);
 }
 
 static PyObject *
 weakref___new__(PyTypeObject *type, PyObject *args, PyObject *kwargs)
 {
-    PyWeakReference *self = NULL;
-    PyObject *ob, *callback = NULL;
+    PyObject *ob;
 
-    if (parse_weakref_init_args("__new__", args, kwargs, &ob, &callback)) {
-        PyWeakReference *ref, *proxy;
-        PyWeakReference **list;
+    if (!parse_weakref_init_args("__new__", args, kwargs, &ob))
+        return NULL;
 
-        if (!PyType_SUPPORTS_WEAKREFS(Py_Type(ob))) {
-            PyErr_Format(PyExc_TypeError,
-                         "cannot create weak reference to '%s' object",
-                         Py_Type(ob)->tp_name);
-            return NULL;
-        }
-        if (callback == Py_None)
-            callback = NULL;
-        list = GET_WEAKREFS_LISTPTR(ob);
-        get_basic_refs(*list, &ref, &proxy);
-        if (callback == NULL && type == &_PyWeakref_RefType) {
-            if (ref != NULL) {
-                /* We can re-use an existing reference. */
-                Py_INCREF(ref);
-                return (PyObject *)ref;
-            }
-        }
-        /* We have to create a new reference. */
-        /* Note: the tp_alloc() can trigger cyclic GC, so the weakref
-           list on ob can be mutated.  This means that the ref and
-           proxy pointers we got back earlier may have been collected,
-           so we need to compute these values again before we use
-           them. */
-        self = (PyWeakReference *) (type->tp_alloc(type, 0));
-        if (self != NULL) {
-            init_weakref(self, ob, callback);
-            if (callback == NULL && type == &_PyWeakref_RefType) {
-                insert_head(self, list);
-            }
-            else {
-                PyWeakReference *prev;
-
-                get_basic_refs(*list, &ref, &proxy);
-                prev = (proxy == NULL) ? ref : proxy;
-                if (prev == NULL)
-                    insert_head(self, list);
-                else
-                    insert_after(self, prev);
-            }
-        }
-    }
-    return (PyObject *)self;
+    return PyWeakref_NewRef(ob, NULL);
 }
 
 static int
 weakref___init__(PyObject *self, PyObject *args, PyObject *kwargs)
 {
-    PyObject *tmp;
+    PyObject *ob;
 
-    if (parse_weakref_init_args("__init__", args, kwargs, &tmp, &tmp))
+    if (parse_weakref_init_args("__init__", args, kwargs, &ob))
         return 0;
     else
         return 1;
@@ -333,31 +157,33 @@
 
 
 PyTypeObject
-_PyWeakref_RefType = {
+_PyWeakref_Type = {
     PyVarObject_HEAD_INIT(&PyType_Type, 0)
     "weakref",
     sizeof(PyWeakReference),
     0,
-    weakref_dealloc,            /*tp_dealloc*/
-    0,	                        /*tp_print*/
+    (destructor)weakref_dealloc,  /*tp_dealloc*/
+    0,                          /*tp_print*/
     0,                          /*tp_getattr*/
     0,                          /*tp_setattr*/
-    0,	                        /*tp_compare*/
+    0,                          /*tp_compare*/
     (reprfunc)weakref_repr,     /*tp_repr*/
     0,                          /*tp_as_number*/
     0,                          /*tp_as_sequence*/
     0,                          /*tp_as_mapping*/
     (hashfunc)weakref_hash,     /*tp_hash*/
-    (ternaryfunc)weakref_call,  /*tp_call*/
+    weakref_call,               /*tp_call*/
     0,                          /*tp_str*/
     0,                          /*tp_getattro*/
     0,                          /*tp_setattro*/
     0,                          /*tp_as_buffer*/
-    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC
-        | Py_TPFLAGS_BASETYPE,  /*tp_flags*/
+    /* There is only ever one weakref per object, so subclassing is
+     * unsupported. */
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
+        Py_TPFLAGS_SHAREABLE,  /*tp_flags*/
     0,                          /*tp_doc*/
-    (traverseproc)gc_traverse,  /*tp_traverse*/
-    (inquiry)gc_clear,          /*tp_clear*/
+    (traverseproc)weakref_traverse,  /*tp_traverse*/
+    0,                          /*tp_clear*/
     (richcmpfunc)weakref_richcompare,	/*tp_richcompare*/
     0,                          /*tp_weaklistoffset*/
     0,                          /*tp_iter*/
@@ -371,548 +197,990 @@
     0,                          /*tp_descr_set*/
     0,                          /*tp_dictoffset*/
     weakref___init__,           /*tp_init*/
-    PyType_GenericAlloc,        /*tp_alloc*/
     weakref___new__,            /*tp_new*/
-    PyObject_GC_Del,            /*tp_free*/
 };
 
 
-static int
-proxy_checkref(PyWeakReference *proxy)
+static void
+deathqueuehandle_dealloc(PyDeathQueueHandle *self)
 {
-    if (PyWeakref_GET_OBJECT(proxy) == Py_None) {
-        PyErr_SetString(PyExc_ReferenceError,
-                        "weakly-referenced object no longer exists");
-        return 0;
+    /* queue holds a reference to us, so we should never get deleted
+     * without clearing us first. */
+    assert(self->weakref == NULL);
+    assert(self->queue == NULL);
+    assert(PyLinkedList_Detatched(&self->weakref_links));
+    assert(PyLinkedList_Detatched(&self->queue_links));
+    PyCritical_Free(self->crit);
+    PyObject_DEL(self);
+}
+
+static PyObject *
+deathqueuehandle_repr(PyDeathQueueHandle *self)
+{
+    char buffer[256];
+    PyObject *payload;
+    PyWeakReference *weakref;
+
+    PyCritical_Enter(self->crit);
+    payload = self->payload;
+    weakref = self->weakref;
+    Py_XINCREF(payload);
+    Py_XINCREF(weakref);
+    PyCritical_Exit(self->crit);
+
+    if (payload == NULL)
+        PyOS_snprintf(buffer, sizeof(buffer),
+            "<deathqueuehandle at %p; cancelled/processed>", self);
+    else {
+        char *name = NULL;
+        char *state = (weakref != NULL) ? "live" : "dead";
+        PyObject *nameobj = PyObject_GetAttrString(payload, "__name__");
+
+        if (nameobj == NULL)
+            PyErr_Clear();
+        else if (PyUnicode_Check(nameobj))
+            name = PyUnicode_AsString(nameobj);
+
+        if (name != NULL)
+            PyOS_snprintf(buffer, sizeof(buffer),
+                "<deathqueuehandle at %p; payload '%.50s' at %p (%s); %s>",
+                self, Py_Type(payload)->tp_name, payload, name, state);
+        else
+            PyOS_snprintf(buffer, sizeof(buffer),
+                "<deathqueuehandle at %p; payload '%.50s' at %p; %s>",
+                self, Py_Type(payload)->tp_name, payload, state);
+        Py_XDECREF(nameobj);
     }
-    return 1;
+
+    Py_XDECREF(payload);
+    Py_XDECREF(weakref);
+
+    return PyUnicode_FromString(buffer);
 }
 
+static int
+deathqueuehandle_traverse(PyDeathQueueHandle *self, visitproc visit, void *arg)
+{
+    Py_VISIT(self->payload);
+    Py_VISIT(self->weakref);
+    return 0;
+}
 
-/* If a parameter is a proxy, check that it is still "live" and wrap it,
- * replacing the original value with the raw object.  Raises ReferenceError
- * if the param is a dead proxy.
- */
-#define UNWRAP(o) \
-        if (PyWeakref_CheckProxy(o)) { \
-            if (!proxy_checkref((PyWeakReference *)o)) \
-                return NULL; \
-            o = PyWeakref_GET_OBJECT(o); \
-        }
 
-#define UNWRAP_I(o) \
-        if (PyWeakref_CheckProxy(o)) { \
-            if (!proxy_checkref((PyWeakReference *)o)) \
-                return -1; \
-            o = PyWeakref_GET_OBJECT(o); \
-        }
+PyTypeObject
+_PyDeathQueueHandle_Type = {
+    PyVarObject_HEAD_INIT(&PyType_Type, 0)
+    "deathqueuehandle",
+    sizeof(PyDeathQueueHandle),
+    0,
+    (destructor)deathqueuehandle_dealloc,  /*tp_dealloc*/
+    0,                          /*tp_print*/
+    0,                          /*tp_getattr*/
+    0,                          /*tp_setattr*/
+    0,                          /*tp_compare*/
+    (reprfunc)deathqueuehandle_repr,  /*tp_repr*/
+    0,                          /*tp_as_number*/
+    0,                          /*tp_as_sequence*/
+    0,                          /*tp_as_mapping*/
+    0,                          /*tp_hash*/
+    0,                          /*tp_call*/
+    0,                          /*tp_str*/
+    0,                          /*tp_getattro*/
+    0,                          /*tp_setattro*/
+    0,                          /*tp_as_buffer*/
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
+        Py_TPFLAGS_SHAREABLE,  /*tp_flags*/
+    0,                          /*tp_doc*/
+    (traverseproc)deathqueuehandle_traverse,  /*tp_traverse*/
+    0,                          /*tp_clear*/
+    0,                          /*tp_richcompare*/
+    0,                          /*tp_weaklistoffset*/
+    0,                          /*tp_iter*/
+    0,                          /*tp_iternext*/
+    0,                          /*tp_methods*/
+    0,                          /*tp_members*/
+    0,                          /*tp_getset*/
+    0,                          /*tp_base*/
+    0,                          /*tp_dict*/
+    0,                          /*tp_descr_get*/
+    0,                          /*tp_descr_set*/
+    0,                          /*tp_dictoffset*/
+    0,                          /*tp_init*/
+    0,                          /*tp_new*/
+};
 
-#define WRAP_UNARY(method, generic) \
-    static PyObject * \
-    method(PyObject *proxy) { \
-        UNWRAP(proxy); \
-        return generic(proxy); \
+
+static void
+deathqueue_dealloc(PyDeathQueue *self)
+{
+    deathqueue_clear(self);
+
+    if (Py_RefcntSnoop(self) != 1) {
+        /* Another thread is trying to manipulate us.  Probably a
+         * handle getting set to dead.  We can finish deleting later. */
+        PyObject_REVIVE(self);
+        Py_DECREF_ASYNC(self);
+    } else {
+        assert(PyLinkedList_Empty(&self->live_links));
+        assert(PyLinkedList_Empty(&self->dead_links));
+        PyCritical_Free(self->crit);
+        PyThread_cond_free(self->cond);
+        PyObject_DEL(self);
     }
+}
 
-#define WRAP_BINARY(method, generic) \
-    static PyObject * \
-    method(PyObject *x, PyObject *y) { \
-        UNWRAP(x); \
-        UNWRAP(y); \
-        return generic(x, y); \
+static int
+deathqueue_traverse(PyDeathQueue *queue, visitproc visit, void *arg)
+{
+    PyDeathQueueHandle *handle;
+    PyLinkedList *handle_links;
+
+    handle_links = &queue->live_links;
+    while (PyLinkedList_Next(&queue->live_links, &handle_links)) {
+        handle = PyLinkedList_Restore(PyDeathQueueHandle, queue_links,
+            handle_links);
+        Py_VISIT(handle);
     }
 
-/* Note that the third arg needs to be checked for NULL since the tp_call
- * slot can receive NULL for this arg.
- */
-#define WRAP_TERNARY(method, generic) \
-    static PyObject * \
-    method(PyObject *proxy, PyObject *v, PyObject *w) { \
-        UNWRAP(proxy); \
-        UNWRAP(v); \
-        if (w != NULL) \
-            UNWRAP(w); \
-        return generic(proxy, v, w); \
+    handle_links = &queue->dead_links;
+    while (PyLinkedList_Next(&queue->dead_links, &handle_links)) {
+        handle = PyLinkedList_Restore(PyDeathQueueHandle, queue_links,
+            handle_links);
+        Py_VISIT(handle);
     }
 
+    return 0;
+}
 
-/* direct slots */
+static int
+deathqueue_clear(PyDeathQueue *queue)
+{
+    /* When called by the tracing GC (not deathqueue_dealloc), we don't
+     * need to deal with the critical sections, as the tracing GC won't
+     * run while a thread is in one.  It won't hurt either though. */
+    while (1) {
+        PyDeathQueueHandle *handle;
 
-WRAP_BINARY(proxy_getattr, PyObject_GetAttr)
-WRAP_UNARY(proxy_str, PyObject_Str)
-WRAP_TERNARY(proxy_call, PyEval_CallObjectWithKeywords)
+        PyCritical_Enter(queue->crit);
+        if (!PyLinkedList_Empty(&queue->live_links)) {
+            handle = PyLinkedList_Restore(PyDeathQueueHandle,
+                queue_links, queue->live_links.next);
+            Py_INCREF(handle);
+        } else
+            handle = NULL;
+        PyCritical_Exit(queue->crit);
 
+        if (handle != NULL) {
+            if (PyDeathQueue_Cancel(queue, handle))
+                Py_FatalError("deathqueue_clear failed when calling "
+                    "PyDeathQueue_Cancel");
+        } else
+            break;
+    }
+
+    while (1) {
+        PyDeathQueueHandle *handle;
+
+        PyCritical_Enter(queue->crit);
+        if (!PyLinkedList_Empty(&queue->dead_links)) {
+            handle = PyLinkedList_Restore(PyDeathQueueHandle,
+                queue_links, queue->dead_links.next);
+            Py_INCREF(handle);
+        } else
+            handle = NULL;
+        PyCritical_Exit(queue->crit);
+
+        if (handle != NULL) {
+            if (PyDeathQueue_Cancel(queue, handle))
+                Py_FatalError("deathqueue_clear failed when calling "
+                    "PyDeathQueue_Cancel");
+        } else
+            break;
+    }
+
+    return 0;
+}
+
 static PyObject *
-proxy_repr(PyWeakReference *proxy)
+deathqueue___new__(PyTypeObject *type, PyObject *args, PyObject *kwargs)
 {
-    char buf[160];
-    PyOS_snprintf(buf, sizeof(buf),
-		  "<weakproxy at %p to %.100s at %p>", proxy,
-		  Py_Type(PyWeakref_GET_OBJECT(proxy))->tp_name,
-		  PyWeakref_GET_OBJECT(proxy));
-    return PyUnicode_FromString(buf);
+    PyDeathQueue *queue;
+
+    static char *kwlist[] = {NULL};
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "", kwlist))
+        return NULL;
+
+    queue = PyObject_NEW(PyDeathQueue, &_PyDeathQueue_Type);
+    if (queue == NULL)
+        return NULL;
+
+    queue->crit = PyCritical_Allocate(PyCRITICAL_WEAKREF_QUEUE);
+    if (queue->crit == NULL) {
+        PyObject_DEL(queue);
+        PyErr_NoMemory();
+        return NULL;
+    }
+
+    queue->cond = PyThread_cond_allocate();
+    if (queue->cond == NULL) {
+        PyCritical_Free(queue->cond);
+        PyObject_DEL(queue);
+        PyErr_NoMemory();
+        return NULL;
+    }
+
+    queue->live_links.prev = &queue->live_links;
+    queue->live_links.next = &queue->live_links;
+    queue->dead_links.prev = &queue->dead_links;
+    queue->dead_links.next = &queue->dead_links;
+
+    return (PyObject *)queue;
 }
 
-
 static int
-proxy_setattr(PyWeakReference *proxy, PyObject *name, PyObject *value)
+deathqueue___init__(PyObject *self, PyObject *args, PyObject *kwargs)
 {
-    if (!proxy_checkref(proxy))
-        return -1;
-    return PyObject_SetAttr(PyWeakref_GET_OBJECT(proxy), name, value);
+    static char *kwlist[] = {NULL};
+
+    if (!PyArg_ParseTupleAndKeywords(args, kwargs, "", kwlist))
+        return 1;
+
+    return 0;
 }
 
 static PyObject *
-proxy_richcompare(PyObject *proxy, PyObject *v, int op)
+deathqueue_watch(PyDeathQueue *queue, PyObject *args)
 {
-    UNWRAP(proxy);
-    UNWRAP(v);
-    return PyObject_RichCompare(proxy, v, op);
-}
+    PyObject *obj, *payload;
+    PyWeakReference *ref;
+    PyDeathQueueHandle *handle;
 
-/* number slots */
-WRAP_BINARY(proxy_add, PyNumber_Add)
-WRAP_BINARY(proxy_sub, PyNumber_Subtract)
-WRAP_BINARY(proxy_mul, PyNumber_Multiply)
-WRAP_BINARY(proxy_mod, PyNumber_Remainder)
-WRAP_BINARY(proxy_divmod, PyNumber_Divmod)
-WRAP_TERNARY(proxy_pow, PyNumber_Power)
-WRAP_UNARY(proxy_neg, PyNumber_Negative)
-WRAP_UNARY(proxy_pos, PyNumber_Positive)
-WRAP_UNARY(proxy_abs, PyNumber_Absolute)
-WRAP_UNARY(proxy_invert, PyNumber_Invert)
-WRAP_BINARY(proxy_lshift, PyNumber_Lshift)
-WRAP_BINARY(proxy_rshift, PyNumber_Rshift)
-WRAP_BINARY(proxy_and, PyNumber_And)
-WRAP_BINARY(proxy_xor, PyNumber_Xor)
-WRAP_BINARY(proxy_or, PyNumber_Or)
-WRAP_UNARY(proxy_int, PyNumber_Int)
-WRAP_UNARY(proxy_long, PyNumber_Long)
-WRAP_UNARY(proxy_float, PyNumber_Float)
-WRAP_BINARY(proxy_iadd, PyNumber_InPlaceAdd)
-WRAP_BINARY(proxy_isub, PyNumber_InPlaceSubtract)
-WRAP_BINARY(proxy_imul, PyNumber_InPlaceMultiply)
-WRAP_BINARY(proxy_imod, PyNumber_InPlaceRemainder)
-WRAP_TERNARY(proxy_ipow, PyNumber_InPlacePower)
-WRAP_BINARY(proxy_ilshift, PyNumber_InPlaceLshift)
-WRAP_BINARY(proxy_irshift, PyNumber_InPlaceRshift)
-WRAP_BINARY(proxy_iand, PyNumber_InPlaceAnd)
-WRAP_BINARY(proxy_ixor, PyNumber_InPlaceXor)
-WRAP_BINARY(proxy_ior, PyNumber_InPlaceOr)
+    if (!PyArg_UnpackTuple(args, "watch", 2, 2, &obj, &payload))
+        return NULL;
 
-static int
-proxy_bool(PyWeakReference *proxy)
-{
-    PyObject *o = PyWeakref_GET_OBJECT(proxy);
-    if (!proxy_checkref(proxy))
-        return -1;
-    return PyObject_IsTrue(o);
+    if (!PyObject_IsShareable(payload)) {
+        PyErr_Format(PyExc_TypeError,
+            "deathqueue.watch()'s payload argument must be shareable, '%s' object "
+            "is not", payload->ob_type->tp_name);
+        return NULL;
+    }
+
+    ref = (PyWeakReference *)PyWeakref_NewRef(obj, NULL);
+    if (ref == NULL)
+        return NULL;
+
+    handle = PyObject_NEW(PyDeathQueueHandle, &_PyDeathQueueHandle_Type);
+    if (handle == NULL) {
+        Py_DECREF(ref);
+        return NULL;
+    }
+
+    handle->crit = PyCritical_Allocate(PyCRITICAL_WEAKREF_HANDLE);
+    if (handle->crit == NULL) {
+        PyObject_DEL(handle);
+        Py_DECREF(ref);
+        return NULL;
+    }
+
+    PyCritical_Enter(ref->crit);
+    /* We skip handle->crit as nobody else has a reference to handle yet. */
+    PyCritical_Enter(queue->crit);
+
+    assert(ref->wr_object != NULL);
+
+    /* The underlying ownership order is queue -> handle -> weakref.
+     * queue needs a reference to us, but handle doesn't INCREF them
+     * (they clear our pointer if they get deleted), and we already have
+     * a reference to weakref. */
+    Py_INCREF(handle);
+
+    Py_INCREF(payload);
+    handle->payload = payload;
+    handle->queue = queue;
+    handle->weakref = ref;
+
+    PyLinkedList_Append(&ref->handle_links, &handle->weakref_links);
+    PyLinkedList_Append(&queue->live_links, &handle->queue_links);
+
+    PyCritical_Exit(queue->crit);
+    PyCritical_Exit(ref->crit);
+
+    return (PyObject *)handle;
 }
 
-static void
-proxy_dealloc(PyWeakReference *self)
+PyObject *
+deathqueue_cancel(PyDeathQueue *queue, PyObject *args)
 {
-    if (self->wr_callback != NULL)
-        PyObject_GC_UnTrack((PyObject *)self);
-    clear_weakref(self);
-    PyObject_GC_Del(self);
+    PyDeathQueueHandle *handle;
+
+    if (!PyArg_UnpackTuple(args, "cancel", 1, 1, &handle))
+        return NULL;
+
+    if (!PyDeathQueueHandle_Check(handle)) {
+        PyErr_Format(PyExc_TypeError, "cancel expected deathqueuehandle "
+            "(not \"%.200s\")", Py_Type(handle)->tp_name);
+        return NULL;
+    }
+
+    if (PyDeathQueue_Cancel(queue, handle))
+        return NULL;
+
+    Py_INCREF(Py_None);
+    return Py_None;
 }
 
-/* sequence slots */
-
+/* Warning: this function deletes queue's reference to handle.  If the
+ * caller doesn't have their own reference to handle, it may be gone by
+ * the time this function returns. */
 static int
-proxy_contains(PyWeakReference *proxy, PyObject *value)
+PyDeathQueue_Cancel(PyDeathQueue *queue, PyDeathQueueHandle *handle)
 {
-    if (!proxy_checkref(proxy))
-        return -1;
-    return PySequence_Contains(PyWeakref_GET_OBJECT(proxy), value);
-}
+    PyWeakReference *ref;
+    int decref_weakref = 0;
 
+    /* "climb" up the ordered critical sections */
+    PyCritical_Enter(handle->crit);
+    ref = handle->weakref;
+    Py_XINCREF(ref);
+    PyCritical_Exit(handle->crit);
 
-/* mapping slots */
+    /* Begin entering all 3 critical sections (weakref, handle, queue) */
+    if (ref != NULL)
+        PyCritical_Enter(ref->crit);
+    PyCritical_Enter(handle->crit);
 
-static Py_ssize_t
-proxy_length(PyWeakReference *proxy)
-{
-    if (!proxy_checkref(proxy))
-        return -1;
-    return PyObject_Length(PyWeakref_GET_OBJECT(proxy));
+    /* Early out if we've got nothing to do */
+    if (handle->queue != queue) {
+        PyDeathQueue *badqueue = handle->queue;
+        PyCritical_Exit(handle->crit);
+        if (ref != NULL)
+            PyCritical_Exit(ref->crit);
+        Py_XDECREF(ref);
+
+        if (handle->queue == NULL) {
+            /* Already cleared */
+            return 0;
+        } else {
+            /* Wrong queue! */
+            PyErr_Format(PyExc_ValueError, "cancel called on %p queue "
+                "but handle %p is for %p queue", queue, handle, badqueue);
+            return 1;
+        }
+    }
+
+    PyCritical_Enter(queue->crit);
+
+    /* The real work of this function */
+    if (handle->weakref != NULL) {
+        PyLinkedList_Remove(&handle->weakref_links);
+        handle->weakref = NULL;
+        decref_weakref = 1;
+    }
+
+    PyLinkedList_Remove(&handle->queue_links);
+    handle->queue = NULL;
+
+    /* Exit the critical sections */
+    PyCritical_Exit(queue->crit);
+    PyCritical_Exit(handle->crit);
+    if (ref != NULL)
+        PyCritical_Exit(ref->crit);
+
+    /* Finally, cleanup */
+    Py_DECREF(handle);  /* queue -> handle reference */
+    Py_XDECREF(ref);  /* our reference */
+    if (decref_weakref)
+        Py_DECREF(ref);  /* handle -> weakref reference */
+
+    return 0;
 }
 
-WRAP_BINARY(proxy_getitem, PyObject_GetItem)
-
+/* Returns 0 for success and 1 for empty */
 static int
-proxy_setitem(PyWeakReference *proxy, PyObject *key, PyObject *value)
+pop_common(PyDeathQueue *queue, PyObject **payload)
 {
-    if (!proxy_checkref(proxy))
-        return -1;
+    PyDeathQueueHandle *handle;
 
-    if (value == NULL)
-        return PyObject_DelItem(PyWeakref_GET_OBJECT(proxy), key);
-    else
-        return PyObject_SetItem(PyWeakref_GET_OBJECT(proxy), key, value);
+    while (1) {
+        PyCritical_Enter(queue->crit);
+        if (PyLinkedList_Empty(&queue->dead_links)) {
+            PyCritical_Exit(queue->crit);
+            return 1;
+        }
+        handle = PyLinkedList_Restore(PyDeathQueueHandle, queue_links,
+            queue->dead_links.next);
+        Py_INCREF(handle);
+        PyCritical_Exit(queue->crit);
+
+        PyCritical_Enter(handle->crit);
+        PyCritical_Enter(queue->crit);
+
+        if (handle->queue == NULL) {
+            /* Another thread popped the handle on us, or cancelled it */
+            PyCritical_Exit(queue->crit);
+            PyCritical_Exit(handle->crit);
+            Py_DECREF(handle);
+            continue;
+        }
+
+        assert(handle->weakref == NULL);
+        PyLinkedList_Remove(&handle->queue_links);
+        *payload = handle->payload;
+        handle->payload = NULL;  /* We steal their reference */
+        handle->queue = NULL;
+
+        PyCritical_Exit(queue->crit);
+        PyCritical_Exit(handle->crit);
+
+        Py_DECREF(handle);
+        return 0;
+    }
 }
 
-/* iterator slots */
+static PyObject *
+deathqueue_pop(PyDeathQueue *queue)
+{
+    PyObject *payload, *x;
 
+    while (1) {
+        x = deathqueue_wait(queue);
+        if (x == NULL)
+            return NULL;
+        Py_DECREF(x);
+        if (!pop_common(queue, &payload))
+            return payload;
+    }
+}
+
 static PyObject *
-proxy_iter(PyWeakReference *proxy)
+deathqueue_trypop(PyDeathQueue *queue)
 {
-    if (!proxy_checkref(proxy))
+    PyObject *payload;
+
+    if (pop_common(queue, &payload)) {
+        PyErr_SetString(PyExc_ValueError, "trypop from empty deathqueue");
         return NULL;
-    return PyObject_GetIter(PyWeakref_GET_OBJECT(proxy));
+    } else
+        return payload;
 }
 
+static int
+deathqueue_bool(PyDeathQueue *queue)
+{
+    int result;
+
+    PyCritical_Enter(queue->crit);
+    result = !PyLinkedList_Empty(&queue->dead_links);
+    PyCritical_Exit(queue->crit);
+
+    return result;
+}
+
 static PyObject *
-proxy_iternext(PyWeakReference *proxy)
+deathqueue_wait(PyDeathQueue *queue)
 {
-    if (!proxy_checkref(proxy))
-        return NULL;
-    return PyIter_Next(PyWeakref_GET_OBJECT(proxy));
+    /* Using this method is racey, giving you extra wakeups and forcing
+     * you to have retry loops, so we don't bother to add another retry
+     * loop inside it. */
+    PyCritical_Enter(queue->crit);
+
+    if (PyLinkedList_Empty(&queue->dead_links))
+        _PyCritical_CondWait(queue->crit, queue->cond);
+
+    PyCritical_Exit(queue->crit);
+    Py_INCREF(Py_None);
+    return Py_None;
 }
 
 
-static PyNumberMethods proxy_as_number = {
-    proxy_add,              /*nb_add*/
-    proxy_sub,              /*nb_subtract*/
-    proxy_mul,              /*nb_multiply*/
-    proxy_mod,              /*nb_remainder*/
-    proxy_divmod,           /*nb_divmod*/
-    proxy_pow,              /*nb_power*/
-    proxy_neg,              /*nb_negative*/
-    proxy_pos,              /*nb_positive*/
-    proxy_abs,              /*nb_absolute*/
-    (inquiry)proxy_bool,    /*nb_bool*/
-    proxy_invert,           /*nb_invert*/
-    proxy_lshift,           /*nb_lshift*/
-    proxy_rshift,           /*nb_rshift*/
-    proxy_and,              /*nb_and*/
-    proxy_xor,              /*nb_xor*/
-    proxy_or,               /*nb_or*/
-    0,                      /*nb_reserved*/
-    proxy_int,              /*nb_int*/
-    proxy_long,             /*nb_long*/
-    proxy_float,            /*nb_float*/
-    0,                      /*nb_oct*/
-    0,                      /*nb_hex*/
-    proxy_iadd,             /*nb_inplace_add*/
-    proxy_isub,             /*nb_inplace_subtract*/
-    proxy_imul,             /*nb_inplace_multiply*/
-    proxy_imod,             /*nb_inplace_remainder*/
-    proxy_ipow,             /*nb_inplace_power*/
-    proxy_ilshift,          /*nb_inplace_lshift*/
-    proxy_irshift,          /*nb_inplace_rshift*/
-    proxy_iand,             /*nb_inplace_and*/
-    proxy_ixor,             /*nb_inplace_xor*/
-    proxy_ior,              /*nb_inplace_or*/
-};
+PyDoc_STRVAR(watch_doc,
+"deathqueue.watch(obj, payload) -> handle.  payload is returned from\n\
+deathqueue.pop() once obj dies, unless canceled first.");
 
-static PySequenceMethods proxy_as_sequence = {
-    (lenfunc)proxy_length,      /*sq_length*/
-    0,                          /*sq_concat*/
-    0,                          /*sq_repeat*/
-    0,                          /*sq_item*/
-    0,                          /*sq_slice*/
-    0,                          /*sq_ass_item*/
-    0,				 /*sq_ass_slice*/
-    (objobjproc)proxy_contains, /* sq_contains */
-};
+PyDoc_STRVAR(cancel_doc,
+"deathqueue.cancel(handle) -> None.  Cancels watching of associated obj.");
 
-static PyMappingMethods proxy_as_mapping = {
-    (lenfunc)proxy_length,        /*mp_length*/
-    proxy_getitem,                /*mp_subscript*/
-    (objobjargproc)proxy_setitem, /*mp_ass_subscript*/
-};
+PyDoc_STRVAR(pop_doc,
+"deathqueue.pop() -> payload.  Returns the payload passed to\n\
+deathqueue.watch().  Blocks if no watched objects have died yet.");
 
+PyDoc_STRVAR(trypop_doc,
+"deathqueue.trypop() -> payload.  Used once bool(deathqueue) or\n\
+deathqueue.wait() indicate a watched obj has died; returns the payload\n\
+passed to deathqueue.watch().");
 
-PyTypeObject
-_PyWeakref_ProxyType = {
-    PyVarObject_HEAD_INIT(&PyType_Type, 0)
-    "weakproxy",
-    sizeof(PyWeakReference),
-    0,
-    /* methods */
-    (destructor)proxy_dealloc,          /* tp_dealloc */
-    0,				        /* tp_print */
-    0,				        /* tp_getattr */
-    0, 				        /* tp_setattr */
-    0,				        /* tp_compare */
-    (reprfunc)proxy_repr,	        /* tp_repr */
-    &proxy_as_number,		        /* tp_as_number */
-    &proxy_as_sequence,		        /* tp_as_sequence */
-    &proxy_as_mapping,		        /* tp_as_mapping */
-    0,	                                /* tp_hash */
-    0,	                                /* tp_call */
-    proxy_str,                          /* tp_str */
-    proxy_getattr,                      /* tp_getattro */
-    (setattrofunc)proxy_setattr,        /* tp_setattro */
-    0,				        /* tp_as_buffer */
-    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC, /* tp_flags */
-    0,                                  /* tp_doc */
-    (traverseproc)gc_traverse,          /* tp_traverse */
-    (inquiry)gc_clear,                  /* tp_clear */
-    proxy_richcompare,                  /* tp_richcompare */
-    0,                                  /* tp_weaklistoffset */
-    (getiterfunc)proxy_iter,            /* tp_iter */
-    (iternextfunc)proxy_iternext,       /* tp_iternext */
+PyDoc_STRVAR(wait_doc,
+"deathqueue.wait() -> None.  Does not return until a watched obj has\n\
+died.  This function is interruptible.");
+
+static PyNumberMethods deathqueue_as_number = {
+    0,                              /*nb_add*/
+    0,                              /*nb_subtract*/
+    0,                              /*nb_multiply*/
+    0,                              /*nb_remainder*/
+    0,                              /*nb_divmod*/
+    0,                              /*nb_power*/
+    0,                              /*nb_negative*/
+    0,                              /*nb_positive*/
+    0,                              /*nb_absolute*/
+    (inquiry)deathqueue_bool,       /*nb_bool*/
 };
 
+static PyMethodDef deathqueue_methods[] = {
+    {"watch",       (PyCFunction)deathqueue_watch,      METH_VARARGS, watch_doc},
+    {"cancel",      (PyCFunction)deathqueue_cancel,     METH_VARARGS, cancel_doc},
+    {"pop",         (PyCFunction)deathqueue_pop,        METH_NOARGS, pop_doc},
+    {"trypop",      (PyCFunction)deathqueue_trypop,     METH_NOARGS, trypop_doc},
+    {"wait",        (PyCFunction)deathqueue_wait,       METH_NOARGS, wait_doc},
+    {NULL}
+};
 
+static int
+deathqueue_isshareable (PyDeathQueue *queue)
+{
+    return 1;
+}
+
 PyTypeObject
-_PyWeakref_CallableProxyType = {
+_PyDeathQueue_Type = {
     PyVarObject_HEAD_INIT(&PyType_Type, 0)
-    "weakcallableproxy",
-    sizeof(PyWeakReference),
+    "deathqueue",
+    sizeof(PyDeathQueue),
     0,
-    /* methods */
-    (destructor)proxy_dealloc,          /* tp_dealloc */
-    0,				        /* tp_print */
-    0,				        /* tp_getattr */
-    0, 				        /* tp_setattr */
-    0,				        /* tp_compare */
-    (unaryfunc)proxy_repr,	        /* tp_repr */
-    &proxy_as_number,		        /* tp_as_number */
-    &proxy_as_sequence,		        /* tp_as_sequence */
-    &proxy_as_mapping,		        /* tp_as_mapping */
-    0,	                                /* tp_hash */
-    proxy_call,	                        /* tp_call */
-    proxy_str,	                        /* tp_str */
-    proxy_getattr,                      /* tp_getattro */
-    (setattrofunc)proxy_setattr,        /* tp_setattro */
-    0,				        /* tp_as_buffer */
-    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC, /* tp_flags */
-    0,                                  /* tp_doc */
-    (traverseproc)gc_traverse,          /* tp_traverse */
-    (inquiry)gc_clear,                  /* tp_clear */
-    proxy_richcompare,                  /* tp_richcompare */
-    0,                                  /* tp_weaklistoffset */
-    (getiterfunc)proxy_iter,            /* tp_iter */
-    (iternextfunc)proxy_iternext,       /* tp_iternext */
+    (destructor)deathqueue_dealloc,  /*tp_dealloc*/
+    0,                          /*tp_print*/
+    0,                          /*tp_getattr*/
+    0,                          /*tp_setattr*/
+    0,                          /*tp_compare*/
+    0,                          /*tp_repr*/
+    &deathqueue_as_number,      /*tp_as_number*/
+    0,                          /*tp_as_sequence*/
+    0,                          /*tp_as_mapping*/
+    0,                          /*tp_hash*/
+    0,                          /*tp_call*/
+    0,                          /*tp_str*/
+    0,                          /*tp_getattro*/
+    0,                          /*tp_setattro*/
+    0,                          /*tp_as_buffer*/
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
+        Py_TPFLAGS_SHAREABLE,  /*tp_flags*/
+    0,                          /*tp_doc*/
+    (traverseproc)deathqueue_traverse,  /*tp_traverse*/
+    0,                          /*tp_clear*/
+    0,                          /*tp_richcompare*/
+    0,                          /*tp_weaklistoffset*/
+    0,                          /*tp_iter*/
+    0,                          /*tp_iternext*/
+    deathqueue_methods,         /*tp_methods*/
+    0,                          /*tp_members*/
+    0,                          /*tp_getset*/
+    0,                          /*tp_base*/
+    0,                          /*tp_dict*/
+    0,                          /*tp_descr_get*/
+    0,                          /*tp_descr_set*/
+    0,                          /*tp_dictoffset*/
+    deathqueue___init__,        /*tp_init*/
+    deathqueue___new__,         /*tp_new*/
+    0,                          /*tp_is_gc*/
+    0,                          /*tp_bases*/
+    0,                          /*tp_mro*/
+    0,                          /*tp_cache*/
+    0,                          /*tp_subclasses*/
+    0,                          /*tp_weaklist*/
+    (isshareablefunc)deathqueue_isshareable,    /*tp_isshareable*/
 };
 
 
-
 PyObject *
 PyWeakref_NewRef(PyObject *ob, PyObject *callback)
 {
-    PyWeakReference *result = NULL;
-    PyWeakReference **list;
-    PyWeakReference *ref, *proxy;
+    PyWeakReference **ptr;
+    PyWeakReference *ref;
 
     if (!PyType_SUPPORTS_WEAKREFS(Py_Type(ob))) {
         PyErr_Format(PyExc_TypeError,
-		     "cannot create weak reference to '%s' object",
+                     "cannot create weak reference to '%s' object",
                      Py_Type(ob)->tp_name);
         return NULL;
     }
-    list = GET_WEAKREFS_LISTPTR(ob);
-    get_basic_refs(*list, &ref, &proxy);
-    if (callback == Py_None)
-        callback = NULL;
-    if (callback == NULL)
-        /* return existing weak reference if it exists */
-        result = ref;
-    if (result != NULL)
-        Py_INCREF(result);
-    else {
-        /* Note: new_weakref() can trigger cyclic GC, so the weakref
-           list on ob can be mutated.  This means that the ref and
-           proxy pointers we got back earlier may have been collected,
-           so we need to compute these values again before we use
-           them. */
-        result = new_weakref(ob, callback);
-        if (result != NULL) {
-            get_basic_refs(*list, &ref, &proxy);
-            if (callback == NULL) {
-                if (ref == NULL)
-                    insert_head(result, list);
-                else {
-                    /* Someone else added a ref without a callback
-                       during GC.  Return that one instead of this one
-                       to avoid violating the invariants of the list
-                       of weakrefs for ob. */
-                    Py_DECREF(result);
-                    Py_INCREF(ref);
-                    result = ref;
-                }
-            }
-            else {
-                PyWeakReference *prev;
+    if (callback != NULL) {
+        PyErr_Format(PyExc_TypeError,
+            "weakrefs no longer support callbacks");
+        return NULL;
+    }
 
-                prev = (proxy == NULL) ? ref : proxy;
-                if (prev == NULL)
-                    insert_head(result, list);
-                else
-                    insert_after(result, prev);
-            }
-        }
+    ptr = _PY_GETWEAKREFPTR(ob);
+
+    /* XXX FIXME We should have some sort of fake critical section to
+     * ensure the tracing GC doesn't activate and delete the weakref */
+
+    /* Use the existing ref if there is one */
+    ref = (PyWeakReference *)AO_load_full((AO_t *)ptr);
+    if (ref != NULL) {
+        Py_INCREF(ref);
+        return (PyObject *)ref;
     }
-    return (PyObject *) result;
+
+    /* If there isn't a ref we start creating one */
+    ref = PyObject_NEW(PyWeakReference, &_PyWeakref_Type);
+    ref->crit = PyCritical_Allocate(PyCRITICAL_WEAKREF_REF);
+    if (ref->crit == NULL) {
+        PyObject_DEL(ref);
+        PyErr_NoMemory();
+        return NULL;
+    }
+    ref->hash = (AO_t)-1;
+    ref->wr_object = ob;
+    ref->handle_links.prev = &ref->handle_links;
+    ref->handle_links.next = &ref->handle_links;
+    ref->binding_links.prev = &ref->binding_links;
+    ref->binding_links.next = &ref->binding_links;
+
+    if (!AO_compare_and_swap_full((AO_t *)ptr, (AO_t)NULL, (AO_t)ref)) {
+        /* Another thread beat us to it.  Use theirs instead. */
+        Py_DECREF(ref);
+        ref = (PyWeakReference *)AO_load_full((AO_t *)ptr);
+        assert(ref != NULL);
+    }
+
+    /* ob has the original reference, so we need another one to return
+     * to our caller */
+    Py_INCREF(ref);
+    return (PyObject *)ref;
 }
 
 
+/* Unlike the old function, this DOES include an INCREF */
 PyObject *
-PyWeakref_NewProxy(PyObject *ob, PyObject *callback)
+PyWeakref_GetObjectEx(PyObject *ref_)
 {
-    PyWeakReference *result = NULL;
-    PyWeakReference **list;
-    PyWeakReference *ref, *proxy;
+    PyObject *ob;
+    PyWeakReference *ref = (PyWeakReference *)ref_;
 
-    if (!PyType_SUPPORTS_WEAKREFS(Py_Type(ob))) {
-        PyErr_Format(PyExc_TypeError,
-		     "cannot create weak reference to '%s' object",
-                     Py_Type(ob)->tp_name);
+    if (ref == NULL || !PyWeakref_Check(ref)) {
+        PyErr_BadInternalCall();
         return NULL;
     }
-    list = GET_WEAKREFS_LISTPTR(ob);
-    get_basic_refs(*list, &ref, &proxy);
-    if (callback == Py_None)
-        callback = NULL;
-    if (callback == NULL)
-        /* attempt to return an existing weak reference if it exists */
-        result = proxy;
-    if (result != NULL)
-        Py_INCREF(result);
-    else {
-        /* Note: new_weakref() can trigger cyclic GC, so the weakref
-           list on ob can be mutated.  This means that the ref and
-           proxy pointers we got back earlier may have been collected,
-           so we need to compute these values again before we use
-           them. */
-        result = new_weakref(ob, callback);
-        if (result != NULL) {
-            PyWeakReference *prev;
 
-            if (PyCallable_Check(ob))
-                Py_Type(result) = &_PyWeakref_CallableProxyType;
-            else
-                Py_Type(result) = &_PyWeakref_ProxyType;
-            get_basic_refs(*list, &ref, &proxy);
-            if (callback == NULL) {
-                if (proxy != NULL) {
-                    /* Someone else added a proxy without a callback
-                       during GC.  Return that one instead of this one
-                       to avoid violating the invariants of the list
-                       of weakrefs for ob. */
-                    Py_DECREF(result);
-                    Py_INCREF(result = proxy);
-                    goto skip_insert;
-                }
-                prev = ref;
-            }
-            else
-                prev = (proxy == NULL) ? ref : proxy;
+    PyCritical_Enter(ref->crit);
+    ob = ref->wr_object;
+    Py_XINCREF(ob);
+    PyCritical_Exit(ref->crit);
 
-            if (prev == NULL)
-                insert_head(result, list);
-            else
-                insert_after(result, prev);
-        skip_insert:
-            ;
+    return ob;
+}
+
+int
+_PyWeakref_TryDelete(PyObject *object, PyWeakReference *ref)
+{
+    PyCritical_Enter(ref->crit);
+    assert(ref->wr_object == object);
+    if (Py_RefcntSnoop(object) != 1) {
+        /* Brought back from the brink of death! */
+        PyCritical_Exit(ref->crit);
+        return 1;
+    } else {
+        ref->wr_object = NULL;
+
+        while (!PyLinkedList_Empty(&ref->handle_links)) {
+            PyDeathQueueHandle *handle = PyLinkedList_Restore(
+                PyDeathQueueHandle, weakref_links, ref->handle_links.next);
+
+            PyCritical_Enter(handle->crit);
+            assert(handle->queue != NULL);
+            PyCritical_Enter(handle->queue->crit);
+
+            PyLinkedList_Remove(&handle->weakref_links);
+            handle->weakref = NULL;
+            /* There should always be one reference remaining, borrowed
+             * from the caller. */
+            Py_DECREF(ref);
+
+            PyLinkedList_Remove(&handle->queue_links);
+            PyLinkedList_Append(&handle->queue->dead_links, &handle->queue_links);
+            PyThread_cond_wakeall(handle->queue->cond);
+
+            PyCritical_Exit(handle->queue->crit);
+            PyCritical_Exit(handle->crit);
         }
+
+        PyCritical_Exit(ref->crit);
+
+        _PyWeakref_ClearBindings(object, ref);
+
+        return 0;
     }
-    return (PyObject *) result;
 }
 
+/* XXX This version will actually be called by Py_Dealloc and may
+ * indicate the object is not to be deleted after all. */
+/* XXX FIXME this whole function should get moved into gcmodule.c */
+int
+_PyObject_TryClearWeakref(PyObject *object)
+{
+    PyWeakReference **ptr;
+    PyWeakReference *ref;
+    int result;
 
+    if (object == NULL ||
+            !PyType_SUPPORTS_WEAKREFS(Py_Type(object)) ||
+            !Py_RefcntMatches(object, 1)) {
+        PyErr_BadInternalCall();
+        return 0;
+    }
+    ptr = _PY_GETWEAKREFPTR(object);
+
+    ref = (PyWeakReference *)AO_load_full((AO_t *)ptr);
+    if (ref == NULL)
+        return 0;
+    Py_INCREF(ref);
+
+    result = _PyWeakref_TryDelete(object, ref);
+
+    Py_DECREF(ref);
+    return result;
+}
+
+
 PyObject *
-PyWeakref_GetObject(PyObject *ref)
+PyWeakref_NewBinding(PyObject *ob, PyObject *value)
 {
-    if (ref == NULL || !PyWeakref_Check(ref)) {
-        PyErr_BadInternalCall();
+    PyWeakReference *ref;
+    PyWeakBinding *bind;
+
+    bind = PyObject_NEW(PyWeakBinding, &_PyWeakBinding_Type);
+    if (bind == NULL)
         return NULL;
+
+    ref = (PyWeakReference *)PyWeakref_NewRef(ob, NULL);
+    if (ref == NULL) {
+        PyObject_DEL(bind);
+        return NULL;
     }
-    return PyWeakref_GET_OBJECT(ref);
+
+    PyCritical_Enter(ref->crit);
+    assert(ref->wr_object != NULL);
+    bind->weakref = ref;
+    Py_INCREF(value); /* This is actually owned by ob */
+    bind->value = value;
+    PyLinkedList_Append(&ref->binding_links, &bind->weakref_links);
+    PyCritical_Exit(ref->crit);
+
+    return (PyObject *)bind;
 }
 
-/* Note that there's an inlined copy-paste of handle_callback() in gcmodule.c's
- * handle_weakrefs().
- */
-static void
-handle_callback(PyWeakReference *ref, PyObject *callback)
+PyObject *
+PyWeakref_GetBindingObject(PyObject *bind_, PyObject **value)
 {
-    PyObject *cbresult = PyObject_CallFunctionObjArgs(callback, ref, NULL);
+    PyObject *ob;
+    PyWeakBinding *bind = (PyWeakBinding *)bind_;
 
-    if (cbresult == NULL)
-        PyErr_WriteUnraisable(callback);
-    else
-        Py_DECREF(cbresult);
+    if (bind == NULL || !PyWeakBinding_Check(bind) || value == NULL) {
+        PyErr_BadInternalCall();
+        return NULL;
+    }
+
+    PyCritical_Enter(bind->weakref->crit);
+    if (!PyLinkedList_Detatched(&bind->weakref_links) &&
+            bind->weakref->wr_object != NULL) {
+        ob = bind->weakref->wr_object;
+        Py_INCREF(ob);
+        *value = bind->value;
+        Py_INCREF(*value);
+        PyCritical_Exit(bind->weakref->crit);
+        return ob;
+    } else {
+        PyCritical_Exit(bind->weakref->crit);
+        *value = NULL;
+        return NULL;
+    }
 }
 
-/* This function is called by the tp_dealloc handler to clear weak references.
- *
- * This iterates through the weak references for 'object' and calls callbacks
- * for those references which have one.  It returns when all callbacks have
- * been attempted.
- */
 void
-PyObject_ClearWeakRefs(PyObject *object)
+_PyWeakref_ClearBindings(PyObject *ob, PyWeakReference *ref)
 {
-    PyWeakReference **list;
+    /* Deleting the values may cause another binding to be deleted,
+     * reentering the critical section.  Thus the hoops about making
+     * sure all the bindings we want stay alive long enough, and exiting
+     * the critical section while calling DECREF */
+    PyLinkedList *binding_links;
+    PyWeakBinding *bind;
+    PyObject *value;
 
-    if (object == NULL
-        || !PyType_SUPPORTS_WEAKREFS(Py_Type(object))
-        || object->ob_refcnt != 0) {
-        PyErr_BadInternalCall();
-        return;
+    PyCritical_Enter(ref->crit);
+    binding_links = &ref->binding_links;
+    assert(ref->wr_object == NULL);
+
+    while (PyLinkedList_Next(&ref->binding_links, &binding_links)) {
+        bind = PyLinkedList_Restore(PyWeakBinding, weakref_links,
+            binding_links);
+        Py_INCREF(bind);
     }
-    list = GET_WEAKREFS_LISTPTR(object);
-    /* Remove the callback-less basic and proxy references */
-    if (*list != NULL && (*list)->wr_callback == NULL) {
-        clear_weakref(*list);
-        if (*list != NULL && (*list)->wr_callback == NULL)
-            clear_weakref(*list);
+
+    while (!PyLinkedList_Empty(&ref->binding_links)) {
+        bind = PyLinkedList_Restore(PyWeakBinding, weakref_links,
+            ref->binding_links.next);
+
+        PyLinkedList_Remove(&bind->weakref_links);
+        value = bind->value;
+        bind->value = NULL;
+
+        PyCritical_Exit(ref->crit);
+        Py_DECREF(bind);
+        Py_DECREF(value);
+        PyCritical_Enter(ref->crit);
     }
-    if (*list != NULL) {
-        PyWeakReference *current = *list;
-        Py_ssize_t count = _PyWeakref_GetWeakrefCount(current);
-        int restore_error = PyErr_Occurred() ? 1 : 0;
-        PyObject *err_type, *err_value, *err_tb;
 
-        if (restore_error)
-            PyErr_Fetch(&err_type, &err_value, &err_tb);
-        if (count == 1) {
-            PyObject *callback = current->wr_callback;
+    PyCritical_Exit(ref->crit);
+}
 
-            current->wr_callback = NULL;
-            clear_weakref(current);
-            if (callback != NULL) {
-                handle_callback(current, callback);
-                Py_DECREF(callback);
-            }
-        }
-        else {
-            PyObject *tuple;
-            Py_ssize_t i = 0;
-    
-            tuple = PyTuple_New(count * 2);
-            if (tuple == NULL) {
-                if (restore_error)
-                    PyErr_Fetch(&err_type, &err_value, &err_tb);
-                return;
-            }
+static void
+weakbind_dealloc(PyWeakBinding *bind)
+{
+    PyCritical_Enter(bind->weakref->crit);
+    if (!PyLinkedList_Detatched(&bind->weakref_links)) {
+        PyObject *value;
+        assert(bind->value);
+        PyLinkedList_Remove(&bind->weakref_links);
+        value = bind->value;
+        bind->value = NULL;
+        /* At this point we've taken ob's reference to value and now
+         * own it directly. */
+        PyCritical_Exit(bind->weakref->crit);
+        Py_DECREF(value);
+    } else
+        PyCritical_Exit(bind->weakref->crit);
 
-            for (i = 0; i < count; ++i) {
-                PyWeakReference *next = current->wr_next;
+    if (Py_RefcntSnoop(bind) != 1) {
+        /* Another thread is trying to manipulate us.  Probably a
+         * clearing all the bindings for a weakref.  We can finish
+         * deleting later. */
+        PyObject_REVIVE(bind);
+        Py_DECREF_ASYNC(bind);
+        return;
+    }
 
-                Py_INCREF(current);
-                PyTuple_SET_ITEM(tuple, i * 2, (PyObject *) current);
-                PyTuple_SET_ITEM(tuple, i * 2 + 1, current->wr_callback);
-                current->wr_callback = NULL;
-                clear_weakref(current);
-                current = next;
-            }
-            for (i = 0; i < count; ++i) {
-                PyObject *callback = PyTuple_GET_ITEM(tuple, i * 2 + 1);
+    Py_DECREF(bind->weakref);
 
-                if (callback != NULL) {
-                    PyObject *item = PyTuple_GET_ITEM(tuple, i * 2);
-                    handle_callback((PyWeakReference *)item, callback);
-                }
-            }
-            Py_DECREF(tuple);
-        }
-        if (restore_error)
-            PyErr_Restore(err_type, err_value, err_tb);
+    PyObject_DEL(bind);
+}
+
+static int
+weakbind_traverse(PyWeakBinding *bind, visitproc visit, void *arg)
+{
+    Py_VISIT(bind->weakref);
+    return 0;
+}
+
+static PyObject *
+weakbind_call(PyObject *bind, PyObject *args, PyObject *kw)
+{
+    static char *kwlist[] = {NULL};
+    PyObject *ob, *value;
+
+    if (!PyArg_ParseTupleAndKeywords(args, kw, ":__call__", kwlist))
+        return NULL;
+
+    ob = PyWeakref_GetBindingObject(bind, &value);
+
+    if (ob == NULL)
+        return Py_BuildValue("OO", Py_None, Py_None);
+    else
+        return Py_BuildValue("NN", ob, value);
+}
+
+static PyObject *
+weakbind_repr(PyWeakBinding *bind)
+{
+    char buffer[256];
+    PyObject *ob, *value;
+
+    ob = PyWeakref_GetBindingObject((PyObject *)bind, &value);
+
+    if (ob == NULL)
+        PyOS_snprintf(buffer, sizeof(buffer), "<weakbinding at %p; dead>", bind);
+    else {
+        PyOS_snprintf(buffer, sizeof(buffer),
+            "<weakbinding at %p; from '%.50s' at %p to '%.50s' at %p>",
+            bind, Py_Type(ob)->tp_name, ob, Py_Type(value)->tp_name, value);
+        Py_DECREF(ob);
+        Py_DECREF(value);
     }
+
+    return PyUnicode_FromString(buffer);
 }
+
+static int
+parse_weakbind_init_args(char *funcname, PyObject *args, PyObject *kwargs,
+                        PyObject **obp, PyObject **valuep)
+{
+    /* XXX Should check that kwargs == NULL or is empty. */
+    return PyArg_UnpackTuple(args, funcname, 2, 2, obp, valuep);
+}
+
+static PyObject *
+weakbind___new__(PyTypeObject *type, PyObject *args, PyObject *kwargs)
+{
+    PyObject *ob, *value;
+
+    if (!parse_weakbind_init_args("__new__", args, kwargs, &ob, &value))
+        return NULL;
+
+    return PyWeakref_NewBinding(ob, value);
+}
+
+static int
+weakbind___init__(PyObject *self, PyObject *args, PyObject *kwargs)
+{
+    PyObject *ob, *value;
+
+    if (parse_weakbind_init_args("__init__", args, kwargs, &ob, &value))
+        return 0;
+    else
+        return 1;
+}
+
+
+PyTypeObject
+_PyWeakBinding_Type = {
+    PyVarObject_HEAD_INIT(&PyType_Type, 0)
+    "weakbinding",
+    sizeof(PyWeakBinding),
+    0,
+    (destructor)weakbind_dealloc,  /*tp_dealloc*/
+    0,                          /*tp_print*/
+    0,                          /*tp_getattr*/
+    0,                          /*tp_setattr*/
+    0,                          /*tp_compare*/
+    (reprfunc)weakbind_repr,    /*tp_repr*/
+    0,                          /*tp_as_number*/
+    0,                          /*tp_as_sequence*/
+    0,                          /*tp_as_mapping*/
+    0,                          /*tp_hash*/
+    weakbind_call,              /*tp_call*/
+    0,                          /*tp_str*/
+    0,                          /*tp_getattro*/
+    0,                          /*tp_setattro*/
+    0,                          /*tp_as_buffer*/
+    /* subclassing is unsupported */
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
+        Py_TPFLAGS_SHAREABLE,  /*tp_flags*/
+    0,                          /*tp_doc*/
+    (traverseproc)weakbind_traverse,  /*tp_traverse*/
+    0,                          /*tp_clear*/
+    0,                          /*tp_richcompare*/
+    0,                          /*tp_weaklistoffset*/
+    0,                          /*tp_iter*/
+    0,                          /*tp_iternext*/
+    0,                          /*tp_methods*/
+    0,                          /*tp_members*/
+    0,                          /*tp_getset*/
+    0,                          /*tp_base*/
+    0,                          /*tp_dict*/
+    0,                          /*tp_descr_get*/
+    0,                          /*tp_descr_set*/
+    0,                          /*tp_dictoffset*/
+    weakbind___init__,          /*tp_init*/
+    weakbind___new__,           /*tp_new*/
+};
Index: Objects/unicodeobject.c
===================================================================
--- Objects/unicodeobject.c	(revision 58355)
+++ Objects/unicodeobject.c	(working copy)
@@ -41,6 +41,7 @@
 
 #define PY_SSIZE_T_CLEAN
 #include "Python.h"
+#include "pythread.h"
 
 #include "unicodeobject.h"
 #include "ucnhash.h"
@@ -51,6 +52,8 @@
 #include <windows.h>
 #endif
 
+//#define USE_UNICODE_FREELIST
+
 /* Limit for the Unicode object free list */
 
 #define MAX_UNICODE_FREELIST_SIZE       1024
@@ -94,6 +97,21 @@
 extern "C" {
 #endif
 
+/* Use only if you know it's a string */
+static inline int
+PyUnicode_SnoopState(PyUnicodeObject *op)
+{
+    /* XXX Just what is required here?  This all needs to be audited/fixed anyway.. */
+    //return (int)AO_load_full(&op->state);
+    return (int)AO_load_acquire(&op->state);
+}
+
+static inline void
+PyUnicode_SetState(PyUnicodeObject *op, int state)
+{
+    AO_store_full(&op->state, state);
+}
+
 /* This dictionary holds all interned unicode strings.  Note that references
    to strings in this dictionary are *not* counted in the string's ob_refcnt.
    When the interned string reaches a refcnt of 0 the string deallocation
@@ -103,10 +121,16 @@
    count of a string is:  s->ob_refcnt + (s->ob_sstate?2:0)
 */
 static PyObject *interned;
+/* Some dict and list operations will be called while holding
+ * interned_critical.  This is dangerous, but presumably unavoidable. */
+static PyCritical *interned_critical;
 
+#ifdef USE_UNICODE_FREELIST
 /* Free list for Unicode objects */
 static PyUnicodeObject *unicode_freelist;
 static int unicode_freelist_size;
+static PyCritical *unicode_freelist_critical;
+#endif
 
 /* The empty Unicode object is shared to improve performance. */
 static PyUnicodeObject *unicode_empty;
@@ -248,35 +272,42 @@
         return unicode_empty;
     }
 
+#ifdef USE_UNICODE_FREELIST
     /* Unicode freelist & memory allocation */
+    PyCritical_Enter(unicode_freelist_critical);
     if (unicode_freelist) {
         unicode = unicode_freelist;
         unicode_freelist = *(PyUnicodeObject **)unicode;
         unicode_freelist_size--;
-	if (unicode->str) {
-	    /* Keep-Alive optimization: we only upsize the buffer,
-	       never downsize it. */
-	    if ((unicode->length < length) &&
+        PyCritical_Exit(unicode_freelist_critical);
+        if (unicode->str) {
+            /* Keep-Alive optimization: we only upsize the buffer,
+               never downsize it. */
+            if ((unicode->length < length) &&
                 unicode_resize(unicode, length) < 0) {
-		PyMem_DEL(unicode->str);
-		goto onError;
-	    }
-	}
+                PyMem_DEL(unicode->str);
+                goto onError;
+            }
+        }
         else {
-	    unicode->str = PyMem_NEW(Py_UNICODE, length + 1);
+            unicode->str = PyMem_NEW(Py_UNICODE, length + 1);
         }
         PyObject_INIT(unicode, &PyUnicode_Type);
     }
     else {
-        unicode = PyObject_New(PyUnicodeObject, &PyUnicode_Type);
+        PyCritical_Exit(unicode_freelist_critical);
+#endif
+        unicode = PyObject_NEW(PyUnicodeObject, &PyUnicode_Type);
         if (unicode == NULL)
             return NULL;
-	unicode->str = PyMem_NEW(Py_UNICODE, length + 1);
+        unicode->str = PyMem_NEW(Py_UNICODE, length + 1);
+#ifdef USE_UNICODE_FREELIST
     }
+#endif
 
     if (!unicode->str) {
-	PyErr_NoMemory();
-	goto onError;
+        PyErr_NoMemory();
+        goto onError;
     }
     /* Initialize the first element to guard against cases where
      * the caller fails before initializing str -- unicode_resize()
@@ -294,55 +325,80 @@
     return unicode;
 
  onError:
-    _Py_ForgetReference((PyObject *)unicode);
-    PyObject_Del(unicode);
+    PyObject_DEL(unicode);
     return NULL;
 }
 
+/* There's many assumptions built in here about what we can do safely. */
 static
 void unicode_dealloc(register PyUnicodeObject *unicode)
 {
-    switch (PyUnicode_CHECK_INTERNED(unicode)) {
-        case SSTATE_NOT_INTERNED:
-            break;
+    int state = PyUnicode_SnoopState(unicode);
+    assert(Py_RefcntSnoop(unicode) == 1);
+    assert(unicode->state == SSTATE_NOT_INTERNED ||
+        unicode->state == SSTATE_INTERNED);
 
-        case SSTATE_INTERNED_MORTAL:
-            /* revive dead object temporarily for DelItem */
-            Py_Refcnt(unicode) = 3;
-            if (PyDict_DelItem(interned, (PyObject *)unicode) != 0)
-                Py_FatalError(
-                    "deletion of interned unicode string failed");
-            break;
+    if (state == SSTATE_INTERNED) {
+        PyCritical_Enter(interned_critical);
+        if (Py_RefcntSnoop(unicode) > 1) {
+            PyCritical_Exit(interned_critical);
+            /* An asynchronous DECREF is used to ensure we
+             * don't become recursive and risk blowing our
+             * stack. */
+            PyObject_REVIVE(unicode);
+            Py_DECREF_ASYNC(unicode);
+            return;
+        }
 
-        case SSTATE_INTERNED_IMMORTAL:
-            Py_FatalError("Immortal interned unicode string died.");
+        /* We got a refcnt of 0 then we must be the owner of it, and the
+         * only remaining reference is this interned, which we hold the
+         * lock to.  Thus, we can safely alter the refcnt. */
+        /* We're assuming PyDict_DelItem won't do anything that might
+         * release the PyState */
+        //((PyObject *)unicode)->ob_refowner = (AO_t)PyThreadState_Get();
+        //((PyObject *)unicode)->ob_refcnt = 3;
+        Py_INCREF(unicode);
+        Py_INCREF(unicode);
+        if (PyDict_DelItem(interned, (PyObject *)unicode) != 0)
+            Py_FatalError("deletion of interned unicode string failed");
 
-        default:
-            Py_FatalError("Inconsistent interned unicode string state.");
+        assert(Py_RefcntSnoop(unicode) == 1);
+
+        //((PyObject *)unicode)->ob_refcnt = 0;
+
+        PyCritical_Exit(interned_critical);
     }
 
+#ifdef USE_UNICODE_FREELIST
+    PyCritical_Enter(unicode_freelist_critical);
     if (PyUnicode_CheckExact(unicode) &&
 	unicode_freelist_size < MAX_UNICODE_FREELIST_SIZE) {
+	PyObject *defenc;
         /* Keep-Alive optimization */
 	if (unicode->length >= KEEPALIVE_SIZE_LIMIT) {
 	    PyMem_DEL(unicode->str);
 	    unicode->str = NULL;
 	    unicode->length = 0;
 	}
-	if (unicode->defenc) {
-	    Py_DECREF(unicode->defenc);
-	    unicode->defenc = NULL;
-	}
+	defenc = unicode->defenc;
+	unicode->defenc = NULL;
 	/* Add to free list */
         *(PyUnicodeObject **)unicode = unicode_freelist;
         unicode_freelist = unicode;
         unicode_freelist_size++;
+	PyCritical_Exit(unicode_freelist_critical);
+	Py_XDECREF(defenc);
     }
     else {
+	PyCritical_Exit(unicode_freelist_critical);
+#endif
 	PyMem_DEL(unicode->str);
 	Py_XDECREF(unicode->defenc);
-	Py_Type(unicode)->tp_free((PyObject *)unicode);
+	assert(Py_RefcntSnoop(unicode) == 1);
+        PyObject_DEL(unicode);
+#ifdef USE_UNICODE_FREELIST
     }
+#endif
 }
 
 int PyUnicode_Resize(PyObject **unicode, Py_ssize_t length)
@@ -355,7 +411,7 @@
 	return -1;
     }
     v = (PyUnicodeObject *)*unicode;
-    if (v == NULL || !PyUnicode_Check(v) || Py_Refcnt(v) != 1 || length < 0) {
+    if (v == NULL || !PyUnicode_Check(v) || !Py_RefcntMatches(v, 1) || length < 0) {
 	PyErr_BadInternalCall();
 	return -1;
     }
@@ -4012,7 +4068,7 @@
 /* Charmap encoding: the lookup table */
 
 struct encoding_map{
-  PyObject_HEAD
+  PyObject_VAR_HEAD
   unsigned char level1[32];
   int count2, count3;
   unsigned char level23[1];
@@ -4035,14 +4091,14 @@
 static void
 encoding_map_dealloc(PyObject* o)
 {
-	PyObject_FREE(o);
+	PyObject_Del(o);
 }
 
 static PyTypeObject EncodingMapType = {
 	PyVarObject_HEAD_INIT(NULL, 0)
         "EncodingMap",          /*tp_name*/
         sizeof(struct encoding_map),   /*tp_basicsize*/
-        0,                      /*tp_itemsize*/
+        sizeof(char),           /*tp_itemsize*/
         /* methods */
         encoding_map_dealloc,   /*tp_dealloc*/
         0,                      /*tp_print*/
@@ -4076,9 +4132,7 @@
         0,                      /*tp_descr_set*/
         0,                      /*tp_dictoffset*/
         0,                      /*tp_init*/
-        0,                      /*tp_alloc*/
         0,                      /*tp_new*/
-        0,                      /*tp_free*/
         0,                      /*tp_is_gc*/
 };
 
@@ -4157,11 +4211,14 @@
     }
 
     /* Create a three-level trie */
-    result = PyObject_MALLOC(sizeof(struct encoding_map) +
-                             16*count2 + 128*count3 - 1);
-    if (!result)
-        return PyErr_NoMemory();
-    PyObject_Init(result, &EncodingMapType);
+    //result = PyObject_MALLOC(sizeof(struct encoding_map) +
+    //                         16*count2 + 128*count3 - 1);
+    //if (!result)
+    //    return PyErr_NoMemory();
+    //PyObject_Init(result, &EncodingMapType);
+    result = PyObject_NewVar(&EncodingMapType, 16*count2 + 128*count3 - 1);
+    if (result == NULL)
+        return NULL;
     mresult = (struct encoding_map*)result;
     mresult->count2 = count2;
     mresult->count3 = count3;
@@ -7848,7 +7905,11 @@
 static PyObject*
 unicode_freelistsize(PyUnicodeObject *self)
 {
-    return PyInt_FromLong(unicode_freelist_size);
+    int size;
+    PyCritical_Enter(unicode_freelist_critical);
+    size = unicode_freelist_size;
+    PyCritical_Exit(unicode_freelist_critical);
+    return PyInt_FromLong(size);
 }
 #endif
 
@@ -8855,15 +8916,15 @@
 	if (tmp == NULL)
 		return NULL;
 	assert(PyUnicode_Check(tmp));
-	pnew = (PyUnicodeObject *) type->tp_alloc(type, n = tmp->length);
+	n = tmp->length;
+	pnew = PyObject_NEW(PyUnicodeObject, type);
 	if (pnew == NULL) {
 		Py_DECREF(tmp);
 		return NULL;
 	}
 	pnew->str = PyMem_NEW(Py_UNICODE, n+1);
 	if (pnew->str == NULL) {
-		_Py_ForgetReference((PyObject *)pnew);
-		PyObject_Del(pnew);
+		PyObject_DEL(pnew);
 		Py_DECREF(tmp);
 		return PyErr_NoMemory();
 	}
@@ -8874,6 +8935,12 @@
 	return (PyObject *)pnew;
 }
 
+static int
+unicode_isshareable (PyObject *v)
+{
+	return PyUnicode_CheckExact(v);
+}
+
 PyDoc_STRVAR(unicode_doc,
 "str(string [, encoding[, errors]]) -> object\n\
 \n\
@@ -8905,7 +8972,8 @@
     0,			 		/* tp_setattro */
     &unicode_as_buffer,			/* tp_as_buffer */
     Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | 
-        Py_TPFLAGS_UNICODE_SUBCLASS,	/* tp_flags */
+        Py_TPFLAGS_UNICODE_SUBCLASS |
+        Py_TPFLAGS_SHAREABLE,		/* tp_flags */
     unicode_doc,			/* tp_doc */
     0,					/* tp_traverse */
     0,					/* tp_clear */
@@ -8922,15 +8990,37 @@
     0,					/* tp_descr_set */
     0,					/* tp_dictoffset */
     0,					/* tp_init */
-    0,					/* tp_alloc */
     unicode_new,			/* tp_new */
-    PyObject_Del,      		/* tp_free */
+    0,					/* tp_is_gc */
+    0,					/* tp_bases */
+    0,					/* tp_mro */
+    0,					/* tp_cache */
+    0,					/* tp_subclasses */
+    0,					/* tp_weaklist */
+    unicode_isshareable,		/* tp_isshareable */
 };
 
 /* Initialize the Unicode implementation */
 
-void _PyUnicode_Init(void)
+/* Even type and object's initialization calls us, so we need a bare
+ * minimum of functionality to be ready even before them. */
+void
+_PyUnicode_PreInit(void)
 {
+    interned_critical = PyCritical_Allocate(PyCRITICAL_NORMAL);
+    if (!interned_critical)
+        Py_FatalError("unable to allocate lock");
+
+#ifdef USE_UNICODE_FREELIST
+    unicode_freelist_critical = PyCritical_Allocate(PyCRITICAL_NORMAL);
+    if (!unicode_freelist_critical)
+        Py_FatalError("unable to allocate lock");
+#endif
+}
+
+void
+_PyUnicode_Init(void)
+{
     int i;
 
     /* XXX - move this array to unicodectype.c ? */
@@ -8946,8 +9036,10 @@
     };
 
     /* Init the implementation */
-    unicode_freelist = NULL;
-    unicode_freelist_size = 0;
+#ifdef USE_UNICODE_FREELIST
+    assert(unicode_freelist == NULL && unicode_freelist_size == 0 &&
+	unicode_empty == NULL);
+#endif
     unicode_empty = _PyUnicode_New(0);
     if (!unicode_empty)
 	return;
@@ -8983,6 +9075,7 @@
 	}
     }
 
+#ifdef USE_UNICODE_FREELIST
     for (u = unicode_freelist; u != NULL;) {
 	PyUnicodeObject *v = u;
 	u = *(PyUnicodeObject **)u;
@@ -8993,64 +9086,76 @@
     }
     unicode_freelist = NULL;
     unicode_freelist_size = 0;
+#endif
 }
 
 void
-PyUnicode_InternInPlace(PyObject **p)
+_PyUnicode_PostFini(void)
 {
-	register PyUnicodeObject *s = (PyUnicodeObject *)(*p);
-	PyObject *t;
-	if (s == NULL || !PyUnicode_Check(s))
-		Py_FatalError(
-		    "PyUnicode_InternInPlace: unicode strings only please!");
-	/* If it's a subclass, we don't really know what putting
-	   it in the interned dict might do. */
-	if (!PyUnicode_CheckExact(s))
-		return;
-	if (PyUnicode_CHECK_INTERNED(s))
-		return;
-	if (interned == NULL) {
-		interned = PyDict_New();
-		if (interned == NULL) {
-			PyErr_Clear(); /* Don't leave an exception */
-			return;
-		}
-	}
-	/* It might be that the GetItem call fails even
-	   though the key is present in the dictionary,
-	   namely when this happens during a stack overflow. */
-	Py_ALLOW_RECURSION
-	t = PyDict_GetItem(interned, (PyObject *)s);
-	Py_END_ALLOW_RECURSION
+    PyCritical_Free(interned_critical);
+    interned_critical = NULL;
 
-	if (t) {
-		Py_INCREF(t);
-		Py_DECREF(*p);
-		*p = t;
-		return;
-	}
-
-	PyThreadState_GET()->recursion_critical = 1;
-	if (PyDict_SetItem(interned, (PyObject *)s, (PyObject *)s) < 0) {
-		PyErr_Clear();
-		PyThreadState_GET()->recursion_critical = 0;
-		return;
-	}
-	PyThreadState_GET()->recursion_critical = 0;
-	/* The two references in interned are not counted by refcnt.
-	   The deallocator will take care of this */
-	Py_Refcnt(s) -= 2;
-	PyUnicode_CHECK_INTERNED(s) = SSTATE_INTERNED_MORTAL;
+#ifdef USE_UNICODE_FREELIST
+    PyCritical_Free(unicode_freelist_critical);
+    unicode_freelist_critical = NULL;
+#endif
 }
 
 void
-PyUnicode_InternImmortal(PyObject **p)
+PyUnicode_InternInPlace(PyObject **p)
 {
-	PyUnicode_InternInPlace(p);
-	if (PyUnicode_CHECK_INTERNED(*p) != SSTATE_INTERNED_IMMORTAL) {
-		PyUnicode_CHECK_INTERNED(*p) = SSTATE_INTERNED_IMMORTAL;
-		Py_INCREF(*p);
-	}
+    register PyUnicodeObject *s = (PyUnicodeObject *)(*p);
+    PyObject *t;
+    if (s == NULL || !PyUnicode_Check(s))
+        Py_FatalError(
+            "PyUnicode_InternInPlace: unicode strings only please!");
+    /* If it's a subclass, we don't really know what putting
+       it in the interned dict might do. */
+    if (!PyUnicode_CheckExact(s))
+        return;
+    if (PyUnicode_SnoopState(s))
+        return;
+
+    PyCritical_Enter(interned_critical);
+    if (interned == NULL) {
+        interned = PyDict_New();
+        if (interned == NULL) {
+            PyCritical_Exit(interned_critical);
+            PyErr_Clear(); /* Don't leave an exception */
+            return;
+        }
+    }
+
+    /* It might be that the GetItem call fails even
+       though the key is present in the dictionary,
+       namely when this happens during a stack overflow. */
+    Py_ALLOW_RECURSION
+    t = PyDict_GetItem(interned, (PyObject *)s);
+    Py_END_ALLOW_RECURSION
+
+    if (t) {
+        assert(PyUnicode_CheckExact(t));
+        Py_INCREF(t);
+        PyCritical_Exit(interned_critical);
+        Py_DECREF(*p);
+        *p = t;
+        return;
+    }
+
+    PyThreadState_Get()->recursion_critical = 1;
+    if (PyDict_SetItem(interned, (PyObject *)s, (PyObject *)s) < 0) {
+        PyCritical_Exit(interned_critical);
+        PyErr_Clear();
+        PyThreadState_Get()->recursion_critical = 0;
+        return;
+    }
+    PyThreadState_Get()->recursion_critical = 0;
+    /* The two references in interned are not counted by refcnt.
+       The deallocator will take care of this */
+    Py_DECREF(s);
+    Py_DECREF(s);
+    PyUnicode_SetState(s, SSTATE_INTERNED);
+    PyCritical_Exit(interned_critical);
 }
 
 PyObject *
@@ -9065,15 +9170,23 @@
 
 void _Py_ReleaseInternedUnicodeStrings(void)
 {
-	PyObject *keys;
-	PyUnicodeObject *s;
+	PyObject *keys, *temp;
 	Py_ssize_t i, n;
-	Py_ssize_t immortal_size = 0, mortal_size = 0;
+	Py_ssize_t mortal_size = 0;
+	PyThreadState *tstate = PyThreadState_Get();
 
-	if (interned == NULL || !PyDict_Check(interned))
+	PyCritical_Enter(interned_critical);
+	if (AO_load_full(&tstate->interp->tstate_count) != 1)
+		Py_FatalError("Attempting to release interned strings while "
+			"multiple threads exist");
+
+	if (interned == NULL || !PyDict_Check(interned)) {
+		PyCritical_Exit(interned_critical);
 		return;
+	}
 	keys = PyDict_Keys(interned);
 	if (keys == NULL || !PyList_Check(keys)) {
+		PyCritical_Exit(interned_critical);
 		PyErr_Clear();
 		return;
 	}
@@ -9087,31 +9200,30 @@
 	fprintf(stderr, "releasing %" PY_FORMAT_SIZE_T "d interned strings\n",
 		n);
 	for (i = 0; i < n; i++) {
-		s = (PyUnicodeObject *) PyList_GET_ITEM(keys, i);
-		switch (s->state) {
-		case SSTATE_NOT_INTERNED:
-			/* XXX Shouldn't happen */
-			break;
-		case SSTATE_INTERNED_IMMORTAL:
-			Py_Refcnt(s) += 1;
-			immortal_size += s->length;
-			break;
-		case SSTATE_INTERNED_MORTAL:
-			Py_Refcnt(s) += 2;
-			mortal_size += s->length;
-			break;
-		default:
+		PyUnicodeObject *s = (PyUnicodeObject *) PyList_GET_ITEM(keys, i);
+		void *owner = (void *)AO_load_full(&((PyObject *)s)->ob_refowner);
+		if (PyUnicode_SnoopState(s) != SSTATE_INTERNED)
 			Py_FatalError("Inconsistent interned string state.");
-		}
+
+		if (owner == (void *)Py_REFOWNER_STATICINIT) {
+			/* Inline _PyGC_RefMode_Promote */
+			((PyObject *)s)->ob_refowner = (AO_t)tstate;
+		} else if (owner != tstate)
+			Py_FatalError("Interned string has wrong owner");
+
+		Py_INCREF(s);
+		Py_INCREF(s);
+		mortal_size += s->length;
 		s->state = SSTATE_NOT_INTERNED;
 	}
 	fprintf(stderr, "total size of all interned strings: "
-			"%" PY_FORMAT_SIZE_T "d/%" PY_FORMAT_SIZE_T "d "
-			"mortal/immortal\n", mortal_size, immortal_size);
+			"%" PY_FORMAT_SIZE_T "d\n", mortal_size);
+	temp = interned;
+	interned = NULL;
+	PyCritical_Exit(interned_critical);
 	Py_DECREF(keys);
-	PyDict_Clear(interned);
-	Py_DECREF(interned);
-	interned = NULL;
+	PyDict_Clear(temp);
+	Py_DECREF(temp);
 }
 
 
@@ -9126,9 +9238,8 @@
 static void
 unicodeiter_dealloc(unicodeiterobject *it)
 {
-	_PyObject_GC_UNTRACK(it);
 	Py_XDECREF(it->it_seq);
-	PyObject_GC_Del(it);
+	PyObject_DEL(it);
 }
 
 static int
@@ -9222,13 +9333,12 @@
 		PyErr_BadInternalCall();
 		return NULL;
 	}
-	it = PyObject_GC_New(unicodeiterobject, &PyUnicodeIter_Type);
+	it = PyObject_NEW(unicodeiterobject, &PyUnicodeIter_Type);
 	if (it == NULL)
 		return NULL;
 	it->it_index = 0;
 	Py_INCREF(seq);
 	it->it_seq = (PyUnicodeObject *)seq;
-	_PyObject_GC_TRACK(it);
 	return (PyObject *)it;
 }
 
Index: Objects/tupleobject.c
===================================================================
--- Objects/tupleobject.c	(revision 58355)
+++ Objects/tupleobject.c	(working copy)
@@ -3,6 +3,10 @@
 
 #include "Python.h"
 
+#ifdef WITH_FREETHREAD
+#define MAXSAVESIZE 1  /* Disabled to remove lock contention */
+#endif
+
 /* Speed optimization to avoid frequent malloc/free of small tuples */
 #ifndef MAXSAVESIZE
 #define MAXSAVESIZE	20  /* Largest tuple to save on free list */
@@ -48,11 +52,11 @@
 		fast_tuple_allocs++;
 #endif
 		/* Inline PyObject_InitVar */
-#ifdef Py_TRACE_REFS
-		Py_Size(op) = size;
-		Py_Type(op) = &PyTuple_Type;
-#endif
-		_Py_NewReference((PyObject *)op);
+//#ifdef Py_TRACE_REFS
+//		Py_Size(op) = size;
+//		Py_Type(op) = &PyTuple_Type;
+//#endif
+//		_Py_NewReference((PyObject *)op);
 	}
 	else
 #endif
@@ -65,20 +69,20 @@
 		{
 			return PyErr_NoMemory();
 		}
-		op = PyObject_GC_NewVar(PyTupleObject, &PyTuple_Type, size);
+		op = PyObject_NEWVAR(PyTupleObject, &PyTuple_Type, size);
 		if (op == NULL)
 			return NULL;
 	}
 	for (i=0; i < size; i++)
 		op->ob_item[i] = NULL;
 #if MAXSAVESIZE > 0
+	/* XXX FIXME this isn't threadsafe and should probably be done elsewhere */
 	if (size == 0) {
 		free_tuples[0] = op;
 		++num_free_tuples[0];
 		Py_INCREF(op);	/* extra INCREF so that this is never freed */
 	}
 #endif
-	_PyObject_GC_TRACK(op);
 	return (PyObject *) op;
 }
 
@@ -112,7 +116,7 @@
 {
 	register PyObject *olditem;
 	register PyObject **p;
-	if (!PyTuple_Check(op) || op->ob_refcnt != 1) {
+	if (!PyTuple_Check(op) || !Py_RefcntMatches(op, 1)) {
 		Py_XDECREF(newitem);
 		PyErr_BadInternalCall();
 		return -1;
@@ -161,8 +165,6 @@
 {
 	register Py_ssize_t i;
 	register Py_ssize_t len =  Py_Size(op);
-	PyObject_GC_UnTrack(op);
-	Py_TRASHCAN_SAFE_BEGIN(op)
 	if (len > 0) {
 		i = len;
 		while (--i >= 0)
@@ -175,13 +177,11 @@
 			op->ob_item[0] = (PyObject *) free_tuples[len];
 			num_free_tuples[len]++;
 			free_tuples[len] = op;
-			goto done; /* return */
+			return;
 		}
 #endif
 	}
-	Py_Type(op)->tp_free((PyObject *)op);
-done:
-	Py_TRASHCAN_SAFE_END(op)
+	PyObject_DEL(op);
 }
 
 static PyObject *
@@ -531,7 +531,7 @@
 	if (tmp == NULL)
 		return NULL;
 	assert(PyTuple_Check(tmp));
-	newobj = type->tp_alloc(type, n = PyTuple_GET_SIZE(tmp));
+	newobj = PyObject_NewVar(type, n = PyTuple_GET_SIZE(tmp));
 	if (newobj == NULL)
 		return NULL;
 	for (i = 0; i < n; i++) {
@@ -634,6 +634,23 @@
 	0
 };
 
+static int
+tuple_isshareable (PyTupleObject *v)
+{
+    Py_ssize_t i;
+
+    if (AO_load_full(&v->shareable))
+        return 1;
+
+    for (i = 0; i < Py_Size(v); i++) {
+        if (!PyObject_IsShareable(PyTuple_GET_ITEM(v, i)))
+            return 0;
+    }
+
+    AO_store_full(&v->shareable, 1);
+    return 1;
+}
+
 static PyObject *tuple_iter(PyObject *seq);
 
 PyTypeObject PyTuple_Type = {
@@ -657,7 +674,8 @@
 	0,					/* tp_setattro */
 	0,					/* tp_as_buffer */
 	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
-		Py_TPFLAGS_BASETYPE | Py_TPFLAGS_TUPLE_SUBCLASS, /* tp_flags */
+		Py_TPFLAGS_BASETYPE | Py_TPFLAGS_TUPLE_SUBCLASS |
+		Py_TPFLAGS_SHAREABLE,		/* tp_flags */
 	tuple_doc,				/* tp_doc */
  	(traverseproc)tupletraverse,		/* tp_traverse */
 	0,					/* tp_clear */
@@ -674,9 +692,14 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	tuple_new,				/* tp_new */
-	PyObject_GC_Del,        		/* tp_free */
+	0,					/* tp_is_gc */
+	0,					/* tp_bases */
+	0,					/* tp_mro */
+	0,					/* tp_cache */
+	0,					/* tp_subclasses */
+	0,					/* tp_weaklist */
+	(isshareablefunc)tuple_isshareable,	/* tp_isshareable */
 };
 
 /* The following function breaks the notion that tuples are immutable:
@@ -696,7 +719,8 @@
 
 	v = (PyTupleObject *) *pv;
 	if (v == NULL || Py_Type(v) != &PyTuple_Type ||
-	    (Py_Size(v) != 0 && Py_Refcnt(v) != 1)) {
+	    (Py_Size(v) != 0 && !Py_RefcntMatches(v, 1)) ||
+	    v == free_tuples[0]) {
 		*pv = 0;
 		Py_XDECREF(v);
 		PyErr_BadInternalCall();
@@ -715,32 +739,28 @@
 		return *pv == NULL ? -1 : 0;
 	}
 
-	/* XXX UNREF/NEWREF interface should be more symmetrical */
-	_Py_DEC_REFTOTAL;
-	_PyObject_GC_UNTRACK(v);
-	_Py_ForgetReference((PyObject *) v);
 	/* DECREF items deleted by shrinkage */
-	for (i = newsize; i < oldsize; i++) {
-		Py_XDECREF(v->ob_item[i]);
-		v->ob_item[i] = NULL;
-	}
-	sv = PyObject_GC_Resize(PyTupleObject, v, newsize);
+	for (i = newsize; i < oldsize; i++)
+		Py_CLEAR(v->ob_item[i]);
+
+	sv = PyObject_RESIZE(PyTupleObject, v, newsize);
 	if (sv == NULL) {
 		*pv = NULL;
-		PyObject_GC_Del(v);
+		/* XXX FIXME this leaks any remaining contents */
+		PyObject_DEL(v);
 		return -1;
 	}
-	_Py_NewReference((PyObject *) sv);
-	/* Zero out items added by growing */
-	if (newsize > oldsize)
-		memset(&sv->ob_item[oldsize], 0,
-		       sizeof(*sv->ob_item) * (newsize - oldsize));
+
 	*pv = (PyObject *) sv;
-	_PyObject_GC_TRACK(sv);
 	return 0;
 }
 
 void
+_PyTuple_Init(void)
+{
+}
+
+void
 PyTuple_Fini(void)
 {
 #if MAXSAVESIZE > 0
@@ -756,7 +776,7 @@
 		while (p) {
 			q = p;
 			p = (PyTupleObject *)(p->ob_item[0]);
-			PyObject_GC_Del(q);
+			PyObject_DEL(q);
 		}
 	}
 #endif
@@ -773,9 +793,8 @@
 static void
 tupleiter_dealloc(tupleiterobject *it)
 {
-	_PyObject_GC_UNTRACK(it);
 	Py_XDECREF(it->it_seq);
-	PyObject_GC_Del(it);
+	PyObject_DEL(it);
 }
 
 static int
@@ -867,12 +886,11 @@
 		PyErr_BadInternalCall();
 		return NULL;
 	}
-	it = PyObject_GC_New(tupleiterobject, &PyTupleIter_Type);
+	it = PyObject_NEW(tupleiterobject, &PyTupleIter_Type);
 	if (it == NULL)
 		return NULL;
 	it->it_index = 0;
 	Py_INCREF(seq);
 	it->it_seq = (PyTupleObject *)seq;
-	_PyObject_GC_TRACK(it);
 	return (PyObject *)it;
 }
Index: Objects/boolobject.c
===================================================================
--- Objects/boolobject.c	(revision 58355)
+++ Objects/boolobject.c	(working copy)
@@ -80,6 +80,12 @@
 	return PyBool_FromLong((a == Py_True) ^ (b == Py_True));
 }
 
+static int
+bool_isshareable (PyObject *self)
+{
+	return 1;
+}
+
 /* Doc string */
 
 PyDoc_STRVAR(bool_doc,
@@ -153,7 +159,7 @@
 	0,					/* tp_getattro */
 	0,					/* tp_setattro */
 	0,					/* tp_as_buffer */
-	Py_TPFLAGS_DEFAULT,			/* tp_flags */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_SHAREABLE,	/* tp_flags */
 	bool_doc,				/* tp_doc */
 	0,					/* tp_traverse */
 	0,					/* tp_clear */
@@ -170,8 +176,14 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	bool_new,				/* tp_new */
+	0,					/* tp_is_gc */
+	0,					/* tp_bases */
+	0,					/* tp_mro */
+	0,					/* tp_cache */
+	0,					/* tp_subclasses */
+	0,					/* tp_weaklist */
+	bool_isshareable,			/* tp_isshareable */
 };
 
 /* The objects representing bool values False and True */
Index: Objects/rangeobject.c
===================================================================
--- Objects/rangeobject.c	(revision 58355)
+++ Objects/rangeobject.c	(working copy)
@@ -54,6 +54,8 @@
     rangeobject *obj = NULL;
     PyObject *start = NULL, *stop = NULL, *step = NULL;
 
+    if (!(type->tp_flags & Py_TPFLAGS_READY))
+        Py_FatalError("range type (or subtype) isn't initialized");
     if (!_PyArg_NoKeywords("range()", kw))
         return NULL;
 
@@ -81,7 +83,7 @@
             goto Fail;
     }
 
-    obj = PyObject_New(rangeobject, &PyRange_Type);
+    obj = PyObject_NEW(rangeobject, &PyRange_Type);
     if (obj == NULL)
         goto Fail;
     obj->start = start;
@@ -107,6 +109,7 @@
     Py_DECREF(r->start);
     Py_DECREF(r->stop);
     Py_DECREF(r->step);
+    PyObject_DEL(r);
 }
 
 /* Return number of items in range (lo, hi, step), when arguments are
@@ -291,7 +294,7 @@
 	PyObject_GenericGetAttr,  /* tp_getattro */
 	0,			/* tp_setattro */
 	0,			/* tp_as_buffer */
-	Py_TPFLAGS_DEFAULT,	/* tp_flags */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_SHAREABLE,	/* tp_flags */
 	range_doc,		/* tp_doc */
 	0,			/* tp_traverse */
 	0,			/* tp_clear */
@@ -308,7 +311,6 @@
 	0,			/* tp_descr_set */
 	0,			/* tp_dictoffset */
 	0,			/* tp_init */
-	0,			/* tp_alloc */
 	range_new,		/* tp_new */
 };
 
@@ -404,7 +406,6 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	rangeiter_new,				/* tp_new */
 };
 
@@ -440,7 +441,7 @@
 static PyObject *
 int_range_iter(long start, long stop, long step)
 {
-    rangeiterobject *it = PyObject_New(rangeiterobject, &Pyrangeiter_Type);
+    rangeiterobject *it = PyObject_NEW(rangeiterobject, &Pyrangeiter_Type);
     if (it == NULL)
         return NULL;
     it->start = start;
@@ -481,6 +482,7 @@
     Py_XDECREF(r->start);
     Py_XDECREF(r->step);
     Py_XDECREF(r->len);
+    PyObject_DEL(r);
 }
 
 static PyObject *
@@ -565,7 +567,7 @@
                       PyLong_AsLong(r->stop),
                       PyLong_AsLong(r->step));
 
-    it = PyObject_New(longrangeiterobject, &Pylongrangeiter_Type);
+    it = PyObject_NEW(longrangeiterobject, &Pylongrangeiter_Type);
     if (it == NULL)
         return NULL;
 
@@ -625,7 +627,7 @@
         return int_range_iter(new_start, new_stop, -step);
     }
 
-    it = PyObject_New(longrangeiterobject, &Pylongrangeiter_Type);
+    it = PyObject_NEW(longrangeiterobject, &Pylongrangeiter_Type);
     if (it == NULL)
         return NULL;
 
@@ -655,7 +657,7 @@
     it->step = PyNumber_Negative(range->step);
     if (!it->step) {
         Py_DECREF(it->start);
-        PyObject_Del(it);
+        PyObject_DEL(it);
         return NULL;
     }
 
@@ -672,6 +674,198 @@
 
 create_failure:
     Py_XDECREF(len);
-    PyObject_Del(it);
+    PyObject_DEL(it);
     return NULL;
 }
+
+
+/* DUMMY */
+PyTypeObject PyFakeRange_Type;
+
+typedef struct {
+	PyObject_HEAD
+	PyObject *start;
+	PyObject *stop;
+	PyObject *step;
+	long	x_index;
+	long	x_start;
+	long	x_step;
+	long	x_len;
+} fakerangeobject;
+
+static PyObject *
+fakerange_new(PyTypeObject *type, PyObject *args, PyObject *kw)
+{
+    fakerangeobject *obj = NULL;
+    PyObject *start = NULL, *stop = NULL, *step = NULL;
+
+    if (!_PyArg_NoKeywords("range()", kw))
+        return NULL;
+
+    if (PyTuple_Size(args) <= 1) {
+        if (!PyArg_UnpackTuple(args, "range", 1, 1, &stop))
+            goto Fail;
+        stop = PyNumber_Index(stop);
+        if (!stop)
+            goto Fail;
+        start = PyInt_FromLong(0);
+        step = PyInt_FromLong(1);
+        if (!start || !step)
+            goto Fail;
+    }
+    else {
+        if (!PyArg_UnpackTuple(args, "range", 2, 3,
+                               &start, &stop, &step))
+            goto Fail;
+
+        /* Convert borrowed refs to owned refs */
+        start = PyNumber_Index(start);
+        stop = PyNumber_Index(stop);
+        step = validate_step(step);
+        if (!start || !stop || !step)
+            goto Fail;
+    }
+
+    obj = PyObject_NEW(fakerangeobject, &PyFakeRange_Type);
+    if (obj == NULL)
+        goto Fail;
+    obj->start = start;
+    obj->stop = stop;
+    obj->step = step;
+    Py_INCREF(obj->start);
+    Py_INCREF(obj->stop);
+    Py_INCREF(obj->step);
+    obj->x_start = PyLong_AsLong(start);
+    //obj->x_stop = PyLong_AsLong(stop);
+    obj->x_step = PyLong_AsLong(step);
+    if (obj->x_step > 0)
+        obj->x_len = get_len_of_range(obj->x_start, PyLong_AsLong(stop), obj->x_step);
+    else
+        obj->x_len = get_len_of_range(PyLong_AsLong(stop), obj->x_start, -obj->x_step);
+    obj->x_index = 0;
+    return (PyObject *) obj;
+
+Fail:
+    //Py_XDECREF(start);
+    //Py_XDECREF(stop);
+    //Py_XDECREF(step);
+    return NULL;
+}
+
+static void
+fakerange_dealloc(rangeobject *r)
+{
+    printf("Fakerange dealloc\n");
+    Py_DECREF(r->start);
+    Py_DECREF(r->stop);
+    Py_DECREF(r->step);
+    r->start = NULL;
+    r->stop = NULL;
+    r->step = NULL;
+    PyObject_DEL(r);
+}
+
+static PyObject *
+fakerange_iter(PyObject *seq)
+{
+    Py_INCREF(seq);
+    return seq;
+}
+
+#include <pthread.h>
+AO_t rocky;
+AO_t bullwinkle[16];
+AO_t bob;
+
+static PyObject *
+fakerange_next(fakerangeobject *r)
+{
+#if 1
+    int i;
+    bullwinkle[0] = 0;
+    for (i = 0; i < 1000; i++) {
+        //AO_fetch_and_add1(&rocky);
+        //AO_fetch_and_sub1(&rocky);
+        //(void)AO_load_full(&bob);
+        //(void)AO_load_full(&bob);
+        //printf("%p %p\n", &rocky, &bob);
+        //static pthread_mutex_t rocky = PTHREAD_MUTEX_INITIALIZER;
+        //pthread_mutex_lock(&rocky);
+        //pthread_mutex_unlock(&rocky);
+        //static AO_t rocky;
+        //while (1) {
+        //    AO_t prev = AO_load_full(&rocky);
+        //    if (AO_compare_and_swap(&rocky, prev, prev + 1))
+        //        break;
+        //}
+        //while (1) {
+        //    AO_t prev = AO_load_full(&rocky);
+        //    if (AO_compare_and_swap(&rocky, prev, prev - 1))
+        //        break;
+        //}
+    }
+    if (r->x_index < r->x_len) {
+        r->x_index++;
+        //Py_INCREF(Py_None);
+        //return Py_None;
+        //free(malloc(sizeof(PyVarObject)+4));
+        Py_INCREF(r->start);
+        return r->start;
+    }
+    return NULL;
+#elif 0
+    if (r->x_index < r->x_len) {
+        PyObject *foo;
+        r->x_index++;
+        foo = PyInt_FromLong(100000);
+        //printf("Foo: %p\n", foo);
+        return foo;
+    }
+    return NULL;
+#else
+    if (r->x_index < r->x_len)
+        return PyInt_FromLong(r->x_start + (r->x_index++) * r->x_step);
+    return NULL;
+#endif
+}
+
+PyTypeObject PyFakeRange_Type = {
+	PyVarObject_HEAD_INIT(&PyType_Type, 0)
+	"fakerange",		/* Name of this type */
+	sizeof(fakerangeobject),	/* Basic object size */
+	0,			/* Item size for varobject */
+	(destructor)fakerange_dealloc, /* tp_dealloc */
+	0,			/* tp_print */
+	0,			/* tp_getattr */
+	0,			/* tp_setattr */
+	0,			/* tp_compare */
+	(reprfunc)range_repr,	/* tp_repr */
+	0,			/* tp_as_number */
+	&range_as_sequence,	/* tp_as_sequence */
+	0,			/* tp_as_mapping */
+	0,			/* tp_hash */
+	0,			/* tp_call */
+	0,			/* tp_str */
+	PyObject_GenericGetAttr,  /* tp_getattro */
+	0,			/* tp_setattro */
+	0,			/* tp_as_buffer */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_SHAREABLE,	/* tp_flags */
+	range_doc,		/* tp_doc */
+	0,			/* tp_traverse */
+	0,			/* tp_clear */
+	0,			/* tp_richcompare */
+	0,			/* tp_weaklistoffset */
+	fakerange_iter,		/* tp_iter */
+	(iternextfunc)fakerange_next,		/* tp_iternext */
+	range_methods,		/* tp_methods */
+	0,			/* tp_members */
+	0,			/* tp_getset */
+	0,			/* tp_base */
+	0,			/* tp_dict */
+	0,			/* tp_descr_get */
+	0,			/* tp_descr_set */
+	0,			/* tp_dictoffset */
+	0,			/* tp_init */
+	fakerange_new,		/* tp_new */
+};
+
Index: Objects/interruptobject.c
===================================================================
--- Objects/interruptobject.c	(revision 0)
+++ Objects/interruptobject.c	(revision 0)
@@ -0,0 +1,342 @@
+
+#include "Python.h"
+#include "interruptobject.h"
+#include "pystate.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* PyInterrupt */
+
+PyInterruptObject *
+PyInterrupt_New(void (*callback_c)(struct _PyInterruptQueue *, void *),
+		void *arg, PyObject *callback_python)
+{
+	PyInterruptObject *point;
+
+	if (!callback_c && !callback_python)
+		Py_FatalError("PyInterrupt_New called with no callback");
+	if (callback_c && callback_python)
+		Py_FatalError("PyInterrupt_New called with both callbacks");
+
+	point = PyObject_NEW(PyInterruptObject, &PyInterrupt_Type);
+	if (point == NULL)
+		return NULL;
+	point->lock = PyThread_lock_allocate();
+	if (!point->lock) {
+		PyObject_DEL(point);
+		PyErr_NoMemory();
+		return NULL;
+	}
+
+	Py_XINCREF(callback_python);
+	point->interrupted = 0;
+	point->parent = NULL;
+	point->child = NULL;
+	point->notify_parent_int_c = callback_c;
+	point->arg = arg;
+	point->notify_parent_int_python = callback_python;
+	point->next = NULL;
+
+	return point;
+}
+
+void
+PyInterrupt_Push(PyInterruptObject *point)
+{
+	int run_callbacks = 0;
+	PyThreadState *tstate = PyThreadState_Get();
+
+	assert(point->parent == NULL);
+	assert(point->child == NULL);
+
+	point->parent = tstate->interrupt_point;
+	if (point->parent) {
+		PyThread_lock_acquire(point->parent->lock);
+		assert(point->parent->child == NULL);
+		point->parent->child = point;
+		if (point->parent->interrupted) {
+			run_callbacks = 1;
+		}
+		PyThread_lock_release(point->parent->lock);
+	}
+	tstate->interrupt_point = point;
+
+	if (run_callbacks) {
+		PyInterruptQueue queue;
+
+		PyInterruptQueue_Init(&queue);
+		PyInterruptQueue_AddFromParent(&queue, point);
+		PyInterruptQueue_Finish(&queue);
+	}
+}
+
+void
+PyInterrupt_Pop(PyInterruptObject *point)
+{
+	PyThreadState *tstate = PyThreadState_Get();
+
+	assert(point->child == NULL);
+	if (point != tstate->interrupt_point)
+		Py_FatalError("Popping wrong interrupt point");
+
+	tstate->interrupt_point = point->parent;
+	if (point->parent != NULL) {
+		PyThread_lock_acquire(point->parent->lock);
+		assert(point->parent->child == point);
+		point->parent->child = NULL;
+		PyThread_lock_release(point->parent->lock);
+		point->parent = NULL;
+	}
+
+	PyThread_lock_acquire(point->lock);
+	/* Other threads may still reference us, but they'll now have no effect */
+	PyThread_lock_release(point->lock);
+}
+
+static void
+interrupt_dealloc(PyInterruptObject *point)
+{
+	assert(point->notify_parent_int_c || point->notify_parent_int_python);
+	assert(!(point->notify_parent_int_c && point->notify_parent_int_python));
+	assert(point->parent == NULL);
+	assert(point->child == NULL);
+	assert(point->next == NULL);
+
+	Py_XDECREF(point->notify_parent_int_python);
+	PyThread_lock_free(point->lock);
+}
+
+static int
+interrupt_traverse(PyInterruptObject *point, visitproc visit, void *arg)
+{
+	Py_VISIT(point->notify_parent_int_python);
+	return 0;
+}
+
+static PyObject *
+interrupt_interrupt(PyInterruptObject *point)
+{
+	PyInterruptQueue queue;
+
+	PyInterruptQueue_Init(&queue);
+	PyInterruptQueue_Add(&queue, point);
+	PyInterruptQueue_Finish(&queue);
+
+	Py_INCREF(Py_None);
+	return Py_None;
+}
+
+static int
+interrupt_isshareable(PyObject *obj)
+{
+	return 1;
+}
+
+PyDoc_STRVAR(interrupt_doc,
+"FIXME");
+
+static PyMethodDef interrupt_methods[] = {
+	{"interrupt", (PyCFunction)interrupt_interrupt, METH_NOARGS|METH_SHARED, interrupt_doc},
+ 	{NULL,		NULL}		/* sentinel */
+};
+
+PyTypeObject PyInterrupt_Type = {
+	PyVarObject_HEAD_INIT(&PyType_Type, 0)
+	"Interrupt",
+	sizeof(PyInterruptObject),
+	0,
+	(destructor)interrupt_dealloc,		/* tp_dealloc */
+	0,					/* tp_print */
+	0,					/* tp_getattr */
+	0,					/* tp_setattr */
+	0,					/* tp_compare */
+	0,					/* tp_repr */
+	0,					/* tp_as_number */
+	0,					/* tp_as_sequence */
+	0,					/* tp_as_mapping */
+	0,					/* tp_hash */
+	0,					/* tp_call */
+	0,					/* tp_str */
+	PyObject_GenericGetAttr,		/* tp_getattro */
+	0,					/* tp_setattro */
+	0,					/* tp_as_buffer */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,/* tp_flags */
+ 	0,					/* tp_doc */
+ 	(traverseproc)interrupt_traverse,	/* tp_traverse */
+	0,					/* tp_clear */
+	0,					/* tp_richcompare */
+	0,					/* tp_weaklistoffset */
+	0,					/* tp_iter */
+	0,					/* tp_iternext */
+	interrupt_methods,			/* tp_methods */
+	0,					/* tp_members */
+	0,					/* tp_getset */
+	0,					/* tp_base */
+	0,					/* tp_dict */
+	0,					/* tp_descr_get */
+	0,					/* tp_descr_set */
+	0,					/* tp_dictoffset */
+	0,					/* tp_init */
+	0,					/* tp_new */
+	0,					/* tp_is_gc */
+	0,					/* tp_bases */
+	0,					/* tp_mro */
+	0,					/* tp_cache */
+	0,					/* tp_subclasses */
+	0,					/* tp_weaklist */
+	interrupt_isshareable,			/* tp_isshareable */
+};
+
+
+void
+PyInterruptQueue_Init(PyInterruptQueue *queue)
+{
+	queue->head = NULL;
+	queue->tail = NULL;
+}
+
+void
+PyInterruptQueue_Add(PyInterruptQueue *queue, PyInterruptObject *point)
+{
+	PyThread_lock_acquire(point->lock);
+	if (!point->interrupted) {
+		point->interrupted = 1;
+
+		if (point->child)
+			PyInterruptQueue_AddFromParent(queue, point->child);
+	}
+	PyThread_lock_release(point->lock);
+}
+
+void
+PyInterruptQueue_AddFromParent(PyInterruptQueue *queue, PyInterruptObject *point)
+{
+	PyThread_lock_acquire(point->lock);
+	assert(point->next == NULL);
+	if (point->parent != NULL) {
+		if (point->notify_parent_int_c) {
+			point->notify_parent_int_c(queue, point->arg);
+		} else {
+			assert(point->notify_parent_int_python);
+			if (queue->tail) {
+				queue->tail->next = point;
+				queue->tail = point;
+			} else {
+				queue->head = point;
+				queue->tail = point;
+			}
+			Py_INCREF(point);
+		}
+	}
+	PyThread_lock_release(point->lock);
+}
+
+void
+PyInterruptQueue_Finish(PyInterruptQueue *queue)
+{
+	while (queue->head) {
+		PyObject *result;
+		PyInterruptObject *point = queue->head;
+		queue->head = point->next;
+		point->next = NULL;
+
+		/* XXX FIXME returning True should implicitly call
+		 * .interrupt().  Maybe? */
+		result = PyObject_CallObject(point->notify_parent_int_python, NULL);
+		if (result == NULL)
+			PyErr_WriteUnraisable(point->notify_parent_int_python);
+		else
+			Py_DECREF(result);
+
+		Py_DECREF(point);
+	}
+}
+
+
+/* Returns 0 if we're not in an interrupted state,
+ * 1 and raises an exception if we are */
+int
+PyCancel_Check(void)
+{
+    PyThreadState *tstate = PyThreadState_Get();
+
+    PyThread_lock_acquire(tstate->interrupt_point->lock);
+    if (tstate->interrupt_point->interrupted) {
+        PyThread_lock_release(tstate->interrupt_point->lock);
+        PyErr_SetNone(PyExc_Interrupted);
+        return 1;
+    }
+    PyThread_lock_release(tstate->interrupt_point->lock);
+    return 0;
+}
+
+
+#warning blah blah signal interrupt API should have retries
+/* XXX FIXME the signal handler thread should be used to send the signal multiple times, if the first attempt doesn't work.  Actually, the signal handler itself should mark it as received, and the retry should check if the call actually stopped.
+ * Or should whoever's running the interrupt callback do the retry?  Just have them stick around until the interruption process finishes.
+ */
+void
+PyCancel_SignalEnter(void)
+{
+    // wipe state
+    // allocate lock
+    // allocate semaphore
+    // setup interrupt callback
+    // PyState_Suspend();
+    // grab lock
+    // mark as active (interrupt callback may now actually send signal)
+    // release lock
+    Py_FatalError("PyCancel_SignalEnter not implemented");
+}
+
+void
+PyCancel_SignalExit(void)
+{
+    // grab lock
+    // mark as inactive
+    // post semaphore
+    // XXX FIXME blah, I need more work to coordinate teardown with the interrupt callback
+    // release lock
+    // PyState_Resume();
+    // Remove interrupt callback
+    // ??? release lock
+    // ??? release semaphore
+    // I need to track that the interrupt callback has started, and if so I have to wake them up and then either wait for them to signal me that they've exited, or let them do the cleanup.  The number of context switches seems the same either way, and I think it'd be simpler if it was always this function doing the cleanup.
+    // XXX FIXME this should also save errno
+    Py_FatalError("PyCancel_SignalExit not implemented");
+}
+
+int
+PyCancel_Poll(int fd)
+{
+    Py_FatalError("PyCancel_Poll not implemented");
+}
+
+#if 0
+int
+PyCancel_WaitForMultipleObjects(...)
+{
+    Py_FatalError("PyCancel_WaitForMultipleObjects not implemented");
+}
+#endif
+
+int
+PyCancel_Sleep(double secs)
+{
+    Py_FatalError("PyCancel_Sleep not implemented");
+}
+
+/* XXX FIXME consider replacing this with Sleep(Inf) */
+int
+PyCancel_SleepForever(void)
+{
+    Py_FatalError("PyCancel_SleepForever not implemented");
+}
+
+
+#ifdef __cplusplus
+}
+#endif
Index: Objects/descrobject.c
===================================================================
--- Objects/descrobject.c	(revision 58355)
+++ Objects/descrobject.c	(working copy)
@@ -2,14 +2,14 @@
 
 #include "Python.h"
 #include "structmember.h" /* Why is this not included in Python.h? */
+#include "monitorobject.h"
 
 static void
 descr_dealloc(PyDescrObject *descr)
 {
-	_PyObject_GC_UNTRACK(descr);
 	Py_XDECREF(descr->d_type);
 	Py_XDECREF(descr->d_name);
-	PyObject_GC_Del(descr);
+	PyObject_DEL(descr);
 }
 
 static PyObject *
@@ -58,6 +58,13 @@
 			  "<slot wrapper '%V' of '%s' objects>");
 }
 
+static PyObject *
+finalizeattr_repr(PyFinalizeAttrDescrObject *descr)
+{
+    return descr_repr((PyDescrObject *)descr,
+        "<finalizeattr '%V' of '%s' objects>");
+}
+
 static int
 descr_check(PyDescrObject *descr, PyObject *obj, PyObject **pres)
 {
@@ -134,6 +141,12 @@
 
 	if (descr_check((PyDescrObject *)descr, obj, &res))
 		return res;
+	if (PyMonitor_Check(obj) &&
+			!PyMonitorSpace_IsCurrent(PyMonitor_GetMonitorSpace(obj))) {
+		PyErr_SetString(PyExc_AttributeError,
+			descr->d_member->name);
+		return NULL;
+	}
 	return PyMember_GetOne((char *)obj, descr->d_member);
 }
 
@@ -163,9 +176,49 @@
 	return PyWrapper_New((PyObject *)descr, obj);
 }
 
+static PyObject *
+finalizeattr_get(PyFinalizeAttrDescrObject *descr, PyObject *obj, PyObject *type)
+{
+    PyObject *res, *core;
+
+    if (descr_check((PyDescrObject *)descr, obj, &res))
+        return res;
+
+    core = PyObject_GetAttrString(obj, "__finalizecore__");
+    if (core == NULL && PyErr_ExceptionMatches(PyExc_AttributeError)) {
+        PyErr_Clear();
+        Py_INCREF(Py_None);
+        core = Py_None;
+    }
+
+    if (core == NULL)
+        return NULL;
+
+    if (core == Py_None) {
+        PyObject *dict;
+
+        Py_DECREF(core);
+
+        dict = PyObject_GetAttrString(obj, "__dict__");
+        if (dict == NULL)
+            return NULL;
+
+        if (PyDict_GetItemEx(dict, descr->d_name, &res) > 0)
+            PyErr_Format(PyExc_AttributeError,
+                "'%.50s' object has no attribute '%.400s'",
+                ((PyTypeObject *)type)->tp_name,
+                PyUnicode_AsString(descr->d_name));
+        Py_DECREF(dict);
+        return res;
+    } else {
+        res = PyObject_GetAttr(core, descr->d_name);
+        Py_DECREF(core);
+        return res;
+    }
+}
+
 static int
-descr_setcheck(PyDescrObject *descr, PyObject *obj, PyObject *value,
-	       int *pres)
+descr_setcheck(PyDescrObject *descr, PyObject *obj)
 {
 	assert(obj != NULL);
 	if (!PyObject_IsInstance(obj, (PyObject *)(descr->d_type))) {
@@ -175,8 +228,7 @@
 			     descr_name(descr), "?",
 			     descr->d_type->tp_name,
 			     obj->ob_type->tp_name);
-		*pres = -1;
-		return 1;
+		return -1;
 	}
 	return 0;
 }
@@ -184,20 +236,25 @@
 static int
 member_set(PyMemberDescrObject *descr, PyObject *obj, PyObject *value)
 {
-	int res;
-
-	if (descr_setcheck((PyDescrObject *)descr, obj, value, &res))
-		return res;
+	if (descr_setcheck((PyDescrObject *)descr, obj))
+		return -1;
+	if (PyMonitor_Check(obj) &&
+			!PyMonitorSpace_IsCurrent(PyMonitor_GetMonitorSpace(obj))) {
+		PyErr_Format(PyExc_AttributeError,
+			"descriptor '%.200s' for '%.100s' objects "
+			"can't be applied from outside of Monitor",
+			descr->d_member->name,
+			descr->d_type->tp_name);
+		return -1;
+	}
 	return PyMember_SetOne((char *)obj, descr->d_member, value);
 }
 
 static int
 getset_set(PyGetSetDescrObject *descr, PyObject *obj, PyObject *value)
 {
-	int res;
-
-	if (descr_setcheck((PyDescrObject *)descr, obj, value, &res))
-		return res;
+	if (descr_setcheck((PyDescrObject *)descr, obj))
+		return -1;
 	if (descr->d_getset->set != NULL)
 		return descr->d_getset->set(obj, value,
 					    descr->d_getset->closure);
@@ -208,6 +265,50 @@
 	return -1;
 }
 
+static int
+finalizeattr_set(PyFinalizeAttrDescrObject *descr, PyObject *obj, PyObject *value)
+{
+    PyObject *core;
+
+    if (descr_setcheck((PyDescrObject *)descr, obj))
+        return -1;
+
+    core = PyObject_GetAttrString(obj, "__finalizecore__");
+    if (core == NULL && PyErr_ExceptionMatches(PyExc_AttributeError)) {
+        PyErr_Clear();
+        Py_INCREF(Py_None);
+        core = Py_None;
+    }
+
+    if (core == NULL)
+        return -1;
+
+    if (core == Py_None) {
+        int res;
+        PyObject *dict;
+
+        Py_DECREF(core);
+
+        dict = PyObject_GetAttrString(obj, "__dict__");
+        if (dict == NULL)
+            return -1;
+
+        if (value == NULL)
+            res = PyDict_DelItem(dict, descr->d_name);
+        else
+            res = PyDict_SetItem(dict, descr->d_name, value);
+        Py_DECREF(dict);
+        return res;
+    } else {
+        if (PyObject_SetAttr(core, descr->d_name, value) == -1) {
+            Py_DECREF(core);
+            return -1;
+        }
+        Py_DECREF(core);
+        return 0;
+    }
+}
+
 static PyObject *
 methoddescr_call(PyMethodDescrObject *descr, PyObject *args, PyObject *kwds)
 {
@@ -375,6 +476,17 @@
 	{0}
 };
 
+static PyObject *
+finalizeattr_get_doc(PyFinalizeAttrDescrObject *descr, void *closure)
+{
+    return PyUnicode_FromString("Finalize Attribute proxy");
+}
+
+static PyGetSetDef finalizeattr_getset[] = {
+    {"__doc__", (getter)finalizeattr_get_doc},
+    {0}
+};
+
 static int
 descr_traverse(PyObject *self, visitproc visit, void *arg)
 {
@@ -383,6 +495,13 @@
 	return 0;
 }
 
+static int
+descr_isshareable(PyObject *self)
+{
+	/* XXX FIXME Pure hack */
+	return 1;
+}
+
 static PyTypeObject PyMethodDescr_Type = {
 	PyVarObject_HEAD_INIT(&PyType_Type, 0)
 	"method_descriptor",
@@ -403,7 +522,7 @@
 	PyObject_GenericGetAttr,		/* tp_getattro */
 	0,					/* tp_setattro */
 	0,					/* tp_as_buffer */
-	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC, /* tp_flags */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_SKIPWIPE, /* tp_flags */
 	0,					/* tp_doc */
 	descr_traverse,				/* tp_traverse */
 	0,					/* tp_clear */
@@ -441,7 +560,7 @@
 	PyObject_GenericGetAttr,		/* tp_getattro */
 	0,					/* tp_setattro */
 	0,					/* tp_as_buffer */
-	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC, /* tp_flags */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_SKIPWIPE, /* tp_flags */
 	0,					/* tp_doc */
 	descr_traverse,				/* tp_traverse */
 	0,					/* tp_clear */
@@ -478,7 +597,7 @@
 	PyObject_GenericGetAttr,		/* tp_getattro */
 	0,					/* tp_setattro */
 	0,					/* tp_as_buffer */
-	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC, /* tp_flags */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_SKIPWIPE, /* tp_flags */
 	0,					/* tp_doc */
 	descr_traverse,				/* tp_traverse */
 	0,					/* tp_clear */
@@ -493,6 +612,16 @@
 	0,					/* tp_dict */
 	(descrgetfunc)member_get,		/* tp_descr_get */
 	(descrsetfunc)member_set,		/* tp_descr_set */
+	0,					/* tp_dictoffset */
+	0,					/* tp_init */
+	0,					/* tp_new */
+	0,					/* tp_is_gc */
+	0,					/* tp_bases */
+	0,					/* tp_mro */
+	0,					/* tp_cache */
+	0,					/* tp_subclasses */
+	0,					/* tp_weaklist */
+	descr_isshareable,			/* tp_isshareable */
 };
 
 static PyTypeObject PyGetSetDescr_Type = {
@@ -515,7 +644,7 @@
 	PyObject_GenericGetAttr,		/* tp_getattro */
 	0,					/* tp_setattro */
 	0,					/* tp_as_buffer */
-	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC, /* tp_flags */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_SKIPWIPE, /* tp_flags */
 	0,					/* tp_doc */
 	descr_traverse,				/* tp_traverse */
 	0,					/* tp_clear */
@@ -530,6 +659,16 @@
 	0,					/* tp_dict */
 	(descrgetfunc)getset_get,		/* tp_descr_get */
 	(descrsetfunc)getset_set,		/* tp_descr_set */
+	0,					/* tp_dictoffset */
+	0,					/* tp_init */
+	0,					/* tp_new */
+	0,					/* tp_is_gc */
+	0,					/* tp_bases */
+	0,					/* tp_mro */
+	0,					/* tp_cache */
+	0,					/* tp_subclasses */
+	0,					/* tp_weaklist */
+	descr_isshareable,			/* tp_isshareable */
 };
 
 PyTypeObject PyWrapperDescr_Type = {
@@ -552,7 +691,7 @@
 	PyObject_GenericGetAttr,		/* tp_getattro */
 	0,					/* tp_setattro */
 	0,					/* tp_as_buffer */
-	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC, /* tp_flags */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_SKIPWIPE, /* tp_flags */
 	0,					/* tp_doc */
 	descr_traverse,				/* tp_traverse */
 	0,					/* tp_clear */
@@ -567,14 +706,71 @@
 	0,					/* tp_dict */
 	(descrgetfunc)wrapperdescr_get,		/* tp_descr_get */
 	0,					/* tp_descr_set */
+	0,					/* tp_dictoffset */
+	0,					/* tp_init */
+	0,					/* tp_new */
+	0,					/* tp_is_gc */
+	0,					/* tp_bases */
+	0,					/* tp_mro */
+	0,					/* tp_cache */
+	0,					/* tp_subclasses */
+	0,					/* tp_weaklist */
+	descr_isshareable,			/* tp_isshareable */
 };
 
+PyTypeObject PyFinalizeAttrDescr_Type = {
+	PyVarObject_HEAD_INIT(&PyType_Type, 0)
+	"finalizeattr_descriptor",
+	sizeof(PyFinalizeAttrDescrObject),
+	0,
+	(destructor)descr_dealloc,		/* tp_dealloc */
+	0,					/* tp_print */
+	0,					/* tp_getattr */
+	0,					/* tp_setattr */
+	0,					/* tp_compare */
+	(reprfunc)finalizeattr_repr,		/* tp_repr */
+	0,					/* tp_as_number */
+	0,					/* tp_as_sequence */
+	0,					/* tp_as_mapping */
+	0,					/* tp_hash */
+	0,					/* tp_call */
+	0,					/* tp_str */
+	PyObject_GenericGetAttr,		/* tp_getattro */
+	0,					/* tp_setattro */
+	0,					/* tp_as_buffer */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_SKIPWIPE, /* tp_flags */
+	0,					/* tp_doc */
+	descr_traverse,				/* tp_traverse */
+	0,					/* tp_clear */
+	0,					/* tp_richcompare */
+	0,					/* tp_weaklistoffset */
+	0,					/* tp_iter */
+	0,					/* tp_iternext */
+	0,					/* tp_methods */
+	descr_members,				/* tp_members */
+	finalizeattr_getset,			/* tp_getset */
+	0,					/* tp_base */
+	0,					/* tp_dict */
+	(descrgetfunc)finalizeattr_get,		/* tp_descr_get */
+	(descrsetfunc)finalizeattr_set,		/* tp_descr_set */
+	0,					/* tp_dictoffset */
+	0,					/* tp_init */
+	0,					/* tp_new */
+	0,					/* tp_is_gc */
+	0,					/* tp_bases */
+	0,					/* tp_mro */
+	0,					/* tp_cache */
+	0,					/* tp_subclasses */
+	0,					/* tp_weaklist */
+	descr_isshareable,			/* tp_isshareable */
+};
+
 static PyDescrObject *
 descr_new(PyTypeObject *descrtype, PyTypeObject *type, const char *name)
 {
 	PyDescrObject *descr;
 
-	descr = (PyDescrObject *)PyType_GenericAlloc(descrtype, 0);
+	descr = PyObject_NEW(PyDescrObject, descrtype);
 	if (descr != NULL) {
 		Py_XINCREF(type);
 		descr->d_type = type;
@@ -594,8 +790,10 @@
 
 	descr = (PyMethodDescrObject *)descr_new(&PyMethodDescr_Type,
 						 type, method->ml_name);
-	if (descr != NULL)
-		descr->d_method = method;
+	if (descr == NULL)
+		return NULL;
+	descr->d_method = method;
+	PyObject_COMPLETE(descr);
 	return (PyObject *)descr;
 }
 
@@ -606,8 +804,10 @@
 
 	descr = (PyMethodDescrObject *)descr_new(&PyClassMethodDescr_Type,
 						 type, method->ml_name);
-	if (descr != NULL)
-		descr->d_method = method;
+	if (descr == NULL)
+		return NULL;
+	descr->d_method = method;
+	PyObject_COMPLETE(descr);
 	return (PyObject *)descr;
 }
 
@@ -618,8 +818,10 @@
 
 	descr = (PyMemberDescrObject *)descr_new(&PyMemberDescr_Type,
 						 type, member->name);
-	if (descr != NULL)
-		descr->d_member = member;
+	if (descr == NULL)
+		return NULL;
+	descr->d_member = member;
+	PyObject_COMPLETE(descr);
 	return (PyObject *)descr;
 }
 
@@ -630,8 +832,10 @@
 
 	descr = (PyGetSetDescrObject *)descr_new(&PyGetSetDescr_Type,
 						 type, getset->name);
-	if (descr != NULL)
-		descr->d_getset = getset;
+	if (descr == NULL)
+		return NULL;
+	descr->d_getset = getset;
+	PyObject_COMPLETE(descr);
 	return (PyObject *)descr;
 }
 
@@ -642,14 +846,28 @@
 
 	descr = (PyWrapperDescrObject *)descr_new(&PyWrapperDescr_Type,
 						 type, base->name);
-	if (descr != NULL) {
-		descr->d_base = base;
-		descr->d_wrapped = wrapped;
-	}
+	if (descr == NULL)
+		return NULL;
+	descr->d_base = base;
+	descr->d_wrapped = wrapped;
+	PyObject_COMPLETE(descr);
 	return (PyObject *)descr;
 }
 
+PyObject *
+PyDescr_NewFinalizeAttr(PyTypeObject *type, PyObject *name)
+{
+    PyFinalizeAttrDescrObject *descr;
 
+    descr = (PyFinalizeAttrDescrObject *)descr_new(&PyFinalizeAttrDescr_Type,
+        type, PyUnicode_AsString(name));
+    if (descr == NULL)
+        return NULL;
+    PyObject_COMPLETE(descr);
+    return (PyObject *)descr;
+}
+
+
 /* --- Readonly proxy for dictionaries (actually any mapping) --- */
 
 /* This has no reason to be in this file except that adding new files is a
@@ -773,9 +991,8 @@
 static void
 proxy_dealloc(proxyobject *pp)
 {
-	_PyObject_GC_UNTRACK(pp);
 	Py_DECREF(pp->dict);
-	PyObject_GC_Del(pp);
+	PyObject_DEL(pp);
 }
 
 static PyObject *
@@ -831,7 +1048,7 @@
 	PyObject_GenericGetAttr,		/* tp_getattro */
 	0,					/* tp_setattro */
 	0,					/* tp_as_buffer */
-	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC, /* tp_flags */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_SKIPWIPE, /* tp_flags */
  	0,					/* tp_doc */
 	proxy_traverse,				/* tp_traverse */
  	0,					/* tp_clear */
@@ -853,11 +1070,11 @@
 {
 	proxyobject *pp;
 
-	pp = PyObject_GC_New(proxyobject, &proxytype);
+	pp = PyObject_NEW(proxyobject, &proxytype);
 	if (pp != NULL) {
 		Py_INCREF(dict);
 		pp->dict = dict;
-		_PyObject_GC_TRACK(pp);
+		PyObject_COMPLETE(pp);
 	}
 	return (PyObject *)pp;
 }
@@ -877,12 +1094,9 @@
 static void
 wrapper_dealloc(wrapperobject *wp)
 {
-	PyObject_GC_UnTrack(wp);
-	Py_TRASHCAN_SAFE_BEGIN(wp)
 	Py_XDECREF(wp->descr);
 	Py_XDECREF(wp->self);
-	PyObject_GC_Del(wp);
-	Py_TRASHCAN_SAFE_END(wp)
+	PyObject_DEL(wp);
 }
 
 static int
@@ -991,6 +1205,14 @@
 	return 0;
 }
 
+static int
+wrapper_isshareable(wrapperobject *wp)
+{
+	/* XXX FIXME I doubt this is sufficiently strict */
+	return PyObject_IsShareable((PyObject *)wp->descr->d_type) &&
+		PyObject_IsShareable(wp->self);
+}
+
 static PyTypeObject wrappertype = {
 	PyVarObject_HEAD_INIT(&PyType_Type, 0)
 	"method-wrapper",			/* tp_name */
@@ -1012,7 +1234,7 @@
 	PyObject_GenericGetAttr,		/* tp_getattro */
 	0,					/* tp_setattro */
 	0,					/* tp_as_buffer */
-	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC, /* tp_flags */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_SKIPWIPE, /* tp_flags */
  	0,					/* tp_doc */
 	wrapper_traverse,			/* tp_traverse */
  	0,					/* tp_clear */
@@ -1027,6 +1249,16 @@
 	0,					/* tp_dict */
 	0,					/* tp_descr_get */
 	0,					/* tp_descr_set */
+	0,					/* tp_dictoffset */
+	0,					/* tp_init */
+	0,					/* tp_new */
+	0,					/* tp_is_gc */
+	0,					/* tp_bases */
+	0,					/* tp_mro */
+	0,					/* tp_cache */
+	0,					/* tp_subclasses */
+	0,					/* tp_weaklist */
+	(isshareablefunc)wrapper_isshareable,	/* tp_isshareable */
 };
 
 PyObject *
@@ -1039,13 +1271,13 @@
 	descr = (PyWrapperDescrObject *)d;
 	assert(PyObject_IsInstance(self, (PyObject *)(descr->d_type)));
 
-	wp = PyObject_GC_New(wrapperobject, &wrappertype);
+	wp = PyObject_NEW(wrapperobject, &wrappertype);
 	if (wp != NULL) {
 		Py_INCREF(descr);
 		wp->descr = descr;
 		Py_INCREF(self);
 		wp->self = self;
-		_PyObject_GC_TRACK(wp);
+		PyObject_COMPLETE(wp);
 	}
 	return (PyObject *)wp;
 }
@@ -1105,12 +1337,11 @@
 {
 	propertyobject *gs = (propertyobject *)self;
 
-	_PyObject_GC_UNTRACK(self);
 	Py_XDECREF(gs->prop_get);
 	Py_XDECREF(gs->prop_set);
 	Py_XDECREF(gs->prop_del);
 	Py_XDECREF(gs->prop_doc);
-	self->ob_type->tp_free(self);
+	PyObject_Del(self);
 }
 
 static PyObject *
@@ -1243,7 +1474,7 @@
 	0,					/* tp_setattro */
 	0,					/* tp_as_buffer */
 	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
-		Py_TPFLAGS_BASETYPE,		/* tp_flags */
+		Py_TPFLAGS_BASETYPE | Py_TPFLAGS_SHAREABLE,	/* tp_flags */
  	property_doc,				/* tp_doc */
 	property_traverse,			/* tp_traverse */
  	0,					/* tp_clear */
@@ -1260,7 +1491,5 @@
 	property_descr_set,			/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	property_init,				/* tp_init */
-	PyType_GenericAlloc,			/* tp_alloc */
 	PyType_GenericNew,			/* tp_new */
-	PyObject_GC_Del,               		/* tp_free */
 };
Index: Objects/memoryobject.c
===================================================================
--- Objects/memoryobject.c	(revision 58355)
+++ Objects/memoryobject.c	(working copy)
@@ -28,9 +28,9 @@
 {
 	PyMemoryViewObject *mview;
 
-	mview = (PyMemoryViewObject *)PyObject_New(PyMemoryViewObject,
-						   &PyMemoryView_Type);
-	if (mview == NULL) return NULL;
+	mview = PyObject_NEW(PyMemoryViewObject, &PyMemoryView_Type);
+	if (mview == NULL)
+		return NULL;
 	mview->base = NULL;
 	mview->view = *info;
 	return (PyObject *)mview;
@@ -48,7 +48,7 @@
                 return NULL;
         }
 
-        mview = (PyMemoryViewObject *)PyObject_New(PyMemoryViewObject,
+        mview = (PyMemoryViewObject *)PyObject_NEW(PyMemoryViewObject,
                                                    &PyMemoryView_Type);
         if (mview == NULL) return NULL;
 
@@ -211,7 +211,7 @@
                 return NULL;
         }
 
-        mem = PyObject_New(PyMemoryViewObject, &PyMemoryView_Type);
+        mem = PyObject_NEW(PyMemoryViewObject, &PyMemoryView_Type);
         if (mem == NULL) return NULL;
 
         view = &PyMemoryView(mem);
@@ -564,7 +564,7 @@
 	PyObject_GenericGetAttr,		/* tp_getattro */
 	0,					/* tp_setattro */
 	&memory_as_buffer,			/* tp_as_buffer */
-	Py_TPFLAGS_DEFAULT,			/* tp_flags */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_SHAREABLE,	/* tp_flags */
 	memory_doc,				/* tp_doc */
 	0,					/* tp_traverse */
 	0,					/* tp_clear */
@@ -581,6 +581,5 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	memory_new,				/* tp_new */
 };
Index: Objects/genobject.c
===================================================================
--- Objects/genobject.c	(revision 58355)
+++ Objects/genobject.c	(working copy)
@@ -14,35 +14,49 @@
 	return 0;
 }
 
+static inline int
+bitcount(AO_t num)
+{
+	int count = 0;
+	while (num) {
+		count += num & 1;
+		num >>= 1;
+	}
+	return count;
+}
+
 static void
 gen_dealloc(PyGenObject *gen)
 {
-	PyObject *self = (PyObject *) gen;
-
-	_PyObject_GC_UNTRACK(gen);
-
-	if (gen->gi_weakreflist != NULL)
-		PyObject_ClearWeakRefs(self);
-
-	_PyObject_GC_TRACK(self);
-
 	if (gen->gi_frame != NULL && gen->gi_frame->f_stacktop != NULL) {
-		/* Generator is paused, so we need to close */
-		Py_Type(gen)->tp_del(self);
-		if (self->ob_refcnt > 0)
-			return;		/* resurrected.  :( */
+		/* XXX We should require all generators with "try"
+		 * blocks to be bound to the stack before first running
+		 * them, making this impossible. */
+		static AO_t warning_count = 0;
+		AO_t current = AO_fetch_and_add1_full(&warning_count) + 1;
+
+		/* This might get printed out of order, but who cares?
+		 * Heck, there's no guarantee the printing itself is
+		 * atomic. */
+		/* All we do here is check for powers of 2.  The key to
+		 * this test is that the only time your mask won't
+		 * include your most-significant-bit is when it rolls
+		 * over from 0x100 to 0xFF. */
+		if (current != 0 && !(current & (current - 1)))
+			fprintf(stderr, "Warning: deleting paused "
+				"generator without closing, %lu times\n",
+				current);
 	}
 
-	_PyObject_GC_UNTRACK(self);
 	Py_CLEAR(gen->gi_frame);
-	PyObject_GC_Del(gen);
+	PyObject_DEL(gen);
 }
 
 
 static PyObject *
 gen_send_ex(PyGenObject *gen, PyObject *arg, int exc)
 {
-	PyThreadState *tstate = PyThreadState_GET();
+	PyThreadState *tstate = PyThreadState_Get();
 	PyFrameObject *f = gen->gi_frame;
 	PyObject *result;
 
@@ -142,69 +156,8 @@
 	return NULL;
 }
 
-static void
-gen_del(PyObject *self)
-{
-        PyObject *res;
-        PyObject *error_type, *error_value, *error_traceback;
-	PyGenObject *gen = (PyGenObject *)self;
 
-	if (gen->gi_frame == NULL || gen->gi_frame->f_stacktop == NULL)
-		/* Generator isn't paused, so no need to close */
-		return;
 
-        /* Temporarily resurrect the object. */
-        assert(self->ob_refcnt == 0);
-        self->ob_refcnt = 1;
-
-        /* Save the current exception, if any. */
-        PyErr_Fetch(&error_type, &error_value, &error_traceback);
-
-	res = gen_close(gen, NULL);
-
-	if (res == NULL)
-		PyErr_WriteUnraisable(self);
-	else
-		Py_DECREF(res);
-
-        /* Restore the saved exception. */
-        PyErr_Restore(error_type, error_value, error_traceback);
-
-        /* Undo the temporary resurrection; can't use DECREF here, it would
-         * cause a recursive call.
-         */
-        assert(self->ob_refcnt > 0);
-        if (--self->ob_refcnt == 0)
-                return; /* this is the normal path out */
-
-        /* close() resurrected it!  Make it look like the original Py_DECREF
-         * never happened.
-         */
-        {
-                Py_ssize_t refcnt = self->ob_refcnt;
-                _Py_NewReference(self);
-                self->ob_refcnt = refcnt;
-        }
-        assert(PyType_IS_GC(self->ob_type) &&
-               _Py_AS_GC(self)->gc.gc_refs != _PyGC_REFS_UNTRACKED);
-
-        /* If Py_REF_DEBUG, _Py_NewReference bumped _Py_RefTotal, so
-         * we need to undo that. */
-        _Py_DEC_REFTOTAL;
-        /* If Py_TRACE_REFS, _Py_NewReference re-added self to the object
-         * chain, so no more to do there.
-         * If COUNT_ALLOCS, the original decref bumped tp_frees, and
-         * _Py_NewReference bumped tp_allocs:  both of those need to be
-         * undone.
-         */
-#ifdef COUNT_ALLOCS
-        --self->ob_type->tp_frees;
-        --self->ob_type->tp_allocs;
-#endif
-}
-
-
-
 PyDoc_STRVAR(throw_doc,
 "throw(typ[,val[,tb]]) -> raise exception in generator,\n\
 return next yielded value or raise StopIteration.");
@@ -332,22 +285,19 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	0,					/* tp_new */
-	0,					/* tp_free */
 	0,					/* tp_is_gc */
 	0,					/* tp_bases */
 	0,					/* tp_mro */
 	0,					/* tp_cache */
 	0,					/* tp_subclasses */
 	0,					/* tp_weaklist */
-	gen_del,				/* tp_del */
 };
 
 PyObject *
 PyGen_New(PyFrameObject *f)
 {
-	PyGenObject *gen = PyObject_GC_New(PyGenObject, &PyGen_Type);
+	PyGenObject *gen = PyObject_NEW(PyGenObject, &PyGen_Type);
 	if (gen == NULL) {
 		Py_DECREF(f);
 		return NULL;
@@ -355,7 +305,6 @@
 	gen->gi_frame = f;
 	gen->gi_running = 0;
 	gen->gi_weakreflist = NULL;
-	_PyObject_GC_TRACK(gen);
 	return (PyObject *)gen;
 }
 
Index: Objects/bufferobject.c
===================================================================
--- Objects/bufferobject.c	(revision 58355)
+++ Objects/bufferobject.c	(working copy)
@@ -171,7 +171,6 @@
 PyObject *
 PyBuffer_New(Py_ssize_t size)
 {
-	PyObject *o;
 	PyBufferObject * b;
 
 	if (size < 0) {
@@ -181,10 +180,13 @@
 	}
 	/* XXX: check for overflow in multiply */
 	/* Inline PyObject_New */
-	o = (PyObject *)PyObject_MALLOC(sizeof(*b) + size);
-	if (o == NULL)
-		return PyErr_NoMemory();
-	b = (PyBufferObject *) PyObject_INIT(o, &PyBuffer_Type);
+	//o = (PyObject *)PyObject_MALLOC(sizeof(*b) + size);
+	//if (o == NULL)
+	//	return PyErr_NoMemory();
+	//b = (PyBufferObject *) PyObject_INIT(o, &PyBuffer_Type);
+	b = PyObject_NEWVAR(PyBufferObject, &PyBuffer_Type, size);
+	if (b == NULL)
+		return NULL;
 
 	b->b_base = NULL;
 	b->b_ptr = (void *)(b + 1);
@@ -193,7 +195,7 @@
 	b->b_readonly = 0;
 	b->b_hash = -1;
 
-	return o;
+	return (PyObject *)b;
 }
 
 /* Methods */
@@ -702,7 +704,7 @@
 	PyObject_GenericGetAttr,		/* tp_getattro */
 	0,					/* tp_setattro */
 	&buffer_as_buffer,			/* tp_as_buffer */
-	Py_TPFLAGS_DEFAULT,			/* tp_flags */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_SHAREABLE,	/* tp_flags */
 	buffer_doc,				/* tp_doc */
 	0,					/* tp_traverse */
 	0,					/* tp_clear */
@@ -719,6 +721,5 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	buffer_new,				/* tp_new */
 };
Index: Objects/listobject.c
===================================================================
--- Objects/listobject.c	(revision 58355)
+++ Objects/listobject.c	(working copy)
@@ -1,6 +1,7 @@
 /* List object implementation */
 
 #include "Python.h"
+#include "pythread.h"
 
 #ifdef STDC_HEADERS
 #include <stddef.h>
@@ -63,22 +64,40 @@
 	return 0;
 }
 
+#ifdef USE_LIST_FREELIST
 /* Empty list reuse scheme to save calls to malloc and free */
 #define MAXFREELISTS 80
 static PyListObject *free_lists[MAXFREELISTS];
 static int num_free_lists = 0;
+static PyThread_type_lock free_lists_lock;
+#endif
 
 void
+_PyList_Init(void)
+{
+#ifdef USE_LIST_FREELIST
+	free_lists_lock = PyThread_lock_allocate();
+	if (!free_lists_lock)
+		Py_FatalError("unable to allocate lock");
+#endif
+}
+
+void
 PyList_Fini(void)
 {
+#ifdef USE_LIST_FREELIST
 	PyListObject *op;
 
 	while (num_free_lists) {
 		num_free_lists--;
 		op = free_lists[num_free_lists]; 
 		assert(PyList_CheckExact(op));
-		PyObject_GC_Del(op);
+		PyObject_DEL(op);
 	}
+
+	PyThread_lock_free(free_lists_lock);
+	free_lists_lock = NULL;
+#endif
 }
 
 PyObject *
@@ -95,15 +114,22 @@
 	/* Check for overflow */
 	if (nbytes / sizeof(PyObject *) != (size_t)size)
 		return PyErr_NoMemory();
+#ifdef USE_LIST_FREELIST
+	PyThread_lock_acquire(free_lists_lock);
 	if (num_free_lists) {
 		num_free_lists--;
 		op = free_lists[num_free_lists];
-		_Py_NewReference((PyObject *)op);
+		PyThread_lock_release(free_lists_lock);
+		//_Py_NewReference((PyObject *)op);
 	} else {
-		op = PyObject_GC_New(PyListObject, &PyList_Type);
+		PyThread_lock_release(free_lists_lock);
+#endif
+		op = PyObject_NEW(PyListObject, &PyList_Type);
 		if (op == NULL)
 			return NULL;
+#ifdef USE_LIST_FREELIST
 	}
+#endif
 	if (size <= 0)
 		op->ob_item = NULL;
 	else {
@@ -116,7 +142,7 @@
 	}
 	Py_Size(op) = size;
 	op->allocated = size;
-	_PyObject_GC_TRACK(op);
+
 	return (PyObject *) op;
 }
 
@@ -252,8 +278,6 @@
 list_dealloc(PyListObject *op)
 {
 	Py_ssize_t i;
-	PyObject_GC_UnTrack(op);
-	Py_TRASHCAN_SAFE_BEGIN(op)
 	if (op->ob_item != NULL) {
 		/* Do it backwards, for Christian Tismer.
 		   There's a simple test case where somehow this reduces
@@ -265,11 +289,18 @@
 		}
 		PyMem_FREE(op->ob_item);
 	}
-	if (num_free_lists < MAXFREELISTS && PyList_CheckExact(op))
+#ifdef USE_LIST_FREELIST
+	PyThread_lock_acquire(free_lists_lock);
+	if (num_free_lists < MAXFREELISTS && PyList_CheckExact(op)) {
 		free_lists[num_free_lists++] = op;
-	else
-		Py_Type(op)->tp_free((PyObject *)op);
-	Py_TRASHCAN_SAFE_END(op)
+		PyThread_lock_release(free_lists_lock);
+	} else {
+		PyThread_lock_release(free_lists_lock);
+#endif
+		PyObject_DEL(op);
+#ifdef USE_LIST_FREELIST
+	}
+#endif
 }
 
 static PyObject *
@@ -1832,7 +1863,7 @@
 {
 	Py_XDECREF(so->key);
 	Py_XDECREF(so->value);
-	PyObject_Del(so);
+	PyObject_DEL(so);
 }
 
 /* Returns a new reference to a sortwrapper.
@@ -1843,7 +1874,7 @@
 {
 	sortwrapperobject *so;
 
-	so = PyObject_New(sortwrapperobject, &sortwrapper_type);
+	so = PyObject_NEW(sortwrapperobject, &sortwrapper_type);
 	if (so == NULL)
 		return NULL;
 	so->key = key;
@@ -1880,7 +1911,7 @@
 cmpwrapper_dealloc(cmpwrapperobject *co)
 {
 	Py_XDECREF(co->func);
-	PyObject_Del(co);
+	PyObject_DEL(co);
 }
 
 static PyObject *
@@ -1933,7 +1964,7 @@
 {
 	cmpwrapperobject *co;
 
-	co = PyObject_New(cmpwrapperobject, &cmpwrapper_type);
+	co = PyObject_NEW(cmpwrapperobject, &cmpwrapper_type);
 	if (co == NULL)
 		return NULL;
 	Py_INCREF(cmpfunc);
@@ -2358,7 +2389,7 @@
 	if (!PyArg_ParseTupleAndKeywords(args, kw, "|O:list", kwlist, &arg))
 		return -1;
 
-	/* Verify list invariants established by PyType_GenericAlloc() */
+	/* Verify list invariants established by PyObject_New() */
 	assert(0 <= Py_Size(self));
 	assert(Py_Size(self) <= self->allocated || self->allocated == -1);
 	assert(self->ob_item != NULL ||
@@ -2677,7 +2708,8 @@
 	0,					/* tp_setattro */
 	0,					/* tp_as_buffer */
 	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
-		Py_TPFLAGS_BASETYPE | Py_TPFLAGS_LIST_SUBCLASS,	/* tp_flags */
+		Py_TPFLAGS_BASETYPE | Py_TPFLAGS_LIST_SUBCLASS |
+		Py_TPFLAGS_SHAREABLE,		/* tp_flags */
  	list_doc,				/* tp_doc */
  	(traverseproc)list_traverse,		/* tp_traverse */
  	(inquiry)list_clear,			/* tp_clear */
@@ -2694,9 +2726,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	(initproc)list_init,			/* tp_init */
-	PyType_GenericAlloc,			/* tp_alloc */
 	PyType_GenericNew,			/* tp_new */
-	PyObject_GC_Del,			/* tp_free */
 };
 
 
@@ -2764,22 +2794,20 @@
 		PyErr_BadInternalCall();
 		return NULL;
 	}
-	it = PyObject_GC_New(listiterobject, &PyListIter_Type);
+	it = PyObject_NEW(listiterobject, &PyListIter_Type);
 	if (it == NULL)
 		return NULL;
 	it->it_index = 0;
 	Py_INCREF(seq);
 	it->it_seq = (PyListObject *)seq;
-	_PyObject_GC_TRACK(it);
 	return (PyObject *)it;
 }
 
 static void
 listiter_dealloc(listiterobject *it)
 {
-	_PyObject_GC_UNTRACK(it);
 	Py_XDECREF(it->it_seq);
-	PyObject_GC_Del(it);
+	PyObject_DEL(it);
 }
 
 static int
@@ -2880,23 +2908,21 @@
 {
 	listreviterobject *it;
 
-	it = PyObject_GC_New(listreviterobject, &PyListRevIter_Type);
+	it = PyObject_NEW(listreviterobject, &PyListRevIter_Type);
 	if (it == NULL)
 		return NULL;
 	assert(PyList_Check(seq));
 	it->it_index = PyList_GET_SIZE(seq) - 1;
 	Py_INCREF(seq);
 	it->it_seq = seq;
-	PyObject_GC_Track(it);
 	return (PyObject *)it;
 }
 
 static void
 listreviter_dealloc(listreviterobject *it)
 {
-	PyObject_GC_UnTrack(it);
 	Py_XDECREF(it->it_seq);
-	PyObject_GC_Del(it);
+	PyObject_DEL(it);
 }
 
 static int
Index: Objects/fileobject.c
===================================================================
--- Objects/fileobject.c	(revision 58355)
+++ Objects/fileobject.c	(working copy)
@@ -95,7 +95,7 @@
 					"EOF when reading a line");
 		}
 		else if (s[len-1] == '\n') {
-			if (result->ob_refcnt == 1)
+			if (Py_RefcntSnoop(result) == 1)
 				_PyString_Resize(&result, len-1);
 			else {
 				PyObject *v;
@@ -115,7 +115,7 @@
 					"EOF when reading a line");
 		}
 		else if (s[len-1] == '\n') {
-			if (result->ob_refcnt == 1)
+			if (Py_RefcntSnoop(result) == 1)
 				PyUnicode_Resize(&result, len-1);
 			else {
 				PyObject *v;
Index: Objects/stringlib/string_format.h
===================================================================
--- Objects/stringlib/string_format.h	(revision 58355)
+++ Objects/stringlib/string_format.h	(working copy)
@@ -485,7 +485,7 @@
 
     /* Initialize cached value */
     if (format_str == NULL) {
-        /* Initialize static variable needed by _PyType_Lookup */
+        /* Initialize static variable needed by _PyType_LookupEx */
         format_str = PyUnicode_FromString("__format__");
         if (format_str == NULL)
             return NULL;
@@ -501,8 +501,9 @@
     if (spec == NULL)
         goto done;
 
-    /* Find the (unbound!) __format__ method (a borrowed reference) */
-    meth = _PyType_Lookup(Py_Type(fieldobj), format_str);
+    /* Find the (unbound!) __format__ method */
+    if (_PyType_LookupEx(Py_Type(fieldobj), format_str, &meth) < 0)
+        goto done;
     if (meth == NULL) {
         PyErr_Format(PyExc_TypeError,
                      "Type %.100s doesn't define __format__",
@@ -512,6 +513,7 @@
 
     /* And call it, binding it to the value */
     result = PyObject_CallFunctionObjArgs(meth, fieldobj, spec, NULL);
+    Py_DECREF(meth);
     if (result == NULL)
         goto done;
 
@@ -967,7 +969,7 @@
 formatteriter_dealloc(formatteriterobject *it)
 {
     Py_XDECREF(it->str);
-    PyObject_FREE(it);
+    PyObject_DEL(it);
 }
 
 /* returns a tuple:
@@ -1089,7 +1091,7 @@
 {
     formatteriterobject *it;
 
-    it = PyObject_New(formatteriterobject, &PyFormatterIter_Type);
+    it = PyObject_NEW(formatteriterobject, &PyFormatterIter_Type);
     if (it == NULL)
         return NULL;
 
@@ -1127,7 +1129,7 @@
 fieldnameiter_dealloc(fieldnameiterobject *it)
 {
     Py_XDECREF(it->str);
-    PyObject_FREE(it);
+    PyObject_DEL(it);
 }
 
 /* returns a tuple:
@@ -1229,7 +1231,7 @@
     PyObject *first_obj = NULL;
     PyObject *result = NULL;
 
-    it = PyObject_New(fieldnameiterobject, &PyFieldNameIter_Type);
+    it = PyObject_NEW(fieldnameiterobject, &PyFieldNameIter_Type);
     if (it == NULL)
         return NULL;
 
Index: Objects/moduleobject.c
===================================================================
--- Objects/moduleobject.c	(revision 58355)
+++ Objects/moduleobject.c	(working copy)
@@ -17,13 +17,22 @@
 PyObject *
 PyModule_New(const char *name)
 {
+	return PyModule_NewEx(name, 0);
+}
+
+PyObject *
+PyModule_NewEx(const char *name, int shared)
+{
 	PyModuleObject *m;
 	PyObject *nameobj;
-	m = PyObject_GC_New(PyModuleObject, &PyModule_Type);
+	m = PyObject_NEW(PyModuleObject, &PyModule_Type);
 	if (m == NULL)
 		return NULL;
 	nameobj = PyUnicode_FromString(name);
-	m->md_dict = PyDict_New();
+	if (shared)
+		m->md_dict = PyObject_CallObject((PyObject *)&PySharedDict_Type, NULL);
+	else
+		m->md_dict = PyDict_New();
 	if (m->md_dict == NULL || nameobj == NULL)
 		goto fail;
 	if (PyDict_SetItemString(m->md_dict, "__name__", nameobj) != 0)
@@ -31,7 +40,6 @@
 	if (PyDict_SetItemString(m->md_dict, "__doc__", Py_None) != 0)
 		goto fail;
 	Py_DECREF(nameobj);
-	PyObject_GC_Track(m);
 	return (PyObject *)m;
 
  fail:
@@ -59,19 +67,22 @@
 {
 	PyObject *d;
 	PyObject *nameobj;
+	const char *retval;
 	if (!PyModule_Check(m)) {
 		PyErr_BadArgument();
 		return NULL;
 	}
 	d = ((PyModuleObject *)m)->md_dict;
-	if (d == NULL ||
-	    (nameobj = PyDict_GetItemString(d, "__name__")) == NULL ||
-	    !PyUnicode_Check(nameobj))
-	{
+	if (d == NULL || PyDict_GetItemStringEx(d, "__name__", &nameobj) > 0) {
 		PyErr_SetString(PyExc_SystemError, "nameless module");
 		return NULL;
 	}
-	return PyUnicode_AsString(nameobj);
+	if (nameobj == NULL)
+		return NULL;
+	retval = PyUnicode_AsString(nameobj);
+	Py_DECREF(nameobj);
+#warning XXX FIXME PyModule_GetName is racey (not thread-safe)
+	return retval;
 }
 
 const char *
@@ -114,7 +125,7 @@
 
 	/* First, clear only names starting with a single underscore */
 	pos = 0;
-	while (PyDict_Next(d, &pos, &key, &value)) {
+	while (PyDict_NextEx(d, &pos, &key, &value)) {
 		if (value != Py_None && PyUnicode_Check(key)) {
 			const char *s = PyUnicode_AsString(key);
 			if (s[0] == '_' && s[1] != '_') {
@@ -123,11 +134,13 @@
 				PyDict_SetItem(d, key, Py_None);
 			}
 		}
+		Py_DECREF(key);
+		Py_DECREF(value);
 	}
 
 	/* Next, clear all names except for __builtins__ */
 	pos = 0;
-	while (PyDict_Next(d, &pos, &key, &value)) {
+	while (PyDict_NextEx(d, &pos, &key, &value)) {
 		if (value != Py_None && PyUnicode_Check(key)) {
 			const char *s = PyUnicode_AsString(key);
 			if (s[0] != '_' || strcmp(s, "__builtins__") != 0) {
@@ -136,6 +149,8 @@
 				PyDict_SetItem(d, key, Py_None);
 			}
 		}
+		Py_DECREF(key);
+		Py_DECREF(value);
 	}
 
 	/* Note: we leave __builtins__ in place, so that destructors
@@ -171,12 +186,11 @@
 static void
 module_dealloc(PyModuleObject *m)
 {
-	PyObject_GC_UnTrack(m);
 	if (m->md_dict != NULL) {
 		_PyModule_Clear((PyObject *)m);
 		Py_DECREF(m->md_dict);
 	}
-	Py_Type(m)->tp_free((PyObject *)m);
+	PyObject_DEL(m);
 }
 
 static PyObject *
@@ -208,6 +222,18 @@
 	return 0;
 }
 
+static int
+module_isshareable(PyModuleObject *m)
+{
+	/* XXX FIXME HACK! */
+	const char *name = PyModule_GetName((PyObject *)m);
+	if (strcmp(name, "sys") == 0 || strcmp(name, "os") == 0 ||
+			strcmp(name, "io") == 0)
+		return 1;
+
+	return PyObject_IsShareable(m->md_dict);
+}
+
 PyDoc_STRVAR(module_doc,
 "module(name[, doc])\n\
 \n\
@@ -235,7 +261,8 @@
 	PyObject_GenericSetAttr,		/* tp_setattro */
 	0,					/* tp_as_buffer */
 	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
-		Py_TPFLAGS_BASETYPE,		/* tp_flags */
+		Py_TPFLAGS_BASETYPE |
+		Py_TPFLAGS_SHAREABLE,		/* tp_flags */
 	module_doc,				/* tp_doc */
 	(traverseproc)module_traverse,		/* tp_traverse */
 	0,					/* tp_clear */
@@ -252,7 +279,12 @@
 	0,					/* tp_descr_set */
 	offsetof(PyModuleObject, md_dict),	/* tp_dictoffset */
 	(initproc)module_init,			/* tp_init */
-	PyType_GenericAlloc,			/* tp_alloc */
 	PyType_GenericNew,			/* tp_new */
-	PyObject_GC_Del,		        /* tp_free */
+	0,					/* tp_is_gc */
+	0,					/* tp_bases */
+	0,					/* tp_mro */
+	0,					/* tp_cache */
+	0,					/* tp_subclasses */
+	0,					/* tp_weaklist */
+	(isshareablefunc)module_isshareable,	/* tp_isshareable */
 };
Index: Objects/bytesobject.c
===================================================================
--- Objects/bytesobject.c	(revision 58355)
+++ Objects/bytesobject.c	(working copy)
@@ -21,7 +21,7 @@
 int
 PyBytes_Init(void)
 {
-    nullbytes = PyObject_New(PyBytesObject, &PyBytes_Type);
+    nullbytes = PyObject_NEW(PyBytesObject, &PyBytes_Type);
     if (nullbytes == NULL)
         return 0;
     nullbytes->ob_bytes = NULL;
@@ -112,7 +112,7 @@
 
     assert(size >= 0);
 
-    new = PyObject_New(PyBytesObject, &PyBytes_Type);
+    new = PyObject_NEW(PyBytesObject, &PyBytes_Type);
     if (new == NULL)
         return NULL;
 
@@ -1025,7 +1025,7 @@
     if (self->ob_bytes != 0) {
         PyMem_Free(self->ob_bytes);
     }
-    Py_Type(self)->tp_free((PyObject *)self);
+    PyObject_DEL(self);
 }
 
 
@@ -3005,7 +3005,7 @@
     0,                                  /* tp_setattro */
     &bytes_as_buffer,                   /* tp_as_buffer */
     /* bytes is 'final' or 'sealed' */
-    Py_TPFLAGS_DEFAULT,                 /* tp_flags */
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_SHAREABLE,  /* tp_flags */
     bytes_doc,                          /* tp_doc */
     0,                                  /* tp_traverse */
     0,                                  /* tp_clear */
@@ -3022,7 +3022,5 @@
     0,                                  /* tp_descr_set */
     0,                                  /* tp_dictoffset */
     (initproc)bytes_init,               /* tp_init */
-    PyType_GenericAlloc,                /* tp_alloc */
     PyType_GenericNew,                  /* tp_new */
-    PyObject_Del,                       /* tp_free */
 };
Index: Objects/monitorobject.c
===================================================================
--- Objects/monitorobject.c	(revision 0)
+++ Objects/monitorobject.c	(revision 0)
@@ -0,0 +1,534 @@
+
+#include "Python.h"
+#include "ceval.h"
+#include "monitorobject.h"
+
+/* MonitorMeta methods */
+
+static void
+MonitorMeta_dealloc(PyTypeObject *self)
+{
+	PyObject_DEL(self);
+}
+
+static PyObject *
+MonitorMeta_call(PyTypeObject *self, PyObject *args, PyObject *kwds)
+{
+	PyObject *monitorspace;
+	PyObject *super;
+	PyObject *nextmethod;
+	PyObject *enter;
+	Py_ssize_t size, i;
+	PyObject *built_args;
+	PyObject *result;
+
+	assert(PyTuple_Check(args));
+
+	/* This can all be summed up as:
+	   monitorspace = MonitorSpace()
+	   nextmethod = super(MonitorMeta, self).__call__
+	   return monitorspace.enter(nextmethod, *args, **kwargs)
+	 */
+
+	monitorspace = PyObject_CallObject((PyObject *)&PyMonitorSpace_Type, NULL);
+	if (monitorspace == NULL)
+		return NULL;
+
+	super = PyEval_CallFunction((PyObject *)&PySuper_Type, "OO",
+		&PyMonitorMeta_Type, self);
+	if (super == NULL) {
+		Py_DECREF(monitorspace);
+		return NULL;
+	}
+
+	nextmethod = PyObject_GetAttrString(super, "__call__");
+	Py_DECREF(super);
+	if (nextmethod == NULL) {
+		Py_DECREF(monitorspace);
+		return NULL;
+	}
+
+	size = PyTuple_Size(args) + 1;
+	built_args = PyTuple_New(size);
+	if (built_args == NULL) {
+		Py_DECREF(monitorspace);
+		Py_DECREF(nextmethod);
+		return NULL;
+	}
+	PyTuple_SET_ITEM(built_args, 0, nextmethod); /* Steals our reference */
+	nextmethod = NULL;
+	for (i = 1; i < size; i++) {
+		PyObject *item = PyTuple_GET_ITEM(args, i-1);
+		Py_INCREF(item);
+		PyTuple_SET_ITEM(built_args, i, item);
+	}
+
+	enter = PyObject_GetAttrString(monitorspace, "enter");
+	if (enter == NULL) {
+		Py_DECREF(monitorspace);
+		Py_DECREF(built_args);
+		return NULL;
+	}
+
+	result = PyEval_CallObjectWithKeywords(enter, built_args, kwds);
+
+	Py_DECREF(monitorspace);
+	Py_DECREF(built_args);
+	Py_DECREF(enter);
+
+	return result;
+}
+
+static int
+MonitorMeta_traverse(PyTypeObject *self, visitproc visit, void *arg)
+{
+	return 0;
+}
+
+PyTypeObject PyMonitorMeta_Type = {
+	PyVarObject_HEAD_INIT(&PyType_Type, 0)
+	"_threadtoolsmodule.MonitorMeta",	/*tp_name*/
+	sizeof(PyHeapTypeObject),	/*tp_basicsize*/
+	0/*sizeof(PyMemberDef)*/,	/*tp_itemsize*/
+	(destructor)MonitorMeta_dealloc,	/*tp_dealloc*/
+	0,			/*tp_print*/
+	0,			/*tp_getattr*/
+	0,			/*tp_setattr*/
+	0,			/*tp_compare*/
+	0,			/*tp_repr*/
+	0,			/*tp_as_number*/
+	0,			/*tp_as_sequence*/
+	0,			/*tp_as_mapping*/
+	0,			/*tp_hash*/
+	(ternaryfunc)MonitorMeta_call,	/*tp_call*/
+	0,			/*tp_str*/
+	PyObject_GenericGetAttr,	/*tp_getattro*/
+	0,			/*tp_setattro*/
+	0,			/*tp_as_buffer*/
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
+		Py_TPFLAGS_BASETYPE |
+		Py_TPFLAGS_SHAREABLE,	/*tp_flags*/
+	0,			/*tp_doc*/
+	(traverseproc)MonitorMeta_traverse,	/*tp_traverse*/
+	0,			/*tp_clear*/
+	0,			/*tp_richcompare*/
+	0,			/*tp_weaklistoffset*/
+	0,			/*tp_iter*/
+	0,			/*tp_iternext*/
+	0,			/*tp_methods*/
+	0,			/*tp_members*/
+	0,			/*tp_getset*/
+	0,			/*tp_base*/
+	0,			/*tp_dict*/
+	0,			/*tp_descr_get*/
+	0,			/*tp_descr_set*/
+	0,			/*tp_dictoffset*/
+	0,			/*tp_init*/
+	0,			/*tp_new*/
+};
+/* --------------------------------------------------------------------- */
+
+
+/* Monitor methods */
+
+static void
+Monitor_dealloc(PyMonitorObject *self)
+{
+	PyObject *monitorspace = self->mon_monitorspace;
+	PyObject_DEL(self);
+	Py_DECREF(monitorspace);
+}
+
+static PyObject *
+Monitor_enter(PyMonitorObject *self, PyObject *args, PyObject *kwds)
+{
+	PyObject *monitorspace_enter;
+	PyObject *result;
+
+	monitorspace_enter = PyObject_GetAttrString(self->mon_monitorspace, "enter");
+	if (monitorspace_enter == NULL)
+	    return NULL;
+
+	result = PyEval_CallObjectWithKeywords(monitorspace_enter, args, kwds);
+	Py_DECREF(monitorspace_enter);
+	return result;
+}
+
+static int
+Monitor_traverse(PyMonitorObject *self, visitproc visit, void *arg)
+{
+	Py_VISIT(self->mon_monitorspace);
+	return 0;
+}
+
+static PyObject *
+Monitor_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
+{
+	PyObject *self;
+
+	assert(type != NULL);
+	self = PyObject_New(type);
+	if (self != NULL) {
+		PyMonitorObject *x = (PyMonitorObject *)self;
+		x->mon_monitorspace = PyMonitorSpace_GetCurrent();
+		if (x->mon_monitorspace == NULL) {
+			PyObject_Del(self);
+			return NULL;
+		}
+	}
+	return self;
+}
+
+static int
+Monitor_isshareable (PyObject *self)
+{
+	return 1;
+}
+
+PyDoc_STRVAR(Monitor_enter__doc__, "enter(func, *args, **kwargs) -> object");
+
+static PyMethodDef Monitor_methods[] = {
+	{"enter",	(PyCFunction)Monitor_enter,	METH_VARARGS | METH_KEYWORDS,
+		Monitor_enter__doc__},
+	{NULL,		NULL}		/* sentinel */
+};
+
+PyTypeObject PyMonitor_Type = {
+	PyVarObject_HEAD_INIT(&PyMonitorMeta_Type, 0)
+	"_threadtoolsmodule.Monitor",	/*tp_name*/
+	sizeof(PyMonitorObject),	/*tp_basicsize*/
+	0,			/*tp_itemsize*/
+	(destructor)Monitor_dealloc,	/*tp_dealloc*/
+	0,			/*tp_print*/
+	0,			/*tp_getattr*/
+	0,			/*tp_setattr*/
+	0,			/*tp_compare*/
+	0,			/*tp_repr*/
+	0,			/*tp_as_number*/
+	0,			/*tp_as_sequence*/
+	0,			/*tp_as_mapping*/
+	0,			/*tp_hash*/
+	0,			/*tp_call*/
+	0,			/*tp_str*/
+	PyObject_GenericGetAttr,	/*tp_getattro*/
+	0,			/*tp_setattro*/
+	0,			/*tp_as_buffer*/
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
+		Py_TPFLAGS_BASETYPE | Py_TPFLAGS_MONITOR_SUBCLASS |
+		Py_TPFLAGS_SHAREABLE,	/*tp_flags*/
+	0,			/*tp_doc*/
+	(traverseproc)Monitor_traverse,	/*tp_traverse*/
+	0,			/*tp_clear*/
+	0,			/*tp_richcompare*/
+	0,			/*tp_weaklistoffset*/
+	0,			/*tp_iter*/
+	0,			/*tp_iternext*/
+	Monitor_methods,	/*tp_methods*/
+	0,			/*tp_members*/
+	0,			/*tp_getset*/
+	0,			/*tp_base*/
+	0,			/*tp_dict*/
+	0,			/*tp_descr_get*/
+	0,			/*tp_descr_set*/
+	0,			/*tp_dictoffset*/
+	0,			/*tp_init*/
+	Monitor_new,		/*tp_new*/
+	0,			/*tp_is_gc*/
+	0,			/*tp_bases*/
+	0,			/*tp_mro*/
+	0,			/*tp_cache*/
+	0,			/*tp_subclasses*/
+	0,			/*tp_weaklist*/
+	Monitor_isshareable,	/*tp_isshareable*/
+};
+/* --------------------------------------------------------------------- */
+
+
+/* MonitorSpace methods */
+
+static void
+waitqueue_push(PyMonitorSpaceObject *queue, PyThreadState *tstate)
+{
+	if (queue->first_waiter) {
+		tstate->lockwait_prev = queue->last_waiter;
+		tstate->lockwait_next = NULL;
+		queue->last_waiter->lockwait_next = tstate;
+		queue->last_waiter = tstate;
+	} else {
+		tstate->lockwait_prev = NULL;
+		tstate->lockwait_next = NULL;
+		queue->first_waiter = tstate;
+		queue->last_waiter = tstate;
+	}
+}
+
+static void
+waitqueue_pop(PyMonitorSpaceObject *queue, PyThreadState *tstate)
+{
+	if (tstate->lockwait_prev != NULL)
+		tstate->lockwait_prev->lockwait_next = tstate->lockwait_next;
+	if (tstate->lockwait_next != NULL)
+		tstate->lockwait_next->lockwait_prev = tstate->lockwait_prev;
+
+	if (queue->first_waiter == tstate)
+		queue->first_waiter = tstate->lockwait_next;
+	if (queue->last_waiter == tstate)
+		queue->last_waiter = tstate->lockwait_prev;
+
+	tstate->lockwait_next = NULL;
+	tstate->lockwait_prev = NULL;
+}
+
+static int
+lock_enter(PyMonitorSpaceObject *self)
+{
+	PyThreadState *tstate = PyThreadState_Get();
+	assert(tstate->active_lock == NULL);
+
+	tstate->active_lock = self;
+	PyState_Suspend();
+	PyThread_lock_acquire(self->lock);
+
+	if (self->lock_holder == NULL)
+		self->lock_holder = tstate;
+	else {
+		waitqueue_push(self, tstate);
+		while (self->lock_holder != NULL)
+			PyThread_cond_wait(tstate->lockwait_cond, self->lock);
+		waitqueue_pop(self, tstate);
+		self->lock_holder = tstate;
+	}
+
+	PyThread_lock_release(self->lock);
+	PyState_Resume();
+	tstate->active_lock = NULL;
+
+	return 0;
+}
+
+static int
+lock_exit(PyMonitorSpaceObject *self)
+{
+	PyThreadState *tstate = PyThreadState_Get();
+	assert(tstate->active_lock == NULL);
+
+	tstate->active_lock = self;
+	PyState_Suspend();
+	PyThread_lock_acquire(self->lock);
+
+	assert(self->lock_holder == tstate);
+	self->lock_holder = NULL;
+	if (self->first_waiter) {
+		/* Ensure there's at least one thread that's awake. */
+		PyThread_cond_wakeone(self->first_waiter->lockwait_cond);
+	}
+
+	PyThread_lock_release(self->lock);
+	PyState_Resume();
+	tstate->active_lock = NULL;
+
+	return 0;
+}
+
+static PyObject *
+monitorspace_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
+{
+	PyObject *self;
+
+	assert(type != NULL);
+	self = PyObject_New(type);
+	if (self != NULL) {
+		PyMonitorSpaceObject *x = (PyMonitorSpaceObject *)self;
+		x->lock = PyThread_lock_allocate();
+		if (x->lock == NULL) {
+			PyObject_Del(self);
+			PyErr_SetString(PyExc_RuntimeError, "can't allocate lock");
+			return NULL;
+		}
+		x->lock_holder = NULL;
+		x->first_waiter = NULL;
+		x->last_waiter = NULL;
+	}
+	return self;
+}
+
+static void
+monitorspace_dealloc(PyMonitorSpaceObject *self)
+{
+	assert(self->lock_holder == NULL);
+	assert(self->first_waiter == NULL);
+	assert(self->last_waiter == NULL);
+	PyThread_lock_free(self->lock);
+	PyObject_DEL(self);
+}
+
+void
+_PyMonitorSpace_Push(PyMonitorSpaceFrame *frame, struct _PyMonitorSpaceObject *monitorspace)
+{
+	PyThreadState *tstate = PyThreadState_Get();
+
+	assert(frame != NULL);
+	assert(frame->prevframe == NULL);
+
+	frame->prevframe = tstate->monitorspace_frame;
+	frame->monitorspace = monitorspace;
+	tstate->monitorspace_frame = frame;
+	Py_XINCREF(monitorspace);
+}
+
+void
+_PyMonitorSpace_Pop(PyMonitorSpaceFrame *frame)
+{
+	struct _PyMonitorSpaceObject *monitorspace;
+	PyThreadState *tstate = PyThreadState_Get();
+
+	assert(frame != NULL);
+	if (tstate->monitorspace_frame != frame)
+		Py_FatalError("Pop of non-top monitorspace frame");
+
+        monitorspace = frame->monitorspace;
+	tstate->monitorspace_frame = frame->prevframe;
+	frame->prevframe = NULL;
+	frame->monitorspace = NULL;
+	Py_XDECREF(monitorspace);
+}
+
+static PyObject *
+monitorspace_enter(PyMonitorSpaceObject *self, PyObject *args, PyObject *kwds)
+{
+	PyObject *func;
+	PyObject *smallargs;
+	PyObject *result;
+	PyMonitorSpaceFrame frame = PyMonitorSpaceFrame_INIT;
+
+	if (PyTuple_Size(args) < 1) {
+		PyErr_SetString(PyExc_TypeError,
+			"Monitor.enter() needs a function to be called");
+		return NULL;
+	}
+
+	func = PyTuple_GetItem(args, 0);
+
+	if (!PyObject_IsShareable(func)) {
+		PyErr_Format(PyExc_TypeError,
+			"Function argument must be shareable, '%s' object "
+			"is not", func->ob_type->tp_name);
+		return NULL;
+	}
+
+	smallargs = PyTuple_GetSlice(args, 1, PyTuple_Size(args));
+	if (smallargs == NULL) {
+		return NULL;
+	}
+
+	if (!PyArg_RequireShareable("Monitor.enter", smallargs, kwds)) {
+		Py_DECREF(smallargs);
+		return NULL;
+	}
+
+	lock_enter(self);
+	_PyMonitorSpace_Push(&frame, self);
+
+	result = PyEval_CallObjectWithKeywords(func, smallargs, kwds);
+	if (!PyArg_RequireShareableReturn("Monitor.enter", func, result)) {
+		Py_XDECREF(result);
+		result = NULL;
+	}
+	Py_DECREF(smallargs);
+
+	_PyMonitorSpace_Pop(&frame);
+	lock_exit(self);
+
+	return result;
+}
+
+int
+PyMonitorSpace_IsCurrent(struct _PyMonitorSpaceObject *monitorspace)
+{
+	PyThreadState *tstate = PyThreadState_Get();
+
+	assert(monitorspace != NULL);
+	return tstate->monitorspace_frame->monitorspace == monitorspace;
+}
+
+/* Returns a NEW reference */
+PyObject *
+PyMonitorSpace_GetCurrent(void)
+{
+    PyThreadState *tstate = PyThreadState_Get();
+    PyObject *monitorspace = (PyObject *)tstate->monitorspace_frame->monitorspace;
+
+    if (monitorspace == NULL) {
+        monitorspace = PyObject_CallObject((PyObject *)&PyMonitorSpace_Type, NULL);
+        if (monitorspace == NULL)
+            return NULL;
+        assert(tstate->monitorspace_frame->monitorspace == NULL);
+        tstate->monitorspace_frame->monitorspace =
+            (struct _PyMonitorSpaceObject *)monitorspace;
+    }
+
+    Py_INCREF(monitorspace);
+    return monitorspace;
+}
+
+static int
+monitorspace_isshareable (PyObject *self)
+{
+	return 1;
+}
+
+PyDoc_STRVAR(monitorspace_enter__doc__, "enter(func, *args, **kwargs) -> object");
+
+static PyMethodDef monitorspace_methods[] = {
+	{"enter",	(PyCFunction)monitorspace_enter,	METH_VARARGS | METH_KEYWORDS,
+		monitorspace_enter__doc__},
+	{NULL,		NULL}		/* sentinel */
+};
+
+PyTypeObject PyMonitorSpace_Type = {
+	PyVarObject_HEAD_INIT(&PyType_Type, 0)
+	"_threadtoolsmodule.MonitorSpace",	/*tp_name*/
+	sizeof(PyMonitorSpaceObject),	/*tp_basicsize*/
+	0,			/*tp_itemsize*/
+	(destructor)monitorspace_dealloc,	/*tp_dealloc*/
+	0,			/*tp_print*/
+	0,			/*tp_getattr*/
+	0,			/*tp_setattr*/
+	0,			/*tp_compare*/
+	0,			/*tp_repr*/
+	0,			/*tp_as_number*/
+	0,			/*tp_as_sequence*/
+	0,			/*tp_as_mapping*/
+	0,			/*tp_hash*/
+	0,			/*tp_call*/
+	0,			/*tp_str*/
+	PyObject_GenericGetAttr,	/*tp_getattro*/
+	0,			/*tp_setattro*/
+	0,			/*tp_as_buffer*/
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |
+		Py_TPFLAGS_SHAREABLE,	/*tp_flags*/
+	0,			/*tp_doc*/
+	0,			/*tp_traverse*/
+	0,			/*tp_clear*/
+	0,			/*tp_richcompare*/
+	0,			/*tp_weaklistoffset*/
+	0,			/*tp_iter*/
+	0,			/*tp_iternext*/
+	monitorspace_methods,	/*tp_methods*/
+	0,			/*tp_members*/
+	0,			/*tp_getset*/
+	0,			/*tp_base*/
+	0,			/*tp_dict*/
+	0,			/*tp_descr_get*/
+	0,			/*tp_descr_set*/
+	0,			/*tp_dictoffset*/
+	0,			/*tp_init*/
+	monitorspace_new,		/*tp_new*/
+	0,			/*tp_is_gc*/
+	0,			/*tp_bases*/
+	0,			/*tp_mro*/
+	0,			/*tp_cache*/
+	0,			/*tp_subclasses*/
+	0,			/*tp_weaklist*/
+	monitorspace_isshareable,	/*tp_isshareable*/
+};
Index: Objects/frameobject.c
===================================================================
--- Objects/frameobject.c	(revision 58355)
+++ Objects/frameobject.c	(working copy)
@@ -6,6 +6,7 @@
 #include "frameobject.h"
 #include "opcode.h"
 #include "structmember.h"
+#include "pythread.h"
 
 #undef MIN
 #undef MAX
@@ -392,51 +393,58 @@
    frames could provoke free_list into growing without bound.
 */
 
+#ifndef WITH_FREETHREAD
+#define USE_FRAME_FREELIST
+#endif
+
+#ifdef USE_FRAME_FREELIST
 static PyFrameObject *free_list = NULL;
 static int numfree = 0;		/* number of frames currently in free_list */
 #define MAXFREELIST 200		/* max value for numfree */
+#endif
 
 static void
 frame_dealloc(PyFrameObject *f)
 {
+	PyThreadState *tstate = PyThreadState_Get();
 	PyObject **p, **valuestack;
 	PyCodeObject *co;
 
-	PyObject_GC_UnTrack(f);
-	Py_TRASHCAN_SAFE_BEGIN(f)
 	/* Kill all local variables */
 	valuestack = f->f_valuestack;
 	for (p = f->f_localsplus; p < valuestack; p++)
-		Py_CLEAR(*p);
+		Py_CLEARTS(*p);
 
 	/* Free stack */
 	if (f->f_stacktop != NULL) {
 		for (p = valuestack; p < f->f_stacktop; p++)
-			Py_XDECREF(*p);
+			Py_XDECREFTS(*p);
 	}
 
-	Py_XDECREF(f->f_back);
-	Py_DECREF(f->f_builtins);
-	Py_DECREF(f->f_globals);
-	Py_CLEAR(f->f_locals);
-	Py_CLEAR(f->f_trace);
-	Py_CLEAR(f->f_exc_type);
-	Py_CLEAR(f->f_exc_value);
-	Py_CLEAR(f->f_exc_traceback);
+	Py_XDECREFTS(f->f_back);
+	Py_DECREFTS(f->f_builtins);
+	Py_DECREFTS(f->f_globals);
+	Py_CLEARTS(f->f_locals);
+	Py_CLEARTS(f->f_trace);
+	Py_CLEARTS(f->f_exc_type);
+	Py_CLEARTS(f->f_exc_value);
+	Py_CLEARTS(f->f_exc_traceback);
 
 	co = f->f_code;
+#ifdef USE_FRAME_FREELIST
 	if (co->co_zombieframe == NULL)
 		co->co_zombieframe = f;
 	else if (numfree < MAXFREELIST) {
 		++numfree;
 		f->f_back = free_list;
 		free_list = f;
-	}
-	else 
-		PyObject_GC_Del(f);
+	} else
+		PyObject_DEL(f);
+#else
+	PyObject_DEL(f);
+#endif
 
-	Py_DECREF(co);
-	Py_TRASHCAN_SAFE_END(f)
+	Py_DECREFTS(co);
 }
 
 static int
@@ -562,7 +570,8 @@
 	}
 #endif
 	if (back == NULL || back->f_globals != globals) {
-		builtins = PyDict_GetItem(globals, builtin_object);
+		if (PyDict_GetItemEx(globals, builtin_object, &builtins) < 0)
+			return NULL;
 		if (builtins) {
 			if (PyModule_Check(builtins)) {
 				builtins = PyModule_GetDict(builtins);
@@ -572,7 +581,7 @@
 				builtins = NULL;
 		}
 		if (builtins == NULL) {
-			/* No builtins!	 Make up a minimal one
+			/* No builtins!  Make up a minimal one
 			   Give them 'None', at least. */
 			builtins = PyDict_New();
 			if (builtins == NULL ||
@@ -581,7 +590,7 @@
 				return NULL;
 		}
 		else
-			Py_INCREF(builtins);
+			Py_INCREFTS(builtins);
 
 	}
 	else {
@@ -589,27 +598,32 @@
 		   Save a lookup and a call. */
 		builtins = back->f_builtins;
 		assert(builtins != NULL && PyDict_Check(builtins));
-		Py_INCREF(builtins);
+		Py_INCREFTS(builtins);
 	}
+#ifdef USE_FRAME_FREELIST
 	if (code->co_zombieframe != NULL) {
 		f = code->co_zombieframe;
 		code->co_zombieframe = NULL;
 		_Py_NewReference((PyObject *)f);
 		assert(f->f_code == code);
-	}
-	else {
+	} else
+#endif
+        {
 		Py_ssize_t extras, ncells, nfrees;
 		ncells = PyTuple_GET_SIZE(code->co_cellvars);
 		nfrees = PyTuple_GET_SIZE(code->co_freevars);
 		extras = code->co_stacksize + code->co_nlocals + ncells +
 		    nfrees;
+#ifdef USE_FRAME_FREELIST
 		if (free_list == NULL) {
-		    f = PyObject_GC_NewVar(PyFrameObject, &PyFrame_Type,
+#endif
+		    f = PyObject_NEWVAR(PyFrameObject, &PyFrame_Type,
 			extras);
 		    if (f == NULL) {
-			    Py_DECREF(builtins);
+			    Py_DECREFTS(builtins);
 			    return NULL;
 		    }
+#ifdef USE_FRAME_FREELIST
 		}
 		else {
 		    assert(numfree > 0);
@@ -617,14 +631,23 @@
 		    f = free_list;
 		    free_list = free_list->f_back;
 		    if (Py_Size(f) < extras) {
+#if 0
 			    f = PyObject_GC_Resize(PyFrameObject, f, extras);
 			    if (f == NULL) {
-				    Py_DECREF(builtins);
+				    Py_DECREFTS(builtins);
 				    return NULL;
 			    }
+#else
+			    PyObject *tmp = PyObject_RESIZE(PyFrameObject, f, extras);
+			    if (tmp == NULL) {
+				Py_DECREF(f);
+				return NULL;
+			    }
+#endif
 		    }
 		    _Py_NewReference((PyObject *)f);
 		}
+#endif
 
 		f->f_code = code;
 		extras = code->co_nlocals + ncells + nfrees;
@@ -637,10 +660,10 @@
 	}
 	f->f_stacktop = f->f_valuestack;
 	f->f_builtins = builtins;
-	Py_XINCREF(back);
+	Py_XINCREFTS(back);
 	f->f_back = back;
-	Py_INCREF(code);
-	Py_INCREF(globals);
+	Py_INCREFTS(code);
+	Py_INCREFTS(globals);
 	f->f_globals = globals;
 	/* Most functions have CO_NEWLOCALS and CO_OPTIMIZED set. */
 	if ((code->co_flags & (CO_NEWLOCALS | CO_OPTIMIZED)) ==
@@ -649,7 +672,7 @@
 	else if (code->co_flags & CO_NEWLOCALS) {
 		locals = PyDict_New();
 		if (locals == NULL) {
-			Py_DECREF(f);
+			Py_DECREFTS(f);
 			return NULL;
 		}
 		f->f_locals = locals;
@@ -657,7 +680,7 @@
 	else {
 		if (locals == NULL)
 			locals = globals;
-		Py_INCREF(locals);
+		Py_INCREFTS(locals);
 		f->f_locals = locals;
 	}
 	f->f_tstate = tstate;
@@ -666,7 +689,6 @@
 	f->f_lineno = code->co_firstlineno;
 	f->f_iblock = 0;
 
-	_PyObject_GC_TRACK(f);
 	return f;
 }
 
@@ -886,13 +908,15 @@
 void
 PyFrame_Fini(void)
 {
+#ifdef USE_FRAME_FREELIST
 	while (free_list != NULL) {
 		PyFrameObject *f = free_list;
 		free_list = free_list->f_back;
-		PyObject_GC_Del(f);
+		PyObject_DEL(f);
 		--numfree;
 	}
 	assert(numfree == 0);
+#endif
 	Py_XDECREF(builtin_object);
 	builtin_object = NULL;
 }
Index: Objects/exceptions.c
===================================================================
--- Objects/exceptions.c	(revision 58355)
+++ Objects/exceptions.c	(working copy)
@@ -23,7 +23,7 @@
 {
     PyBaseExceptionObject *self;
 
-    self = (PyBaseExceptionObject *)type->tp_alloc(type, 0);
+    self = PyObject_NEW(PyBaseExceptionObject, type);
     if (!self)
         return NULL;
     /* the dict is created on the fly in PyObject_GenericSetAttr */
@@ -66,9 +66,8 @@
 static void
 BaseException_dealloc(PyBaseExceptionObject *self)
 {
-    _PyObject_GC_UNTRACK(self);
     BaseException_clear(self);
-    Py_Type(self)->tp_free((PyObject *)self);
+    PyObject_DEL(self);
 }
 
 static int
@@ -327,7 +326,7 @@
     PyObject_GenericSetAttr,    /*tp_setattro*/
     0,                          /*tp_as_buffer*/
     Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC |
-    	Py_TPFLAGS_BASE_EXC_SUBCLASS,  /*tp_flags*/
+    	Py_TPFLAGS_BASE_EXC_SUBCLASS | Py_TPFLAGS_SHAREABLE,  /*tp_flags*/
     PyDoc_STR("Common base class for all exceptions"), /* tp_doc */
     (traverseproc)BaseException_traverse, /* tp_traverse */
     (inquiry)BaseException_clear, /* tp_clear */
@@ -344,7 +343,6 @@
     0,                          /* tp_descr_set */
     offsetof(PyBaseExceptionObject, dict), /* tp_dictoffset */
     (initproc)BaseException_init, /* tp_init */
-    0,                          /* tp_alloc */
     BaseException_new,          /* tp_new */
 };
 /* the CPython API expects exceptions to be (PyObject *) - both a hold-over
@@ -362,11 +360,11 @@
     sizeof(PyBaseExceptionObject), \
     0, (destructor)BaseException_dealloc, 0, 0, 0, 0, 0, 0, 0, \
     0, 0, 0, 0, 0, 0, 0, \
-    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC, \
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_SHAREABLE, \
     PyDoc_STR(EXCDOC), (traverseproc)BaseException_traverse, \
     (inquiry)BaseException_clear, 0, 0, 0, 0, 0, 0, 0, &_ ## EXCBASE, \
     0, 0, 0, offsetof(PyBaseExceptionObject, dict), \
-    (initproc)BaseException_init, 0, BaseException_new,\
+    (initproc)BaseException_init, BaseException_new,\
 }; \
 PyObject *PyExc_ ## EXCNAME = (PyObject *)&_PyExc_ ## EXCNAME
 
@@ -377,11 +375,11 @@
     sizeof(Py ## EXCSTORE ## Object), \
     0, (destructor)EXCSTORE ## _dealloc, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
     0, 0, 0, 0, 0, \
-    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC, \
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_SHAREABLE, \
     PyDoc_STR(EXCDOC), (traverseproc)EXCSTORE ## _traverse, \
     (inquiry)EXCSTORE ## _clear, 0, 0, 0, 0, 0, 0, 0, &_ ## EXCBASE, \
     0, 0, 0, offsetof(Py ## EXCSTORE ## Object, dict), \
-    (initproc)EXCSTORE ## _init, 0, BaseException_new,\
+    (initproc)EXCSTORE ## _init, BaseException_new,\
 }; \
 PyObject *PyExc_ ## EXCNAME = (PyObject *)&_PyExc_ ## EXCNAME
 
@@ -392,12 +390,12 @@
     sizeof(Py ## EXCSTORE ## Object), 0, \
     (destructor)EXCSTORE ## _dealloc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \
     (reprfunc)EXCSTR, 0, 0, 0, \
-    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC, \
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_SHAREABLE, \
     PyDoc_STR(EXCDOC), (traverseproc)EXCSTORE ## _traverse, \
     (inquiry)EXCSTORE ## _clear, 0, 0, 0, 0, EXCMETHODS, \
     EXCMEMBERS, 0, &_ ## EXCBASE, \
     0, 0, 0, offsetof(Py ## EXCSTORE ## Object, dict), \
-    (initproc)EXCSTORE ## _init, 0, BaseException_new,\
+    (initproc)EXCSTORE ## _init, BaseException_new,\
 }; \
 PyObject *PyExc_ ## EXCNAME = (PyObject *)&_PyExc_ ## EXCNAME
 
@@ -463,9 +461,8 @@
 static void
 SystemExit_dealloc(PySystemExitObject *self)
 {
-    _PyObject_GC_UNTRACK(self);
     SystemExit_clear(self);
-    Py_Type(self)->tp_free((PyObject *)self);
+    PyObject_DEL(self);
 }
 
 static int
@@ -568,9 +565,8 @@
 static void
 EnvironmentError_dealloc(PyEnvironmentErrorObject *self)
 {
-    _PyObject_GC_UNTRACK(self);
     EnvironmentError_clear(self);
-    Py_Type(self)->tp_free((PyObject *)self);
+    PyObject_DEL(self);
 }
 
 static int
@@ -689,9 +685,8 @@
 static void
 WindowsError_dealloc(PyWindowsErrorObject *self)
 {
-    _PyObject_GC_UNTRACK(self);
     WindowsError_clear(self);
-    Py_Type(self)->tp_free((PyObject *)self);
+    PyObject_DEL(self);
 }
 
 static int
@@ -887,9 +882,8 @@
 static void
 SyntaxError_dealloc(PySyntaxErrorObject *self)
 {
-    _PyObject_GC_UNTRACK(self);
     SyntaxError_clear(self);
-    Py_Type(self)->tp_free((PyObject *)self);
+    PyObject_DEL(self);
 }
 
 static int
@@ -1335,9 +1329,8 @@
 static void
 UnicodeError_dealloc(PyUnicodeErrorObject *self)
 {
-    _PyObject_GC_UNTRACK(self);
     UnicodeError_clear(self);
-    Py_Type(self)->tp_free((PyObject *)self);
+    PyObject_DEL(self);
 }
 
 static int
@@ -1414,11 +1407,11 @@
     sizeof(PyUnicodeErrorObject), 0,
     (destructor)UnicodeError_dealloc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     (reprfunc)UnicodeEncodeError_str, 0, 0, 0,
-    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_SHAREABLE,
     PyDoc_STR("Unicode encoding error."), (traverseproc)UnicodeError_traverse,
     (inquiry)UnicodeError_clear, 0, 0, 0, 0, 0, UnicodeError_members,
     0, &_PyExc_UnicodeError, 0, 0, 0, offsetof(PyUnicodeErrorObject, dict),
-    (initproc)UnicodeEncodeError_init, 0, BaseException_new,
+    (initproc)UnicodeEncodeError_init, BaseException_new,
 };
 PyObject *PyExc_UnicodeEncodeError = (PyObject *)&_PyExc_UnicodeEncodeError;
 
@@ -1475,11 +1468,11 @@
     sizeof(PyUnicodeErrorObject), 0,
     (destructor)UnicodeError_dealloc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     (reprfunc)UnicodeDecodeError_str, 0, 0, 0,
-    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_SHAREABLE,
     PyDoc_STR("Unicode decoding error."), (traverseproc)UnicodeError_traverse,
     (inquiry)UnicodeError_clear, 0, 0, 0, 0, 0, UnicodeError_members,
     0, &_PyExc_UnicodeError, 0, 0, 0, offsetof(PyUnicodeErrorObject, dict),
-    (initproc)UnicodeDecodeError_init, 0, BaseException_new,
+    (initproc)UnicodeDecodeError_init, BaseException_new,
 };
 PyObject *PyExc_UnicodeDecodeError = (PyObject *)&_PyExc_UnicodeDecodeError;
 
@@ -1561,11 +1554,11 @@
     sizeof(PyUnicodeErrorObject), 0,
     (destructor)UnicodeError_dealloc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
     (reprfunc)UnicodeTranslateError_str, 0, 0, 0,
-    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_SHAREABLE,
     PyDoc_STR("Unicode translation error."), (traverseproc)UnicodeError_traverse,
     (inquiry)UnicodeError_clear, 0, 0, 0, 0, 0, UnicodeError_members,
     0, &_PyExc_UnicodeError, 0, 0, 0, offsetof(PyUnicodeErrorObject, dict),
-    (initproc)UnicodeTranslateError_init, 0, BaseException_new,
+    (initproc)UnicodeTranslateError_init, BaseException_new,
 };
 PyObject *PyExc_UnicodeTranslateError = (PyObject *)&_PyExc_UnicodeTranslateError;
 
@@ -1641,7 +1634,17 @@
  */
 SimpleExtendsException(PyExc_Exception, BufferError, "Buffer error.");
 
+/*
+ *    MultipleError extends Exception
+ */
+SimpleExtendsException(PyExc_Exception, MultipleError, "Multiple errors.");
 
+/*
+ *    Interrupted extends Exception
+ */
+SimpleExtendsException(PyExc_Exception, Interrupted, "Thread interrupted by parent.");
+
+
 /* Warning category docstrings */
 
 /*
@@ -1799,6 +1802,8 @@
     PRE_INIT(ReferenceError)
     PRE_INIT(BufferError)
     PRE_INIT(MemoryError)
+    PRE_INIT(MultipleError)
+    PRE_INIT(Interrupted)
     PRE_INIT(Warning)
     PRE_INIT(UserWarning)
     PRE_INIT(DeprecationWarning)
@@ -1859,6 +1864,8 @@
     POST_INIT(ReferenceError)
     POST_INIT(BufferError)
     POST_INIT(MemoryError)
+    POST_INIT(MultipleError)
+    POST_INIT(Interrupted)
     POST_INIT(Warning)
     POST_INIT(UserWarning)
     POST_INIT(DeprecationWarning)
Index: Objects/setobject.c
===================================================================
--- Objects/setobject.c	(revision 58355)
+++ Objects/setobject.c	(working copy)
@@ -50,10 +50,13 @@
 	INIT_NONZERO_SET_SLOTS(so);				\
     } while(0)
 
+#ifdef USE_SETS_FREELIST
 /* Reuse scheme to save calls to malloc, free, and memset */
 #define MAXFREESETS 80
 static PySetObject *free_sets[MAXFREESETS];
 static int num_free_sets = 0;
+static PyThread_type_lock free_sets_lock;
+#endif
 
 /*
 The basic lookup function used by all operations.
@@ -545,10 +548,6 @@
 {
 	register setentry *entry;
 	Py_ssize_t fill = so->fill;
-	PyObject_GC_UnTrack(so);
-	Py_TRASHCAN_SAFE_BEGIN(so)
-	if (so->weakreflist != NULL)
-		PyObject_ClearWeakRefs((PyObject *) so);
 
 	for (entry = so->table; fill > 0; entry++) {
 		if (entry->key) {
@@ -558,11 +557,18 @@
 	}
 	if (so->table != so->smalltable)
 		PyMem_DEL(so->table);
-	if (num_free_sets < MAXFREESETS && PyAnySet_CheckExact(so))
+#ifdef USE_SETS_FREELIST
+	PyThread_lock_acquire(free_sets_lock);
+	if (num_free_sets < MAXFREESETS && PyAnySet_CheckExact(so)) {
 		free_sets[num_free_sets++] = so;
-	else 
-		Py_Type(so)->tp_free(so);
-	Py_TRASHCAN_SAFE_END(so)
+		PyThread_lock_release(free_sets_lock);
+	} else {
+		PyThread_lock_release(free_sets_lock);
+#endif
+		PyObject_DEL(so);
+#ifdef USE_SETS_FREELIST
+	}
+#endif
 }
 
 static PyObject *
@@ -792,7 +798,7 @@
 setiter_dealloc(setiterobject *si)
 {
 	Py_XDECREF(si->si_set);
-	PyObject_Del(si);
+	PyObject_DEL(si);
 }
 
 static PyObject *
@@ -885,7 +891,7 @@
 static PyObject *
 set_iter(PySetObject *so)
 {
-	setiterobject *si = PyObject_New(setiterobject, &PySetIter_Type);
+	setiterobject *si = PyObject_NEW(setiterobject, &PySetIter_Type);
 	if (si == NULL)
 		return NULL;
 	Py_INCREF(so);
@@ -972,22 +978,27 @@
 	}
 
 	/* create PySetObject structure */
+#ifdef USE_SETS_FREELIST
+	PyThread_lock_acquire(free_sets_lock);
 	if (num_free_sets && 
 	    (type == &PySet_Type  ||  type == &PyFrozenSet_Type)) {
 		so = free_sets[--num_free_sets];
+		PyThread_lock_release(free_sets_lock);
 		assert (so != NULL && PyAnySet_CheckExact(so));
 		Py_Type(so) = type;
-		_Py_NewReference((PyObject *)so);
+		//_Py_NewReference((PyObject *)so);
 		EMPTY_TO_MINSIZE(so);
 		PyObject_GC_Track(so);
 	} else {
-		so = (PySetObject *)type->tp_alloc(type, 0);
+		PyThread_lock_release(free_sets_lock);
+#endif
+		so = PyObject_NEW(PySetObject, type);
 		if (so == NULL)
 			return NULL;
-		/* tp_alloc has already zeroed the structure */
-		assert(so->table == NULL && so->fill == 0 && so->used == 0);
 		INIT_NONZERO_SET_SLOTS(so);
+#ifdef USE_SETS_FREELIST
 	}
+#endif
 
 	so->lookup = set_lookkey_string;
 	so->weakreflist = NULL;
@@ -1038,17 +1049,34 @@
 }
 
 void
+_PySet_Init(void)
+{
+#ifdef USE_SETS_FREELIST
+	free_sets_lock = PyThread_lock_allocate();
+	if (!free_sets_lock)
+		Py_FatalError("unable to allocate lock");
+#endif
+}
+
+void
 PySet_Fini(void)
 {
+#ifdef USE_SETS_FREELIST
 	PySetObject *so;
 
 	while (num_free_sets) {
 		num_free_sets--;
 		so = free_sets[num_free_sets];
-		PyObject_GC_Del(so);
+		PyObject_DEL(so);
 	}
+#endif
 	Py_CLEAR(dummy);
 	Py_CLEAR(emptyfrozenset);
+
+#ifdef USE_SETS_FREELIST
+	PyThread_lock_free(free_sets_lock);
+	free_sets_lock = NULL;
+#endif
 }
 
 static PyObject *
@@ -1926,7 +1954,8 @@
 	0,				/* tp_setattro */
 	0,				/* tp_as_buffer */
 	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
-		Py_TPFLAGS_BASETYPE,	/* tp_flags */
+		Py_TPFLAGS_BASETYPE | Py_TPFLAGS_SHAREABLE,
+					/* tp_flags */
 	set_doc,			/* tp_doc */
 	(traverseproc)set_traverse,	/* tp_traverse */
 	(inquiry)set_clear_internal,	/* tp_clear */
@@ -1943,9 +1972,7 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	(initproc)set_init,		/* tp_init */
-	PyType_GenericAlloc,		/* tp_alloc */
 	set_new,			/* tp_new */
-	PyObject_GC_Del,		/* tp_free */
 };
 
 /* frozenset object ********************************************************/
@@ -2019,7 +2046,8 @@
 	0,				/* tp_setattro */
 	0,				/* tp_as_buffer */
 	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
-		Py_TPFLAGS_BASETYPE,	/* tp_flags */
+		Py_TPFLAGS_BASETYPE | Py_TPFLAGS_SHAREABLE,
+					/* tp_flags */
 	frozenset_doc,			/* tp_doc */
 	(traverseproc)set_traverse,	/* tp_traverse */
 	(inquiry)set_clear_internal,	/* tp_clear */
@@ -2036,9 +2064,7 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	0,				/* tp_init */
-	PyType_GenericAlloc,		/* tp_alloc */
 	frozenset_new,			/* tp_new */
-	PyObject_GC_Del,		/* tp_free */
 };
 
 
Index: Objects/funcobject.c
===================================================================
--- Objects/funcobject.c	(revision 58355)
+++ Objects/funcobject.c	(working copy)
@@ -9,7 +9,7 @@
 PyObject *
 PyFunction_New(PyObject *code, PyObject *globals)
 {
-	PyFunctionObject *op = PyObject_GC_New(PyFunctionObject,
+	PyFunctionObject *op = PyObject_NEW(PyFunctionObject,
 					    &PyFunction_Type);
 	static PyObject *__name__ = 0;
 	if (op != NULL) {
@@ -50,15 +50,14 @@
 				return NULL;
 			}
 		}
-		module = PyDict_GetItem(globals, __name__);
-		if (module) {
-		    Py_INCREF(module);
-		    op->func_module = module;
+		if (PyDict_GetItemEx(globals, __name__, &module) < 0) {
+			Py_DECREF(op);
+			return NULL;
 		}
+		op->func_module = module;
 	}
 	else
 		return NULL;
-	_PyObject_GC_TRACK(op);
 	return (PyObject *)op;
 }
 
@@ -549,9 +548,6 @@
 static void
 func_dealloc(PyFunctionObject *op)
 {
-	_PyObject_GC_UNTRACK(op);
-	if (op->func_weakreflist != NULL)
-		PyObject_ClearWeakRefs((PyObject *) op);
 	Py_DECREF(op->func_code);
 	Py_DECREF(op->func_globals);
 	Py_XDECREF(op->func_module);
@@ -562,7 +558,7 @@
 	Py_XDECREF(op->func_dict);
 	Py_XDECREF(op->func_closure);
 	Py_XDECREF(op->func_annotations);
-	PyObject_GC_Del(op);
+	PyObject_DEL(op);
 }
 
 static PyObject*
@@ -648,6 +644,13 @@
 	return PyMethod_New(func, obj, type);
 }
 
+static int
+func_isshareable(PyFunctionObject *f)
+{
+	/* XXX FIXME this is a bodge.  Shareable should be a flag and result in the usual shareable limitations */
+	return PyObject_IsShareable(f->func_globals);
+}
+
 PyTypeObject PyFunction_Type = {
 	PyVarObject_HEAD_INIT(&PyType_Type, 0)
 	"function",
@@ -685,8 +688,14 @@
 	0,					/* tp_descr_set */
 	offsetof(PyFunctionObject, func_dict),	/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	func_new,				/* tp_new */
+	0,					/* tp_is_gc */
+	0,					/* tp_bases */
+	0,					/* tp_mro */
+	0,					/* tp_cache */
+	0,					/* tp_subclasses */
+	0,					/* tp_weaklist */
+	(isshareablefunc)func_isshareable,	/* tp_isshareable */
 };
 
 
@@ -717,9 +726,8 @@
 static void
 cm_dealloc(classmethod *cm)
 {
-	_PyObject_GC_UNTRACK((PyObject *)cm);
 	Py_XDECREF(cm->cm_callable);
-	Py_Type(cm)->tp_free((PyObject *)cm);
+	PyObject_DEL(cm);
 }
 
 static int
@@ -774,6 +782,12 @@
 	return 0;
 }
 
+static int
+cm_isshareable(classmethod *cm)
+{
+	return PyObject_IsShareable(cm->cm_callable);
+}
+
 PyDoc_STRVAR(classmethod_doc,
 "classmethod(function) -> method\n\
 \n\
@@ -815,7 +829,8 @@
 	PyObject_GenericGetAttr,		/* tp_getattro */
 	0,					/* tp_setattro */
 	0,					/* tp_as_buffer */
-	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |
+		Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_SHAREABLE,
 	classmethod_doc,			/* tp_doc */
 	(traverseproc)cm_traverse,		/* tp_traverse */
 	(inquiry)cm_clear,			/* tp_clear */
@@ -832,16 +847,20 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	cm_init,				/* tp_init */
-	PyType_GenericAlloc,			/* tp_alloc */
 	PyType_GenericNew,			/* tp_new */
-	PyObject_GC_Del,	                /* tp_free */
+	0,					/* tp_is_gc */
+	0,					/* tp_bases */
+	0,					/* tp_mro */
+	0,					/* tp_cache */
+	0,					/* tp_subclasses */
+	0,					/* tp_weaklist */
+	(isshareablefunc)cm_isshareable,	/* tp_isshareable */
 };
 
 PyObject *
 PyClassMethod_New(PyObject *callable)
 {
-	classmethod *cm = (classmethod *)
-		PyType_GenericAlloc(&PyClassMethod_Type, 0);
+	classmethod *cm = PyObject_NEW(classmethod, &PyClassMethod_Type);
 	if (cm != NULL) {
 		Py_INCREF(callable);
 		cm->cm_callable = callable;
@@ -874,9 +893,8 @@
 static void
 sm_dealloc(staticmethod *sm)
 {
-	_PyObject_GC_UNTRACK((PyObject *)sm);
 	Py_XDECREF(sm->sm_callable);
-	Py_Type(sm)->tp_free((PyObject *)sm);
+	PyObject_DEL(sm);
 }
 
 static int
@@ -924,6 +942,12 @@
 	return 0;
 }
 
+static int
+sm_isshareable(staticmethod *sm)
+{
+	return PyObject_IsShareable(sm->sm_callable);
+}
+
 PyDoc_STRVAR(staticmethod_doc,
 "staticmethod(function) -> method\n\
 \n\
@@ -962,7 +986,8 @@
 	PyObject_GenericGetAttr,		/* tp_getattro */
 	0,					/* tp_setattro */
 	0,					/* tp_as_buffer */
-	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_HAVE_GC,
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |
+		Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_SHAREABLE,
 	staticmethod_doc,			/* tp_doc */
 	(traverseproc)sm_traverse,		/* tp_traverse */
 	(inquiry)sm_clear,			/* tp_clear */
@@ -979,16 +1004,20 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	sm_init,				/* tp_init */
-	PyType_GenericAlloc,			/* tp_alloc */
 	PyType_GenericNew,			/* tp_new */
-	PyObject_GC_Del,           		/* tp_free */
+	0,					/* tp_is_gc */
+	0,					/* tp_bases */
+	0,					/* tp_mro */
+	0,					/* tp_cache */
+	0,					/* tp_subclasses */
+	0,					/* tp_weaklist */
+	(isshareablefunc)sm_isshareable,	/* tp_isshareable */
 };
 
 PyObject *
 PyStaticMethod_New(PyObject *callable)
 {
-	staticmethod *sm = (staticmethod *)
-		PyType_GenericAlloc(&PyStaticMethod_Type, 0);
+	staticmethod *sm = PyObject_NEW(staticmethod, &PyStaticMethod_Type);
 	if (sm != NULL) {
 		Py_INCREF(callable);
 		sm->sm_callable = callable;
Index: Objects/branchobject.c
===================================================================
--- Objects/branchobject.c	(revision 0)
+++ Objects/branchobject.c	(revision 0)
@@ -0,0 +1,805 @@
+
+#include "Python.h"
+#include "ceval.h"
+#include "interruptobject.h"
+#include "branchobject.h"
+
+
+/* Branch methods */
+
+static void branch_baseinterrupt(struct _PyInterruptQueue *queue, void *arg);
+static void branchchild_interrupt(PyInterruptQueue *queue, void *arg);
+static int branch_add_common(PyBranchObject *self, PyObject *args,
+    PyObject *kwds, char *name, int saveresult);
+static void branch_threadbootstrap(void *arg);
+static int branch_spawn_thread(PyBranchObject *self, PyObject *func,
+    PyObject *args, PyObject *kwds, char *name, int save_result);
+
+static void BranchChild_Delete(PyBranchChild *child);
+static void BranchChild_DeleteWithResult(PyBranchChild *child);
+static void BranchChild_DeleteWithException(PyBranchChild *child);
+static void _push_child(PyBranchObject *self, PyBranchChild *child);
+static void _pop_child(PyBranchObject *self, PyBranchChild *child);
+
+static PyObject *Branch_getresults(PyBranchObject *self);
+static void Branch_raiseexception(PyBranchObject *self);
+
+static PyObject *
+Branch_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
+{
+    PyBranchObject *self;
+
+    assert(type != NULL);
+
+    self = PyObject_NEW(PyBranchObject, type);
+    if (self == NULL)
+        return NULL;
+
+    self->col_lock = PyThread_lock_allocate();
+    if (self->col_lock == NULL) {
+        PyObject_DEL(self);
+        PyErr_SetString(PyExc_RuntimeError, "can't allocate lock");
+        return NULL;
+    }
+
+    self->col_state = BRANCH_NEW;
+    self->col_ownerthread = NULL;
+    self->col_threads = NULL;
+    self->col_head = NULL;
+    self->col_tail = NULL;
+
+    self->col_threadcount = 0;
+    self->col_nothreads = PyThread_sem_allocate(1);
+    if (self->col_nothreads == NULL) {
+        PyThread_lock_free(self->col_lock);
+        PyObject_DEL(self);
+        PyErr_SetString(PyExc_RuntimeError, "can't allocate semaphore");
+        return NULL;
+    }
+    self->col_baseinterrupt = NULL;
+
+    self->col_interrupting = 0;
+    self->col_resultcount = 0;
+    self->col_exceptioncount = 0;
+
+    return (PyObject *)self;
+}
+
+static void
+Branch_dealloc(PyBranchObject *self)
+{
+    if (self->col_state != BRANCH_NEW && self->col_state != BRANCH_DEAD)
+        Py_FatalError("Invalid state in Branch_dealloc()");
+    if (self->col_threadcount != 0)
+        Py_FatalError("Remaining threads in Branch_dealloc()");
+
+    PyThread_lock_free(self->col_lock);
+    PyThread_sem_free(self->col_nothreads);
+
+    assert(self->col_baseinterrupt == NULL);
+
+    while (self->col_head) {
+        PyBranchChild *child = self->col_head;
+        _pop_child(self, child);
+        BranchChild_DeleteWithResult(child);
+        self->col_resultcount--;
+    }
+
+    assert(self->col_resultcount == 0);
+    assert(self->col_exceptioncount == 0);
+
+    PyObject_DEL(self);
+}
+
+static PyBranchChild *
+BranchChild_New(PyBranchObject *branch, PyObject *func, PyObject *args,
+        PyObject *kwds)
+{
+    PyBranchChild *child;
+
+    child = malloc(sizeof(PyBranchChild));
+    if (child == NULL) {
+        PyErr_NoMemory();
+        return NULL;
+    }
+    child->interp = PyThreadState_Get()->interp;
+    child->tstate = NULL;
+    child->interrupt_point = PyInterrupt_New(branchchild_interrupt,
+            NULL, NULL);
+    if (child->interrupt_point == NULL) {
+        free(child);
+        PyErr_NoMemory();
+        return NULL;
+    }
+    child->branch = branch;
+
+    Py_INCREF(func);
+    child->func = func;
+    Py_INCREF(args);
+    child->args = args;
+    Py_XINCREF(kwds);
+    child->kwds = kwds;
+
+    child->save_result = 0;
+    child->result = NULL;
+    child->exception = NULL;
+    child->prev = NULL;
+    child->next = NULL;
+
+    return child;
+}
+
+static void
+BranchChild_Delete(PyBranchChild *child)
+{
+    Py_DECREF(child->interrupt_point);
+
+    assert(child->prev == NULL);
+    assert(child->next == NULL);
+
+    assert(child->result == NULL);
+    assert(child->exception == NULL);
+
+    Py_XDECREF(child->func);
+    Py_XDECREF(child->args);
+    Py_XDECREF(child->kwds);
+
+    free(child);
+}
+
+static void
+BranchChild_DeleteWithResult(PyBranchChild *child)
+{
+    Py_DECREF(child->interrupt_point);
+
+    assert(child->prev == NULL);
+    assert(child->next == NULL);
+
+    Py_XDECREF(child->result);
+    assert(child->exception == NULL);
+
+    Py_XDECREF(child->func);
+    Py_XDECREF(child->args);
+    Py_XDECREF(child->kwds);
+
+    free(child);
+}
+
+static void
+BranchChild_DeleteWithException(PyBranchChild *child)
+{
+    Py_DECREF(child->interrupt_point);
+
+    assert(child->prev == NULL);
+    assert(child->next == NULL);
+
+    assert(child->result == NULL);
+    Py_XDECREF(child->exception);
+
+    Py_XDECREF(child->func);
+    Py_XDECREF(child->args);
+    Py_XDECREF(child->kwds);
+
+    free(child);
+}
+
+static void
+branchchild_interrupt(PyInterruptQueue *queue, void *arg)
+{
+    Py_FatalError("branchchild_interrupt called");
+    /* XXX FIXME */
+}
+
+static PyObject *
+Branch___enter__(PyBranchObject *self)
+{
+    PyInterruptObject *baseinterrupt;
+    PyBranchChild *mainchild = BranchChild_New(self, Py_None, Py_None, Py_None);
+    if (mainchild == NULL)
+        return NULL;
+
+    baseinterrupt = PyInterrupt_New(branch_baseinterrupt, self, NULL);
+    if (baseinterrupt == NULL) {
+        BranchChild_Delete(mainchild);
+        return NULL;
+    }
+
+    /* Begin unlocked region */
+    PyState_Suspend();
+    PyThread_lock_acquire(self->col_lock);
+
+    if (self->col_state != BRANCH_NEW) {
+        PyThread_lock_release(self->col_lock);
+        PyState_Resume();
+        /* End unlocked region */
+
+        Py_DECREF(baseinterrupt);
+        BranchChild_Delete(mainchild);
+        PyErr_SetString(PyExc_TypeError, "branch.__enter__() called in "
+            "wrong state");
+        return NULL;
+    }
+
+    self->col_mainthread = mainchild;
+    _push_child(self, mainchild);
+    /* XXX setup interrupt stack for current thread */
+    self->col_baseinterrupt = baseinterrupt;
+    PyInterrupt_Push(self->col_baseinterrupt);
+    PyInterrupt_Push(self->col_mainthread->interrupt_point);
+
+    self->col_state = BRANCH_ALIVE;
+
+    PyThread_lock_release(self->col_lock);
+    PyState_Resume();
+    /* End unlocked region */
+
+    Py_INCREF(self);
+    return (PyObject *)self;
+}
+
+static PyObject *
+Branch___exit__(PyBranchObject *self, PyObject *args)
+{
+    PyInterruptQueue queue;
+    int run_queue = 0;
+    PyObject *type, *val, *tb;
+    int delete_child = 0;
+
+    if (!PyArg_ParseTuple(args, "OOO", &type, &val, &tb))
+        Py_FatalError("Branch.__exit__() got bad arguments");
+
+    if (type == Py_None)
+        val = NULL;
+    else {
+        Py_INCREF(type);
+        Py_INCREF(val);
+        Py_INCREF(tb);
+        val = PyErr_SimplifyException(type, val, tb);
+    }
+
+    /* Begin unlocked region */
+    PyState_Suspend();
+    PyThread_lock_acquire(self->col_lock);
+
+    assert(self->col_state == BRANCH_ALIVE);
+    self->col_state = BRANCH_DYING;
+
+    /* XXX pop interrupt stack for current thread */
+    if (val != NULL) {
+        self->col_exceptioncount++;
+        self->col_mainthread->exception = val;
+        if (self->col_exceptioncount == 1) {
+            PyBranchChild *child;
+
+            PyInterruptQueue_Init(&queue);
+            for (child = self->col_head; child; child = child->next)
+                PyInterruptQueue_Add(&queue, child->interrupt_point);
+            run_queue = 1;
+        }
+    } else
+        delete_child = 1;
+
+    PyThread_lock_release(self->col_lock);
+    /* We release the GIL *and* branch's lock */
+
+    if (run_queue) {
+        PyState_Resume();
+        PyInterruptQueue_Finish(&queue);
+        PyState_Suspend();
+    }
+
+    /* Wait until nothreads is 1 (true, there are no threads)
+     * Sets it to 0 as a side effect */
+    PyThread_sem_wait(self->col_nothreads);
+
+    /* We reacquire branch's lock but NOT the GIL */
+    PyThread_lock_acquire(self->col_lock);
+
+    assert(self->col_threadcount == 0);
+    assert(self->col_state == BRANCH_DYING);
+    self->col_state = BRANCH_DEAD;
+
+    PyThread_lock_release(self->col_lock);
+    PyState_Resume();
+    /* End unlocked region */
+
+    /* Now that we're dead it's safe to check our variables without
+     * acquiring the lock */
+
+    PyInterrupt_Pop(self->col_mainthread->interrupt_point);
+    PyInterrupt_Pop(self->col_baseinterrupt);
+    Py_CLEAR(self->col_baseinterrupt);
+
+    if (delete_child) {
+        _pop_child(self, self->col_mainthread);
+        BranchChild_Delete(self->col_mainthread);
+        self->col_mainthread = NULL;
+    }
+
+    if (self->col_exceptioncount && self->col_resultcount) {
+        /* Purge the results so they're not mixed with the exceptions */
+        PyBranchChild *next = self->col_head;
+        while (next) {
+            PyBranchChild *child = next;
+            next = child->next;
+
+            if (child->result != NULL) {
+                _pop_child(self, child);
+                BranchChild_DeleteWithResult(child);
+                self->col_resultcount--;
+            }
+        }
+        assert(self->col_resultcount == 0);
+    }
+
+    if (self->col_exceptioncount) {
+        Branch_raiseexception(self);
+        return NULL;
+    } else {
+        Py_INCREF(Py_None);
+        return Py_None;
+    }
+}
+
+static void
+branch_baseinterrupt(struct _PyInterruptQueue *queue, void *arg)
+{
+    PyBranchChild *child;
+    PyBranchObject *self = (PyBranchObject *)arg;
+
+    PyThread_lock_acquire(self->col_lock);
+    self->col_interrupting = 1;
+    for (child = self->col_head; child; child = child->next) {
+        PyInterruptQueue_Add(queue, child->interrupt_point);
+    }
+    PyThread_lock_release(self->col_lock);
+}
+
+static PyObject *
+Branch_add(PyBranchObject *self, PyObject *args, PyObject *kwds)
+{
+    if (!branch_add_common(self, args, kwds, "branch.add", 0))
+        return NULL;
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+static PyObject *
+Branch_addresult(PyBranchObject *self, PyObject *args, PyObject *kwds)
+{
+    if (!branch_add_common(self, args, kwds, "branch.addresult", 1))
+        return NULL;
+
+    Py_INCREF(Py_None);
+    return Py_None;
+}
+
+static int
+branch_add_common(PyBranchObject *self, PyObject *args, PyObject *kwds,
+        char *name, int saveresult)
+{
+    PyObject *func;
+    PyObject *smallargs;
+
+    if (PyTuple_Size(args) < 1) {
+        PyErr_Format(PyExc_TypeError, "%s() needs a function to be "
+            "called", name);
+        return 0;
+    }
+
+    func = PyTuple_GetItem(args, 0);
+
+    if (!PyObject_IsShareable(func)) {
+        PyErr_Format(PyExc_TypeError, "%s()'s function argument must be "
+            "shareable, '%s' object is not", name, func->ob_type->tp_name);
+        return 0;
+    }
+
+    smallargs = PyTuple_GetSlice(args, 1, PyTuple_Size(args));
+    if (smallargs == NULL) {
+        return 0;
+    }
+
+    if (!PyArg_RequireShareable(name, smallargs, kwds)) {
+        Py_DECREF(smallargs);
+        return 0;
+    }
+
+    if (!branch_spawn_thread(self, func, smallargs, kwds, name, saveresult)) {
+        Py_DECREF(smallargs);
+        return 0;
+    }
+
+    Py_DECREF(smallargs);
+    return 1;
+}
+
+static int
+branch_spawn_thread(PyBranchObject *self, PyObject *func, PyObject *args,
+        PyObject *kwds, char *name, int save_result)
+{
+    PyBranchChild *child;
+    PyObject *exc;
+    const char *format;
+
+    child = BranchChild_New(self, func, args, kwds);
+    if (child == NULL)
+        return 0;
+    child->save_result = save_result;
+
+    child->tstate = _PyThreadState_New();
+    if (child->tstate == NULL) {
+        BranchChild_Delete(child);
+        PyErr_NoMemory();
+        return 0;
+    }
+
+    if (self->col_interrupting)
+        /* XXX FIXME this is a hack! */
+        child->interrupt_point->interrupted = 1;
+
+    /* Begin unlocked region */
+    PyState_Suspend();
+    PyThread_lock_acquire(self->col_lock);
+
+    if (self->col_state != BRANCH_ALIVE) {
+        exc = PyExc_TypeError;
+        format = "%s() called in wrong state";
+        goto failed;
+    }
+
+    if (PyThreadState_Get()->import_depth)
+        Py_FatalError("importing is not thread-safe");
+
+    _push_child(self, child);
+
+    if (PyThread_start_new_thread(NULL, branch_threadbootstrap, child) < 0) {
+        exc = PyExc_RuntimeError;
+        format = "%s can't spawn new thread";
+        goto failed;
+    }
+
+    if (self->col_threadcount == 0) {
+        /* Set nothreads to 0 (false, there is a thread) */
+        PyThread_sem_wait(self->col_nothreads);
+    }
+    self->col_threadcount++;
+
+    PyThread_lock_release(self->col_lock);
+    PyState_Resume();
+    /* End unlocked region */
+    return 1;
+
+failed:
+    if (self->col_tail == child)
+        _pop_child(self, child);
+    PyThread_lock_release(self->col_lock);
+    PyState_Resume();
+    /* End unlocked region */
+
+    if (child->tstate)
+        _PyThreadState_Delete(child->tstate);
+    BranchChild_Delete(child);
+
+    if (exc != NULL)
+        PyErr_Format(exc, format, name);
+    else
+        PyErr_NoMemory();
+
+    return 0;
+}
+
+static void
+branch_threadbootstrap(void *arg)
+{
+    PyInterruptQueue queue;
+    int run_queue = 0;
+    PyBranchChild *child = (PyBranchChild *)arg;
+    PyState_EnterTag entertag;
+    PyBranchObject *branch = child->branch;
+    int delete_child = 0;
+
+    entertag = _PyState_EnterPreallocated(child->tstate);
+    if (!entertag) {
+        /* Because we preallocate everything, it should be
+         * impossible to fail. */
+        Py_FatalError("PyState_EnterPreallocated failed");
+    }
+
+    PyInterrupt_Push(child->interrupt_point);
+
+    child->result = PyObject_Call(child->func, child->args, child->kwds);
+    if (!PyArg_RequireShareableReturn("branch._threadbootstrap",
+            child->func, child->result))
+        Py_CLEAR(child->result);
+
+    PyInterrupt_Pop(child->interrupt_point);
+
+    Py_CLEAR(child->func);
+    Py_CLEAR(child->args);
+    Py_CLEAR(child->kwds);
+
+    if (child->result != NULL) {
+        if (!child->save_result)
+            Py_DECREF(child->result);
+    } else {
+        PyObject *type, *val, *tb;
+        PyErr_Fetch(&type, &val, &tb);
+        child->exception = PyErr_SimplifyException(type, val, tb);
+    }
+
+    /* Begin unlocked region */
+    PyState_Suspend();
+    PyThread_lock_acquire(branch->col_lock);
+
+    if (child->result != NULL) {
+        if (child->save_result)
+            branch->col_resultcount++;
+        else {
+            /* XXX child->result was DECREF's earlier */
+            child->result = NULL;
+            _pop_child(branch, child);
+            //BranchChild_Delete(child);
+            delete_child = 1;
+        }
+    } else {
+        branch->col_exceptioncount++;
+        if (branch->col_exceptioncount == 1) {
+            PyBranchChild *otherchild;
+
+            PyInterruptQueue_Init(&queue);
+            for (otherchild = branch->col_head; otherchild;
+                    otherchild = otherchild->next)
+                PyInterruptQueue_Add(&queue, otherchild->interrupt_point);
+            run_queue = 1;
+        }
+    }
+
+    PyThread_lock_release(branch->col_lock);
+    PyState_Resume();
+    /* End unlocked region */
+
+    if (delete_child)
+        BranchChild_Delete(child);
+
+    if (run_queue)
+        PyInterruptQueue_Finish(&queue);
+
+    PyState_Exit(entertag);
+
+    /* This part is evil.  We've already released all our access to
+     * the interpreter, but we're going to access branch's lock,
+     * threadcount, and semaphore anyway.  This should work so long
+     * as there's a main thread with its own refcount blocked on the
+     * semaphore/lock.  It also assumes that the unlock function
+     * stops touching the lock's memory as soon as it allows the
+     * main thread to run. */
+    PyThread_lock_acquire(branch->col_lock);
+
+    branch->col_threadcount--;
+    if (branch->col_threadcount == 0) {
+        /* Set nothreads to 1 (true, there are no threads) */
+        PyThread_sem_post(branch->col_nothreads);
+    }
+
+    PyThread_lock_release(branch->col_lock);
+}
+
+static void
+_push_child(PyBranchObject *self, PyBranchChild *child)
+{
+    child->next = NULL;
+    child->prev = self->col_tail;
+    if (self->col_tail == NULL) {
+        self->col_head = child;
+        self->col_tail = child;
+    } else {
+        self->col_tail->next = child;
+        self->col_tail = child;
+    }
+}
+
+static void
+_pop_child(PyBranchObject *self, PyBranchChild *child)
+{
+    if (child->prev != NULL)
+        child->prev->next = child->next;
+    if (child->next != NULL)
+        child->next->prev = child->prev;
+    if (self->col_tail == child)
+        self->col_tail = child->prev;
+    if (self->col_head == child)
+        self->col_head = child->next;
+
+    child->prev = NULL;
+    child->next = NULL;
+}
+
+static PyObject *
+Branch_getresults(PyBranchObject *self)
+{
+    int state;
+    PyObject *results;
+    Py_ssize_t i;
+
+    /* Begin unlocked region */
+    PyState_Suspend();
+    PyThread_lock_acquire(self->col_lock);
+
+    state = self->col_state;
+
+    PyThread_lock_release(self->col_lock);
+    PyState_Resume();
+    /* End unlocked region */
+
+    if (state != BRANCH_DEAD) {
+        PyErr_SetString(PyExc_TypeError, "branch.getresults() called in "
+            "wrong state");
+        return NULL;
+    }
+
+    /* Once we know the state is BRANCH_DEAD we can be sure no
+     * other threads will access us.  Thus, we can rely on the GIL. */
+
+    assert(!self->col_exceptioncount);
+
+    results = PyList_New(self->col_resultcount);
+    if (results == NULL)
+        return NULL;
+
+    i = 0;
+    while (self->col_head) {
+        assert(i < self->col_resultcount);
+        PyBranchChild *child = self->col_head;
+
+        _pop_child(self, child);
+        assert(child->exception == NULL);
+        assert(child->result != NULL);
+
+        /* Copy across, stealing references */
+        PyList_SET_ITEM(results, i, child->result);
+        child->result = NULL;
+        BranchChild_Delete(child);
+        i++;
+    }
+    assert(i == self->col_resultcount);
+    self->col_resultcount = 0;
+    return results;
+}
+
+static void
+Branch_raiseexception(PyBranchObject *self)
+{
+    Py_ssize_t i;
+    PyObject *causes;
+    PyObject *interesting = NULL;
+    int multiple = 0;
+    PyObject *type, *val, *tb;
+
+    assert(self->col_state == BRANCH_DEAD);
+    assert(self->col_resultcount == 0);
+    assert(self->col_exceptioncount);
+
+    causes = PyTuple_New(self->col_exceptioncount);
+    if (causes == NULL) {
+        PyErr_NoMemory();
+        goto failed;
+    }
+
+    i = 0;
+    while (self->col_head) {
+        PyBranchChild *child = self->col_head;
+        PyObject *tup;
+
+        assert(i < self->col_exceptioncount);
+        _pop_child(self, child);
+
+        assert(child->result == NULL);
+        assert(child->exception != NULL);
+
+        if (!PyErr_GivenExceptionMatches(child->exception,
+                PyExc_Interrupted)) {
+            if (interesting != NULL) {
+                Py_DECREF(interesting);
+                interesting = NULL;
+                multiple = 1;
+            } else if (!multiple) {
+                Py_INCREF(child->exception);
+                interesting = child->exception;
+            }
+        }
+
+        Py_INCREF(child->exception);
+        PyTuple_SET_ITEM(causes, i, child->exception);
+        BranchChild_DeleteWithException(child);
+        i++;
+    }
+
+    if (interesting) {
+        PyErr_SetObject((PyObject *)Py_Type(interesting),
+            ((PyBaseExceptionObject *)interesting)->args);
+        Py_DECREF(interesting);
+    } else if (self->col_interrupting && !multiple)
+        PyErr_SetNone(PyExc_Interrupted);
+    else
+        PyErr_SetNone(PyExc_MultipleError);
+
+    PyErr_Fetch(&type, &val, &tb);
+    PyErr_NormalizeException(&type, &val, &tb);
+    PyException_SetCause(val, causes); /* Consumes a reference to causes */
+    PyErr_Restore(type, val, tb);
+
+    assert(i == self->col_exceptioncount);
+    self->col_exceptioncount = 0;
+    return;
+
+failed:
+    while (self->col_head) {
+        PyBranchChild *child = self->col_head;
+        _pop_child(self, child);
+        BranchChild_DeleteWithException(child);
+    }
+    self->col_exceptioncount = 0;
+}
+
+PyDoc_STRVAR(Branch___enter____doc__, "");
+PyDoc_STRVAR(Branch___exit____doc__, "");
+PyDoc_STRVAR(Branch_add__doc__, "add(func, *args, **kwargs) -> None");
+PyDoc_STRVAR(Branch_addresult__doc__, "addresult(func, *args, **kwargs) -> None");
+PyDoc_STRVAR(Branch_getresults__doc__, "getresults() -> list");
+
+static PyMethodDef Branch_methods[] = {
+    {"__enter__",       (PyCFunction)Branch___enter__,  METH_NOARGS,
+        Branch___enter____doc__},
+    {"__exit__",        (PyCFunction)Branch___exit__,   METH_VARARGS,
+        Branch___exit____doc__},
+    {"add",             (PyCFunction)Branch_add,        METH_VARARGS | METH_KEYWORDS,
+        Branch_add__doc__},
+    {"addresult",       (PyCFunction)Branch_addresult,  METH_VARARGS | METH_KEYWORDS,
+        Branch_addresult__doc__},
+    {"getresults",      (PyCFunction)Branch_getresults, METH_NOARGS,
+        Branch_getresults__doc__},
+    {NULL,              NULL}  /* sentinel */
+};
+
+PyTypeObject PyBranch_Type = {
+    PyVarObject_HEAD_INIT(&PyType_Type, 0)
+    "_threadtoolsmodule.branch",        /*tp_name*/
+    sizeof(PyBranchObject),             /*tp_basicsize*/
+    0,                                  /*tp_itemsize*/
+    (destructor)Branch_dealloc,         /*tp_dealloc*/
+    0,                                  /*tp_print*/
+    0,                                  /*tp_getattr*/
+    0,                                  /*tp_setattr*/
+    0,                                  /*tp_compare*/
+    0,                                  /*tp_repr*/
+    0,                                  /*tp_as_number*/
+    0,                                  /*tp_as_sequence*/
+    0,                                  /*tp_as_mapping*/
+    0,                                  /*tp_hash*/
+    0,                                  /*tp_call*/
+    0,                                  /*tp_str*/
+    PyObject_GenericGetAttr,            /*tp_getattro*/
+    0,                                  /*tp_setattro*/
+    0,                                  /*tp_as_buffer*/
+    Py_TPFLAGS_DEFAULT | Py_TPFLAGS_SHAREABLE,  /*tp_flags*/
+    0,                                  /*tp_doc*/
+    0,                                  /*tp_traverse*/
+    0,                                  /*tp_clear*/
+    0,                                  /*tp_richcompare*/
+    0,                                  /*tp_weaklistoffset*/
+    0,                                  /*tp_iter*/
+    0,                                  /*tp_iternext*/
+    Branch_methods,                     /*tp_methods*/
+    0,                                  /*tp_members*/
+    0,                                  /*tp_getset*/
+    0,                                  /*tp_base*/
+    0,                                  /*tp_dict*/
+    0,                                  /*tp_descr_get*/
+    0,                                  /*tp_descr_set*/
+    0,                                  /*tp_dictoffset*/
+    0,                                  /*tp_init*/
+    Branch_new,                         /*tp_new*/
+};
+
Index: Objects/sliceobject.c
===================================================================
--- Objects/sliceobject.c	(revision 58355)
+++ Objects/sliceobject.c	(working copy)
@@ -22,6 +22,12 @@
 	return PyUnicode_FromString("Ellipsis");
 }
 
+static int
+ellipsis_isshareable(PyObject *op)
+{
+	return 1;
+}
+
 static PyTypeObject PyEllipsis_Type = {
 	PyVarObject_HEAD_INIT(&PyType_Type, 0)
 	"ellipsis",			/* tp_name */
@@ -42,13 +48,41 @@
 	PyObject_GenericGetAttr,	/* tp_getattro */
 	0,				/* tp_setattro */
 	0,				/* tp_as_buffer */
-	Py_TPFLAGS_DEFAULT,		/* tp_flags */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_SHAREABLE,
+					/* tp_flags */
+	0,				/* tp_doc */
+	0,				/* tp_traverse */
+	0,				/* tp_clear */
+	0,				/* tp_richcompare */
+	0,				/* tp_weaklistoffset */
+	0,				/* tp_iter */
+	0,				/* tp_iternext */
+	0,				/* tp_methods */
+	0,				/* tp_members */
+	0,				/* tp_getset */
+	0,				/* tp_base */
+	0,				/* tp_dict */
+	0,				/* tp_descr_get */
+	0,				/* tp_descr_set */
+	0,				/* tp_dictoffset */
+	0,				/* tp_init */
+	0,				/* tp_new */
+	0,				/* tp_is_gc */
+	0,				/* tp_bases */
+	0,				/* tp_mro */
+	0,				/* tp_cache */
+	0,				/* tp_subclasses */
+	0,				/* tp_weaklist */
+	ellipsis_isshareable,		/* tp_isshareable */
 };
 
+/*
 PyObject _Py_EllipsisObject = {
 	_PyObject_EXTRA_INIT
-	1, &PyEllipsis_Type
+	1, {}, &PyEllipsis_Type
 };
+*/
+PyObject _Py_EllipsisObject = PyObject_HEAD_INIT_NOCOMMA(&PyEllipsis_Type);
 
 
 /* Slice object implementation
@@ -60,7 +94,7 @@
 PyObject *
 PySlice_New(PyObject *start, PyObject *stop, PyObject *step)
 {
-	PySliceObject *obj = PyObject_New(PySliceObject, &PySlice_Type);
+	PySliceObject *obj = PyObject_NEW(PySliceObject, &PySlice_Type);
 
 	if (obj == NULL)
 		return NULL;
@@ -220,7 +254,7 @@
 	Py_DECREF(r->step);
 	Py_DECREF(r->start);
 	Py_DECREF(r->stop);
-	PyObject_Del(r);
+	PyObject_DEL(r);
 }
 
 static PyObject *
@@ -362,7 +396,7 @@
 	PyObject_GenericGetAttr,		/* tp_getattro */
 	0,					/* tp_setattro */
 	0,					/* tp_as_buffer */
-	Py_TPFLAGS_DEFAULT,			/* tp_flags */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_SHAREABLE,	/* tp_flags */
 	slice_doc,				/* tp_doc */
 	0,					/* tp_traverse */
 	0,					/* tp_clear */
@@ -379,6 +413,5 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	slice_new,				/* tp_new */
 };
Index: Objects/longobject.c
===================================================================
--- Objects/longobject.c	(revision 58355)
+++ Objects/longobject.c	(working copy)
@@ -58,7 +58,7 @@
 /* If a freshly-allocated long is already shared, it must
    be a small integer, so negating it must go to PyLong_FromLong */
 #define NEGATE(x) \
-	do if (Py_Refcnt(x) == 1) Py_Size(x) = -Py_Size(x);  \
+	do if (Py_RefcntMatches(x, 1)) Py_Size(x) = -Py_Size(x);  \
 	   else { PyObject* tmp=PyInt_FromLong(-MEDIUM_VALUE(x));  \
 		   Py_DECREF(x); (x) = (PyLongObject*)tmp; }	   \
         while(0)
@@ -89,12 +89,6 @@
 static PyLongObject *muladd1(PyLongObject *, wdigit, wdigit);
 static PyLongObject *divrem1(PyLongObject *, digit, digit *);
 
-#define SIGCHECK(PyTryBlock) \
-	if (--_Py_Ticker < 0) { \
-		_Py_Ticker = _Py_CheckInterval; \
-		if (PyErr_CheckSignals()) PyTryBlock \
-	}
-
 /* Normalize (remove leading zeros from) a long int object.
    Doesn't attempt to free the storage--in most cases, due to the nature
    of the algorithms used, this could save at most be one word anyway. */
@@ -118,7 +112,7 @@
 PyLongObject *
 _PyLong_New(Py_ssize_t size)
 {
-	PyLongObject *result;
+	//PyLongObject *result;
 	/* Can't use sizeof(PyLongObject) here, since the
 	   compiler takes padding at the end into account.
 	   As the consequence, this would waste 2 bytes on
@@ -126,13 +120,18 @@
 	   This computation would be incorrect on systems
 	   which have padding before the digits; with 16-bit
 	   digits this should not happen. */
-	result = PyObject_MALLOC(sizeof(PyVarObject) + 
-				 size*sizeof(digit));
-	if (!result) {
-		PyErr_NoMemory();
-		return NULL;
-	}
-	return (PyLongObject*)PyObject_INIT_VAR(result, &PyLong_Type, size);
+	//result = PyObject_MALLOC(sizeof(PyVarObject) + 
+	//			 size*sizeof(digit));
+	//result = (PyLongObject *) _PyObject_GC_Malloc(sizeof(PyVarObject) +
+	//		size * sizeof(digit));
+	/* XXX FIXME _PyObject_GC_Malloc already calls PyErr_NoMemory */
+	//if (!result) {
+	//	PyErr_NoMemory();
+	//	return NULL;
+	//}
+	//return (PyLongObject*)PyObject_INIT_VAR(result, &PyLong_Type, size);
+	/* XXX FIXME reduce extra size somehow */
+	return PyObject_NEWVAR(PyLongObject, &PyLong_Type, size);
 }
 
 PyObject *
@@ -172,6 +171,15 @@
 
 	CHECK_SMALL_INT(ival);
 
+#if 0
+	{
+		static AO_t count;
+		AO_t cur = AO_fetch_and_add1_full(&count);
+		if ((cur % 100) == 0)
+			printf("count: %llu\n", (unsigned long long)cur);
+	}
+#endif
+
 	if (ival < 0) {
 		ival = -ival;
 		sign = -1;
@@ -191,6 +199,8 @@
 	if (!(ival >> 2*PyLong_SHIFT)) {
 		v = _PyLong_New(2);
 		if (v) {
+			//printf("Moo: long %p  value %08ld  thread %p\n", v, ival, PyThreadState_Get());
+			//printf("Moo: long %p  thread %p\n", v, PyThreadState_Get());
 			Py_Size(v) = 2*sign;
 			v->ob_digit[0] = (digit)ival & PyLong_MASK;
 			v->ob_digit[1] = ival >> PyLong_SHIFT;
@@ -1512,11 +1522,11 @@
 			pin = scratch->ob_digit; /* no need to use a again */
 			if (pin[size - 1] == 0)
 				--size;
-			SIGCHECK({
+			if (PyThreadState_Tick()) {
 				Py_DECREF(scratch);
 				Py_DECREF(str);
 				return NULL;
-			})
+			}
 
 			/* Break rem into digits. */
 			assert(ntostore > 0);
@@ -2043,7 +2053,7 @@
 	}
 
 	assert(size_v >= size_w && size_w > 1); /* Assert checks by div() */
-	assert(Py_Refcnt(v) == 1); /* Since v will be used as accumulator! */
+	assert(Py_RefcntMatches(v, 1)); /* Since v will be used as accumulator! */
 	assert(size_w == ABS(Py_Size(w))); /* That's how d was calculated */
 
 	size_v = ABS(Py_Size(v));
@@ -2056,11 +2066,11 @@
 		stwodigits carry = 0;
 		int i;
 
-		SIGCHECK({
+		if (PyThreadState_Tick()) {
 			Py_DECREF(a);
 			a = NULL;
 			break;
-		})
+		}
 		if (vj == w->ob_digit[size_w-1])
 			q = PyLong_MASK;
 		else
@@ -2129,7 +2139,7 @@
 static void
 long_dealloc(PyObject *v)
 {
-	Py_Type(v)->tp_free(v);
+	PyObject_Del(v);
 }
 
 static PyObject *
@@ -2396,10 +2406,10 @@
 			digit *pa = a->ob_digit + i + 1;
 			digit *paend = a->ob_digit + size_a;
 
-			SIGCHECK({
+			if (PyThreadState_Tick()) {
 				Py_DECREF(z);
 				return NULL;
-			})
+			}
 
 			carry = *pz + f * f;
 			*pz++ = (digit)(carry & PyLong_MASK);
@@ -2434,10 +2444,10 @@
 			digit *pb = b->ob_digit;
 			digit *pbend = b->ob_digit + size_b;
 
-			SIGCHECK({
+			if (PyThreadState_Tick()) {
 				Py_DECREF(z);
 				return NULL;
-			})
+			}
 
 			while (pb < pbend) {
 				carry += *pz + *pb++ * f;
@@ -3507,7 +3517,7 @@
 	n = Py_Size(tmp);
 	if (n < 0)
 		n = -n;
-	newobj = (PyLongObject *)type->tp_alloc(type, n);
+	newobj = PyObject_NEWVAR(PyLongObject, type, n);
 	if (newobj == NULL) {
 		Py_DECREF(tmp);
 		return NULL;
@@ -3531,6 +3541,12 @@
 	return PyLong_FromLong((intptr_t)context);
 }
 
+static int
+long_isshareable (PyObject *v)
+{
+	return PyLong_CheckExact(v);
+}
+
 static PyObject *
 long__format__(PyObject *self, PyObject *args)
 {
@@ -3677,7 +3693,8 @@
 	0,					/* tp_setattro */
 	0,					/* tp_as_buffer */
 	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |
-		Py_TPFLAGS_LONG_SUBCLASS,	/* tp_flags */
+		Py_TPFLAGS_LONG_SUBCLASS |
+		Py_TPFLAGS_SHAREABLE,		/* tp_flags */
 	long_doc,				/* tp_doc */
 	0,					/* tp_traverse */
 	0,					/* tp_clear */
@@ -3694,11 +3711,19 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	long_new,				/* tp_new */
-	PyObject_Del,                           /* tp_free */
+	0,					/* tp_is_gc */
+	0,					/* tp_bases */
+	0,					/* tp_mro */
+	0,					/* tp_cache */
+	0,					/* tp_subclasses */
+	0,					/* tp_weaklist */
+	long_isshareable,			/* tp_isshareable */
 };
 
+static const PyLongObject dummy = 
+	{PyVarObject_HEAD_INIT_NOCOMMA(&PyLong_Type, 0)};
+
 int
 _PyLong_Init(void)
 {
@@ -3706,12 +3731,12 @@
 	int ival;
 	PyLongObject *v = small_ints;
 	for (ival = -NSMALLNEGINTS; ival < 0; ival++, v++) {
-		PyObject_INIT(v, &PyLong_Type);
+		*v = dummy;
 		Py_Size(v) = -1;
 		v->ob_digit[0] = -ival;
 	}
 	for (; ival < NSMALLPOSINTS; ival++, v++) {
-		PyObject_INIT(v, &PyLong_Type);
+		*v = dummy;
 		Py_Size(v) = ival ? 1 : 0;
 		v->ob_digit[0] = ival;
 	}
Index: Objects/obmalloc.c
===================================================================
--- Objects/obmalloc.c	(revision 58355)
+++ Objects/obmalloc.c	(working copy)
@@ -1,6 +1,224 @@
 #include "Python.h"
 
+#include <pthread.h>
+
+
+#if 0
+#define CFPRINT(...) do {char buf[1024]; snprintf(buf, 1024, __VA_ARGS__); write(2, buf, strlen(buf)); } while(0)
+#elif 0
+#define CFPRINT(...) do {dprintf(2, __VA_ARGS__)} while (0)
+#else
+#define CFPRINT(...) do {} while (0)
+#endif
+
+PyThreadState * (*pymalloc_threadstate_hook)(void);
+
+static pthread_mutex_t pymemwrap_lock = PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP;
+
+#define GET_SIZE(size_class) ((size_class) <= 0 ? size_classes[-(size_class)] : (size_class))
+
+/* XXX Must match up with PYMALLOC_CACHE_SIZECLASSES */
+static const Py_ssize_t size_classes[] = {
+	32,
+	48,
+	64,
+	96,
+	128,
+	192,
+	256,
+	384,
+	512,
+	768,
+	1024,
+	1536,
+	2048,
+};
+
+static Py_ssize_t
+find_size_class(size_t size)
+{
+	Py_ssize_t i;
+
+	assert(sizeof(size_classes) / sizeof(*size_classes) ==
+			PYMALLOC_CACHE_SIZECLASSES);
+	if (size > size_classes[PYMALLOC_CACHE_SIZECLASSES - 1])
+		return size; /* Too large to cache */
+
+	for (i = 0; ; i++) {
+		if (size <= size_classes[i])
+			return -i;
+	}
+}
+
+
+void *
+pymemcache_malloc(size_t size)
+{
+	void *mem;
+	Py_ssize_t size_class = find_size_class(size);
+
+	if (pymalloc_threadstate_hook != NULL && size_class <= 0) {
+		PyThreadState *tstate = pymalloc_threadstate_hook();
+		Py_ssize_t i;
+
+		for (i = 0; i < PYMALLOC_CACHE_COUNT; i++) {
+			if (tstate->malloc_cache[-size_class][i] != NULL) {
+				mem = tstate->malloc_cache[-size_class][i];
+				tstate->malloc_cache[-size_class][i] = NULL;
+				//printf("%p Cache hit!        %8d\n", tstate, size_class);
+				return mem;
+			}
+		}
+	}
+	//printf("%p Cache miss.       %8d\n", pymalloc_threadstate_hook(), size_class);
+
+	mem = malloc(GET_SIZE(size_class) + sizeof(Py_ssize_t));
+	if (mem == NULL)
+		return NULL;
+	*((Py_ssize_t *)mem) = size_class;
+	return mem + sizeof(Py_ssize_t);
+}
+
+void *
+pymemcache_realloc(void *old_inner_mem, size_t size)
+{
+	void *old_outer_mem;
+	void *new_outer_mem;
+	Py_ssize_t old_size_class;
+	Py_ssize_t new_size_class = find_size_class(size);
+
+	if (old_inner_mem == NULL)
+		old_outer_mem = NULL;
+	else {
+		old_outer_mem = old_inner_mem - sizeof(Py_ssize_t);
+		old_size_class = *((Py_ssize_t *)old_outer_mem);
+		if (old_size_class == new_size_class)
+			return old_inner_mem;  /* That was easy */
+	}
+
+	new_outer_mem = realloc(old_outer_mem, GET_SIZE(new_size_class) + sizeof(Py_ssize_t));
+	if (new_outer_mem == NULL)
+		return NULL;
+	*((Py_ssize_t *)new_outer_mem) = new_size_class;
+	return new_outer_mem + sizeof(Py_ssize_t);
+}
+
+void
+pymemcache_free(void *inner_mem)
+{
+	void *outer_mem;
+	Py_ssize_t size_class;
+
+	if (inner_mem == NULL)
+		return;
+	outer_mem = inner_mem - sizeof(Py_ssize_t);
+	size_class = *((Py_ssize_t *)outer_mem);
+
+	if (pymalloc_threadstate_hook != NULL && size_class <= 0) {
+		PyThreadState *tstate = pymalloc_threadstate_hook();
+		Py_ssize_t i;
+
+		for (i = 0; i < PYMALLOC_CACHE_COUNT; i++) {
+			if (tstate->malloc_cache[-size_class][i] == NULL) {
+				tstate->malloc_cache[-size_class][i] = inner_mem;
+                //printf("%p Cached filled.    %8d\n", tstate, size_class);
+				return;
+			}
+		}
+	}
+    //printf("%p Cache not filled. %8d\n", pymalloc_threadstate_hook(), size_class);
+
+	free(outer_mem);
+}
+
+
+void *
+_pymemwrap_malloc(const char *name, const char *group, size_t size)
+{
+#if 1
+	return pymemcache_malloc(size);
+#elif 1
+	if (size == 0)
+		/*Py_FatalError("No size!");*/
+		size = 1;
+	return malloc(size);
+#else
+	void *innermem;
+	void *outermem;
+	pthread_mutex_lock(&pymemwrap_lock);
+	size += sizeof(size_t) * 100;
+	if (size == 0)
+		/*Py_FatalError("No size!");*/
+		size = 1;
+	outermem = malloc(size);
+	if (outermem != NULL)
+		innermem = outermem + sizeof(size_t) * 50;
+	else
+		innermem = NULL;
+	CFPRINT("%s + %p (%d) %s\n", #group, outermem, size, #name);
+	pthread_mutex_unlock(&pymemwrap_lock);
+	return innermem;
+#endif
+}
+
+void *
+_pymemwrap_realloc(const char *name, const char *group, void *oldinnermem, size_t size)
+{
+#if 1
+	return pymemcache_realloc(oldinnermem, size);
+#elif 1
+	if (size == 0)
+		/*Py_FatalError("No size!");*/
+		size = 1;
+	return realloc(oldinnermem, size);
+#else
+	void *oldoutermem, *newinnermem, *newoutermem;
+	pthread_mutex_lock(&pymemwrap_lock);
+	CFPRINT("%s - %p %s\n", #group, oldoutermem, #name);
+	if (oldinnermem != NULL)
+		oldoutermem = oldinnermem - sizeof(size_t) * 50;
+	else
+		oldoutermem = NULL;
+	size += sizeof(size_t) * 100;
+	if (size == 0)
+		/*Py_FatalError("No size!");*/
+		size = 1;
+	newoutermem = realloc(oldoutermem, size);
+	if (newoutermem != NULL)
+		newinnermem = newoutermem + sizeof(size_t) * 50;
+	else
+		newinnermem = NULL;
+	CFPRINT("%s + %p from %p (%d) %s\n", #group, newoutermem, oldoutermem, size, #name);
+	pthread_mutex_unlock(&pymemwrap_lock);
+	return newinnermem;
+#endif
+}
+
+void
+_pymemwrap_free(const char *name, const char *group, void *innermem)
+{
+#if 1
+	pymemcache_free(innermem);
+#elif 1
+	free(innermem);
+#else
+	void *outermem;
+	pthread_mutex_lock(&pymemwrap_lock);
+	if (innermem != NULL)
+		outermem = innermem - sizeof(size_t) * 50;
+	else
+		outermem = NULL;
+	CFPRINT("%s - %p %s\n", #group, outermem, #name);
+	free(outermem);
+	pthread_mutex_unlock(&pymemwrap_lock);
+#endif
+}
+
+
 #ifdef WITH_PYMALLOC
+#ifdef WITH_FREETHREAD
+//#error "WITH_FREETHREAD is incompatible with WITH_PYMALLOC"
+#endif
 
 /* An object allocator for Python.
 
@@ -717,10 +935,38 @@
  * Unless the optimizer reorders everything, being too smart...
  */
 
+PyThreadState * (*pymalloc_threadstate_hook)(void);
+
 #undef PyObject_Malloc
 void *
 PyObject_Malloc(size_t nbytes)
 {
+#if 1
+	unsigned char *mem;
+    Py_FatalError("MOOO");
+
+	if (nbytes < 4)
+		nbytes = 4;
+	if (nbytes >= 14 && nbytes < 16)
+		nbytes = 16;
+
+	if (pymalloc_threadstate_hook != NULL) {
+		PyThreadState *tstate = pymalloc_threadstate_hook();
+		if (tstate->malloc_cache != NULL && *(size_t *)tstate->malloc_cache >= nbytes) {
+			mem = tstate->malloc_cache;
+			//printf("Using   cached mem: %p %p %d %d\n", tstate, mem, nbytes, *(size_t *)mem);
+			tstate->malloc_cache = NULL;
+			return mem + sizeof(size_t);
+		}
+	}
+
+	mem = malloc(nbytes + sizeof(size_t));
+	if (mem == NULL)
+		return NULL;
+
+	*(size_t *)mem = nbytes;
+	return mem + sizeof(size_t);
+#else
 	block *bp;
 	poolp pool;
 	poolp next;
@@ -900,6 +1146,7 @@
 	if (nbytes == 0)
 		nbytes = 1;
 	return (void *)malloc(nbytes);
+#endif
 }
 
 /* free */
@@ -908,6 +1155,28 @@
 void
 PyObject_Free(void *p)
 {
+#if 1
+	unsigned char *mem;
+	size_t nbytes;
+
+	if (p == NULL)
+		return;
+
+	mem = p - sizeof(size_t);
+	nbytes = *(size_t *)mem;
+
+	if (pymalloc_threadstate_hook != NULL) {
+		PyThreadState *tstate = pymalloc_threadstate_hook();
+		if (tstate->malloc_cache == NULL && nbytes >= 14) {
+			tstate->malloc_cache = mem;
+			//printf("Storing cached mem: %p %p %d\n", tstate, mem, nbytes);
+			return;
+		}
+	}
+
+	//printf("Mooo, free of %d %p\n", nbytes, mem);
+	free(mem);
+#else
 	poolp pool;
 	block *lastfree;
 	poolp next, prev;
@@ -1112,6 +1381,7 @@
 
 	/* We didn't allocate this address. */
 	free(p);
+#endif
 }
 
 /* realloc.  If p is NULL, this acts like malloc(nbytes).  Else if nbytes==0,
@@ -1123,6 +1393,23 @@
 void *
 PyObject_Realloc(void *p, size_t nbytes)
 {
+#if 1
+	unsigned char *mem;
+
+	if (p == NULL)
+		return PyObject_Malloc(nbytes);
+
+	mem = p - sizeof(size_t);
+	if (nbytes < 4)
+		nbytes = 4;
+
+	mem = realloc(mem, nbytes + sizeof(size_t));
+	if (mem == NULL)
+		return NULL;
+
+	*(size_t *)mem = nbytes;
+	return mem + sizeof(size_t);
+#else
 	void *bp;
 	poolp pool;
 	size_t size;
@@ -1177,6 +1464,7 @@
 	 */
 	bp = realloc(p, 1);
    	return bp ? bp : p;
+#endif
 }
 
 #else	/* ! WITH_PYMALLOC */
@@ -1185,6 +1473,7 @@
 /* pymalloc not enabled:  Redirect the entry points to malloc.  These will
  * only be used by extensions that are compiled with pymalloc enabled. */
 
+#if 0
 void *
 PyObject_Malloc(size_t n)
 {
@@ -1202,6 +1491,7 @@
 {
 	PyMem_FREE(p);
 }
+#endif
 #endif /* WITH_PYMALLOC */
 
 #ifdef PYMALLOC_DEBUG
Index: Objects/iterobject.c
===================================================================
--- Objects/iterobject.c	(revision 58355)
+++ Objects/iterobject.c	(working copy)
@@ -17,22 +17,20 @@
 		PyErr_BadInternalCall();
 		return NULL;
 	}	
-	it = PyObject_GC_New(seqiterobject, &PySeqIter_Type);
+	it = PyObject_NEW(seqiterobject, &PySeqIter_Type);
 	if (it == NULL)
 		return NULL;
 	it->it_index = 0;
 	Py_INCREF(seq);
 	it->it_seq = seq;
-	_PyObject_GC_TRACK(it);
 	return (PyObject *)it;
 }
 
 static void
 iter_dealloc(seqiterobject *it)
 {
-	_PyObject_GC_UNTRACK(it);
 	Py_XDECREF(it->it_seq);
-	PyObject_GC_Del(it);
+	PyObject_DEL(it);
 }
 
 static int
@@ -138,23 +136,21 @@
 PyCallIter_New(PyObject *callable, PyObject *sentinel)
 {
 	calliterobject *it;
-	it = PyObject_GC_New(calliterobject, &PyCallIter_Type);
+	it = PyObject_NEW(calliterobject, &PyCallIter_Type);
 	if (it == NULL)
 		return NULL;
 	Py_INCREF(callable);
 	it->it_callable = callable;
 	Py_INCREF(sentinel);
 	it->it_sentinel = sentinel;
-	_PyObject_GC_TRACK(it);
 	return (PyObject *)it;
 }
 static void
 calliter_dealloc(calliterobject *it)
 {
-	_PyObject_GC_UNTRACK(it);
 	Py_XDECREF(it->it_callable);
 	Py_XDECREF(it->it_sentinel);
-	PyObject_GC_Del(it);
+	PyObject_DEL(it);
 }
 
 static int
@@ -291,7 +287,7 @@
                 PyTuple_SET_ITEM(result, i, Py_None);
         }
 	
-	zipiter = PyObject_GC_New(zipiterobject, &PyZipIter_Type);
+	zipiter = PyObject_NEW(zipiterobject, &PyZipIter_Type);
 	if (zipiter == NULL) {
 		Py_DECREF(ziptuple);
 		Py_DECREF(result);
@@ -301,17 +297,15 @@
 	zipiter->result = (PyTupleObject*) result;
         zipiter->resultsize = tuplesize;
 	zipiter->it_tuple = (PyTupleObject *) ziptuple;
-	_PyObject_GC_TRACK(zipiter);
 	return (PyObject *)zipiter;
 }
 
 static void
 zipiter_dealloc(zipiterobject *it)
 {
-	_PyObject_GC_UNTRACK(it);
 	Py_XDECREF(it->it_tuple);
 	Py_XDECREF(it->result);
-	PyObject_GC_Del(it);
+	PyObject_DEL(it);
 }
 
 static int
@@ -333,7 +327,7 @@
         if (tuplesize == 0)
                 return NULL;
 
-        if (result->ob_refcnt == 1) {
+        if (Py_RefcntMatches(result, 1)) {
 		Py_INCREF(result);
 		for (i = 0; i < tuplesize; i++) {
 			PyObject *it = PyTuple_GET_ITEM(zit->it_tuple, i);
Index: Objects/enumobject.c
===================================================================
--- Objects/enumobject.c	(revision 58355)
+++ Objects/enumobject.c	(working copy)
@@ -20,7 +20,7 @@
 					 &seq))
 		return NULL;
 
-	en = (enumobject *)type->tp_alloc(type, 0);
+	en = PyObject_NEW(enumobject, type);
 	if (en == NULL)
 		return NULL;
 	en->en_index = 0;
@@ -40,10 +40,9 @@
 static void
 enum_dealloc(enumobject *en)
 {
-	PyObject_GC_UnTrack(en);
 	Py_XDECREF(en->en_sit);
 	Py_XDECREF(en->en_result);
-	Py_Type(en)->tp_free(en);
+	PyObject_DEL(en);
 }
 
 static int
@@ -79,7 +78,7 @@
 	}
 	en->en_index++;
 
-	if (result->ob_refcnt == 1) {
+	if (Py_RefcntMatches(result, 1)) {
 		Py_INCREF(result);
 		Py_DECREF(PyTuple_GET_ITEM(result, 0));
 		Py_DECREF(PyTuple_GET_ITEM(result, 1));
@@ -126,7 +125,8 @@
 	0,                              /* tp_setattro */
 	0,                              /* tp_as_buffer */
 	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
-		Py_TPFLAGS_BASETYPE,    /* tp_flags */
+		Py_TPFLAGS_BASETYPE | Py_TPFLAGS_SHAREABLE,
+					/* tp_flags */
 	enum_doc,                       /* tp_doc */
 	(traverseproc)enum_traverse,    /* tp_traverse */
 	0,                              /* tp_clear */
@@ -143,9 +143,7 @@
 	0,                              /* tp_descr_set */
 	0,                              /* tp_dictoffset */
 	0,                              /* tp_init */
-	PyType_GenericAlloc,            /* tp_alloc */
 	enum_new,                       /* tp_new */
-	PyObject_GC_Del,                /* tp_free */
 };
 
 /* Reversed Object ***************************************************************/
@@ -179,7 +177,7 @@
 	if (n == -1)
 		return NULL;
 
-	ro = (reversedobject *)type->tp_alloc(type, 0);
+	ro = PyObject_NEW(reversedobject, type);
 	if (ro == NULL)
 		return NULL;
 
@@ -192,9 +190,8 @@
 static void
 reversed_dealloc(reversedobject *ro)
 {
-	PyObject_GC_UnTrack(ro);
 	Py_XDECREF(ro->seq);
-	Py_Type(ro)->tp_free(ro);
+	PyObject_DEL(ro);
 }
 
 static int
@@ -273,7 +270,8 @@
 	0,                              /* tp_setattro */
 	0,                              /* tp_as_buffer */
 	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
-		Py_TPFLAGS_BASETYPE,    /* tp_flags */
+		Py_TPFLAGS_BASETYPE | Py_TPFLAGS_SHAREABLE,
+					/* tp_flags */
 	reversed_doc,                   /* tp_doc */
 	(traverseproc)reversed_traverse,/* tp_traverse */
 	0,                              /* tp_clear */
@@ -290,7 +288,5 @@
 	0,                              /* tp_descr_set */
 	0,                              /* tp_dictoffset */
 	0,                              /* tp_init */
-	PyType_GenericAlloc,            /* tp_alloc */
 	reversed_new,                   /* tp_new */
-	PyObject_GC_Del,                /* tp_free */
 };
Index: Objects/classobject.c
===================================================================
--- Objects/classobject.c	(revision 58355)
+++ Objects/classobject.c	(working copy)
@@ -2,6 +2,7 @@
 
 #include "Python.h"
 #include "structmember.h"
+#include "pythread.h"
 
 #define TP_DESCR_GET(t) ((t)->tp_descr_get)
 
@@ -42,8 +43,12 @@
    (b) as unbound methods (returned by ClassName.methodname)
    In case (b), im_self is NULL
 */
+//#define USE_METHOD_FREELIST
 
+#ifdef USE_METHOD_FREELIST
 static PyMethodObject *free_list;
+static PyThread_type_lock free_list_lock;
+#endif
 
 PyObject *
 PyMethod_New(PyObject *func, PyObject *self, PyObject *klass)
@@ -53,16 +58,23 @@
 		PyErr_BadInternalCall();
 		return NULL;
 	}
+#ifdef USE_METHOD_FREELIST
+	PyThread_lock_acquire(free_list_lock);
 	im = free_list;
 	if (im != NULL) {
 		free_list = (PyMethodObject *)(im->im_self);
+		PyThread_lock_release(free_list_lock);
 		PyObject_INIT(im, &PyMethod_Type);
 	}
 	else {
-		im = PyObject_GC_New(PyMethodObject, &PyMethod_Type);
+		PyThread_lock_release(free_list_lock);
+#endif
+		im = PyObject_NEW(PyMethodObject, &PyMethod_Type);
 		if (im == NULL)
 			return NULL;
+#ifdef USE_METHOD_FREELIST
 	}
+#endif
 	im->im_weakreflist = NULL;
 	Py_INCREF(func);
 	im->im_func = func;
@@ -70,7 +82,7 @@
 	im->im_self = self;
 	Py_XINCREF(klass);
 	im->im_class = klass;
-	_PyObject_GC_TRACK(im);
+	PyObject_COMPLETE(im);
 	return (PyObject *)im;
 }
 
@@ -119,22 +131,22 @@
 	PyTypeObject *tp = obj->ob_type;
 	PyObject *descr = NULL;
 
-	{
-		if (tp->tp_dict == NULL) {
-			if (PyType_Ready(tp) < 0)
-				return NULL;
-		}
-		descr = _PyType_Lookup(tp, name);
+	if (tp->tp_dict == NULL) {
+		if (PyType_Ready(tp) < 0)
+			return NULL;
 	}
+	if (_PyType_LookupEx(tp, name, &descr) < 0)
+		return NULL;
 
 	if (descr != NULL) {
 		descrgetfunc f = TP_DESCR_GET(descr->ob_type);
-		if (f != NULL)
-			return f(descr, obj, (PyObject *)obj->ob_type);
-		else {
-			Py_INCREF(descr);
+		if (f != NULL) {
+			PyObject *result = f(descr, obj,
+				(PyObject *)obj->ob_type);
+			Py_DECREF(descr);
+			return result;
+		} else
 			return descr;
-		}
 	}
 
 	return PyObject_GetAttr(im->im_func, name);
@@ -176,14 +188,17 @@
 static void
 method_dealloc(register PyMethodObject *im)
 {
-	_PyObject_GC_UNTRACK(im);
-	if (im->im_weakreflist != NULL)
-		PyObject_ClearWeakRefs((PyObject *)im);
 	Py_DECREF(im->im_func);
 	Py_XDECREF(im->im_self);
 	Py_XDECREF(im->im_class);
+#ifdef USE_METHOD_FREELIST
+	PyThread_lock_acquire(free_list_lock);
 	im->im_self = (PyObject *)free_list;
 	free_list = im;
+	PyThread_lock_release(free_list_lock);
+#else
+	PyObject_DEL(im);
+#endif
 }
 
 static PyObject *
@@ -425,6 +440,14 @@
 	return PyMethod_New(PyMethod_GET_FUNCTION(meth), obj, cls);
 }
 
+static int
+method_isshareable(PyMethodObject *a)
+{
+	return (PyObject_IsShareable(a->im_func) &&
+		(a->im_self == NULL || PyObject_IsShareable(a->im_self)) &&
+		(a->im_class == NULL || PyObject_IsShareable(a->im_class)));
+}
+
 PyTypeObject PyMethod_Type = {
 	PyVarObject_HEAD_INIT(&PyType_Type, 0)
 	"method",
@@ -445,7 +468,7 @@
 	method_getattro,			/* tp_getattro */
 	PyObject_GenericSetAttr,		/* tp_setattro */
 	0,					/* tp_as_buffer */
-	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC, /* tp_flags */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC | Py_TPFLAGS_SKIPWIPE, /* tp_flags */
 	method_doc,				/* tp_doc */
 	(traverseproc)method_traverse,		/* tp_traverse */
 	0,					/* tp_clear */
@@ -462,18 +485,39 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	method_new,				/* tp_new */
+	0,					/* tp_is_gc */
+	0,					/* tp_bases */
+	0,					/* tp_mro */
+	0,					/* tp_cache */
+	0,					/* tp_subclasses */
+	0,					/* tp_weaklist */
+	(isshareablefunc)method_isshareable,	/* tp_isshareable */
 };
 
+void
+_PyMethod_Init(void)
+{
+#ifdef USE_METHOD_FREELIST
+	free_list_lock = PyThread_lock_allocate();
+	if (!free_list_lock)
+		Py_FatalError("unable to allocate lock");
+#endif
+}
+
 /* Clear out the free list */
 
 void
 PyMethod_Fini(void)
 {
+#ifdef USE_METHOD_FREELIST
 	while (free_list) {
 		PyMethodObject *im = free_list;
 		free_list = (PyMethodObject *)(im->im_self);
-		PyObject_GC_Del(im);
+		PyObject_DEL(im);
 	}
+
+	PyThread_lock_free(free_list_lock);
+	free_list_lock = NULL;
+#endif
 }
Index: Objects/floatobject.c
===================================================================
--- Objects/floatobject.c	(revision 58355)
+++ Objects/floatobject.c	(working copy)
@@ -5,6 +5,7 @@
    for any kind of float exception without losing portability. */
 
 #include "Python.h"
+#include "pythread.h"
 
 #include "formatter_unicode.h"
 
@@ -15,51 +16,75 @@
 extern double pow(double, double);
 #endif
 
+#ifndef WITH_FREETHREAD
+#define USE_FLOAT_FREELIST
+#endif
+
+#ifdef USE_FLOAT_FREELIST
 /* Special free list -- see comments for same code in intobject.c. */
 #define BLOCK_SIZE	1000	/* 1K less typical malloc overhead */
 #define BHEAD_SIZE	8	/* Enough for a 64-bit pointer */
 #define N_FLOATOBJECTS	((BLOCK_SIZE - BHEAD_SIZE) / sizeof(PyFloatObject))
 
-struct _floatblock {
+typedef struct _floatblock {
 	struct _floatblock *next;
 	PyFloatObject objects[N_FLOATOBJECTS];
-};
+} PyFloatBlock;
 
-typedef struct _floatblock PyFloatBlock;
-
 static PyFloatBlock *block_list = NULL;
 static PyFloatObject *free_list = NULL;
 
 static PyFloatObject *
-fill_free_list(void)
+add_float_block(void)
 {
-	PyFloatObject *p, *q;
+	PyFloatBlock *block;
+	int i;
+
 	/* XXX Float blocks escape the object heap. Use PyObject_MALLOC ??? */
-	p = (PyFloatObject *) PyMem_MALLOC(sizeof(PyFloatBlock));
-	if (p == NULL)
-		return (PyFloatObject *) PyErr_NoMemory();
-	((PyFloatBlock *)p)->next = block_list;
-	block_list = (PyFloatBlock *)p;
-	p = &((PyFloatBlock *)p)->objects[0];
-	q = p + N_FLOATOBJECTS;
-	while (--q > p)
-		Py_Type(q) = (struct _typeobject *)(q-1);
-	Py_Type(q) = NULL;
-	return p + N_FLOATOBJECTS - 1;
+	block = PyMem_MALLOC(sizeof(PyFloatBlock));
+	if (block == NULL)
+		return NULL;
+
+	block->next = block_list;
+	block_list = block;
+
+	for (i = 0; i < N_FLOATOBJECTS; i++) {
+		PyObject *op = (PyObject *)&block->objects[i];
+		PyObject dummy = PyObject_HEAD_INIT_NOCOMMA(&PyFloat_Type);
+		*op = dummy;
+		if ((i + 1) < N_FLOATOBJECTS)
+			Py_Type(op) = (struct _typeobject *)(&block->objects[i + 1]);
+		else
+			Py_Type(op) = NULL;
+	}
+
+	return &block->objects[0];
 }
+#endif
 
 PyObject *
 PyFloat_FromDouble(double fval)
 {
 	register PyFloatObject *op;
+	static unsigned int count;
+	count++;
+#ifdef USE_FLOAT_FREELIST
 	if (free_list == NULL) {
-		if ((free_list = fill_free_list()) == NULL)
+		if ((free_list = add_float_block()) == NULL) {
+			PyErr_NoMemory();
 			return NULL;
+		}
 	}
 	/* Inline PyObject_New */
 	op = free_list;
 	free_list = (PyFloatObject *)Py_Type(op);
 	PyObject_INIT(op, &PyFloat_Type);
+#else
+	op = PyObject_NEW(PyFloatObject, &PyFloat_Type);
+	//printf("New float %p\n", op);
+	if (op == NULL)
+		return NULL;
+#endif
 	op->ob_fval = fval;
 	return (PyObject *) op;
 }
@@ -153,12 +178,19 @@
 static void
 float_dealloc(PyFloatObject *op)
 {
+	static unsigned int count;
+	count++;
 	if (PyFloat_CheckExact(op)) {
+#ifdef USE_FLOAT_FREELIST
 		Py_Type(op) = (struct _typeobject *)free_list;
 		free_list = op;
+#else
+		PyObject_DEL(op);
+#endif
 	}
 	else
-		Py_Type(op)->tp_free((PyObject *)op);
+		PyObject_DEL(op);
+	//printf("Deleted float %p\n", op);
 }
 
 double
@@ -849,7 +881,8 @@
 	if (tmp == NULL)
 		return NULL;
 	assert(PyFloat_CheckExact(tmp));
-	newobj = type->tp_alloc(type, 0);
+	newobj = PyObject_New(type);
+	//printf("New float subtype_new %p\n", newobj);
 	if (newobj == NULL) {
 		Py_DECREF(tmp);
 		return NULL;
@@ -1110,7 +1143,8 @@
 	PyObject_GenericGetAttr,		/* tp_getattro */
 	0,					/* tp_setattro */
 	0,					/* tp_as_buffer */
-	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |
+		Py_TPFLAGS_SHAREABLE,		/* tp_flags */
 	float_doc,				/* tp_doc */
  	0,					/* tp_traverse */
 	0,					/* tp_clear */
@@ -1127,7 +1161,6 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	float_new,				/* tp_new */
 };
 
@@ -1184,6 +1217,7 @@
 void
 PyFloat_Fini(void)
 {
+#ifdef USE_FLOAT_FREELIST
 	PyFloatObject *p;
 	PyFloatBlock *list, *next;
 	unsigned i;
@@ -1202,7 +1236,7 @@
 		for (i = 0, p = &list->objects[0];
 		     i < N_FLOATOBJECTS;
 		     i++, p++) {
-			if (PyFloat_CheckExact(p) && Py_Refcnt(p) != 0)
+			if (PyFloat_CheckExact(p) && !Py_RefcntMatches(p, 1))
 				frem++;
 		}
 		next = list->next;
@@ -1213,7 +1247,7 @@
 			     i < N_FLOATOBJECTS;
 			     i++, p++) {
 				if (!PyFloat_CheckExact(p) ||
-				    Py_Refcnt(p) == 0) {
+				    Py_RefcntMatches(p, 1)) {
 					Py_Type(p) = (struct _typeobject *)
 						free_list;
 					free_list = p;
@@ -1246,7 +1280,7 @@
 			     i < N_FLOATOBJECTS;
 			     i++, p++) {
 				if (PyFloat_CheckExact(p) &&
-				    Py_Refcnt(p) != 0) {
+				    !Py_RefcntMatches(p, 1)) {
 					char buf[100];
 					format_float(buf, sizeof(buf), p, PREC_STR);
 					/* XXX(twouters) cast refcount to
@@ -1255,12 +1289,13 @@
 					 */
 					fprintf(stderr,
 			     "#   <float at %p, refcnt=%ld, val=%s>\n",
-						p, (long)Py_Refcnt(p), buf);
+						p, (long)Py_RefcntSnoop(p), buf);
 				}
 			}
 			list = list->next;
 		}
 	}
+#endif
 }
 
 /*----------------------------------------------------------------------------
Index: Objects/stringobject.c
===================================================================
--- Objects/stringobject.c	(revision 58355)
+++ Objects/stringobject.c	(working copy)
@@ -3,9 +3,25 @@
 #define PY_SSIZE_T_CLEAN
 
 #include "Python.h"
+#include "pythread.h"
 
 #include <ctype.h>
 
+/* Use only if you know it's a string */
+int
+_PyString_SnoopState(PyStringObject *op)
+{
+	/* XXX Just what is required here?  This all needs to be audited/fixed anyway.. */
+	//return (int)AO_load_full(&op->state);
+	return (int)AO_load_acquire(&op->ob_sstate);
+}
+
+static inline void
+PyString_SetState(PyStringObject *op, int state)
+{
+	AO_store_full(&op->ob_sstate, state);
+}
+
 #ifdef COUNT_ALLOCS
 int null_strings, one_strings;
 #endif
@@ -22,6 +38,7 @@
    count of a string is:  s->ob_refcnt + (s->ob_sstate?2:0)
 */
 static PyObject *interned;
+static PyCritical *interned_critical;
 
 /*
    For both PyString_FromString() and PyString_FromStringAndSize(), the
@@ -72,10 +89,15 @@
 	}
 
 	/* Inline PyObject_NewVar */
-	op = (PyStringObject *)PyObject_MALLOC(sizeof(PyStringObject) + size);
+	//op = (PyStringObject *)PyObject_MALLOC(sizeof(PyStringObject) + size);
+	//op = (PyStringObject *)_PyObject_GC_Malloc(sizeof(PyStringObject) + size);
+	/* XXX FIXME _PyObject_GC_Malloc already calls PyErr_NoMemory */
+	//if (op == NULL)
+	//	return PyErr_NoMemory();
+	//PyObject_INIT_VAR(op, &PyString_Type, size);
+	op = PyObject_NEWVAR(PyStringObject, &PyString_Type, size);
 	if (op == NULL)
-		return PyErr_NoMemory();
-	PyObject_INIT_VAR(op, &PyString_Type, size);
+		return NULL;
 	op->ob_shash = -1;
 	op->ob_sstate = SSTATE_NOT_INTERNED;
 	if (str != NULL)
@@ -127,10 +149,15 @@
 	}
 
 	/* Inline PyObject_NewVar */
-	op = (PyStringObject *)PyObject_MALLOC(sizeof(PyStringObject) + size);
+	//op = (PyStringObject *)PyObject_MALLOC(sizeof(PyStringObject) + size);
+	//op = (PyStringObject *)_PyObject_GC_Malloc(sizeof(PyStringObject) + size);
+	/* XXX FIXME _PyObject_GC_Malloc already calls PyErr_NoMemory */
+	//if (op == NULL)
+	//	return PyErr_NoMemory();
+	//PyObject_INIT_VAR(op, &PyString_Type, size);
+	op = PyObject_NEWVAR(PyStringObject, &PyString_Type, size);
 	if (op == NULL)
-		return PyErr_NoMemory();
-	PyObject_INIT_VAR(op, &PyString_Type, size);
+		return NULL;
 	op->ob_shash = -1;
 	op->ob_sstate = SSTATE_NOT_INTERNED;
 	Py_MEMCPY(op->ob_sval, str, size+1);
@@ -499,27 +526,41 @@
 }
 
 static void
-string_dealloc(PyObject *op)
+string_dealloc(PyStringObject *op)
 {
-	switch (PyString_CHECK_INTERNED(op)) {
-		case SSTATE_NOT_INTERNED:
-			break;
+	int state = _PyString_SnoopState(op);
+	assert(Py_RefcntSnoop(op) == 1);
+	assert(op->ob_sstate == SSTATE_NOT_INTERNED ||
+		op->ob_sstate == SSTATE_INTERNED);
 
-		case SSTATE_INTERNED_MORTAL:
-			/* revive dead object temporarily for DelItem */
-			Py_Refcnt(op) = 3;
-			if (PyDict_DelItem(interned, op) != 0)
-				Py_FatalError(
-					"deletion of interned string failed");
-			break;
+	if (state == SSTATE_INTERNED) {
+		PyCritical_Enter(interned_critical);
+		if (Py_RefcntSnoop(op) > 1) {
+			PyCritical_Exit(interned_critical);
+			/* An asynchronous DECREF is used to ensure we
+			 * don't become recursive and risk blowing our
+			 * stack. */
+			PyObject_REVIVE(op);
+			Py_DECREF_ASYNC(op);
+			return;
+		}
 
-		case SSTATE_INTERNED_IMMORTAL:
-			Py_FatalError("Immortal interned string died.");
+		/* See comments in unicodeobject.c */
+		//((PyObject *)op)->ob_refowner = (AO_t)PyThreadState_Get();
+		//((PyObject *)op)->ob_refcnt = 3;
+		Py_INCREF(op);
+		Py_INCREF(op);
+		if (PyDict_DelItem(interned, (PyObject *)op) != 0)
+			Py_FatalError("deletion of interned str8 string failed");
 
-		default:
-			Py_FatalError("Inconsistent interned string state.");
+		assert(Py_RefcntSnoop(op) == 1);
+
+		//((PyObject *)op)->ob_refcnt = 0;
+
+		PyCritical_Exit(interned_critical);
 	}
-	Py_Type(op)->tp_free(op);
+
+	PyObject_DEL(op);
 }
 
 /* Unescape a backslash-escaped string. If unicode is non-zero,
@@ -898,10 +939,15 @@
 	}
 	  
 	/* Inline PyObject_NewVar */
-	op = (PyStringObject *)PyObject_MALLOC(sizeof(PyStringObject) + size);
+	//op = (PyStringObject *)PyObject_MALLOC(sizeof(PyStringObject) + size);
+	//op = (PyStringObject *)_PyObject_GC_Malloc(sizeof(PyStringObject) + size);
+	/* XXX FIXME _PyObject_GC_Malloc already calls PyErr_NoMemory */
+	//if (op == NULL)
+	//	return PyErr_NoMemory();
+	//PyObject_INIT_VAR(op, &PyString_Type, size);
+	op = PyObject_NEWVAR(PyStringObject, &PyString_Type, size);
 	if (op == NULL)
-		return PyErr_NoMemory();
-	PyObject_INIT_VAR(op, &PyString_Type, size);
+		return NULL;
 	op->ob_shash = -1;
 	op->ob_sstate = SSTATE_NOT_INTERNED;
 	Py_MEMCPY(op->ob_sval, a->ob_sval, Py_Size(a));
@@ -940,11 +986,16 @@
 			"repeated string is too long");
 		return NULL;
 	}
-	op = (PyStringObject *)
-		PyObject_MALLOC(sizeof(PyStringObject) + nbytes);
+	//op = (PyStringObject *)
+	//	PyObject_MALLOC(sizeof(PyStringObject) + nbytes);
+	//op = (PyStringObject *)_PyObject_GC_Malloc(sizeof(PyStringObject) + nbytes);
+	/* XXX FIXME _PyObject_GC_Malloc already calls PyErr_NoMemory */
+	//if (op == NULL)
+	//	return PyErr_NoMemory();
+	//PyObject_INIT_VAR(op, &PyString_Type, size);
+	op = PyObject_NEWVAR(PyStringObject, &PyString_Type, size);
 	if (op == NULL)
-		return PyErr_NoMemory();
-	PyObject_INIT_VAR(op, &PyString_Type, size);
+		return NULL;
 	op->ob_shash = -1;
 	op->ob_sstate = SSTATE_NOT_INTERNED;
 	op->ob_sval[size] = '\0';
@@ -3773,7 +3824,7 @@
 		return NULL;
 	assert(PyString_CheckExact(tmp));
 	n = PyString_GET_SIZE(tmp);
-	pnew = type->tp_alloc(type, n);
+	pnew = PyObject_NewVar(type, n);
 	if (pnew != NULL) {
 		Py_MEMCPY(PyString_AS_STRING(pnew), PyString_AS_STRING(tmp), n+1);
 		((PyStringObject *)pnew)->ob_shash =
@@ -3802,6 +3853,12 @@
 	return PyString_Format(v, w);
 }
 
+static int
+str_isshareable (PyObject *v)
+{
+	return PyString_CheckExact(v);
+}
+
 PyDoc_STRVAR(basestring_doc,
 "Type basestring cannot be instantiated; it is the base for str8 and str.");
 
@@ -3833,7 +3890,8 @@
 	0,					/* tp_getattro */
 	0,					/* tp_setattro */
 	0,					/* tp_as_buffer */
-	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE, /* tp_flags */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |
+		Py_TPFLAGS_SHAREABLE,		/* tp_flags */
 	basestring_doc,				/* tp_doc */
 	0,					/* tp_traverse */
 	0,					/* tp_clear */
@@ -3850,9 +3908,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	basestring_new,				/* tp_new */
-	0,		                	/* tp_free */
 };
 
 PyDoc_STRVAR(string_doc,
@@ -3868,7 +3924,7 @@
 	"str8",
 	sizeof(PyStringObject),
 	sizeof(char),
- 	string_dealloc, 			/* tp_dealloc */
+	(destructor)string_dealloc,		/* tp_dealloc */
 	0,			 		/* tp_print */
 	0,					/* tp_getattr */
 	0,					/* tp_setattr */
@@ -3884,7 +3940,8 @@
 	0,					/* tp_setattro */
 	&string_as_buffer,			/* tp_as_buffer */
 	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE |
-		Py_TPFLAGS_STRING_SUBCLASS,	/* tp_flags */
+		Py_TPFLAGS_STRING_SUBCLASS |
+		Py_TPFLAGS_SHAREABLE,		/* tp_flags */
 	string_doc,				/* tp_doc */
 	0,					/* tp_traverse */
 	0,					/* tp_clear */
@@ -3901,9 +3958,14 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	string_new,				/* tp_new */
-	PyObject_Del,	                	/* tp_free */
+	0,					/* tp_is_gc */
+	0,					/* tp_bases */
+	0,					/* tp_mro */
+	0,					/* tp_cache */
+	0,					/* tp_subclasses */
+	0,					/* tp_weaklist */
+	str_isshareable,			/* tp_isshareable */
 };
 
 void
@@ -3950,26 +4012,20 @@
 	register PyObject *v;
 	register PyStringObject *sv;
 	v = *pv;
-	if (!PyString_Check(v) || Py_Refcnt(v) != 1 || newsize < 0 ||
-	    PyString_CHECK_INTERNED(v)) {
+	if (!PyString_Check(v) || !Py_RefcntMatches(v, 1) || newsize < 0 ||
+	    _PyString_SnoopState((PyStringObject *)v)) {
 		*pv = 0;
 		Py_DECREF(v);
 		PyErr_BadInternalCall();
 		return -1;
 	}
-	/* XXX UNREF/NEWREF interface should be more symmetrical */
-	_Py_DEC_REFTOTAL;
-	_Py_ForgetReference(v);
-	*pv = (PyObject *)
-		PyObject_REALLOC((char *)v, sizeof(PyStringObject) + newsize);
+	*pv = PyObject_Resize(v, newsize);
 	if (*pv == NULL) {
-		PyObject_Del(v);
-		PyErr_NoMemory();
+		Py_DECREF(v);
 		return -1;
 	}
-	_Py_NewReference(*pv);
 	sv = (PyStringObject *) *pv;
-	Py_Size(sv) = newsize;
+	assert(Py_Size(sv) == newsize);
 	sv->ob_sval[newsize] = '\0';
 	sv->ob_shash = -1;	/* invalidate cached hash value */
 	return 0;
@@ -4126,7 +4182,7 @@
 	}
 
 	/* To modify the string in-place, there can only be one reference. */
-	if (Py_Refcnt(result) != 1) {
+	if (!Py_RefcntMatches(result, 1)) {
 		PyErr_BadInternalCall();
 		return NULL;
 	}
@@ -4765,44 +4821,42 @@
 	   it in the interned dict might do. */
 	if (!PyString_CheckExact(s))
 		return;
-	if (PyString_CHECK_INTERNED(s))
+	if (_PyString_SnoopState(s))
 		return;
+
+	PyCritical_Enter(interned_critical);
 	if (interned == NULL) {
 		interned = PyDict_New();
 		if (interned == NULL) {
+			PyCritical_Exit(interned_critical);
 			PyErr_Clear(); /* Don't leave an exception */
 			return;
 		}
 	}
+
 	t = PyDict_GetItem(interned, (PyObject *)s);
 	if (t) {
-		Py_INCREF(t);
-		Py_DECREF(*p);
-		*p = t;
-		return;
+                assert(PyString_CheckExact(t));
+                Py_INCREF(t);
+                PyCritical_Exit(interned_critical);
+                Py_DECREF(*p);
+                *p = t;
+                return;
 	}
 
 	if (PyDict_SetItem(interned, (PyObject *)s, (PyObject *)s) < 0) {
+		PyCritical_Exit(interned_critical);
 		PyErr_Clear();
 		return;
 	}
 	/* The two references in interned are not counted by refcnt.
 	   The string deallocator will take care of this */
-	Py_Refcnt(s) -= 2;
-	PyString_CHECK_INTERNED(s) = SSTATE_INTERNED_MORTAL;
+	Py_DECREF(s);
+	Py_DECREF(s);
+	PyString_SetState(s, SSTATE_INTERNED);
+	PyCritical_Exit(interned_critical);
 }
 
-void
-PyString_InternImmortal(PyObject **p)
-{
-	PyString_InternInPlace(p);
-	if (PyString_CHECK_INTERNED(*p) != SSTATE_INTERNED_IMMORTAL) {
-		PyString_CHECK_INTERNED(*p) = SSTATE_INTERNED_IMMORTAL;
-		Py_INCREF(*p);
-	}
-}
-
-
 PyObject *
 PyString_InternFromString(const char *cp)
 {
@@ -4814,6 +4868,14 @@
 }
 
 void
+_PyString_Init(void)
+{
+	interned_critical = PyCritical_Allocate(PyCRITICAL_NORMAL);
+	if (!interned_critical)
+		Py_FatalError("unable to allocate lock");
+}
+
+void
 PyString_Fini(void)
 {
 	int i;
@@ -4825,17 +4887,32 @@
 	nullstring = NULL;
 }
 
+void
+_PyString_PostFini(void)
+{
+	PyCritical_Free(interned_critical);
+	interned_critical = NULL;
+}
+
 void _Py_ReleaseInternedStrings(void)
 {
-	PyObject *keys;
-	PyStringObject *s;
+	PyObject *keys, *temp;
 	Py_ssize_t i, n;
-	Py_ssize_t immortal_size = 0, mortal_size = 0;
+	Py_ssize_t mortal_size = 0;
+	PyThreadState *tstate = PyThreadState_Get();
 
-	if (interned == NULL || !PyDict_Check(interned))
+	PyCritical_Enter(interned_critical);
+	if (AO_load_full(&tstate->interp->tstate_count) != 1)
+		Py_FatalError("Attempting to release interned strings while "
+			"multiple threads exist");
+
+	if (interned == NULL || !PyDict_Check(interned)) {
+		PyCritical_Exit(interned_critical);
 		return;
+	}
 	keys = PyDict_Keys(interned);
 	if (keys == NULL || !PyList_Check(keys)) {
+		PyCritical_Exit(interned_critical);
 		PyErr_Clear();
 		return;
 	}
@@ -4849,31 +4926,30 @@
 	fprintf(stderr, "releasing %" PY_FORMAT_SIZE_T "d interned strings\n",
 		n);
 	for (i = 0; i < n; i++) {
-		s = (PyStringObject *) PyList_GET_ITEM(keys, i);
-		switch (s->ob_sstate) {
-		case SSTATE_NOT_INTERNED:
-			/* XXX Shouldn't happen */
-			break;
-		case SSTATE_INTERNED_IMMORTAL:
-			Py_Refcnt(s) += 1;
-			immortal_size += Py_Size(s);
-			break;
-		case SSTATE_INTERNED_MORTAL:
-			Py_Refcnt(s) += 2;
-			mortal_size += Py_Size(s);
-			break;
-		default:
+		PyStringObject *s = (PyStringObject *) PyList_GET_ITEM(keys, i);
+		void *owner = (void *)AO_load_full(&((PyObject *)s)->ob_refowner);
+		if (_PyString_SnoopState(s) != SSTATE_INTERNED)
 			Py_FatalError("Inconsistent interned string state.");
-		}
+
+		if (owner == (void *)Py_REFOWNER_STATICINIT) {
+			/* Inline _PyGC_RefMode_Promote */
+			((PyObject *)s)->ob_refowner = (AO_t)tstate;
+		} else if (owner != tstate)
+			Py_FatalError("Interned string has wrong owner");
+
+		Py_INCREF(s);
+		Py_INCREF(s);
+		mortal_size += Py_Size(s);
 		s->ob_sstate = SSTATE_NOT_INTERNED;
 	}
 	fprintf(stderr, "total size of all interned strings: "
-			"%" PY_FORMAT_SIZE_T "d/%" PY_FORMAT_SIZE_T "d "
-			"mortal/immortal\n", mortal_size, immortal_size);
+			"%" PY_FORMAT_SIZE_T "d\n", mortal_size);
+	temp = interned;
+	interned = NULL;
+	PyCritical_Exit(interned_critical);
 	Py_DECREF(keys);
-	PyDict_Clear(interned);
-	Py_DECREF(interned);
-	interned = NULL;
+	PyDict_Clear(temp);
+	Py_DECREF(temp);
 }
 
 
@@ -4888,9 +4964,8 @@
 static void
 striter_dealloc(striterobject *it)
 {
-	_PyObject_GC_UNTRACK(it);
 	Py_XDECREF(it->it_seq);
-	PyObject_GC_Del(it);
+	PyObject_DEL(it);
 }
 
 static int
@@ -4985,12 +5060,11 @@
 		PyErr_BadInternalCall();
 		return NULL;
 	}
-	it = PyObject_GC_New(striterobject, &PyStringIter_Type);
+	it = PyObject_NEW(striterobject, &PyStringIter_Type);
 	if (it == NULL)
 		return NULL;
 	it->it_index = 0;
 	Py_INCREF(seq);
 	it->it_seq = (PyStringObject *)seq;
-	_PyObject_GC_TRACK(it);
 	return (PyObject *)it;
 }
Index: Objects/structseq.c
===================================================================
--- Objects/structseq.c	(revision 58355)
+++ Objects/structseq.c	(working copy)
@@ -31,7 +31,7 @@
 {
 	PyStructSequence *obj;
        
-	obj = PyObject_New(PyStructSequence, type);
+	obj = PyObject_NEW(PyStructSequence, type);
 	Py_Size(obj) = VISIBLE_SIZE_TP(type);
 
 	return (PyObject*) obj;
@@ -46,7 +46,7 @@
 	for (i = 0; i < size; ++i) {
 		Py_XDECREF(obj->ob_item[i]);
 	}
-	PyObject_Del(obj);
+	PyObject_DEL(obj);
 }
 
 static Py_ssize_t
@@ -394,7 +394,6 @@
 	0,					/* tp_descr_set */
 	0,	                                /* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	structseq_new,				/* tp_new */
 };
 
@@ -408,6 +407,10 @@
 #ifdef Py_TRACE_REFS
 	/* if the type object was chained, unchain it first
 	   before overwriting its storage */
+	/* This is "probably" safe.  _ob_next should only be manipulated
+	   during object creation/deletion, so it should have passed
+	   through some memory barriers before we see it.  Then again,
+	   why are we manipulating it here? */
 	if (type->ob_base.ob_base._ob_next) {
 		_Py_ForgetReference((PyObject*)type);
 	}
Index: Parser/intrcheck.c
===================================================================
--- Parser/intrcheck.c	(revision 58355)
+++ Parser/intrcheck.c	(working copy)
@@ -1,172 +0,0 @@
-
-/* Check for interrupts */
-
-#include "Python.h"
-
-#ifdef QUICKWIN
-
-#include <io.h>
-
-void
-PyOS_InitInterrupts(void)
-{
-}
-
-void
-PyOS_FiniInterrupts(void)
-{
-}
-
-int
-PyOS_InterruptOccurred(void)
-{
-	_wyield();
-}
-
-#define OK
-
-#endif /* QUICKWIN */
-
-#if defined(_M_IX86) && !defined(__QNX__)
-#include <io.h>
-#endif
-
-#if defined(MSDOS) && !defined(QUICKWIN)
-
-#ifdef __GNUC__
-
-/* This is for DJGPP's GO32 extender.  I don't know how to trap
- * control-C  (There's no API for ctrl-C, and I don't want to mess with
- * the interrupt vectors.)  However, this DOES catch control-break.
- * --Amrit
- */
-
-#include <go32.h>
-
-void
-PyOS_InitInterrupts(void)
-{
-	_go32_want_ctrl_break(1 /* TRUE */);
-}
-
-void
-PyOS_FiniInterrupts(void)
-{
-}
-
-int
-PyOS_InterruptOccurred(void)
-{
-	return _go32_was_ctrl_break_hit();
-}
-
-#else /* !__GNUC__ */
-
-/* This might work for MS-DOS (untested though): */
-
-void
-PyOS_InitInterrupts(void)
-{
-}
-
-void
-PyOS_FiniInterrupts(void)
-{
-}
-
-int
-PyOS_InterruptOccurred(void)
-{
-	int interrupted = 0;
-	while (kbhit()) {
-		if (getch() == '\003')
-			interrupted = 1;
-	}
-	return interrupted;
-}
-
-#endif /* __GNUC__ */
-
-#define OK
-
-#endif /* MSDOS && !QUICKWIN */
-
-
-#ifndef OK
-
-/* Default version -- for real operating systems and for Standard C */
-
-#include <stdio.h>
-#include <string.h>
-#include <signal.h>
-
-static int interrupted;
-
-void
-PyErr_SetInterrupt(void)
-{
-	interrupted = 1;
-}
-
-extern int PyErr_CheckSignals(void);
-
-static int
-checksignals_witharg(void * arg)
-{
-	return PyErr_CheckSignals();
-}
-
-static void
-intcatcher(int sig)
-{
-	extern void Py_Exit(int);
-	static char message[] =
-"python: to interrupt a truly hanging Python program, interrupt once more.\n";
-	switch (interrupted++) {
-	case 0:
-		break;
-	case 1:
-		write(2, message, strlen(message));
-		break;
-	case 2:
-		interrupted = 0;
-		Py_Exit(1);
-		break;
-	}
-	PyOS_setsig(SIGINT, intcatcher);
-	Py_AddPendingCall(checksignals_witharg, NULL);
-}
-
-static void (*old_siginthandler)(int) = SIG_DFL;
-
-void
-PyOS_InitInterrupts(void)
-{
-	if ((old_siginthandler = PyOS_setsig(SIGINT, SIG_IGN)) != SIG_IGN)
-		PyOS_setsig(SIGINT, intcatcher);
-}
-
-void
-PyOS_FiniInterrupts(void)
-{
-	PyOS_setsig(SIGINT, old_siginthandler);
-}
-
-int
-PyOS_InterruptOccurred(void)
-{
-	if (!interrupted)
-		return 0;
-	interrupted = 0;
-	return 1;
-}
-
-#endif /* !OK */
-
-void
-PyOS_AfterFork(void)
-{
-#ifdef WITH_THREAD
-	PyEval_ReInitThreads();
-#endif
-}
Index: Parser/node.c
===================================================================
--- Parser/node.c	(revision 58355)
+++ Parser/node.c	(working copy)
@@ -13,6 +13,7 @@
 	n->n_type = type;
 	n->n_str = NULL;
 	n->n_lineno = 0;
+    n->n_col_offset = 42424242;
 	n->n_nchildren = 0;
 	n->n_child = NULL;
 	return n;
@@ -102,6 +103,8 @@
 	n = &n1->n_child[n1->n_nchildren++];
 	n->n_type = type;
 	n->n_str = str;
+    //if (str != NULL)
+        //printf("New %p '%s'\n", str, str);
 	n->n_lineno = lineno;
 	n->n_col_offset = col_offset;
 	n->n_nchildren = 0;
@@ -130,6 +133,8 @@
 		freechildren(CHILD(n, i));
 	if (n->n_child != NULL)
 		PyObject_FREE(n->n_child);
-	if (STR(n) != NULL)
+	if (STR(n) != NULL) {
+        //printf("Delete %p '%s'\n", STR(n), STR(n));
 		PyObject_FREE(STR(n));
+    }
 }
Index: Parser/myreadline.c
===================================================================
--- Parser/myreadline.c	(revision 58355)
+++ Parser/myreadline.c	(working copy)
@@ -79,20 +79,28 @@
 		if (errno == EINTR) {
 			int s;
 #ifdef WITH_THREAD
-			PyEval_RestoreThread(_PyOS_ReadlineTState);
+			//PyEval_RestoreThread(_PyOS_ReadlineTState);
+			PyState_Resume();
 #endif
+#if 0
 			s = PyErr_CheckSignals();
+#endif
 #ifdef WITH_THREAD
-			PyEval_SaveThread();
+			//PyEval_SaveThread();
+			PyState_Suspend();
 #endif
+#if 0
 			if (s < 0) {
 				return 1;
 			}
+#endif
 		}
 #endif
+#if 0
 		if (PyOS_InterruptOccurred()) {
 			return 1; /* Interrupt */
 		}
+#endif
 		return -2; /* Error */
 	}
 	/* NOTREACHED */
@@ -157,7 +165,7 @@
 {
 	char *rv;
 
-	if (_PyOS_ReadlineTState == PyThreadState_GET()) {
+	if (_PyOS_ReadlineTState == PyThreadState_Get()) {
 		PyErr_SetString(PyExc_RuntimeError,
 				"can't re-enter readline");
 		return NULL;
@@ -174,14 +182,14 @@
 	
 #ifdef WITH_THREAD
 	if (_PyOS_ReadlineLock == NULL) {
-		_PyOS_ReadlineLock = PyThread_allocate_lock();		
+		_PyOS_ReadlineLock = PyThread_lock_allocate();		
 	}
 #endif
 
-	_PyOS_ReadlineTState = PyThreadState_GET();
+	_PyOS_ReadlineTState = PyThreadState_Get();
 	Py_BEGIN_ALLOW_THREADS
 #ifdef WITH_THREAD
-	PyThread_acquire_lock(_PyOS_ReadlineLock, 1);
+	PyThread_lock_acquire(_PyOS_ReadlineLock);
 #endif
 
         /* This is needed to handle the unlikely case that the
@@ -197,7 +205,7 @@
 	Py_END_ALLOW_THREADS
 
 #ifdef WITH_THREAD
-	PyThread_release_lock(_PyOS_ReadlineLock);
+	PyThread_lock_release(_PyOS_ReadlineLock);
 #endif
 
 	_PyOS_ReadlineTState = NULL;
Index: PC/_subprocess.c
===================================================================
--- PC/_subprocess.c	(revision 58355)
+++ PC/_subprocess.c	(working copy)
@@ -101,7 +101,7 @@
 {
 	if (self->handle != INVALID_HANDLE_VALUE)
 		CloseHandle(self->handle);
-	PyObject_FREE(self);
+	PyObject_DEL(self);
 }
 
 static PyMethodDef sp_handle_methods[] = {
Index: PC/_msi.c
===================================================================
--- PC/_msi.c	(revision 58355)
+++ PC/_msi.c	(working copy)
@@ -454,9 +454,7 @@
         0,                      /*tp_descr_set*/
         0,                      /*tp_dictoffset*/
         0,                      /*tp_init*/
-        0,                      /*tp_alloc*/
         0,                      /*tp_new*/
-        0,                      /*tp_free*/
         0,                      /*tp_is_gc*/
 };
 
@@ -620,9 +618,7 @@
         0,                      /*tp_descr_set*/
         0,                      /*tp_dictoffset*/
         0,                      /*tp_init*/
-        0,                      /*tp_alloc*/
         0,                      /*tp_new*/
-        0,                      /*tp_free*/
         0,                      /*tp_is_gc*/
 };
 
@@ -768,9 +764,7 @@
         0,                      /*tp_descr_set*/
         0,                      /*tp_dictoffset*/
         0,                      /*tp_init*/
-        0,                      /*tp_alloc*/
         0,                      /*tp_new*/
-        0,                      /*tp_free*/
         0,                      /*tp_is_gc*/
 };
 
@@ -885,9 +879,7 @@
         0,                      /*tp_descr_set*/
         0,                      /*tp_dictoffset*/
         0,                      /*tp_init*/
-        0,                      /*tp_alloc*/
         0,                      /*tp_new*/
-        0,                      /*tp_free*/
         0,                      /*tp_is_gc*/
 };
 
Index: Lib/site.py
===================================================================
--- Lib/site.py	(revision 58355)
+++ Lib/site.py	(working copy)
@@ -57,10 +57,12 @@
 ImportError exception, it is silently ignored.
 
 """
+from __future__ import shared_module
 
 import sys
 import os
 import __builtin__
+from threadtools import Monitor, monitormethod
 
 
 def makepath(*paths):
@@ -238,11 +240,14 @@
     else:
         eof = 'Ctrl-D (i.e. EOF)'
 
-    class Quitter(object):
-        def __init__(self, name):
+    class Quitter(Monitor):
+        __shared__ = True
+        def __init__(self, name, eof):
             self.name = name
+            self.eof = eof
+        @monitormethod
         def __repr__(self):
-            return 'Use %s() or %s to exit' % (self.name, eof)
+            return 'Use %s() or %s to exit' % (self.name, self.eof)
         def __call__(self, code=None):
             # Shells like IDLE catch the SystemExit, but listen when their
             # stdin wrapper is closed.
@@ -251,13 +256,14 @@
             except:
                 pass
             raise SystemExit(code)
-    __builtin__.quit = Quitter('quit')
-    __builtin__.exit = Quitter('exit')
+    __builtin__.quit = Quitter('quit', eof)
+    __builtin__.exit = Quitter('exit', eof)
 
 
-class _Printer(object):
+class _Printer(Monitor):
     """interactive prompt objects for printing the license text, a list of
     contributors and the copyright notice."""
+    __shared__ = True
 
     MAXLINES = 23
 
@@ -289,6 +295,7 @@
         self.__lines = data.split('\n')
         self.__linecnt = len(self.__lines)
 
+    @monitormethod
     def __repr__(self):
         self.__setup()
         if len(self.__lines) <= self.MAXLINES:
@@ -296,6 +303,7 @@
         else:
             return "Type %s() to see the full %s text" % ((self.__name,)*2)
 
+    @monitormethod
     def __call__(self):
         self.__setup()
         prompt = 'Hit Return for more, or q (and Return) to quit: '
@@ -330,17 +338,18 @@
     Thanks to CWI, CNRI, BeOpen.com, Zope Corporation and a cast of thousands
     for supporting Python development.  See www.python.org for more information.""")
     here = os.path.dirname(os.__file__)
-    __builtin__.license = _Printer(
-        "license", "See http://www.python.org/%.3s/license.html" % sys.version,
-        ["LICENSE.txt", "LICENSE"],
-        [os.path.join(here, os.pardir), here, os.curdir])
+    #__builtin__.license = _Printer(
+    #    "license", "See http://www.python.org/%.3s/license.html" % sys.version,
+    #    ["LICENSE.txt", "LICENSE"],
+    #    [os.path.join(here, os.pardir), here, os.curdir])
 
 
-class _Helper(object):
+class _Helper(Monitor):
     """Define the built-in 'help'.
     This is a wrapper around pydoc.help (with a twist).
 
     """
+    __shared__ = True
 
     def __repr__(self):
         return "Type help() for interactive help, " \
@@ -410,10 +419,11 @@
     from encodings import latin_1, utf_8
     # Trick so that open won't become a bound method when stored
     # as a class variable (as dumbdbm does)
-    class open:
-        def __new__(cls, *args, **kwds):
+    class open(Monitor):
+        __shared__ = True
+        def __call__(self, *args, **kwds):
             return io.open(*args, **kwds)
-    __builtin__.open = open
+    __builtin__.open = open()
     sys.__stdin__ = sys.stdin = io.open(0, "r", newline='\n')
     sys.__stdout__ = sys.stdout = io.open(1, "w", newline='\n')
     sys.__stderr__ = sys.stderr = io.open(2, "w", newline='\n')
Index: Lib/__future__.py
===================================================================
--- Lib/__future__.py	(revision 58355)
+++ Lib/__future__.py	(working copy)
@@ -53,6 +53,7 @@
     "division",
     "absolute_import",
     "with_statement",
+    "shared_module",
 ]
 
 __all__ = ["all_feature_names"] + all_feature_names
@@ -66,6 +67,7 @@
 CO_FUTURE_DIVISION   = 0x2000   # division
 CO_FUTURE_ABSOLUTE_IMPORT = 0x4000 # perform absolute imports by default
 CO_FUTURE_WITH_STATEMENT  = 0x8000   # with statement
+CO_FUTURE_SHARED_MODULE   = 0x0800 # module shared between threads
 
 class _Feature:
     def __init__(self, optionalRelease, mandatoryRelease, compiler_flag):
@@ -114,3 +116,8 @@
 with_statement = _Feature((2, 5, 0, "alpha", 1),
                           (2, 6, 0, "alpha", 0),
                           CO_FUTURE_WITH_STATEMENT)
+
+shared_module = _Feature((3, 1, 0, "alpha", 1),
+                          (4, 0, 0, "alpha", 0),
+                          CO_FUTURE_SHARED_MODULE)
+shared_module = '__future__.shared_module XXX FIXME'
Index: Lib/threadtools.py
===================================================================
--- Lib/threadtools.py	(revision 0)
+++ Lib/threadtools.py	(revision 0)
@@ -0,0 +1,13 @@
+"""Tools for working with frozen objects and threads"""
+from __future__ import shared_module
+# To prevent users from doing "from threadtools import isShareable", we
+# use the full operator.isShareable() name
+#import operator
+from _threadtools import Monitor, MonitorSpace, MonitorMeta, branch
+
+def monitormethod(func):
+    # XXX FIXME _monitormethod shouldn't be shareable (because it has a
+    # closure), but it seems to be marked as shareable anyway!
+    def _monitormethod(self, *args, **kwargs):
+        return self.enter(func, self, *args, **kwargs)
+    return _monitormethod
Index: Lib/distutils/spawn.py
===================================================================
--- Lib/distutils/spawn.py	(revision 58355)
+++ Lib/distutils/spawn.py	(working copy)
@@ -28,7 +28,9 @@
     return on success.
     """
     if os.name == 'posix':
-        _spawn_posix(cmd, search_path, dry_run=dry_run)
+        #_spawn_posix(cmd, search_path, dry_run=dry_run)
+        # XXX FIXME bodge
+        _spawn_nt(cmd, search_path, dry_run=dry_run)
     elif os.name == 'nt':
         _spawn_nt(cmd, search_path, dry_run=dry_run)
     elif os.name == 'os2':
Index: Lib/ctypes/__init__.py
===================================================================
--- Lib/ctypes/__init__.py	(revision 58355)
+++ Lib/ctypes/__init__.py	(working copy)
@@ -490,7 +490,7 @@
 def cast(obj, typ):
     return _cast(obj, obj, typ)
 
-_string_at = CFUNCTYPE(py_object, c_void_p, c_int)(_string_at_addr)
+_string_at = PYFUNCTYPE(py_object, c_void_p, c_int)(_string_at_addr)
 def string_at(ptr, size=-1):
     """string_at(addr[, size]) -> string
 
@@ -502,7 +502,7 @@
 except ImportError:
     pass
 else:
-    _wstring_at = CFUNCTYPE(py_object, c_void_p, c_int)(_wstring_at_addr)
+    _wstring_at = PYFUNCTYPE(py_object, c_void_p, c_int)(_wstring_at_addr)
     def wstring_at(ptr, size=-1):
         """wstring_at(addr[, size]) -> string
 
@@ -545,4 +545,6 @@
 # function is needed for the unittests on Win64 to succeed.  This MAY
 # be a compiler bug, since the problem occurs only when _ctypes is
 # compiled with the MS SDK compiler.  Or an uninitialized variable?
+# XXX This is itself broken.  If it were ever called it'd have to be
+# a PYFUNCTYPE, not a CFUNCTYPE
 CFUNCTYPE(c_int)(lambda: None)
Index: Lib/weakref.py
===================================================================
--- Lib/weakref.py	(revision 58355)
+++ Lib/weakref.py	(working copy)
@@ -4,210 +4,146 @@
 
 http://python.sourceforge.net/peps/pep-0205.html
 """
+from __future__ import shared_module
 
 # Naming convention: Variables named "wr" are weak reference objects;
 # they are called this instead of "ref" to avoid name collisions with
 # the module-global ref() function imported from _weakref.
 
 import UserDict
+import operator
+from threadtools import Monitor, monitormethod, MonitorMeta
 
-from _weakref import (
-     getweakrefcount,
-     getweakrefs,
-     ref,
-     proxy,
-     CallableProxyType,
-     ProxyType,
-     ReferenceType)
+from _weakref import ref, bind, ReferenceType, DeathQueueType, WeakBindingType
 
 
-ProxyTypes = (ProxyType, CallableProxyType)
+__all__ = ("ref", "bind", "proxy",
+           "ReferenceType", "WeakBindingType", "ProxyType",
+           "WeakKeyDictionary", "WeakValueDictionary")
 
-__all__ = ["ref", "proxy", "getweakrefcount", "getweakrefs",
-           "WeakKeyDictionary", "ReferenceType", "ProxyType",
-           "CallableProxyType", "ProxyTypes", "WeakValueDictionary"]
 
-
-class WeakValueDictionary(UserDict.UserDict):
+class WeakValueDictionary(UserDict.DictMixin):
     """Mapping class that references values weakly.
 
     Entries in the dictionary will be discarded when no strong
-    reference to the value exists anymore
+    reference to the value exists anymore.
+
+    Discarding may be delayed until the dictionary is next used.
     """
+    __shared__ = True
     # We inherit the constructor without worrying about the input
     # dictionary; since it uses our .update() method, we get the right
     # checks (if the other dictionary is a WeakValueDictionary,
     # objects are unwrapped on the way out, and we always wrap on the
     # way in).
 
-    def __init__(self, *args, **kw):
-        def remove(wr, selfref=ref(self)):
-            self = selfref()
-            if self is not None:
-                del self.data[wr.key]
-        self._remove = remove
-        UserDict.UserDict.__init__(self, *args, **kw)
+    def __init__(self, dict=None, **kwargs):
+        self._deathqueue = DeathQueueType()
+        self._data = {}
+        if dict is not None:
+            self.update(dict)
+        if kwargs:
+            self.update(kwargs)
 
+    def _checkdeathqueue(self):
+        while self._deathqueue:
+            hrk = self._deathqueue.pop()
+            tmp = self._data.pop(hrk.key)
+            assert hrk is tmp
+
     def __getitem__(self, key):
-        o = self.data[key]()
+        self._checkdeathqueue()
+        o = self._data[key].ref()
         if o is None:
             raise KeyError(key)
         else:
             return o
 
-    def __contains__(self, key):
-        try:
-            o = self.data[key]()
-        except KeyError:
-            return False
-        return o is not None
+    def __setitem__(self, key, value):
+        self._checkdeathqueue()
+        if key in self._data:
+            self._deathqueue.cancel(self._data[key].handle)
+        hrk = _HandleRefKey(ref(value), key)
+        hrk.handle = self._deathqueue.watch(value, hrk)
+        self._data[key] = hrk
 
+    def __delitem__(self, key):
+        self._checkdeathqueue()
+        hrk = self._data[key]
+        del self._data[key]
+        self._deathqueue.cancel(hrk.handle)
+
     def __repr__(self):
         return "<WeakValueDictionary at %s>" % id(self)
 
-    def __setitem__(self, key, value):
-        self.data[key] = KeyedRef(value, self._remove, key)
-
     def copy(self):
-        new = WeakValueDictionary()
-        for key, wr in self.data.items():
-            o = wr()
-            if o is not None:
-                new[key] = o
-        return new
+        # XXX Is this really important enough to provide?
+        return WeakValueDictionary(self.items())
 
-    def get(self, key, default=None):
-        try:
-            wr = self.data[key]
-        except KeyError:
-            return default
-        else:
-            o = wr()
-            if o is None:
-                # This should only happen
-                return default
-            else:
-                return o
+    def keys(self):
+        self._checkdeathqueue()
+        # Nearly any operation on us could potentially delete values and
+        # invalidate our iteration.  To be safe we always return a list,
+        # even though a real dict returns an iterator since 3.0.
+        return list(self._data.keys())
+    iterkeys = keys
 
     def items(self):
+        self._checkdeathqueue()
+        # Nearly any operation on us could potentially delete values and
+        # invalidate our iteration.  To be safe we always return a list,
+        # even though a real dict returns an iterator since 3.0.
         L = []
-        for key, wr in self.data.items():
-            o = wr()
+        for key, hrk in self._data.items():
+            o = hrk.ref()
             if o is not None:
                 L.append((key, o))
         return L
+    iteritems = items
 
-    def iteritems(self):
-        for wr in self.data.values():
-            value = wr()
-            if value is not None:
-                yield wr.key, value
+    def values(self):
+        self._checkdeathqueue()
+        # Nearly any operation on us could potentially delete values and
+        # invalidate our iteration.  To be safe we always return a list,
+        # even though a real dict returns an iterator since 3.0.
+        L = []
+        for hrk in self._data.values():
+            o = hrk.ref()
+            if o is not None:
+                L.append(o)
+        return L
+    itervalues = values
 
-    def iterkeys(self):
-        return iter(self.data.keys())
-
-    def __iter__(self):
-        return iter(self.data.keys())
-
-    def itervaluerefs(self):
-        """Return an iterator that yields the weak references to the values.
-
-        The references are not guaranteed to be 'live' at the time
-        they are used, so the result of calling the references needs
-        to be checked before being used.  This can be used to avoid
-        creating references that will cause the garbage collector to
-        keep the values around longer than needed.
-
-        """
-        return self.data.values()
-
-    def itervalues(self):
-        for wr in self.data.values():
-            obj = wr()
-            if obj is not None:
-                yield obj
-
     def popitem(self):
+        self._checkdeathqueue()
         while 1:
-            key, wr = self.data.popitem()
-            o = wr()
+            key, hrk = self._data.popitem()
+            o = hrk.ref()
+            self._deathqueue.cancel(hrk.handle)
             if o is not None:
                 return key, o
 
-    def pop(self, key, *args):
-        try:
-            o = self.data.pop(key)()
-        except KeyError:
-            if args:
-                return args[0]
-            raise
-        if o is None:
-            raise KeyError(key)
-        else:
-            return o
 
-    def setdefault(self, key, default=None):
-        try:
-            wr = self.data[key]
-        except KeyError:
-            self.data[key] = KeyedRef(default, self._remove, key)
-            return default
-        else:
-            return wr()
+class BypassCallMeta(MonitorMeta):
+    __shared__ = True
 
-    def update(self, dict=None, **kwargs):
-        d = self.data
-        if dict is not None:
-            if not hasattr(dict, "items"):
-                dict = type({})(dict)
-            for key, o in dict.items():
-                d[key] = KeyedRef(o, self._remove, key)
-        if len(kwargs):
-            self.update(kwargs)
+    def __call__(self, *args, **kwargs):
+        # We bypass MonitorMeta.__call__, so that no MonitorSpace is
+        # created.  This is perverse, but it works.
+        return type.__call__(self, *args, **kwargs)
 
-    def valuerefs(self):
-        """Return a list of weak references to the values.
 
-        The references are not guaranteed to be 'live' at the time
-        they are used, so the result of calling the references needs
-        to be checked before being used.  This can be used to avoid
-        creating references that will cause the garbage collector to
-        keep the values around longer than needed.
+class _HandleRefKey(Monitor, metaclass=BypassCallMeta):
+    __slots__ = "handle", "ref", "key"
+    __shared__ = True
 
-        """
-        return self.data.values()
-
-    def values(self):
-        L = []
-        for wr in self.data.values():
-            o = wr()
-            if o is not None:
-                L.append(o)
-        return L
-
-
-class KeyedRef(ref):
-    """Specialized reference that includes a key corresponding to the value.
-
-    This is used in the WeakValueDictionary to avoid having to create
-    a function object for each key stored in the mapping.  A shared
-    callback object can use the 'key' attribute of a KeyedRef instead
-    of getting a reference to the key from an enclosing scope.
-
-    """
-
-    __slots__ = "key",
-
-    def __new__(type, ob, callback, key):
-        self = ref.__new__(type, ob, callback)
+    def __init__(self, ref, key):
+        self.ref = ref
         self.key = key
-        return self
+        # self.handle has to be filled in after
 
-    def __init__(self, ob, callback, key):
-        super().__init__(ob, callback)
 
-
-class WeakKeyDictionary(UserDict.UserDict):
+class WeakKeyDictionary(UserDict.DictMixin):
     """ Mapping class that references keys weakly.
 
     Entries in the dictionary will be discarded when there is no
@@ -216,124 +152,217 @@
     an application without adding attributes to those objects. This
     can be especially useful with objects that override attribute
     accesses.
+
+    Keys are compared using identity (not value!)
+
+    Discarding may be delayed until the dictionary is next used.
     """
+    __shared__ = True
 
-    def __init__(self, dict=None):
-        self.data = {}
-        def remove(k, selfref=ref(self)):
-            self = selfref()
-            if self is not None:
-                del self.data[k]
-        self._remove = remove
-        if dict is not None: self.update(dict)
+    def __init__(self, dict=None, **kwargs):
+        self._deathqueue = DeathQueueType()
+        self._data = {}
+        if dict is not None:
+            self.update(dict)
+        if kwargs:
+            self.update(kwargs)
 
-    def __delitem__(self, key):
-        del self.data[ref(key)]
+    def _checkdeathqueue(self):
+        while self._deathqueue:
+            wkhv = self._deathqueue.pop()
+            tmp = self._data.pop(wkhv)
+            assert wkhv is tmp
 
     def __getitem__(self, key):
-        return self.data[ref(key)]
+        self._checkdeathqueue()
+        key, value = self._data[_WeakKeyHandleValue(key)].binding()
+        if key is None:
+            raise KeyError(key)
+        return value
 
+    def __setitem__(self, key, value):
+        self._checkdeathqueue()
+        wkhv = _WeakKeyHandleValue(key, value)
+        old_wkhv = self._data.get(wkhv, None)
+        if old_wkhv is not None:
+            del self._data[old_wkhv]
+            self._deathqueue.cancel(old_wkhv.handle)
+
+        wkhv.handle = self._deathqueue.watch(key, wkhv)
+        self._data[wkhv] = wkhv
+
+    def __delitem__(self, key):
+        self._checkdeathqueue()
+        wkhv = self._data[_WeakKeyHandleValue(key)]
+        del self._data[wkhv]
+        self._deathqueue.cancel(wkhv.handle)
+
     def __repr__(self):
         return "<WeakKeyDictionary at %s>" % id(self)
 
-    def __setitem__(self, key, value):
-        self.data[ref(key, self._remove)] = value
-
     def copy(self):
-        new = WeakKeyDictionary()
-        for key, value in self.data.items():
-            o = key()
-            if o is not None:
-                new[o] = value
-        return new
+        # XXX Is this really important enough to provide?
+        return WeakKeyDictionary(self.items())
 
-    def get(self, key, default=None):
-        return self.data.get(ref(key),default)
+    def keys(self):
+        self._checkdeathqueue()
+        # Nearly any operation on us could potentially delete keys and
+        # invalidate our iteration.  To be safe we always return a list,
+        # even though a real dict returns an iterator since 3.0.
+        L = []
+        for wkhv in self._data:
+            key, value = wkhv.binding()
+            if key is not None:
+                L.append(key)
+        return L
+    iterkeys = keys
 
-    def __contains__(self, key):
-        try:
-            wr = ref(key)
-        except TypeError:
-            return 0
-        return wr in self.data
-
     def items(self):
+        self._checkdeathqueue()
+        # Nearly any operation on us could potentially delete keys and
+        # invalidate our iteration.  To be safe we always return a list,
+        # even though a real dict returns an iterator since 3.0.
         L = []
-        for key, value in self.data.items():
-            o = key()
-            if o is not None:
-                L.append((o, value))
+        for wkhv in self._data:
+            key, value = wkhv.binding()
+            if key is not None:
+                L.append((key, value))
         return L
+    iteritems = items
 
-    def iteritems(self):
-        for wr, value in self.data.items():
-            key = wr()
+    def values(self):
+        self._checkdeathqueue()
+        # Nearly any operation on us could potentially delete keys and
+        # invalidate our iteration.  To be safe we always return a list,
+        # even though a real dict returns an iterator since 3.0.
+        L = []
+        for wkhv in self._data:
+            key, value = wkhv.binding()
             if key is not None:
-                yield key, value
+                L.append(value)
+        return L
+    itervalues = values
 
-    def iterkeyrefs(self):
-        """Return an iterator that yields the weak references to the keys.
+    def popitem(self):
+        self._checkdeathqueue()
+        while 1:
+            wkhv, wkhv = self._data.popitem()
+            key, value = wkhv.binding()
+            self._deathqueue.cancel(wkhv.handle)
+            if key is not None:
+                return key, value
 
-        The references are not guaranteed to be 'live' at the time
-        they are used, so the result of calling the references needs
-        to be checked before being used.  This can be used to avoid
-        creating references that will cause the garbage collector to
-        keep the keys around longer than needed.
 
-        """
-        return self.data.keys()
+class _WeakKeyHandleValue(Monitor, metaclass=BypassCallMeta):
+    __slots__ = 'binding', 'handle', '_hash'
+    __shared__ = True
 
-    def iterkeys(self):
-        for wr in self.data.keys():
-            obj = wr()
-            if obj is not None:
-                yield obj
+    def __init__(self, key, value=None):
+        self.binding = bind(key, value)
+        self._hash = hash(id(key))
+        # self.handle has to be filled in after
 
-    def __iter__(self):
-        return iter(self.keys())
+    def __hash__(self):
+        return self._hash
 
-    def itervalues(self):
-        return iter(self.data.values())
+    def __eq__(self, other):
+        if not isinstance(other, _WeakKeyHandleValue):
+            return NotImplemented
 
-    def keyrefs(self):
-        """Return a list of weak references to the keys.
+        # We guarantee a _WeakKeyHandleValue always compares equal to
+        # itself, even if the weakref has been cleared.
+        if self is other:
+            return True
 
-        The references are not guaranteed to be 'live' at the time
-        they are used, so the result of calling the references needs
-        to be checked before being used.  This can be used to avoid
-        creating references that will cause the garbage collector to
-        keep the keys around longer than needed.
+        # If it's a different _WeakKeyHandleValue then we compare
+        # objects, defaulting to False if either of them have been
+        # cleared.
+        self_o, self_value = self.binding()
+        other_o, other_value = self.binding()
+        if self_o is None or other_o is None:
+            return False
+        return self_o is other_o
 
-        """
-        return self.data.keys()
 
-    def keys(self):
-        L = []
-        for wr in self.data.keys():
-            o = wr()
-            if o is not None:
-                L.append(o)
-        return L
+def proxy(obj):
+    return ProxyType(obj)
 
-    def popitem(self):
-        while 1:
-            key, value = self.data.popitem()
-            o = key()
-            if o is not None:
-                return o, value
 
-    def pop(self, key, *args):
-        return self.data.pop(ref(key), *args)
+class ProxyType:
+    __shared__ = True
 
-    def setdefault(self, key, default=None):
-        return self.data.setdefault(ref(key, self._remove),default)
+    def __init__(self, obj):
+        super().__setattr__('ref', ref(obj))
 
-    def update(self, dict=None, **kwargs):
-        d = self.data
-        if dict is not None:
-            if not hasattr(dict, "items"):
-                dict = type({})(dict)
-            for key, value in dict.items():
-                d[ref(key, self._remove)] = value
-        if len(kwargs):
-            self.update(kwargs)
+    def __getattribute__(self, name):
+        o = super().__getattribute__('ref')()
+        if o is None:
+            raise ReferenceError
+        return getattr(o, name)
+
+    def __repr__(self):
+        o = super().__getattribute__('ref')()
+        if o is None:
+            return '<weakproxy at {0}, dead>'.format(hex(id(self)))
+        return '<weakproxy at {0} to {1} at {2}>'.format(hex(id(self)),
+            type(o).__name__, hex(id(o)))
+
+    def __bool__(self):
+        # We can't use our generic operator proxying because the names
+        # are different.  __bool__ -> operator.truth
+        o = super().__getattribute__('ref')()
+        if o is None:
+            raise ReferenceError
+        return bool(o)
+
+CallableProxyType = ProxyType
+
+_directmethods = tuple("""
+setattr delattr call len str
+""".split())
+def _directproxy_(name):
+    name = '__{0}__'.format(name)
+    def _directproxy(self, *args, **kwargs):
+        o = super(ProxyType, self).__getattribute__('ref')()
+        if o is None:
+            raise ReferenceError
+        return getattr(o, name)(*args, **kwargs)
+    return _directproxy
+for _directname in _directmethods:
+    _name = '__' + _directname + '__'
+    setattr(ProxyType, _name, _directproxy_(_directname))
+
+_opermethods = tuple("""
+abs add and concat contains delitem delslice eq floordiv ge getitem
+getslice gt iadd iand iconcat ifloordiv ilshift imod imul index inv
+invert ior ipow irepeat irshift isub itruediv ixor le lshift lt mod mul
+ne neg not or pos pow repeat rshift setitem setslice sub truediv xor
+""".split())
+def _operproxy_(name):
+    oper = getattr(operator, '__{0}__'.format(name))
+    def _operproxy(self, *args):
+        o = super(ProxyType, self).__getattribute__('ref')()
+        if o is None:
+            raise ReferenceError
+        return oper(o, *args)
+    return _operproxy
+for _opername in _opermethods:
+    _name = '__' + _opername + '__'
+    setattr(ProxyType, _name, _operproxy_(_opername))
+
+_reverseopermethods = tuple("""
+add sub mul
+truediv floordiv mod pow
+lshift rshift and xor or
+""".split())
+def _reverseoperproxy_(name):
+    oper = getattr(operator, '__{0}__'.format(name))
+    def _operproxy(self, other):
+        o = super(ProxyType, self).__getattribute__('ref')()
+        if o is None:
+            raise ReferenceError
+        return oper(other, o)
+    return _operproxy
+for _opername in _reverseopermethods:
+    _name = '__r' + _opername + '__'
+    setattr(ProxyType, _name, _reverseoperproxy_(_opername))
Index: Lib/trace.py
===================================================================
--- Lib/trace.py	(revision 58355)
+++ Lib/trace.py	(working copy)
@@ -52,7 +52,7 @@
 import os
 import re
 import sys
-import threading
+#import threading
 import token
 import tokenize
 import types
@@ -478,26 +478,26 @@
         dict = __main__.__dict__
         if not self.donothing:
             sys.settrace(self.globaltrace)
-            threading.settrace(self.globaltrace)
+            #threading.settrace(self.globaltrace)
         try:
             exec(cmd, dict, dict)
         finally:
             if not self.donothing:
                 sys.settrace(None)
-                threading.settrace(None)
+                #threading.settrace(None)
 
     def runctx(self, cmd, globals=None, locals=None):
         if globals is None: globals = {}
         if locals is None: locals = {}
         if not self.donothing:
             sys.settrace(self.globaltrace)
-            threading.settrace(self.globaltrace)
+            #threading.settrace(self.globaltrace)
         try:
             exec(cmd, globals, locals)
         finally:
             if not self.donothing:
                 sys.settrace(None)
-                threading.settrace(None)
+                #threading.settrace(None)
 
     def runfunc(self, func, *args, **kw):
         result = None
Index: Lib/UserDict.py
===================================================================
--- Lib/UserDict.py	(revision 58355)
+++ Lib/UserDict.py	(working copy)
@@ -1,6 +1,8 @@
 """A more or less complete user-defined wrapper around dictionary objects."""
+from __future__ import shared_module
 
 class UserDict:
+    __shared__ = True
     def __init__(self, dict=None, **kwargs):
         self.data = {}
         if dict is not None:
@@ -77,6 +79,7 @@
         return d
 
 class IterableUserDict(UserDict):
+    __shared__ = True
     def __iter__(self):
         return iter(self.data)
 
@@ -89,6 +92,7 @@
     # __contains__(), __iter__(), and iteritems().
 
     # XXX It would make more sense to expect __iter__ to be primitive.
+    __shared__ = True
 
     # second level definitions support higher levels
     def __iter__(self):
Index: Lib/test/trivialthreadbench.py
===================================================================
--- Lib/test/trivialthreadbench.py	(revision 0)
+++ Lib/test/trivialthreadbench.py	(revision 0)
@@ -0,0 +1,23 @@
+#!/usr/bin/env python
+from __future__ import shared_module
+from threadtools import branch
+
+def runthread(start, count):
+    for i in range(start, start + count):
+        pass
+    return i
+
+def main(split, total=10**7):
+    if split:
+        chunk = total // split
+        print("Chunk of", chunk, "for", split, "threads.")
+        with branch() as workers:
+            for i in range(split):
+                workers.addresult(runthread, i * chunk, chunk)
+        print(workers.getresults())
+    else:
+        print("Running", total, "threadless.")
+        runthread(0, total)
+
+if __name__ == '__main__':
+    raise RuntimeError("trivialthreadbench must not be the __main__ module")
Index: Lib/test/test_dict.py
===================================================================
--- Lib/test/test_dict.py	(revision 58355)
+++ Lib/test/test_dict.py	(working copy)
@@ -10,6 +10,7 @@
         # calling built-in types without argument must return empty
         self.assertEqual(dict(), {})
         self.assert_(dict() is not {})
+        self.assertRaises(TypeError, dict, {'a': 7}, {'a': 42})
 
     def test_bool(self):
         self.assert_(not {})
Index: Lib/test/test_sharedmodule.py
===================================================================
--- Lib/test/test_sharedmodule.py	(revision 0)
+++ Lib/test/test_sharedmodule.py	(revision 0)
@@ -0,0 +1,238 @@
+import sys
+import unittest
+from time import sleep
+from test import test_support
+
+from test import sharedmodule
+import threadtools
+
+sharedmoduletest = """
+>>> from test import sharedmodule
+>>> import operator, threadtools
+>>> from time import sleep
+
+>>> operator.isShareable(sharedmodule)
+True
+>>> type(sharedmodule.__dict__)
+<type 'shareddict'>
+>>> sharedmodule.a
+42
+
+>>> sharedmodule.SharedClass.sharedstaticmethod()
+42
+>>> sharedmodule.SharedClass.sharedclassmethod()
+<class 'test.sharedmodule.SharedClass'>
+
+>>> sharedmodule.purple = []
+Traceback (most recent call last):
+  ...
+TypeError: shareddict value must be shareable, 'list' object is not
+
+
+>>> m = sharedmodule.MyMonitor()
+>>> m.foo()
+'pink'
+>>> m.bar()
+'purple'
+>>> m.baz()
+'purple'
+
+>>> operator.isShareable(threadtools.Monitor)
+True
+>>> operator.isShareable(sharedmodule.MyMonitor)
+True
+>>> operator.isShareable(threadtools.Monitor())
+True
+>>> operator.isShareable(m)
+True
+>>> operator.isShareable(m.foo)
+True
+>>> operator.isShareable(m.bar)
+True
+>>> operator.isShareable(sharedmodule.MyMonitor.bar)
+True
+>>> operator.isShareable(sharedmodule.MyMonitor.__dict__['bar'])
+True
+
+>>> m.hello
+Traceback (most recent call last):
+  ...
+AttributeError: hello
+>>> m.enter(getattr, m, 'hello')
+'world'
+>>> m.plumage = 'green'
+Traceback (most recent call last):
+  ...
+AttributeError: 'MyMonitor' object has no attribute 'plumage'
+>>> m.enter(setattr, m, 'plumage', 'orange')
+>>> m.plumage
+Traceback (most recent call last):
+  ...
+AttributeError: 'MyMonitor' object has no attribute 'plumage'
+>>> m.enter(getattr, m, 'plumage')
+'orange'
+
+
+>>> with threadtools.branch() as children:
+...     children.add(sharedmodule.safesharedfunc)
+>>> children.getresults()
+[]
+
+>>> with threadtools.branch() as children:
+...     children.addresult(sharedmodule.safesharedfunc)
+>>> children.getresults()
+[42]
+>>> children.getresults()
+[]
+
+>>> with threadtools.branch() as children:
+...     children.add(sharedmodule.sharedfunc)
+Traceback (most recent call last):
+  ...
+ValueError: moo
+>>> children.getresults()
+[]
+
+>>> with threadtools.branch() as children:
+...     children.addresult(sharedmodule.sharedfunc)
+Traceback (most recent call last):
+  ...
+ValueError: moo
+>>> children.getresults()
+[]
+
+>>> with threadtools.branch() as children:
+...     1/0
+Traceback (most recent call last):
+  ...
+ZeroDivisionError: int division or modulo by zero
+>>> children.getresults()
+[]
+
+
+>>> with threadtools.branch() as children:
+...     children.addresult(m.foo)
+...     children.addresult(m.bar)
+...     children.addresult(m.baz)
+>>> children.getresults()
+['pink', 'purple', 'purple']
+
+>>> counter = sharedmodule.Counter()
+>>> for i in range(10):
+...     counter.tick()
+>>> counter.value()
+10
+>>> with threadtools.branch() as children:
+...     for i in range(15):
+...         children.add(counter.tick)
+>>> counter.value()
+25
+
+#>>> with threadtools.branch() as children:
+#...     for i in range(10000):  # XXX arbitrary value.  Probably should be much higher
+#...         children.add(sleep, 1)
+#Traceback (most recent call last):
+#  ...
+#RuntimeError: branch.add can't spawn new thread
+
+"""
+
+
+class BranchTests(unittest.TestCase):
+    def assertRaisesCause(self, excClass, excCause, func, *args, **kwargs):
+        try:
+            func(*args, **kwargs)
+        except excClass as e:
+            if not isinstance(excCause, tuple):
+                excCause = (excCause,)
+            cause = e.__cause__
+            if not isinstance(cause, tuple):
+                cause = (cause,)
+
+            if len(excCause) != len(cause):
+                raise
+            for c, t in zip(cause, excCause):
+                if not isinstance(c, t):
+                    raise
+
+            return
+
+        excName = str(getattr(excClass, '__name__', excClass))
+        objName = str(getattr(callableObj, '__name__', callableObj))
+        raise self.failureException("%s(%s) not raised by %s" % (excName,
+            excCause, objName))
+
+    def test_main_and_child(self):
+        def x():
+            with threadtools.branch() as children:
+                children.addresult(sharedmodule.sharedfunc)
+                1/0
+        self.assertRaisesCause(MultipleError, (ZeroDivisionError, ValueError), x)
+
+    def test_multiple_child(self):
+        def x():
+            with threadtools.branch() as children:
+                children.addresult(sharedmodule.sharedfunc)
+                children.addresult(sharedmodule.sharedfunc)
+                children.addresult(sharedmodule.sharedfunc)
+        self.assertRaisesCause(MultipleError, (ValueError, ValueError, ValueError), x)
+
+    def test_main_and_interrupted_child(self):
+        def x():
+            with threadtools.branch() as children:
+                children.add(sharedmodule.readloop)
+                1/0
+        self.assertRaisesCause(ZeroDivisionError, (ZeroDivisionError, Interrupted), x)
+
+    def test_nested_branch_failing_outer(self):
+        def x():
+            with threadtools.branch() as outer:
+                with threadtools.branch() as inner:
+                    inner.add(sharedmodule.readloop)
+                    outer.add(sharedmodule.sharedfunc)
+        self.assertRaisesCause(ValueError, (Interrupted, ValueError), x)
+
+    def test_nested_branch_failing_outer_direct(self):
+        def x():
+            with threadtools.branch() as outer:
+                with threadtools.branch() as inner:
+                    outer.add(sharedmodule.sharedfunc)
+                    sharedmodule.readloop()
+        self.assertRaisesCause(ValueError, (Interrupted, ValueError), x)
+
+
+class FinalizeTests(unittest.TestCase):
+    def test_activates(self):
+        counter = sharedmodule.Counter()
+        obj = sharedmodule.Finalizable(counter)
+        del obj
+
+        # We want to wait long enough for this test to complete, but we
+        # also don't want to expand every test run by 5 seconds.  A
+        # polling sleep loop suffices.
+        for i in range(50):
+            if counter.value():
+                break
+            sleep(0.1)
+        else:
+            self.fail("__finalize__ never ran")
+
+    def test_manual(self):
+        # If __finalize__ gets called again by the finalizer thread it
+        # will abort everything with an AttributeError
+        def x():
+            obj = sharedmodule.Finalizable(None)
+            obj.__finalize__()
+        self.assertRaises(AttributeError, x)
+
+
+__test__ = {'sharedmoduletest' : sharedmoduletest}
+
+def test_main(verbose=None):
+    from test import test_sharedmodule
+    test_support.run_doctest(test_sharedmodule, verbose)
+    test_support.run_unittest(BranchTests, FinalizeTests)
+
+
+if __name__ == "__main__":
+    test_main(verbose=True)
Index: Lib/test/pystone.py
===================================================================
--- Lib/test/pystone.py	(revision 58355)
+++ Lib/test/pystone.py	(working copy)
@@ -128,6 +128,8 @@
         IntLoc1 = Proc2(IntLoc1)
 
     benchtime = clock() - starttime - nulltime
+    if benchtime < 0.0001:
+        benchtime = 0.0001
     return benchtime, (loops / benchtime)
 
 def Proc1(PtrParIn):
Index: Lib/test/sharedmodule.py
===================================================================
--- Lib/test/sharedmodule.py	(revision 0)
+++ Lib/test/sharedmodule.py	(revision 0)
@@ -0,0 +1,77 @@
+# WTF.  If my __future__ import is on the first line it gets ignored?!
+from __future__ import shared_module
+
+from threadtools import monitormethod, Monitor
+from operator import isShareable
+a = 42
+
+def safesharedfunc():
+    return a
+
+def sharedfunc():
+    raise ValueError('moo')
+
+def readloop():
+    with open('/dev/zero', 'rb') as f:
+        while f.read(1024):
+            pass
+
+
+class SharedClass:
+    __shared__=True
+
+    @staticmethod
+    def sharedstaticmethod():
+        return a
+
+    @classmethod
+    def sharedclassmethod(cls):
+        return cls
+
+    def normalmethod(self):
+        pass
+
+
+class MyMonitor(Monitor):
+    __shared__ = True
+    __slots__ = 'hello', '__dict__'
+
+    def __init__(self):
+        self.hello = 'world'
+
+    @monitormethod
+    def foo(self):
+        return 'pink'
+
+    def bar(self):
+        return 'purple'
+
+    baz = monitormethod(bar)
+
+
+class Counter(Monitor):
+    __shared__ = True
+
+    def __init__(self):
+        self.count = 0
+
+    @monitormethod
+    def tick(self):
+        self.count += 1
+
+    @monitormethod
+    def value(self):
+        return self.count
+
+
+class Finalizable(Monitor):
+    __shared__ = True
+    __finalizeattrs__ = 'counter'
+
+    def __init__(self, counter):
+        self.counter = counter
+
+    @monitormethod
+    def __finalize__(self):
+        super().__finalize__()
+        self.counter.tick()
Index: Lib/test/test_weakref.py
===================================================================
--- Lib/test/test_weakref.py	(revision 58355)
+++ Lib/test/test_weakref.py	(working copy)
@@ -194,7 +194,7 @@
     # they are active.  In Python 2.3.3 and earlier, this guarantee
     # was not honored, and was broken in different ways for
     # PyWeakref_NewRef() and PyWeakref_NewProxy().  (Two tests.)
-
+    """
     def test_shared_ref_without_callback(self):
         self.check_shared_without_callback(weakref.ref)
 
@@ -218,7 +218,7 @@
         p1 = makeref(o, None)
         p2 = makeref(o)
         self.assert_(p1 is p2, "callbacks were None, NULL in the C API")
-
+"""
     def test_callable_proxy(self):
         o = Callable()
         ref1 = weakref.proxy(o)
@@ -733,7 +733,7 @@
         #
         dict, objects = self.make_weak_valued_dict()
         for o in objects:
-            self.assertEqual(weakref.getweakrefcount(o), 1)
+            #self.assertEqual(weakref.getweakrefcount(o), 1)
             self.assert_(o is dict[o.arg],
                          "wrong object returned by weak dict!")
         items1 = dict.items()
@@ -763,8 +763,8 @@
         #
         dict, objects = self.make_weak_keyed_dict()
         for o in objects:
-            self.assert_(weakref.getweakrefcount(o) == 1,
-                         "wrong number of weak references to %r!" % o)
+            #self.assert_(weakref.getweakrefcount(o) == 1,
+            #             "wrong number of weak references to %r!" % o)
             self.assert_(o.arg is dict[o],
                          "wrong object returned by weak dict!")
         items1 = dict.items()
@@ -782,7 +782,8 @@
         o = Object(42)
         dict[o] = "What is the meaning of the universe?"
         self.assert_(o in dict)
-        self.assert_(34 not in dict)
+        #self.assert_(34 not in dict)
+        self.assert_(Object(34) not in dict)
 
     def test_weak_keyed_iters(self):
         dict, objects = self.make_weak_keyed_dict()
@@ -1048,6 +1049,16 @@
         self.assertEqual(len(d), 0)
         self.assertEqual(count, 2)
 
+    def test_weak_keyed_cycle(self):
+        # Test if a cycle from the value back to the key is collected
+        pass
+        o = Object(42)
+        o.loop = o
+        dict = weakref.WeakKeyDictionary({o:o})
+        del o
+        gc.collect()
+        self.assertEqual(len(dict), 0)
+
 from test import mapping_tests
 
 class WeakValueDictionaryTestCase(mapping_tests.BasicTestMappingProtocol):
Index: Lib/test/thread_pystone.py
===================================================================
--- Lib/test/thread_pystone.py	(revision 0)
+++ Lib/test/thread_pystone.py	(revision 0)
@@ -0,0 +1,151 @@
+#!/usr/bin/env python
+
+"""
+Threaded wrapper for pystone
+"""
+
+from __future__ import shared_module
+
+import sys
+from threadtools import Monitor, monitormethod, branch
+from test.pystone import LOOPS
+from test.pystone import __file__ as pystone_filename
+
+if pystone_filename.endswith('.pyc'):
+    pystone_filename = pystone_filename[:-1]
+
+__version__ = "0.1"
+
+
+TRUE = 1
+
+class Foo:
+    __shared__ = True
+
+class WrappedPystone(Monitor):
+    __shared__ = True
+
+    def __init__(self):
+        #self.globals = {}
+        #with open(pystone_filename, 'r') as f:
+        #    exec(f.read(), self.globals)
+        if 'test.pystone' in sys.modules:
+            del sys.modules['test.pystone']
+        import test.pystone
+        self.globals = test.pystone.__dict__
+        self.mod = test.pystone  # Needed to keep globals alive
+        del sys.modules['test.pystone']
+        pass
+
+    @monitormethod
+    def printfunc(self):
+        print(self.globals['Proc0'])
+
+    def x(self):
+        pass
+
+    @monitormethod
+    def run(self, loops):
+        self.globals['Proc0'](loops)
+        #for i in range(loops):
+            #Foo()
+            #self.globals['Func3'](self.globals['Ident1'])
+            #self.globals['Proc5']()
+            #self.x()
+            #x = []*5000
+            #IntLoc1 = 2
+            #IntLoc2 = 3
+            #while IntLoc1 < IntLoc2:
+            #    IntLoc3 = 5 * IntLoc1 - IntLoc2
+            #    IntLoc3 = self.globals['Proc7'](IntLoc1, IntLoc2)
+            #    IntLoc1 = IntLoc1 + 1
+            #self.globals['Proc8'](self.globals['Array1Glob'], self.globals['Array2Glob'], IntLoc1, IntLoc3)
+
+    def run_external(self, loops):
+        #self.globals['Proc0'](loops)
+        for i in range(loops):
+            #self.globals['Func3'](self.globals['Ident1'])
+            #self.globals['Proc5']()
+            self.x()
+
+def x(loops):
+    n = 1.0
+    for i in fakerange(loops):
+        y()
+        1.0+n
+        pass
+
+def y():
+    pass
+
+
+def main(threads, loops):
+    # WEEEEE!  clock behaves differently for threads!
+    from time import clock  # XXX workaround for clock not being shareable
+    from time import time
+
+    mods = [WrappedPystone() for i in range(threads)]
+    #mods = list(range(threads))
+
+    #starttime = clock()
+    #for i in range(loops):
+    #    pass
+    #nulltime = clock() - starttime
+
+    starttime = clock()
+    starttime2 = time()
+
+    with branch() as jobs:
+        for mod in mods:
+            jobs.add(mod.run, loops)
+            #jobs.add(x, loops)
+
+    #benchtime = clock() - starttime - nulltime
+    benchtime = clock() - starttime
+    benchtime2 = time() - starttime2
+    if benchtime < 0.0001:
+        benchtime = 0.0001
+    stones = (threads * loops) / benchtime2
+
+    #results = jobs.getresults()
+    ## Crude hack!
+    #results = [eval(result) for result in results]
+    #results = [benchtime for benchtime, stones in results]
+    #print(results)
+    #print(benchtime)
+    #print(stones)
+
+    print("Thread-Pystone(%s) time for %d*%d passes = %g" % \
+          (__version__, threads, loops, benchtime2))
+    print("This machine benchmarks at %g pystones/second" % stones)
+    #print(starttime, benchtime)
+    #print(starttime2, benchtime2)
+
+
+if __name__ == '__main__':
+    import sys
+    def error(msg):
+        print(msg, end=' ', file=sys.stderr)
+        print("usage: %s number_of_threads [number_of_loops]" % sys.argv[0], file=sys.stderr)
+        sys.exit(100)
+    nargs = len(sys.argv) - 1
+    if nargs > 2:
+        error("%d arguments are too many;" % nargs)
+    elif nargs < 1:
+        error("not enough arguments")
+
+    try:
+        threads = int(sys.argv[1])
+    except ValueError:
+        error("Invalid thread argument %r;" % sys.argv[1])
+
+    if nargs >= 2:
+        try:
+            loops = int(sys.argv[1])
+        except ValueError:
+            error("Invalid argument %r;" % sys.argv[1])
+    else:
+        loops = LOOPS
+
+    main(threads, loops)
+
Index: Makefile.pre.in
===================================================================
--- Makefile.pre.in	(revision 58355)
+++ Makefile.pre.in	(working copy)
@@ -183,12 +183,10 @@
 		Modules/config.o \
 		Modules/getpath.o \
 		Modules/main.o \
-		Modules/gcmodule.o
+		Modules/gcmodule.o \
+		Modules/signalmodule.o
 
-# Used of signalmodule.o is not available
-SIGNAL_OBJS=	@SIGNAL_OBJS@
 
-
 ##########################################################################
 # Grammar
 GRAMMAR_H=	$(srcdir)/Include/graminit.h
@@ -291,6 +289,7 @@
 		Objects/classobject.o \
 		Objects/cobject.o \
 		Objects/codeobject.o \
+		Objects/branchobject.o \
 		Objects/complexobject.o \
 		Objects/descrobject.o \
 		Objects/enumobject.o \
@@ -300,6 +299,7 @@
 		Objects/floatobject.o \
 		Objects/frameobject.o \
 		Objects/funcobject.o \
+		Objects/interruptobject.o \
 		Objects/iterobject.o \
 		Objects/listobject.o \
 		Objects/longobject.o \
@@ -307,6 +307,7 @@
 		Objects/memoryobject.o \
 		Objects/methodobject.o \
 		Objects/moduleobject.o \
+		Objects/monitorobject.o \
 		Objects/object.o \
 		Objects/obmalloc.o \
 		Objects/rangeobject.o \
@@ -329,7 +330,6 @@
 		$(OBJECT_OBJS) \
 		$(PYTHON_OBJS) \
 		$(MODULE_OBJS) \
-		$(SIGNAL_OBJS) \
 		$(MODOBJS)
 
 #########################################################################
@@ -364,7 +364,7 @@
 	$(AR) cr $@ $(PARSER_OBJS)
 	$(AR) cr $@ $(OBJECT_OBJS)
 	$(AR) cr $@ $(PYTHON_OBJS)
-	$(AR) cr $@ $(MODULE_OBJS) $(SIGNAL_OBJS)
+	$(AR) cr $@ $(MODULE_OBJS)
 	$(AR) cr $@ $(MODOBJS)
 	$(RANLIB) $@
 
@@ -458,7 +458,6 @@
 		$(OBJECT_OBJS) \
 		$(PYTHON_OBJS) \
 		$(MODULE_OBJS) \
-		$(SIGNAL_OBJS) \
 		$(MODOBJS) \
 		$(srcdir)/Modules/getbuildinfo.c
 	$(CC) -c $(PY_CFLAGS) -DSVNVERSION=\"`LC_ALL=C $(SVNVERSION)`\" -o $@ $(srcdir)/Modules/getbuildinfo.c
@@ -537,6 +536,7 @@
 		Include/cobject.h \
 		Include/code.h \
 		Include/codecs.h \
+		Include/branchobject.h \
 		Include/compile.h \
 		Include/complexobject.h \
 		Include/descrobject.h \
@@ -548,8 +548,8 @@
 		Include/formatter_unicode.h \
 		Include/funcobject.h \
 		Include/import.h \
+		Include/interruptobject.h \
 		Include/intobject.h \
-		Include/intrcheck.h \
 		Include/iterobject.h \
 		Include/listobject.h \
 		Include/longobject.h \
@@ -557,6 +557,7 @@
 		Include/methodobject.h \
 		Include/modsupport.h \
 		Include/moduleobject.h \
+		Include/monitorobject.h \
 		Include/object.h \
 		Include/objimpl.h \
 		Include/parsetok.h \
@@ -567,6 +568,7 @@
 		Include/pyfpe.h \
 		Include/pymem.h \
 		Include/pyport.h \
+		Include/pysignal.h \
 		Include/pystate.h \
 		Include/pythonrun.h \
 		Include/rangeobject.h \
Index: Modules/mathmodule.c
===================================================================
--- Modules/mathmodule.c	(revision 58355)
+++ Modules/mathmodule.c	(working copy)
@@ -111,6 +111,7 @@
 static PyObject * math_ceil(PyObject *self, PyObject *number) {
 	static PyObject *ceil_str = NULL;
 	PyObject *method;
+	PyObject *result;
 
 	if (ceil_str == NULL) {
 		ceil_str = PyUnicode_FromString("__ceil__");
@@ -118,11 +119,15 @@
 			return NULL;
 	}
 
-	method = _PyType_Lookup(Py_Type(number), ceil_str);
+	if (_PyType_LookupEx(Py_Type(number), ceil_str, &method) < 0)
+		return NULL;
 	if (method == NULL)
 		return math_1(number, ceil);
-	else
-		return PyObject_CallFunction(method, "O", number);
+	else {
+		result = PyObject_CallFunction(method, "O", number);
+		Py_DECREF(method);
+		return result;
+	}
 }
 
 PyDoc_STRVAR(math_ceil_doc,
@@ -141,6 +146,7 @@
 static PyObject * math_floor(PyObject *self, PyObject *number) {
 	static PyObject *floor_str = NULL;
 	PyObject *method;
+	PyObject *result;
 
 	if (floor_str == NULL) {
 		floor_str = PyUnicode_FromString("__floor__");
@@ -148,11 +154,15 @@
 			return NULL;
 	}
 
-	method = _PyType_Lookup(Py_Type(number), floor_str);
+	if (_PyType_LookupEx(Py_Type(number), floor_str, &method) < 0)
+		return NULL;
 	if (method == NULL)
 		return math_1(number, floor);
-	else
-		return PyObject_CallFunction(method, "O", number);
+	else {
+		result = PyObject_CallFunction(method, "O", number);
+		Py_DECREF(method);
+		return result;
+	}
 }
 
 PyDoc_STRVAR(math_floor_doc,
Index: Modules/_ssl.c
===================================================================
--- Modules/_ssl.c	(revision 58355)
+++ Modules/_ssl.c	(working copy)
@@ -17,11 +17,10 @@
 #ifdef WITH_THREAD
 #include "pythread.h"
 #define PySSL_BEGIN_ALLOW_THREADS { \
-			PyThreadState *_save;  \
-			if (_ssl_locks_count>0) {_save = PyEval_SaveThread();}
-#define PySSL_BLOCK_THREADS	if (_ssl_locks_count>0){PyEval_RestoreThread(_save)};
-#define PySSL_UNBLOCK_THREADS	if (_ssl_locks_count>0){_save = PyEval_SaveThread()};
-#define PySSL_END_ALLOW_THREADS	if (_ssl_locks_count>0){PyEval_RestoreThread(_save);} \
+			if (_ssl_locks_count>0) {PyState_Suspend();}
+#define PySSL_BLOCK_THREADS	if (_ssl_locks_count>0){PyState_Resume();};
+#define PySSL_UNBLOCK_THREADS	if (_ssl_locks_count>0){PyState_Suspend();};
+#define PySSL_END_ALLOW_THREADS	if (_ssl_locks_count>0){PyState_Resume();} \
 		 }
 
 #else	/* no WITH_THREAD */
@@ -269,7 +268,7 @@
 	int sockstate;
 	int verification_mode;
 
-	self = PyObject_New(PySSLObject, &PySSL_Type); /* Create new object */
+	self = PyObject_NEW(PySSLObject, &PySSL_Type); /* Create new object */
 	if (self == NULL)
 		return NULL;
 	memset(self->server, '\0', sizeof(char) * X509_NAME_MAXLEN);
@@ -399,9 +398,6 @@
 			ret = SSL_accept(self->ssl);
 		err = SSL_get_error(self->ssl, ret);
 		PySSL_END_ALLOW_THREADS
-		if(PyErr_CheckSignals()) {
-			goto fail;
-		}
 		if (err == SSL_ERROR_WANT_READ) {
 			sockstate = check_socket_and_wait_for_timeout(Sock, 0);
 		} else if (err == SSL_ERROR_WANT_WRITE) {
@@ -1062,7 +1058,7 @@
 	if (self->ctx)
 		SSL_CTX_free(self->ctx);
 	Py_XDECREF(self->Socket);
-	PyObject_Del(self);
+	PyObject_DEL(self);
 }
 
 /* If the socket has a timeout, do a select()/poll() on the socket.
@@ -1164,9 +1160,6 @@
 		len = SSL_write(self->ssl, data, count);
 		err = SSL_get_error(self->ssl, len);
 		PySSL_END_ALLOW_THREADS
-		if(PyErr_CheckSignals()) {
-			return NULL;
-		}
 		if (err == SSL_ERROR_WANT_READ) {
 			sockstate =
                             check_socket_and_wait_for_timeout(self->Socket, 0);
@@ -1243,10 +1236,6 @@
 		count = SSL_read(self->ssl, PyBytes_AS_STRING(buf), len);
 		err = SSL_get_error(self->ssl, count);
 		PySSL_END_ALLOW_THREADS
-		if(PyErr_CheckSignals()) {
-			Py_DECREF(buf);
-			return NULL;
-		}
 		if (err == SSL_ERROR_WANT_READ) {
 			sockstate =
 			  check_socket_and_wait_for_timeout(self->Socket, 0);
@@ -1414,9 +1403,15 @@
 
 static PyThread_type_lock *_ssl_locks = NULL;
 
+#if OPENSSL_VERSION_NUMBER < 0x0090900fL
 static unsigned long _ssl_thread_id_function (void) {
-	return PyThread_get_thread_ident();
+#if SIZEOF_LONG == SIZEOF_VOID_P
+	return (unsigned long)&errno;
+#else
+#error OpenSSL 0.9.9s API is broken on platforms where sizeof(long) < sizeof(void *)
+#endif
 }
+#endif
 
 static void _ssl_thread_locking_function (int mode, int n, const char *file, int line) {
 	/* this function is needed to perform locking on shared data
@@ -1438,9 +1433,9 @@
 		return;
 
 	if (mode & CRYPTO_LOCK) {
-		PyThread_acquire_lock(_ssl_locks[n], 1);
+		PyThread_lock_acquire(_ssl_locks[n]);
 	} else {
-		PyThread_release_lock(_ssl_locks[n]);
+		PyThread_lock_release(_ssl_locks[n]);
 	}
 }
 
@@ -1456,18 +1451,27 @@
 			return 0;
 		memset(_ssl_locks, 0, sizeof(PyThread_type_lock) * _ssl_locks_count);
 		for (i = 0;  i < _ssl_locks_count;  i++) {
-			_ssl_locks[i] = PyThread_allocate_lock();
+			_ssl_locks[i] = PyThread_lock_allocate();
 			if (_ssl_locks[i] == NULL) {
 				int j;
 				for (j = 0;  j < i;  j++) {
-					PyThread_free_lock(_ssl_locks[j]);
+					PyThread_lock_free(_ssl_locks[j]);
 				}
 				free(_ssl_locks);
 				return 0;
 			}
 		}
 		CRYPTO_set_locking_callback(_ssl_thread_locking_function);
+		/* OpenSSL's API is broken.  It wants a per-thread
+		 * identifier that fits in a long, but all the normal
+		 * ways of getting one are at least size_t.  OpenSSL
+		 * 0.9.9 claims to add an alternate API that uses a
+		 * void * instead, but the default of &errno should work
+		 * on any platform with functional threading, so we just
+		 * skip it entirely there. */
+#if OPENSSL_VERSION_NUMBER < 0x0090900fL
 		CRYPTO_set_id_callback(_ssl_thread_id_function);
+#endif
 	}
 	return 1;
 }
Index: Modules/bz2module.c
===================================================================
--- Modules/bz2module.c	(revision 58355)
+++ Modules/bz2module.c	(working copy)
@@ -78,8 +78,8 @@
 
 
 #ifdef WITH_THREAD
-#define ACQUIRE_LOCK(obj) PyThread_acquire_lock(obj->lock, 1)
-#define RELEASE_LOCK(obj) PyThread_release_lock(obj->lock)
+#define ACQUIRE_LOCK(obj) PyThread_lock_acquire(obj->lock)
+#define RELEASE_LOCK(obj) PyThread_lock_release(obj->lock)
 #else
 #define ACQUIRE_LOCK(obj)
 #define RELEASE_LOCK(obj)
@@ -1192,7 +1192,7 @@
 	 * instead of returning */
 
 #ifdef WITH_THREAD
-	self->lock = PyThread_allocate_lock();
+	self->lock = PyThread_lock_allocate();
 	if (!self->lock) {
 		PyErr_SetString(PyExc_MemoryError, "unable to allocate lock");
 		goto error;
@@ -1220,7 +1220,7 @@
 	self->rawfp = NULL;
 #ifdef WITH_THREAD
 	if (self->lock) {
-		PyThread_free_lock(self->lock);
+		PyThread_lock_free(self->lock);
 		self->lock = NULL;
 	}
 #endif
@@ -1233,7 +1233,7 @@
 	int bzerror;
 #ifdef WITH_THREAD
 	if (self->lock)
-		PyThread_free_lock(self->lock);
+		PyThread_lock_free(self->lock);
 #endif
 	switch (self->mode) {
 		case MODE_READ:
@@ -1248,7 +1248,7 @@
 	Util_DropReadAhead(self);
 	if (self->rawfp != NULL)
 		fclose(self->rawfp);
-	Py_Type(self)->tp_free((PyObject *)self);
+	PyObject_DEL(self);
 }
 
 /* This is a hacked version of Python's fileobject.c:file_getiter(). */
@@ -1337,9 +1337,7 @@
         0,                      /*tp_descr_set*/
         0,                      /*tp_dictoffset*/
         (initproc)BZ2File_init, /*tp_init*/
-        PyType_GenericAlloc,    /*tp_alloc*/
         PyType_GenericNew,      /*tp_new*/
-      	PyObject_Free,          /*tp_free*/
         0,                      /*tp_is_gc*/
 };
 
@@ -1525,7 +1523,7 @@
 	}
 
 #ifdef WITH_THREAD
-	self->lock = PyThread_allocate_lock();
+	self->lock = PyThread_lock_allocate();
 	if (!self->lock) {
 		PyErr_SetString(PyExc_MemoryError, "unable to allocate lock");
 		goto error;
@@ -1545,7 +1543,7 @@
 error:
 #ifdef WITH_THREAD
 	if (self->lock) {
-		PyThread_free_lock(self->lock);
+		PyThread_lock_free(self->lock);
 		self->lock = NULL;
 	}
 #endif
@@ -1557,10 +1555,10 @@
 {
 #ifdef WITH_THREAD
 	if (self->lock)
-		PyThread_free_lock(self->lock);
+		PyThread_lock_free(self->lock);
 #endif
 	BZ2_bzCompressEnd(&self->bzs);
-	Py_Type(self)->tp_free((PyObject *)self);
+	PyObject_DEL(self);
 }
 
 
@@ -1613,9 +1611,7 @@
         0,                      /*tp_descr_set*/
         0,                      /*tp_dictoffset*/
         (initproc)BZ2Comp_init, /*tp_init*/
-        PyType_GenericAlloc,    /*tp_alloc*/
         PyType_GenericNew,      /*tp_new*/
-      	PyObject_Free,          /*tp_free*/
         0,                      /*tp_is_gc*/
 };
 
@@ -1743,7 +1739,7 @@
 		return -1;
 
 #ifdef WITH_THREAD
-	self->lock = PyThread_allocate_lock();
+	self->lock = PyThread_lock_allocate();
 	if (!self->lock) {
 		PyErr_SetString(PyExc_MemoryError, "unable to allocate lock");
 		goto error;
@@ -1768,7 +1764,7 @@
 error:
 #ifdef WITH_THREAD
 	if (self->lock) {
-		PyThread_free_lock(self->lock);
+		PyThread_lock_free(self->lock);
 		self->lock = NULL;
 	}
 #endif
@@ -1781,11 +1777,11 @@
 {
 #ifdef WITH_THREAD
 	if (self->lock)
-		PyThread_free_lock(self->lock);
+		PyThread_lock_free(self->lock);
 #endif
 	Py_XDECREF(self->unused_data);
 	BZ2_bzDecompressEnd(&self->bzs);
-	Py_Type(self)->tp_free((PyObject *)self);
+	PyObject_DEL(self);
 }
 
 
@@ -1837,9 +1833,7 @@
         0,                      /*tp_descr_set*/
         0,                      /*tp_dictoffset*/
         (initproc)BZ2Decomp_init, /*tp_init*/
-        PyType_GenericAlloc,    /*tp_alloc*/
         PyType_GenericNew,      /*tp_new*/
-      	PyObject_Free,          /*tp_free*/
         0,                      /*tp_is_gc*/
 };
 
Index: Modules/dlmodule.c
===================================================================
--- Modules/dlmodule.c	(revision 58355)
+++ Modules/dlmodule.c	(working copy)
@@ -27,7 +27,7 @@
 newdlobject(PyUnivPtr *handle)
 {
 	dlobject *xp;
-	xp = PyObject_New(dlobject, &Dltype);
+	xp = PyObject_NEW(dlobject, &Dltype);
 	if (xp == NULL)
 		return NULL;
 	xp->dl_handle = handle;
@@ -39,7 +39,7 @@
 {
 	if (xp->dl_handle != NULL)
 		dlclose(xp->dl_handle);
-	PyObject_Del(xp);
+	PyObject_DEL(xp);
 }
 
 static PyObject *
Index: Modules/_tkinter.c
===================================================================
--- Modules/_tkinter.c	(revision 58355)
+++ Modules/_tkinter.c	(working copy)
@@ -198,24 +198,22 @@
 
 #define ENTER_TCL \
 	{ PyThreadState *tstate = PyThreadState_Get(); Py_BEGIN_ALLOW_THREADS \
-	    if(tcl_lock)PyThread_acquire_lock(tcl_lock, 1); tcl_tstate = tstate;
+	    if(tcl_lock)PyThread_lock_acquire(tcl_lock); tcl_tstate = tstate;
 
 #define LEAVE_TCL \
-    tcl_tstate = NULL; if(tcl_lock)PyThread_release_lock(tcl_lock); Py_END_ALLOW_THREADS}
+    tcl_tstate = NULL; if(tcl_lock)PyThread_lock_release(tcl_lock); Py_END_ALLOW_THREADS}
 
 #define ENTER_OVERLAP \
 	Py_END_ALLOW_THREADS
 
 #define LEAVE_OVERLAP_TCL \
-	tcl_tstate = NULL; if(tcl_lock)PyThread_release_lock(tcl_lock); }
+	tcl_tstate = NULL; if(tcl_lock)PyThread_lock_release(tcl_lock); }
 
 #define ENTER_PYTHON \
-	{ PyThreadState *tstate = tcl_tstate; tcl_tstate = NULL; \
-	    if(tcl_lock)PyThread_release_lock(tcl_lock); PyEval_RestoreThread((tstate)); }
+	{ if(tcl_lock)PyThread_lock_release(tcl_lock); PyState_Resume(); }
 
 #define LEAVE_PYTHON \
-	{ PyThreadState *tstate = PyEval_SaveThread(); \
-	    if(tcl_lock)PyThread_acquire_lock(tcl_lock, 1); tcl_tstate = tstate; }
+	{ PyState_Suspend(); if(tcl_lock)PyThread_lock_acquire(tcl_lock); }
 
 #define CHECK_TCL_APPARTMENT \
 	if (((TkappObject *)self)->threaded && \
@@ -267,7 +265,7 @@
 #define Tkapp_Result(v) Tcl_GetStringResult(Tkapp_Interp(v))
 
 #define DEBUG_REFCNT(v) (printf("DEBUG: id=%p, refcnt=%i\n", \
-(void *) v, Py_Refcnt(v)))
+(void *) v, Py_RefcntSnoop(v)))
 
 
 
@@ -589,7 +587,7 @@
 	TkappObject *v;
 	char *argv0;
 
-	v = PyObject_New(TkappObject, &Tkapp_Type);
+	v = PyObject_NEW(TkappObject, &Tkapp_Type);
 	if (v == NULL)
 		return NULL;
 
@@ -610,7 +608,7 @@
 #ifdef WITH_THREAD
 	if (v->threaded && tcl_lock) {
 	    /* If Tcl is threaded, we don't need the lock. */
-	    PyThread_free_lock(tcl_lock);
+	    PyThread_lock_free(tcl_lock);
 	    tcl_lock = NULL;
 	}
 #endif
@@ -725,7 +723,7 @@
 newPyTclObject(Tcl_Obj *arg)
 {
 	PyTclObject *self;
-	self = PyObject_New(PyTclObject, &PyTclObject_Type);
+	self = PyObject_NEW(PyTclObject, &PyTclObject_Type);
 	if (self == NULL)
 		return NULL;
 	Tcl_IncrRefCount(arg);
@@ -739,7 +737,7 @@
 {
 	Tcl_DecrRefCount(self->value);
 	Py_XDECREF(self->string);
-	PyObject_Del(self);
+	PyObject_DEL(self);
 }
 
 static char*
@@ -853,9 +851,7 @@
         0,                      /*tp_descr_set*/
         0,                      /*tp_dictoffset*/
         0,                      /*tp_init*/
-        0,                      /*tp_alloc*/
         0,                      /*tp_new*/
-        0,                      /*tp_free*/
         0,                      /*tp_is_gc*/
 };
 
@@ -2283,7 +2279,7 @@
 {
 	TkttObject *v;
   
-	v = PyObject_New(TkttObject, &Tktt_Type);
+	v = PyObject_NEW(TkttObject, &Tktt_Type);
 	if (v == NULL)
 		return NULL;
 
@@ -2458,11 +2454,11 @@
 		}
 		else {
 			Py_BEGIN_ALLOW_THREADS
-			if(tcl_lock)PyThread_acquire_lock(tcl_lock, 1);
+			if(tcl_lock)PyThread_lock_acquire(tcl_lock);
 			tcl_tstate = tstate;
 			result = Tcl_DoOneEvent(TCL_DONT_WAIT);
 			tcl_tstate = NULL;
-			if(tcl_lock)PyThread_release_lock(tcl_lock);
+			if(tcl_lock)PyThread_lock_release(tcl_lock);
 			if (result == 0)
 				Sleep(Tkinter_busywaitinterval);
 			Py_END_ALLOW_THREADS
@@ -2471,11 +2467,6 @@
 		result = Tcl_DoOneEvent(0);
 #endif
 
-		if (PyErr_CheckSignals() != 0) {
-			if (self)
-				self->dispatching = 0;
-			return NULL;
-		}
 		if (result < 0)
 			break;
 	}
@@ -2907,7 +2898,7 @@
 	int tfile;
 #endif
 #ifdef WITH_THREAD
-	PyEval_RestoreThread(event_tstate);
+	PyState_Resume();
 #endif
 	stdin_ready = 0;
 	errorInCmd = 0;
@@ -2925,13 +2916,13 @@
 #endif
 #if defined(WITH_THREAD) || defined(MS_WINDOWS)
 		Py_BEGIN_ALLOW_THREADS
-		if(tcl_lock)PyThread_acquire_lock(tcl_lock, 1);
+		if(tcl_lock)PyThread_lock_acquire(tcl_lock);
 		tcl_tstate = event_tstate;
 
 		result = Tcl_DoOneEvent(TCL_DONT_WAIT);
 
 		tcl_tstate = NULL;
-		if(tcl_lock)PyThread_release_lock(tcl_lock);
+		if(tcl_lock)PyThread_lock_release(tcl_lock);
 		if (result == 0)
 			Sleep(Tkinter_busywaitinterval);
 		Py_END_ALLOW_THREADS
@@ -2952,7 +2943,7 @@
 		PyErr_Print();
 	}
 #ifdef WITH_THREAD
-	PyEval_SaveThread();
+	PyState_Suspend();
 #endif
 	return 0;
 }
@@ -3012,7 +3003,7 @@
 	Py_Type(&Tkapp_Type) = &PyType_Type;
 
 #ifdef WITH_THREAD
-	tcl_lock = PyThread_allocate_lock();
+	tcl_lock = PyThread_lock_allocate();
 #endif
 
 	m = Py_InitModule("_tkinter", moduleMethods);
Index: Modules/_ctypes/callbacks.c
===================================================================
--- Modules/_ctypes/callbacks.c	(revision 58355)
+++ Modules/_ctypes/callbacks.c	(working copy)
@@ -124,7 +124,9 @@
 	PyObject *arglist = NULL;
 	Py_ssize_t nArgs;
 #ifdef WITH_THREAD
-	PyGILState_STATE state = PyGILState_Ensure();
+	PyState_EnterTag entertag = PyState_Enter();
+	if (!entertag)
+		Py_FatalError("PyState_Enter failed");
 #endif
 
 	nArgs = PySequence_Length(converters);
@@ -235,7 +237,7 @@
   Done:
 	Py_XDECREF(arglist);
 #ifdef WITH_THREAD
-	PyGILState_Release(state);
+	PyState_Exit(entertag);
 #endif
 }
 
@@ -349,9 +351,6 @@
 static void LoadPython(void)
 {
 	if (!Py_IsInitialized()) {
-#ifdef WITH_THREAD
-		PyEval_InitThreads();
-#endif
 		Py_Initialize();
 	}
 }
@@ -423,16 +422,18 @@
 {
 	long result;
 #ifdef WITH_THREAD
-	PyGILState_STATE state;
+	PyState_EnterTag entertag;
 #endif
 
 	LoadPython();
 #ifdef WITH_THREAD
-	state = PyGILState_Ensure();
+	entertag = PyState_Enter();
+	if (!entertag)
+		Py_FatalError("PyState_Enter failed");
 #endif
 	result = Call_GetClassObject(rclsid, riid, ppv);
 #ifdef WITH_THREAD
-	PyGILState_Release(state);
+	PyState_Exit(entertag);
 #endif
 	return result;
 }
@@ -486,11 +487,13 @@
 {
 	long result;
 #ifdef WITH_THREAD
-	PyGILState_STATE state = PyGILState_Ensure();
+	PyState_EnterTag entertag = PyState_Enter();
+	if (!entertag)
+		Py_FatalError("PyState_Enter failed");
 #endif
 	result = Call_CanUnloadNow();
 #ifdef WITH_THREAD
-	PyGILState_Release(state);
+	PyState_Exit(entertag);
 #endif
 	return result;
 }
Index: Modules/_ctypes/callproc.c
===================================================================
--- Modules/_ctypes/callproc.c	(revision 58355)
+++ Modules/_ctypes/callproc.c	(working copy)
@@ -280,7 +280,7 @@
 new_CArgObject(void)
 {
 	PyCArgObject *p;
-	p = PyObject_New(PyCArgObject, &PyCArg_Type);
+	p = PyObject_NEW(PyCArgObject, &PyCArg_Type);
 	if (p == NULL)
 		return NULL;
 	p->pffi_type = NULL;
@@ -294,7 +294,7 @@
 PyCArg_dealloc(PyCArgObject *self)
 {
 	Py_XDECREF(self->obj);
-	PyObject_Del(self);
+	PyObject_DEL(self);
 }
 
 static PyObject *
Index: Modules/_ctypes/_ctypes.c
===================================================================
--- Modules/_ctypes/_ctypes.c	(revision 58355)
+++ Modules/_ctypes/_ctypes.c	(working copy)
@@ -463,9 +463,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	StructType_new,				/* tp_new */
-	0,					/* tp_free */
 };
 
 static PyTypeObject UnionType_Type = {
@@ -505,9 +503,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	UnionType_new,				/* tp_new */
-	0,					/* tp_free */
 };
 
 
@@ -719,9 +715,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	PointerType_new,			/* tp_new */
-	0,					/* tp_free */
 };
 
 
@@ -1087,9 +1081,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	ArrayType_new,				/* tp_new */
-	0,					/* tp_free */
 };
 
 
@@ -1725,9 +1717,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	SimpleType_new,				/* tp_new */
-	0,					/* tp_free */
 };
 
 /******************************************************************/
@@ -1935,9 +1925,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	CFuncPtrType_new,			/* tp_new */
-	0,					/* tp_free */
 };
 
 
@@ -2067,7 +2055,7 @@
 CData_dealloc(PyObject *self)
 {
 	CData_clear((CDataObject *)self);
-	Py_Type(self)->tp_free(self);
+	PyObject_Del(self);
 }
 
 static PyMemberDef CData_members[] = {
@@ -2156,9 +2144,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	0,					/* tp_new */
-	0,					/* tp_free */
 };
 
 static int CData_MallocBuffer(CDataObject *obj, StgDictObject *dict)
@@ -2203,7 +2189,7 @@
 		return NULL;
 	}
 	dict->flags |= DICTFLAG_FINAL;
-	cmem = (CDataObject *)((PyTypeObject *)type)->tp_alloc((PyTypeObject *)type, 0);
+	cmem = PyObject_NEW(CDataObject, (PyTypeObject *)type);
 	if (cmem == NULL)
 		return NULL;
 	assert(CDataObject_Check(cmem));
@@ -2246,7 +2232,7 @@
 	}
 	dict->flags |= DICTFLAG_FINAL;
 
-	pd = (CDataObject *)((PyTypeObject *)type)->tp_alloc((PyTypeObject *)type, 0);
+	pd = PyObject_NEW(CDataObject, (PyTypeObject *)type);
 	if (!pd)
 		return NULL;
 	assert(CDataObject_Check(pd));
@@ -2425,7 +2411,7 @@
 	}
 	dict->flags |= DICTFLAG_FINAL;
 
-	obj = (CDataObject *)type->tp_alloc(type, 0);
+	obj = PyObject_NEW(CDataObject, type);
 	if (!obj)
 		return NULL;
 
@@ -3419,7 +3405,7 @@
 CFuncPtr_dealloc(CFuncPtrObject *self)
 {
 	CFuncPtr_clear(self);
-	Py_Type(self)->tp_free((PyObject *)self);
+	PyObject_DEL(self);
 }
 
 static PyObject *
@@ -3474,9 +3460,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
         CFuncPtr_new,				/* tp_new */
-	0,					/* tp_free */
 };
 
 /*****************************************************************/
@@ -3602,9 +3586,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	Struct_init,				/* tp_init */
-	0,					/* tp_alloc */
 	GenericCData_new,			/* tp_new */
-	0,					/* tp_free */
 };
 
 static PyTypeObject Union_Type = {
@@ -3644,9 +3626,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	Struct_init,				/* tp_init */
-	0,					/* tp_alloc */
 	GenericCData_new,			/* tp_new */
-	0,					/* tp_free */
 };
 
 
@@ -3953,9 +3933,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	(initproc)Array_init,			/* tp_init */
-	0,					/* tp_alloc */
         GenericCData_new,			/* tp_new */
-	0,					/* tp_free */
 };
 
 PyObject *
@@ -4169,9 +4147,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	(initproc)Simple_init,			/* tp_init */
-	0,					/* tp_alloc */
         GenericCData_new,			/* tp_new */
-	0,					/* tp_free */
 };
 
 /******************************************************************/
@@ -4546,9 +4522,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	(initproc)Pointer_init,			/* tp_init */
-	0,					/* tp_alloc */
 	Pointer_new,				/* tp_new */
-	0,					/* tp_free */
 };
 
 
@@ -4763,9 +4737,6 @@
    ob_type is the metatype (the 'type'), defaults to PyType_Type,
    tp_base is the base type, defaults to 'object' aka PyBaseObject_Type.
 */
-#ifdef WITH_THREAD
-	PyEval_InitThreads();
-#endif
 	m = Py_InitModule3("_ctypes", module_methods, module_docs);
 	if (!m)
 		return;
Index: Modules/_ctypes/cfield.c
===================================================================
--- Modules/_ctypes/cfield.c	(revision 58355)
+++ Modules/_ctypes/cfield.c	(working copy)
@@ -13,9 +13,7 @@
 static PyObject *
 CField_new(PyTypeObject *type, PyObject *args, PyObject *kwds)
 {
-	CFieldObject *obj;
-	obj = (CFieldObject *)type->tp_alloc(type, 0);
-	return (PyObject *)obj;
+	return PyObject_New(type);
 }
 
 /*
@@ -249,7 +247,7 @@
 CField_dealloc(PyObject *self)
 {
 	CField_clear((CFieldObject *)self);
-	self->ob_type->tp_free((PyObject *)self);
+	PyObject_Del(self);
 }
 
 static PyObject *
@@ -310,9 +308,7 @@
 	(descrsetfunc)CField_set,		/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	CField_new,				/* tp_new */
-	0,					/* tp_free */
 };
 
 
Index: Modules/socketmodule.c
===================================================================
--- Modules/socketmodule.c	(revision 58355)
+++ Modules/socketmodule.c	(working copy)
@@ -165,8 +165,8 @@
 #endif
 
 #ifdef USE_GETADDRINFO_LOCK
-#define ACQUIRE_GETADDRINFO_LOCK PyThread_acquire_lock(netdb_lock, 1);
-#define RELEASE_GETADDRINFO_LOCK PyThread_release_lock(netdb_lock);
+#define ACQUIRE_GETADDRINFO_LOCK PyThread_lock_acquire(netdb_lock);
+#define RELEASE_GETADDRINFO_LOCK PyThread_lock_release(netdb_lock);
 #else
 #define ACQUIRE_GETADDRINFO_LOCK
 #define RELEASE_GETADDRINFO_LOCK
@@ -1933,13 +1933,6 @@
 	res = internal_connect(s, SAS2SA(&addrbuf), addrlen, &timeout);
 	Py_END_ALLOW_THREADS
 
-	/* Signals are not errors (though they may raise exceptions).  Adapted
-	   from PyErr_SetFromErrnoWithFilenameObject(). */
-#ifdef EINTR
-	if (res == EINTR && PyErr_CheckSignals())
-		return NULL;
-#endif
-
 	return PyInt_FromLong((long) res);
 }
 
@@ -2685,7 +2678,7 @@
 {
 	if (s->sock_fd != -1)
 		(void) SOCKETCLOSE(s->sock_fd);
-	Py_Type(s)->tp_free((PyObject *)s);
+	PyObject_DEL(s);
 }
 
 
@@ -2718,7 +2711,7 @@
 {
 	PyObject *new;
 
-	new = type->tp_alloc(type, 0);
+	new = PyObject_New(type);
 	if (new != NULL) {
 		((PySocketSockObject *)new)->sock_fd = -1;
 		((PySocketSockObject *)new)->sock_timeout = -1.0;
@@ -2811,9 +2804,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	sock_initobj,				/* tp_init */
-	PyType_GenericAlloc,			/* tp_alloc */
 	sock_new,				/* tp_new */
-	PyObject_Del,				/* tp_free */
 };
 
 
@@ -3042,7 +3033,7 @@
 #endif
 #else /* not HAVE_GETHOSTBYNAME_R */
 #ifdef USE_GETHOSTBYNAME_LOCK
-	PyThread_acquire_lock(netdb_lock, 1);
+	ACQUIRE_GETADDRINFO_LOCK
 #endif
 	h = gethostbyname(name);
 #endif /* HAVE_GETHOSTBYNAME_R */
@@ -3055,7 +3046,7 @@
 	ret = gethost_common(h, (struct sockaddr *)&addr, sizeof(addr),
 			     sa->sa_family);
 #ifdef USE_GETHOSTBYNAME_LOCK
-	PyThread_release_lock(netdb_lock);
+    RELEASE_GETADDRINFO_LOCK
 #endif
 	return ret;
 }
@@ -3138,14 +3129,14 @@
 #endif
 #else /* not HAVE_GETHOSTBYNAME_R */
 #ifdef USE_GETHOSTBYNAME_LOCK
-	PyThread_acquire_lock(netdb_lock, 1);
+	ACQUIRE_GETADDRINFO_LOCK
 #endif
 	h = gethostbyaddr(ap, al, af);
 #endif /* HAVE_GETHOSTBYNAME_R */
 	Py_END_ALLOW_THREADS
 	ret = gethost_common(h, (struct sockaddr *)&addr, sizeof(addr), af);
 #ifdef USE_GETHOSTBYNAME_LOCK
-	PyThread_release_lock(netdb_lock);
+	RELEASE_GETADDRINFO_LOCK
 #endif
 	return ret;
 }
Index: Modules/mmapmodule.c
===================================================================
--- Modules/mmapmodule.c	(revision 58355)
+++ Modules/mmapmodule.c	(working copy)
@@ -114,7 +114,7 @@
 	}
 #endif /* UNIX */
 
-	PyObject_Del(m_obj);
+	PyObject_DEL(m_obj);
 }
 
 static PyObject *
@@ -965,7 +965,7 @@
 		}
 	}
 #endif
-	m_obj = PyObject_New(mmap_object, &mmap_object_type);
+	m_obj = PyObject_NEW(mmap_object, &mmap_object_type);
 	if (m_obj == NULL) {return NULL;}
 	m_obj->data = NULL;
 	m_obj->size = (size_t) map_size;
@@ -1083,7 +1083,7 @@
 		lseek(fileno, 0, SEEK_SET);
 	}
 
-	m_obj = PyObject_New(mmap_object, &mmap_object_type);
+	m_obj = PyObject_NEW(mmap_object, &mmap_object_type);
 	if (m_obj == NULL)
 		return NULL;
 	/* Set every field to an invalid marker, so we can safely
Index: Modules/datetimemodule.c
===================================================================
--- Modules/datetimemodule.c	(revision 58355)
+++ Modules/datetimemodule.c	(working copy)
@@ -576,57 +576,7 @@
 	return normalize_date(year, month, day);
 }
 
-/* ---------------------------------------------------------------------------
- * Basic object allocation:  tp_alloc implementations.  These allocate
- * Python objects of the right size and type, and do the Python object-
- * initialization bit.  If there's not enough memory, they return NULL after
- * setting MemoryError.  All data members remain uninitialized trash.
- *
- * We abuse the tp_alloc "nitems" argument to communicate whether a tzinfo
- * member is needed.  This is ugly, imprecise, and possibly insecure.
- * tp_basicsize for the time and datetime types is set to the size of the
- * struct that has room for the tzinfo member, so subclasses in Python will
- * allocate enough space for a tzinfo member whether or not one is actually
- * needed.  That's the "ugly and imprecise" parts.  The "possibly insecure"
- * part is that PyType_GenericAlloc() (which subclasses in Python end up
- * using) just happens today to effectively ignore the nitems argument
- * when tp_itemsize is 0, which it is for these type objects.  If that
- * changes, perhaps the callers of tp_alloc slots in this file should
- * be changed to force a 0 nitems argument unless the type being allocated
- * is a base type implemented in this file (so that tp_alloc is time_alloc
- * or datetime_alloc below, which know about the nitems abuse).
- */
 
-static PyObject *
-time_alloc(PyTypeObject *type, Py_ssize_t aware)
-{
-	PyObject *self;
-
-	self = (PyObject *)
-		PyObject_MALLOC(aware ?
-				sizeof(PyDateTime_Time) :
-				sizeof(_PyDateTime_BaseTime));
-	if (self == NULL)
-		return (PyObject *)PyErr_NoMemory();
-	PyObject_INIT(self, type);
-	return self;
-}
-
-static PyObject *
-datetime_alloc(PyTypeObject *type, Py_ssize_t aware)
-{
-	PyObject *self;
-
-	self = (PyObject *)
-		PyObject_MALLOC(aware ?
-				sizeof(PyDateTime_DateTime) :
-				sizeof(_PyDateTime_BaseDateTime));
-	if (self == NULL)
-		return (PyObject *)PyErr_NoMemory();
-	PyObject_INIT(self, type);
-	return self;
-}
-
 /* ---------------------------------------------------------------------------
  * Helpers for setting object fields.  These work on pointers to the
  * appropriate base class.
@@ -652,7 +602,7 @@
 {
 	PyDateTime_Date *self;
 
-	self = (PyDateTime_Date *) (type->tp_alloc(type, 0));
+	self = PyObject_NEW(PyDateTime_Date, type);
 	if (self != NULL)
 		set_date_fields(self, year, month, day);
 	return (PyObject *) self;
@@ -669,7 +619,7 @@
 	PyDateTime_DateTime *self;
 	char aware = tzinfo != Py_None;
 
-	self = (PyDateTime_DateTime *) (type->tp_alloc(type, aware));
+	self = PyObject_NEW(PyDateTime_DateTime, type);
 	if (self != NULL) {
 		self->hastzinfo = aware;
 		set_date_fields((PyDateTime_Date *)self, year, month, day);
@@ -697,7 +647,7 @@
 	PyDateTime_Time *self;
 	char aware = tzinfo != Py_None;
 
-	self = (PyDateTime_Time *) (type->tp_alloc(type, aware));
+	self = PyObject_NEW(PyDateTime_Time, type);
 	if (self != NULL) {
 		self->hastzinfo = aware;
 		self->hashcode = -1;
@@ -736,7 +686,7 @@
  	if (check_delta_day_range(days) < 0)
  		return NULL;
 
-	self = (PyDateTime_Delta *) (type->tp_alloc(type, 0));
+	self = PyObject_NEW(PyDateTime_Delta, type);
 	if (self != NULL) {
 		self->hashcode = -1;
 		SET_TD_DAYS(self, days);
@@ -2141,9 +2091,7 @@
 	0,						/* tp_descr_set */
 	0,						/* tp_dictoffset */
 	0,						/* tp_init */
-	0,						/* tp_alloc */
 	delta_new,					/* tp_new */
-	0,						/* tp_free */
 };
 
 /*
@@ -2198,7 +2146,7 @@
 	{
 	    	PyDateTime_Date *me;
 
-		me = (PyDateTime_Date *) (type->tp_alloc(type, 0));
+		me = PyObject_NEW(PyDateTime_Date, type);
 		if (me != NULL) {
 			char *pdata = PyBytes_AS_STRING(state);
 			memcpy(me->data, pdata, _PyDateTime_DATE_DATASIZE);
@@ -2712,9 +2660,7 @@
 	0,						/* tp_descr_set */
 	0,						/* tp_dictoffset */
 	0,						/* tp_init */
-	0,						/* tp_alloc */
 	date_new,					/* tp_new */
-	0,						/* tp_free */
 };
 
 /*
@@ -2966,9 +2912,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	PyType_GenericNew,			/* tp_new */
-	0,					/* tp_free */
 };
 
 /*
@@ -3057,7 +3001,7 @@
 			}
 		}
 		aware = (char)(tzinfo != Py_None);
-		me = (PyDateTime_Time *) (type->tp_alloc(type, aware));
+		me = PyObject_NEW(PyDateTime_Time, type);
 		if (me != NULL) {
 			char *pdata = PyBytes_AS_STRING(state);
 
@@ -3095,7 +3039,7 @@
 	if (HASTZINFO(self)) {
 		Py_XDECREF(self->tzinfo);
 	}
-	Py_Type(self)->tp_free((PyObject *)self);
+	PyObject_DEL(self);
 }
 
 /*
@@ -3495,9 +3439,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	time_alloc,				/* tp_alloc */
 	time_new,				/* tp_new */
-	0,					/* tp_free */
 };
 
 /*
@@ -3591,7 +3533,7 @@
 			}
 		}
 		aware = (char)(tzinfo != Py_None);
-		me = (PyDateTime_DateTime *) (type->tp_alloc(type , aware));
+		me = PyObject_NEW(PyDateTime_DateTime, type);
 		if (me != NULL) {
 			char *pdata = PyBytes_AS_STRING(state);
 
@@ -3900,7 +3842,7 @@
 	if (HASTZINFO(self)) {
 		Py_XDECREF(self->tzinfo);
 	}
-	Py_Type(self)->tp_free((PyObject *)self);
+	PyObject_DEL(self);
 }
 
 /*
@@ -4589,9 +4531,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	datetime_alloc,				/* tp_alloc */
 	datetime_new,				/* tp_new */
-	0,					/* tp_free */
 };
 
 /* ---------------------------------------------------------------------------
Index: Modules/_lsprof.c
===================================================================
--- Modules/_lsprof.c	(revision 58355)
+++ Modules/_lsprof.c	(working copy)
@@ -210,8 +210,11 @@
 		PyObject *self = fn->m_self;
 		PyObject *name = PyUnicode_FromString(fn->m_ml->ml_name);
 		if (name != NULL) {
-			PyObject *mo = _PyType_Lookup(Py_Type(self), name);
-			Py_XINCREF(mo);
+			PyObject *mo;
+			if (_PyType_LookupEx(Py_Type(self), name, &mo) < 0) {
+				Py_DECREF(name);
+				return NULL;
+			}
 			Py_DECREF(name);
 			if (mo != NULL) {
 				PyObject *res = PyObject_Repr(mo);
@@ -220,7 +223,8 @@
 					return res;
 			}
 		}
-		PyErr_Clear();
+		/* XXX FIXME why is this calling PyErr_Clear()? */
+		//PyErr_Clear();
 		return PyUnicode_FromFormat("<built-in method %s>",
 					    fn->m_ml->ml_name);
 	}
@@ -759,7 +763,7 @@
 	flush_unmatched(op);
 	clearEntries(op);
 	Py_XDECREF(op->externalTimer);
-	Py_Type(op)->tp_free(op);
+	PyObject_DEL(op);
 }
 
 static int
@@ -851,9 +855,7 @@
 	0,                                      /* tp_descr_set */
 	0,                                      /* tp_dictoffset */
 	(initproc)profiler_init,                /* tp_init */
-	PyType_GenericAlloc,                    /* tp_alloc */
 	PyType_GenericNew,                      /* tp_new */
-	PyObject_Del,                           /* tp_free */
 };
 
 static PyMethodDef moduleMethods[] = {
Index: Modules/xxmodule.c
===================================================================
--- Modules/xxmodule.c	(revision 58355)
+++ Modules/xxmodule.c	(working copy)
@@ -134,9 +134,7 @@
         0,                      /*tp_descr_set*/
         0,                      /*tp_dictoffset*/
         0,                      /*tp_init*/
-        0,                      /*tp_alloc*/
         0,                      /*tp_new*/
-        0,                      /*tp_free*/
         0,                      /*tp_is_gc*/
 };
 /* --------------------------------------------------------------------- */
@@ -252,9 +250,7 @@
 	0,			/*tp_descr_set*/
 	0,			/*tp_dictoffset*/
 	0,			/*tp_init*/
-	0,			/*tp_alloc*/
 	0,			/*tp_new*/
-	0,			/*tp_free*/
 	0,			/*tp_is_gc*/
 };
 
@@ -307,9 +303,7 @@
 	0,			/*tp_descr_set*/
 	0,			/*tp_dictoffset*/
 	0,			/*tp_init*/
-	0,			/*tp_alloc*/
 	PyType_GenericNew,	/*tp_new*/
-	0,			/*tp_free*/
 	0,			/*tp_is_gc*/
 };
 
Index: Modules/cjkcodecs/multibytecodec.c
===================================================================
--- Modules/cjkcodecs/multibytecodec.c	(revision 58355)
+++ Modules/cjkcodecs/multibytecodec.c	(working copy)
@@ -676,7 +676,7 @@
 static void
 multibytecodec_dealloc(MultibyteCodecObject *self)
 {
-	PyObject_Del(self);
+	PyObject_DEL(self);
 }
 
 static PyTypeObject MultibyteCodec_Type = {
@@ -905,7 +905,7 @@
 					 incnewkwarglist, &errors))
 		return NULL;
 
-	self = (MultibyteIncrementalEncoderObject *)type->tp_alloc(type, 0);
+	self = PyObject_NEW(MultibyteIncrementalEncoderObject, type);
 	if (self == NULL)
 		return NULL;
 
@@ -953,9 +953,8 @@
 static void
 mbiencoder_dealloc(MultibyteIncrementalEncoderObject *self)
 {
-	PyObject_GC_UnTrack(self);
 	ERROR_DECREF(self->errors);
-	Py_Type(self)->tp_free(self);
+	PyObject_DEL(self);
 }
 
 static PyTypeObject MultibyteIncrementalEncoder_Type = {
@@ -997,7 +996,6 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	mbiencoder_init,		/* tp_init */
-	0,				/* tp_alloc */
 	mbiencoder_new,			/* tp_new */
 };
 
@@ -1105,7 +1103,7 @@
 					 incnewkwarglist, &errors))
 		return NULL;
 
-	self = (MultibyteIncrementalDecoderObject *)type->tp_alloc(type, 0);
+	self = PyObject_NEW(MultibyteIncrementalDecoderObject, type);
 	if (self == NULL)
 		return NULL;
 
@@ -1153,9 +1151,8 @@
 static void
 mbidecoder_dealloc(MultibyteIncrementalDecoderObject *self)
 {
-	PyObject_GC_UnTrack(self);
 	ERROR_DECREF(self->errors);
-	Py_Type(self)->tp_free(self);
+	PyObject_DEL(self);
 }
 
 static PyTypeObject MultibyteIncrementalDecoder_Type = {
@@ -1197,7 +1194,6 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	mbidecoder_init,		/* tp_init */
-	0,				/* tp_alloc */
 	mbidecoder_new,			/* tp_new */
 };
 
@@ -1435,7 +1431,7 @@
 				streamkwarglist, &stream, &errors))
 		return NULL;
 
-	self = (MultibyteStreamReaderObject *)type->tp_alloc(type, 0);
+	self = PyObject_NEW(MultibyteStreamReaderObject, type);
 	if (self == NULL)
 		return NULL;
 
@@ -1486,10 +1482,9 @@
 static void
 mbstreamreader_dealloc(MultibyteStreamReaderObject *self)
 {
-	PyObject_GC_UnTrack(self);
 	ERROR_DECREF(self->errors);
 	Py_DECREF(self->stream);
-	Py_Type(self)->tp_free(self);
+	PyObject_DEL(self);
 }
 
 static PyTypeObject MultibyteStreamReader_Type = {
@@ -1531,7 +1526,6 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	mbstreamreader_init,		/* tp_init */
-	0,				/* tp_alloc */
 	mbstreamreader_new,		/* tp_new */
 };
 
@@ -1638,7 +1632,7 @@
 				streamkwarglist, &stream, &errors))
 		return NULL;
 
-	self = (MultibyteStreamWriterObject *)type->tp_alloc(type, 0);
+	self = PyObject_NEW(MultibyteStreamWriterObject, type);
 	if (self == NULL)
 		return NULL;
 
@@ -1689,10 +1683,9 @@
 static void
 mbstreamwriter_dealloc(MultibyteStreamWriterObject *self)
 {
-	PyObject_GC_UnTrack(self);
 	ERROR_DECREF(self->errors);
 	Py_DECREF(self->stream);
-	Py_Type(self)->tp_free(self);
+	PyObject_DEL(self);
 }
 
 static struct PyMethodDef mbstreamwriter_methods[] = {
@@ -1751,7 +1744,6 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	mbstreamwriter_init,		/* tp_init */
-	0,				/* tp_alloc */
 	mbstreamwriter_new,		/* tp_new */
 };
 
@@ -1775,7 +1767,7 @@
 	if (codec->codecinit != NULL && codec->codecinit(codec->config) != 0)
 		return NULL;
 
-	self = PyObject_New(MultibyteCodecObject, &MultibyteCodec_Type);
+	self = PyObject_NEW(MultibyteCodecObject, &MultibyteCodec_Type);
 	if (self == NULL)
 		return NULL;
 	self->codec = codec;
Index: Modules/dbmmodule.c
===================================================================
--- Modules/dbmmodule.c	(revision 58355)
+++ Modules/dbmmodule.c	(working copy)
@@ -48,7 +48,7 @@
 {
         dbmobject *dp;
 
-	dp = PyObject_New(dbmobject, &Dbmtype);
+	dp = PyObject_NEW(dbmobject, &Dbmtype);
 	if (dp == NULL)
 		return NULL;
 	dp->di_size = -1;
@@ -67,7 +67,7 @@
 {
         if ( dp->di_dbm )
 		dbm_close(dp->di_dbm);
-	PyObject_Del(dp);
+	PyObject_DEL(dp);
 }
 
 static Py_ssize_t
Index: Modules/_typesmodule.c
===================================================================
--- Modules/_typesmodule.c	(revision 58355)
+++ Modules/_typesmodule.c	(working copy)
@@ -69,9 +69,7 @@
     0,						/* tp_descr_set */
     0,						/* tp_dictoffset */
     0,						/* tp_init */
-    0,						/* tp_alloc */
     0,                                          /* tp_new */
-    0,						/* tp_free */
 };
 
 PyMODINIT_FUNC
Index: Modules/_bsddb.c
===================================================================
--- Modules/_bsddb.c	(revision 58355)
+++ Modules/_bsddb.c	(working copy)
@@ -120,9 +120,10 @@
 /* and these are for calling C --> Python */
 #if defined(MYDB_USE_GILSTATE)
 #define MYDB_BEGIN_BLOCK_THREADS \
-		PyGILState_STATE __savestate = PyGILState_Ensure();
+		PyState_EnterTag __entertag = PyState_Enter(); \
+		if (!__entertag) Py_FatalError("PyState_Enter failed");
 #define MYDB_END_BLOCK_THREADS \
-		PyGILState_Release(__savestate);
+		PyState_Exit(__entertag);
 #else /* MYDB_USE_GILSTATE */
 /* Pre GILState API - do it the long old way */
 static PyInterpreterState* _db_interpreterState = NULL;
@@ -874,7 +875,7 @@
     DB_ENV* db_env = NULL;
     int err;
 
-    self = PyObject_New(DBObject, &DB_Type);
+    self = PyObject_NEW(DBObject, &DB_Type);
     if (self == NULL)
         return NULL;
 
@@ -921,7 +922,7 @@
             Py_DECREF(self->myenvobj);
             self->myenvobj = NULL;
         }
-        PyObject_Del(self);
+        PyObject_DEL(self);
         self = NULL;
     }
     return self;
@@ -950,11 +951,6 @@
         }
         self->db = NULL;
     }
-#ifdef HAVE_WEAKREF
-    if (self->in_weakreflist != NULL) {
-        PyObject_ClearWeakRefs((PyObject *) self);
-    }
-#endif
     if (self->myenvobj) {
         Py_DECREF(self->myenvobj);
         self->myenvobj = NULL;
@@ -969,14 +965,14 @@
         self->btCompareCallback = NULL;
     }
 #endif
-    PyObject_Del(self);
+    PyObject_DEL(self);
 }
 
 
 static DBCursorObject*
 newDBCursorObject(DBC* dbc, DBObject* db)
 {
-    DBCursorObject* self = PyObject_New(DBCursorObject, &DBCursor_Type);
+    DBCursorObject* self = PyObject_NEW(DBCursorObject, &DBCursor_Type);
     if (self == NULL)
         return NULL;
 
@@ -995,12 +991,6 @@
 {
     int err;
 
-#ifdef HAVE_WEAKREF
-    if (self->in_weakreflist != NULL) {
-        PyObject_ClearWeakRefs((PyObject *) self);
-    }
-#endif
-
     if (self->dbc != NULL) {
         MYDB_BEGIN_ALLOW_THREADS;
 	/* If the underlying database has been closed, we don't
@@ -1016,7 +1006,7 @@
         MYDB_END_ALLOW_THREADS;
     }
     Py_XDECREF( self->mydb );
-    PyObject_Del(self);
+    PyObject_DEL(self);
 }
 
 
@@ -1024,7 +1014,7 @@
 newDBEnvObject(int flags)
 {
     int err;
-    DBEnvObject* self = PyObject_New(DBEnvObject, &DBEnv_Type);
+    DBEnvObject* self = PyObject_NEW(DBEnvObject, &DBEnv_Type);
     if (self == NULL)
         return NULL;
 
@@ -1040,7 +1030,7 @@
     err = db_env_create(&self->db_env, flags);
     MYDB_END_ALLOW_THREADS;
     if (makeDBError(err)) {
-        PyObject_Del(self);
+        PyObject_DEL(self);
         self = NULL;
     }
     else {
@@ -1053,18 +1043,12 @@
 static void
 DBEnv_dealloc(DBEnvObject* self)
 {
-#ifdef HAVE_WEAKREF
-    if (self->in_weakreflist != NULL) {
-        PyObject_ClearWeakRefs((PyObject *) self);
-    }
-#endif
-
     if (self->db_env && !self->closed) {
         MYDB_BEGIN_ALLOW_THREADS;
         self->db_env->close(self->db_env, 0);
         MYDB_END_ALLOW_THREADS;
     }
-    PyObject_Del(self);
+    PyObject_DEL(self);
 }
 
 
@@ -1072,7 +1056,7 @@
 newDBTxnObject(DBEnvObject* myenv, DB_TXN *parent, int flags)
 {
     int err;
-    DBTxnObject* self = PyObject_New(DBTxnObject, &DBTxn_Type);
+    DBTxnObject* self = PyObject_NEW(DBTxnObject, &DBTxn_Type);
     if (self == NULL)
         return NULL;
     Py_INCREF(myenv);
@@ -1090,7 +1074,7 @@
     MYDB_END_ALLOW_THREADS;
     if (makeDBError(err)) {
         Py_DECREF(self->env);
-        PyObject_Del(self);
+        PyObject_DEL(self);
         self = NULL;
     }
     return self;
@@ -1100,12 +1084,6 @@
 static void
 DBTxn_dealloc(DBTxnObject* self)
 {
-#ifdef HAVE_WEAKREF
-    if (self->in_weakreflist != NULL) {
-        PyObject_ClearWeakRefs((PyObject *) self);
-    }
-#endif
-
 #ifdef HAVE_WARNINGS
     if (self->txn) {
         /* it hasn't been finalized, abort it! */
@@ -1124,7 +1102,7 @@
 #endif
 
     Py_DECREF(self->env);
-    PyObject_Del(self);
+    PyObject_DEL(self);
 }
 
 
@@ -1133,7 +1111,7 @@
                 db_lockmode_t lock_mode, int flags)
 {
     int err;
-    DBLockObject* self = PyObject_New(DBLockObject, &DBLock_Type);
+    DBLockObject* self = PyObject_NEW(DBLockObject, &DBLock_Type);
     if (self == NULL)
         return NULL;
 #ifdef HAVE_WEAKREF
@@ -1149,7 +1127,7 @@
 #endif
     MYDB_END_ALLOW_THREADS;
     if (makeDBError(err)) {
-        PyObject_Del(self);
+        PyObject_DEL(self);
         self = NULL;
     }
 
@@ -1160,14 +1138,9 @@
 static void
 DBLock_dealloc(DBLockObject* self)
 {
-#ifdef HAVE_WEAKREF
-    if (self->in_weakreflist != NULL) {
-        PyObject_ClearWeakRefs((PyObject *) self);
-    }
-#endif
     /* TODO: is this lock held? should we release it? */
 
-    PyObject_Del(self);
+    PyObject_DEL(self);
 }
 
 
@@ -1202,12 +1175,6 @@
 static void
 DBSequence_dealloc(DBSequenceObject* self)
 {
-#ifdef HAVE_WEAKREF
-    if (self->in_weakreflist != NULL) {
-        PyObject_ClearWeakRefs((PyObject *) self);
-    }
-#endif
-
     Py_DECREF(self->mydb);
     PyObject_Del(self);
 }
@@ -1384,7 +1351,7 @@
      *  (see pybsddb-users mailing list post on 2002-08-07)
      */
 #ifdef WITH_THREAD
-    PyEval_InitThreads();
+    //PyState_InitThreads();
 #endif
     MYDB_BEGIN_ALLOW_THREADS;
 #if (DBVER >= 41)
@@ -2326,7 +2293,7 @@
     /* This is to workaround a problem with un-initialized threads (see
        comment in DB_associate) */
 #ifdef WITH_THREAD
-    PyEval_InitThreads();
+    //PyState_InitThreads();
 #endif
 
     err = self->db->set_bt_compare(self->db, _db_compareCallback);
Index: Modules/gdbmmodule.c
===================================================================
--- Modules/gdbmmodule.c	(revision 58355)
+++ Modules/gdbmmodule.c	(working copy)
@@ -60,7 +60,7 @@
 {
     dbmobject *dp;
 
-    dp = PyObject_New(dbmobject, &Dbmtype);
+    dp = PyObject_NEW(dbmobject, &Dbmtype);
     if (dp == NULL)
         return NULL;
     dp->di_size = -1;
@@ -83,7 +83,7 @@
 {
     if (dp->di_dbm)
         gdbm_close(dp->di_dbm);
-    PyObject_Del(dp);
+    PyObject_DEL(dp);
 }
 
 static Py_ssize_t
Index: Modules/unicodedata.c
===================================================================
--- Modules/unicodedata.c	(revision 58355)
+++ Modules/unicodedata.c	(working copy)
@@ -83,7 +83,7 @@
                      Py_UCS4 (*normalization)(Py_UCS4))
 {
 	PreviousDBVersion *self;
-	self = PyObject_New(PreviousDBVersion, &UCD_Type);
+	self = PyObject_NEW(PreviousDBVersion, &UCD_Type);
 	if (self == NULL)
 		return NULL;
 	self->name = name;
@@ -1134,7 +1134,7 @@
 	sizeof(PreviousDBVersion),	/*tp_basicsize*/
 	0,			/*tp_itemsize*/
 	/* methods */
-	(destructor)PyObject_Del, /*tp_dealloc*/
+	_PyObject_Del,			/*tp_dealloc*/
 	0,			/*tp_print*/
 	0,                      /*tp_getattr*/
 	0,			/*tp_setattr*/
@@ -1166,9 +1166,7 @@
         0,                      /*tp_descr_set*/
         0,                      /*tp_dictoffset*/
         0,                      /*tp_init*/
-        0,                      /*tp_alloc*/
         0,                      /*tp_new*/
-        0,                      /*tp_free*/
         0,                      /*tp_is_gc*/
 };
 
Index: Modules/readline.c
===================================================================
--- Modules/readline.c	(revision 58355)
+++ Modules/readline.c	(working copy)
@@ -619,9 +619,11 @@
 {
 	int result = 0;
 	if (func != NULL) {
-		PyObject *r;
+		PyObject *r = NULL;
 #ifdef WITH_THREAD	      
-		PyGILState_STATE gilstate = PyGILState_Ensure();
+		PyState_EnterTag entertag = PyState_Enter();
+		if (!entertag)
+			goto error;
 #endif
 		r = PyObject_CallFunction(func, NULL);
 		if (r == NULL)
@@ -640,7 +642,7 @@
 		Py_XDECREF(r);
 	  done:
 #ifdef WITH_THREAD	      
-		PyGILState_Release(gilstate);
+		PyState_Exit(entertag);
 #endif
 		return result;
 	}
@@ -671,9 +673,11 @@
 	if (completion_display_matches_hook != NULL) {
 	        int i;
 	        PyObject *m, *s;
-	        PyObject *r;
+	        PyObject *r = NULL;
 #ifdef WITH_THREAD	      
-		PyGILState_STATE gilstate = PyGILState_Ensure();
+		PyState_EnterTag entertag = PyState_Enter();
+		if (!entertag)
+			goto error;
 #endif
 		m = PyList_New(num_matches);
 		for (i = 0; i < num_matches; i++) {
@@ -697,8 +701,8 @@
 		PyErr_Clear();
 		Py_XDECREF(r);
 	  done:
-#ifdef WITH_THREAD	      
-		PyGILState_Release(gilstate);
+#ifdef WITH_THREAD
+		PyState_Exit(entertag);
 #endif
 	}
 }
@@ -711,9 +715,11 @@
 {
 	char *result = NULL;
 	if (completer != NULL) {
-		PyObject *r;
+		PyObject *r = NULL;
 #ifdef WITH_THREAD	      
-		PyGILState_STATE gilstate = PyGILState_Ensure();
+		PyState_EnterTag entertag = PyState_Enter();
+		if (!entertag)
+			Py_FatalError("PyState_Enter failed");
 #endif
 		rl_attempted_completion_over = 1;
 		r = PyObject_CallFunction(completer, "si", text, state);
@@ -735,7 +741,7 @@
 		Py_XDECREF(r);
 	  done:
 #ifdef WITH_THREAD	      
-		PyGILState_Release(gilstate);
+		PyState_Exit(entertag);
 #endif
 		return result;
 	}
@@ -866,12 +872,17 @@
 		else if (errno == EINTR) {
 			int s;
 #ifdef WITH_THREAD
-			PyEval_RestoreThread(_PyOS_ReadlineTState);
+			//PyEval_RestoreThread(_PyOS_ReadlineTState);
+			PyState_Resume();
 #endif
+#if 0
 			s = PyErr_CheckSignals();
+#endif
 #ifdef WITH_THREAD
-			PyEval_SaveThread();	
+			//PyEval_SaveThread();
+			PyState_Suspend();
 #endif
+#if 0
 			if (s < 0) {
 				rl_free_line_state();
 				rl_cleanup_after_signal();
@@ -879,6 +890,7 @@
 				*signal = 1;
 				completed_input_string = NULL;
 			}
+#endif
 		}
 	}
 
Index: Modules/arraymodule.c
===================================================================
--- Modules/arraymodule.c	(revision 58355)
+++ Modules/arraymodule.c	(working copy)
@@ -423,7 +423,7 @@
 	if (nbytes / descr->itemsize != (size_t)size) {
 		return PyErr_NoMemory();
 	}
-	op = (arrayobject *) type->tp_alloc(type, 0);
+	op = PyObject_NEW(arrayobject, type);
 	if (op == NULL) {
 		return NULL;
 	}
@@ -434,7 +434,7 @@
 	else {
 		op->ob_item = PyMem_NEW(char, nbytes);
 		if (op->ob_item == NULL) {
-			PyObject_Del(op);
+			PyObject_DEL(op);
 			return PyErr_NoMemory();
 		}
 	}
@@ -490,11 +490,9 @@
 static void
 array_dealloc(arrayobject *op)
 {
-	if (op->weakreflist != NULL)
-		PyObject_ClearWeakRefs((PyObject *) op);
 	if (op->ob_item != NULL)
 		PyMem_DEL(op->ob_item);
-	Py_Type(op)->tp_free((PyObject *)op);
+	PyObject_DEL(op);
 }
 
 static PyObject *
@@ -817,7 +815,7 @@
 	size = Py_Size(self) + Py_Size(b);
         PyMem_RESIZE(self->ob_item, char, size*self->ob_descr->itemsize);
         if (self->ob_item == NULL) {
-                PyObject_Del(self);
+                PyObject_DEL(self);
                 PyErr_NoMemory();
 		return -1;
         }
@@ -2058,9 +2056,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	PyType_GenericAlloc,			/* tp_alloc */
 	array_new,				/* tp_new */
-	PyObject_Del,				/* tp_free */
 };
 
 
@@ -2087,7 +2083,7 @@
 		return NULL;
 	}
 
-	it = PyObject_GC_New(arrayiterobject, &PyArrayIter_Type);
+	it = PyObject_NEW(arrayiterobject, &PyArrayIter_Type);
 	if (it == NULL)
 		return NULL;
 
@@ -2095,7 +2091,6 @@
 	it->ao = ao;
 	it->index = 0;
 	it->getitem = ao->ob_descr->getitem;
-	PyObject_GC_Track(it);
 	return (PyObject *)it;
 }
 
@@ -2111,9 +2106,8 @@
 static void
 arrayiter_dealloc(arrayiterobject *it)
 {
-	PyObject_GC_UnTrack(it);
 	Py_XDECREF(it->ao);
-	PyObject_GC_Del(it);
+	PyObject_DEL(it);
 }
 
 static int
Index: Modules/selectmodule.c
===================================================================
--- Modules/selectmodule.c	(revision 58355)
+++ Modules/selectmodule.c	(working copy)
@@ -550,7 +550,7 @@
 newPollObject(void)
 {
         pollObject *self;
-	self = PyObject_New(pollObject, &poll_Type);
+	self = PyObject_NEW(pollObject, &poll_Type);
 	if (self == NULL)
 		return NULL;
 	/* ufd_uptodate is a Boolean, denoting whether the 
@@ -571,7 +571,7 @@
 	if (self->ufds != NULL)
 		PyMem_DEL(self->ufds);
 	Py_XDECREF(self->dict);
-  	PyObject_Del(self);
+  	PyObject_DEL(self);
 }
 
 static PyObject *
Index: Modules/_randommodule.c
===================================================================
--- Modules/_randommodule.c	(revision 58355)
+++ Modules/_randommodule.c	(working copy)
@@ -484,7 +484,7 @@
 	if (type == &Random_Type && !_PyArg_NoKeywords("Random()", kwds))
 		return NULL;
 
-	self = (RandomObject *)type->tp_alloc(type, 0);
+	self = PyObject_NEW(RandomObject, type);
 	if (self == NULL)
 		return NULL;
 	tmp = random_seed(self, args);
@@ -555,9 +555,7 @@
 	0,				/*tp_descr_set*/
 	0,				/*tp_dictoffset*/
 	0,				/*tp_init*/
-	0,				/*tp_alloc*/
 	random_new,			/*tp_new*/
-	PyObject_Free,			/*tp_free*/
 	0,				/*tp_is_gc*/
 };
 
Index: Modules/_hotshot.c
===================================================================
--- Modules/_hotshot.c	(revision 58355)
+++ Modules/_hotshot.c	(working copy)
@@ -533,7 +533,7 @@
         self->logfp = NULL;
     }
     Py_XDECREF(self->info);
-    PyObject_Del(self);
+    PyObject_DEL(self);
 }
 
 static PyObject *
@@ -1164,7 +1164,7 @@
         fclose(self->logfp);
     Py_XDECREF(self->filemap);
     Py_XDECREF(self->logfilename);
-    PyObject_Del((PyObject *)self);
+    PyObject_DEL((PyObject *)self);
 }
 
 static PyMethodDef profiler_methods[] = {
@@ -1349,7 +1349,7 @@
     int err = 0;
 
     if (PyArg_ParseTuple(args, "s:logreader", &filename)) {
-        self = PyObject_New(LogReaderObject, &LogReaderType);
+        self = PyObject_NEW(LogReaderObject, &LogReaderType);
         if (self != NULL) {
             self->frametimings = 1;
             self->linetimings = 0;
@@ -1500,7 +1500,7 @@
 
     if (PyArg_ParseTuple(args, "s|ii:profiler", &logfilename,
                          &lineevents, &linetimings)) {
-        self = PyObject_New(ProfilerObject, &ProfilerType);
+        self = PyObject_NEW(ProfilerObject, &ProfilerType);
         if (self == NULL)
             return NULL;
         self->frametimings = 1;
Index: Modules/operator.c
===================================================================
--- Modules/operator.c	(revision 58355)
+++ Modules/operator.c	(working copy)
@@ -67,6 +67,7 @@
 
 spami(isNumberType     , PyNumber_Check)
 spami(truth            , PyObject_IsTrue)
+spami(isShareable      , PyObject_IsShareable)
 spam2(op_add           , PyNumber_Add)
 spam2(op_sub           , PyNumber_Subtract)
 spam2(op_mul           , PyNumber_Multiply)
@@ -205,12 +206,12 @@
 #undef spam2
 #undef spam1o
 #undef spam1o
-#define spam1(OP,DOC) {#OP, OP, METH_VARARGS, PyDoc_STR(DOC)},
-#define spam2(OP,ALTOP,DOC) {#OP, op_##OP, METH_VARARGS, PyDoc_STR(DOC)}, \
-			   {#ALTOP, op_##OP, METH_VARARGS, PyDoc_STR(DOC)}, 
-#define spam1o(OP,DOC) {#OP, OP, METH_O, PyDoc_STR(DOC)},
-#define spam2o(OP,ALTOP,DOC) {#OP, op_##OP, METH_O, PyDoc_STR(DOC)}, \
-			   {#ALTOP, op_##OP, METH_O, PyDoc_STR(DOC)}, 
+#define spam1(OP,DOC) {#OP, OP, METH_VARARGS|METH_SHARED, PyDoc_STR(DOC)},
+#define spam2(OP,ALTOP,DOC) {#OP, op_##OP, METH_VARARGS|METH_SHARED, PyDoc_STR(DOC)}, \
+			   {#ALTOP, op_##OP, METH_VARARGS|METH_SHARED, PyDoc_STR(DOC)}, 
+#define spam1o(OP,DOC) {#OP, OP, METH_O|METH_SHARED, PyDoc_STR(DOC)},
+#define spam2o(OP,ALTOP,DOC) {#OP, op_##OP, METH_O|METH_SHARED, PyDoc_STR(DOC)}, \
+			   {#ALTOP, op_##OP, METH_O|METH_SHARED, PyDoc_STR(DOC)}, 
 
 static struct PyMethodDef operator_methods[] = {
 
@@ -220,6 +221,8 @@
  "isSequenceType(a) -- Return True if a has a sequence type, False otherwise.")
 spam1o(truth,
  "truth(a) -- Return True if a is true, False otherwise.")
+spam1o(isShareable,
+ "isShareable(a) -- Return True if a is shareable, False otherwise.")
 spam2(contains,__contains__,
  "contains(a, b) -- Same as b in a (note reversed operands).")
 spam1(indexOf,
@@ -321,7 +324,7 @@
 		item = args;
 
 	/* create itemgetterobject structure */
-	ig = PyObject_GC_New(itemgetterobject, &itemgetter_type);
+	ig = PyObject_NEW(itemgetterobject, &itemgetter_type);
 	if (ig == NULL) 
 		return NULL;	
 	
@@ -329,16 +332,14 @@
 	ig->item = item;
 	ig->nitems = nitems;
 
-	PyObject_GC_Track(ig);
 	return (PyObject *)ig;
 }
 
 static void
 itemgetter_dealloc(itemgetterobject *ig)
 {
-	PyObject_GC_UnTrack(ig);
 	Py_XDECREF(ig->item);
-	PyObject_GC_Del(ig);
+	PyObject_DEL(ig);
 }
 
 static int
@@ -407,7 +408,8 @@
 	PyObject_GenericGetAttr,	/* tp_getattro */
 	0,				/* tp_setattro */
 	0,				/* tp_as_buffer */
-	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,	/* tp_flags */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
+		Py_TPFLAGS_SHAREABLE,	/* tp_flags */
 	itemgetter_doc,			/* tp_doc */
 	(traverseproc)itemgetter_traverse,	/* tp_traverse */
 	0,				/* tp_clear */
@@ -424,9 +426,7 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	0,				/* tp_init */
-	0,				/* tp_alloc */
 	itemgetter_new,			/* tp_new */
-	0,				/* tp_free */
 };
 
 
@@ -458,7 +458,7 @@
 		attr = args;
 
 	/* create attrgetterobject structure */
-	ag = PyObject_GC_New(attrgetterobject, &attrgetter_type);
+	ag = PyObject_NEW(attrgetterobject, &attrgetter_type);
 	if (ag == NULL) 
 		return NULL;	
 	
@@ -466,16 +466,14 @@
 	ag->attr = attr;
 	ag->nattrs = nattrs;
 
-	PyObject_GC_Track(ag);
 	return (PyObject *)ag;
 }
 
 static void
 attrgetter_dealloc(attrgetterobject *ag)
 {
-	PyObject_GC_UnTrack(ag);
 	Py_XDECREF(ag->attr);
-	PyObject_GC_Del(ag);
+	PyObject_DEL(ag);
 }
 
 static int
@@ -544,7 +542,8 @@
 	PyObject_GenericGetAttr,	/* tp_getattro */
 	0,				/* tp_setattro */
 	0,				/* tp_as_buffer */
-	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC,	/* tp_flags */
+	Py_TPFLAGS_DEFAULT | Py_TPFLAGS_HAVE_GC |
+		Py_TPFLAGS_SHAREABLE,	/* tp_flags */
 	attrgetter_doc,			/* tp_doc */
 	(traverseproc)attrgetter_traverse,	/* tp_traverse */
 	0,				/* tp_clear */
@@ -561,9 +560,7 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	0,				/* tp_init */
-	0,				/* tp_alloc */
 	attrgetter_new,			/* tp_new */
-	0,				/* tp_free */
 };
 /* Initialization function for the module (*must* be called initoperator) */
 
@@ -573,8 +570,8 @@
 	PyObject *m;
         
 	/* Create the module and add the functions */
-        m = Py_InitModule4("operator", operator_methods, operator_doc,
-		       (PyObject*)NULL, PYTHON_API_VERSION);
+        m = Py_InitModule5("operator", operator_methods, operator_doc,
+		       (PyObject*)NULL, PYTHON_API_VERSION, 1);
 	if (m == NULL)
 		return;
 
Index: Modules/zipimport.c
===================================================================
--- Modules/zipimport.c	(revision 58355)
+++ Modules/zipimport.c	(working copy)
@@ -167,11 +167,10 @@
 static void
 zipimporter_dealloc(ZipImporter *self)
 {
-	PyObject_GC_UnTrack(self);
 	Py_XDECREF(self->archive);
 	Py_XDECREF(self->prefix);
 	Py_XDECREF(self->files);
-	Py_Type(self)->tp_free((PyObject *)self);
+	PyObject_DEL(self);
 }
 
 static PyObject *
@@ -588,9 +587,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	(initproc)zipimporter_init,		/* tp_init */
-	PyType_GenericAlloc,			/* tp_alloc */
 	PyType_GenericNew,			/* tp_new */
-	PyObject_GC_Del,			/* tp_free */
 };
 
 
Index: Modules/timemodule.c
===================================================================
--- Modules/timemodule.c	(revision 58355)
+++ Modules/timemodule.c	(working copy)
@@ -44,6 +44,7 @@
 #include <windows.h>
 #include "pythread.h"
 
+#if 0
 /* helper to allow us to interrupt sleep() on Windows*/
 static HANDLE hInterruptEvent = NULL;
 static BOOL WINAPI PyCtrlHandler(DWORD dwCtrlType)
@@ -56,6 +57,7 @@
 	return FALSE;
 }
 static long main_thread;
+#endif
 
 #if defined(__BORLANDC__)
 /* These overrides not needed for Win32 */
@@ -790,7 +792,7 @@
 #ifdef HAVE_CLOCK
 	{"clock",	time_clock, METH_NOARGS, clock_doc},
 #endif
-	{"sleep",	time_sleep, METH_VARARGS, sleep_doc},
+	{"sleep",	time_sleep, METH_VARARGS|METH_SHARED, sleep_doc},
 	{"gmtime",	time_gmtime, METH_VARARGS, gmtime_doc},
 	{"localtime",	time_localtime, METH_VARARGS, localtime_doc},
 	{"asctime",	time_asctime, METH_VARARGS, asctime_doc},
@@ -874,6 +876,8 @@
 	/* Set, or reset, module variables like time.timezone */
 	inittimezone(m);
 
+#if 0
+/* This Ctrl-C blurb is unnecessary now */
 #ifdef MS_WINDOWS
 	/* Helper to allow interrupts for Windows.
 	   If Ctrl+C event delivered while not sleeping
@@ -883,6 +887,7 @@
 	hInterruptEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
 	SetConsoleCtrlHandler( PyCtrlHandler, TRUE);
 #endif /* MS_WINDOWS */
+#endif
 	if (!initialized) {
 		PyStructSequence_InitType(&StructTimeType,
 					  &struct_time_type_desc);
@@ -981,9 +986,12 @@
 		 * by Guido, only the main thread can be interrupted.
 		 */
 		ul_millis = (unsigned long)millisecs;
+#if 0
 		if (ul_millis == 0 ||
 		    main_thread != PyThread_get_thread_ident())
+#endif
 			Sleep(ul_millis);
+#if 0
 		else {
 			DWORD rc;
 			ResetEvent(hInterruptEvent);
@@ -999,6 +1007,7 @@
 				return -1;
 			}
 		}
+#endif
 		Py_END_ALLOW_THREADS
 	}
 #elif defined(PYOS_OS2)
Index: Modules/zlibmodule.c
===================================================================
--- Modules/zlibmodule.c	(revision 58355)
+++ Modules/zlibmodule.c	(working copy)
@@ -29,11 +29,11 @@
 
 #define ENTER_ZLIB \
 	Py_BEGIN_ALLOW_THREADS \
-	PyThread_acquire_lock(zlib_lock, 1); \
+	PyThread_lock_acquire(zlib_lock); \
 	Py_END_ALLOW_THREADS
 
 #define LEAVE_ZLIB \
-	PyThread_release_lock(zlib_lock);
+	PyThread_lock_release(zlib_lock);
 
 #else
 
@@ -92,7 +92,7 @@
 newcompobject(PyTypeObject *type)
 {
     compobject *self;
-    self = PyObject_New(compobject, type);
+    self = PyObject_NEW(compobject, type);
     if (self == NULL)
 	return NULL;
     self->is_initialised = 0;
@@ -369,7 +369,7 @@
 	deflateEnd(&self->zst);
     Py_XDECREF(self->unused_data);
     Py_XDECREF(self->unconsumed_tail);
-    PyObject_Del(self);
+    PyObject_DEL(self);
 }
 
 static void
@@ -379,7 +379,7 @@
 	inflateEnd(&self->zst);
     Py_XDECREF(self->unused_data);
     Py_XDECREF(self->unconsumed_tail);
-    PyObject_Del(self);
+    PyObject_DEL(self);
 }
 
 PyDoc_STRVAR(comp_compress__doc__,
@@ -1046,6 +1046,6 @@
     PyModule_AddStringConstant(m, "__version__", "1.0");
 
 #ifdef WITH_THREAD
-    zlib_lock = PyThread_allocate_lock();
+    zlib_lock = PyThread_lock_allocate();
 #endif /* WITH_THREAD */
 }
Index: Modules/_fileio.c
===================================================================
--- Modules/_fileio.c	(revision 58355)
+++ Modules/_fileio.c	(working copy)
@@ -2,10 +2,13 @@
 
 #define PY_SSIZE_T_CLEAN
 #include "Python.h"
+#include "interruptobject.h"
+
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <fcntl.h>
 #include <stddef.h> /* For offsetof */
+#include <poll.h> /* For poll stuff */
 
 /*
  * Known likely problems:
@@ -40,6 +43,96 @@
 
 #define PyFileIO_Check(op) (PyObject_TypeCheck((op), &PyFileIO_Type))
 
+/* Conveniently chosen so that POLL_READ|POLL_WRITE == POLL_ANY. */
+#define POLL_READ 1
+#define POLL_WRITE 2
+#define POLL_ANY 3
+
+/* XXX FIXME clean up the Interrupt API and delete this. */
+typedef struct {
+	int fd;
+	int interrupted;
+} blewed_up;
+
+static void
+poll_wakeup(struct _PyInterruptQueue *queue, void *arg)
+{
+	blewed_up *bu = arg;
+	bu->interrupted = 1;
+	if (write(bu->fd, "x", 1) != 1)
+		Py_FatalError("Writing to I/O wakeup pipe failed");
+}
+
+static int
+poll_single_fd(int fd, int mode)
+{
+	int fds[2];
+	PyInterruptObject *interrupt_point;
+	struct pollfd events[2];
+	int status;
+	blewed_up bu;
+
+	assert(!(mode & ~POLL_ANY));
+
+	if (pipe(fds)) {
+		PyErr_SetFromErrno(PyExc_IOError);
+		return 1;
+	}
+
+	bu.fd = fds[1];
+	bu.interrupted = 0;
+
+	interrupt_point = PyInterrupt_New(poll_wakeup, &bu, NULL);
+	if (interrupt_point == NULL) {
+		close(fds[0]); /* XXX FIXME error handling */
+		close(fds[1]);
+		return 1;
+	}
+
+	events[0].fd = fd;
+	events[0].events = 0;
+	if (mode & POLL_READ)
+		events[0].events |= POLLIN;
+	if (mode & POLL_WRITE)
+		events[0].events |= POLLOUT;
+
+	events[1].fd = fds[0];
+	events[1].events = POLLIN;
+
+	PyInterrupt_Push(interrupt_point);
+	Py_BEGIN_ALLOW_THREADS
+
+	status = poll(events, 2, -1);
+
+	Py_END_ALLOW_THREADS
+	PyInterrupt_Pop(interrupt_point);
+
+	if (status == 0)
+		Py_FatalError("I/O wakeup poll somehow returned 0");
+
+	//if (status == -1 || events[1].revents & (POLLIN|POLLHUP)) {
+	if (bu.interrupted) {
+		char buf[1];
+		/* Reset pipe for next usage */
+		/* XXX doesn't matter yet */
+		if (read(fds[0], buf, 1) != 1)
+			Py_FatalError("Resetting I/O wakeup pipe failed");
+	}
+
+	close(fds[0]); /* XXX FIXME error handling */
+	close(fds[1]);
+
+	if (bu.interrupted) {
+		PyErr_SetString(PyExc_Interrupted,
+			"I/O operation interrupted by parent");
+		Py_DECREF(interrupt_point);
+		return 1;
+	}
+
+	Py_DECREF(interrupt_point);
+	return 0;
+}
+
 /* Returns 0 on success, errno (which is < 0) on failure. */
 static int
 internal_close(PyFileIOObject *self)
@@ -73,9 +166,9 @@
 {
 	PyFileIOObject *self;
 
-	assert(type != NULL && type->tp_alloc != NULL);
+	assert(type != NULL);
 
-	self = (PyFileIOObject *) type->tp_alloc(type, 0);
+	self = PyObject_NEW(PyFileIOObject, type);
 	if (self != NULL) {
 		self->fd = -1;
 		self->weakreflist = NULL;
@@ -235,6 +328,8 @@
 		flags |= O_APPEND;
 #endif
 
+	flags |= O_NONBLOCK;
+
 	if (fd >= 0) {
 		self->fd = fd;
 	}
@@ -267,9 +362,6 @@
 static void
 fileio_dealloc(PyFileIOObject *self)
 {
-	if (self->weakreflist != NULL)
-		PyObject_ClearWeakRefs((PyObject *) self);
-
 	if (self->fd >= 0) {
 		errno = internal_close(self);
 		if (errno < 0) {
@@ -282,7 +374,7 @@
 		}
 	}
 
-	Py_Type(self)->tp_free((PyObject *)self);
+	PyObject_DEL(self);
 }
 
 static PyObject *
@@ -355,10 +447,11 @@
 	if (!PyArg_ParseTuple(args, "w#", &ptr, &n))
 		return NULL;
 
-	Py_BEGIN_ALLOW_THREADS
+	if (poll_single_fd(self->fd, POLL_READ))
+		return NULL;
+
 	errno = 0;
 	n = read(self->fd, ptr, n);
-	Py_END_ALLOW_THREADS
 	if (n < 0) {
 		if (errno == EAGAIN)
 			Py_RETURN_NONE;
@@ -394,12 +487,14 @@
 				break;
 			}
 		}
-		Py_BEGIN_ALLOW_THREADS
+
+		if (poll_single_fd(self->fd, POLL_READ))
+			return NULL;
+
 		errno = 0;
 		n = read(self->fd,
 			 PyBytes_AS_STRING(result) + total,
 			 newsize - total);
-		Py_END_ALLOW_THREADS
 		if (n == 0)
 			break;
 		if (n < 0) {
@@ -451,10 +546,11 @@
 		return NULL;
 	ptr = PyBytes_AsString(bytes);
 
-	Py_BEGIN_ALLOW_THREADS
+	if (poll_single_fd(self->fd, POLL_READ))
+		return NULL;
+
 	errno = 0;
 	n = read(self->fd, ptr, size);
-	Py_END_ALLOW_THREADS
 
 	if (n < 0) {
 		if (errno == EAGAIN)
@@ -487,10 +583,11 @@
 	if (!PyArg_ParseTuple(args, "s#", &ptr, &n))
 		return NULL;
 
-	Py_BEGIN_ALLOW_THREADS
+	if (poll_single_fd(self->fd, POLL_WRITE))
+		return NULL;
+
 	errno = 0;
 	n = write(self->fd, ptr, n);
-	Py_END_ALLOW_THREADS
 
 	if (n < 0) {
 		if (errno == EAGAIN)
@@ -857,9 +954,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	fileio_init,				/* tp_init */
-	PyType_GenericAlloc,			/* tp_alloc */
 	fileio_new,				/* tp_new */
-	PyObject_Del,				/* tp_free */
 };
 
 static PyMethodDef module_methods[] = {
Index: Modules/threadmodule.c
===================================================================
--- Modules/threadmodule.c	(revision 58355)
+++ Modules/threadmodule.c	(working copy)
@@ -27,10 +27,13 @@
 {
 	assert(self->lock_lock);
 	/* Unlock the lock so it's safe to free it */
-	PyThread_acquire_lock(self->lock_lock, 0);
-	PyThread_release_lock(self->lock_lock);
+	/* XXX This is madness.  If another thread holds the lock
+	 * despite having no refcount then they may try to get it
+	 * again anyway. */
+	PyThread_lock_acquire(self->lock_lock);
+	PyThread_lock_release(self->lock_lock);
 	
-	PyThread_free_lock(self->lock_lock);
+	PyThread_lock_free(self->lock_lock);
 	PyObject_Del(self);
 }
 
@@ -39,11 +42,11 @@
 {
 	int i = 1;
 
-	if (!PyArg_ParseTuple(args, "|i:acquire", &i))
+	if (!PyArg_ParseTuple(args, ":acquire"))
 		return NULL;
 
 	Py_BEGIN_ALLOW_THREADS
-	i = PyThread_acquire_lock(self->lock_lock, i);
+	i = PyThread_lock_acquire(self->lock_lock);
 	Py_END_ALLOW_THREADS
 
 	return PyBool_FromLong((long)i);
@@ -63,14 +66,16 @@
 static PyObject *
 lock_PyThread_release_lock(lockobject *self)
 {
+	/* XXX This sanity check contains a race condition.  It needs
+	 * to be replaced with much more robust locking anyway. */
 	/* Sanity check: the lock must be locked */
-	if (PyThread_acquire_lock(self->lock_lock, 0)) {
-		PyThread_release_lock(self->lock_lock);
+	if (_PyThread_lock_tryacquire(self->lock_lock)) {
+		PyThread_lock_release(self->lock_lock);
 		PyErr_SetString(ThreadError, "release unlocked lock");
 		return NULL;
 	}
 
-	PyThread_release_lock(self->lock_lock);
+	PyThread_lock_release(self->lock_lock);
 	Py_INCREF(Py_None);
 	return Py_None;
 }
@@ -86,8 +91,8 @@
 static PyObject *
 lock_locked_lock(lockobject *self)
 {
-	if (PyThread_acquire_lock(self->lock_lock, 0)) {
-		PyThread_release_lock(self->lock_lock);
+	if (_PyThread_lock_tryacquire(self->lock_lock)) {
+		PyThread_lock_release(self->lock_lock);
 		return PyBool_FromLong(0L);
 	}
 	return PyBool_FromLong(1L);
@@ -146,7 +151,7 @@
 	self = PyObject_New(lockobject, &Locktype);
 	if (self == NULL)
 		return NULL;
-	self->lock_lock = PyThread_allocate_lock();
+	self->lock_lock = PyThread_lock_allocate();
 	if (self->lock_lock == NULL) {
 		PyObject_Del(self);
 		self = NULL;
@@ -181,7 +186,7 @@
 		return NULL;
 	}
 
-	self = (localobject *)type->tp_alloc(type, 0);
+	self = PyObject_NEW(localobject, type);
 	if (self == NULL)
 		return NULL;
 
@@ -250,7 +255,7 @@
 	}
 
 	local_clear(self);
-	Py_Type(self)->tp_free((PyObject*)self);
+	PyObject_DEL(self);
 }
 
 static PyObject *
@@ -371,9 +376,7 @@
 	/* tp_descr_set      */ 0,
 	/* tp_dictoffset     */ offsetof(localobject, dict),
 	/* tp_init           */ 0,
-	/* tp_alloc          */ 0,
 	/* tp_new            */ local_new,
-	/* tp_free           */ 0, /* Low-level free-mem routine */
 	/* tp_is_gc          */ 0, /* For PyObject_IS_GC */
 };
 
@@ -413,12 +416,16 @@
 t_bootstrap(void *boot_raw)
 {
 	struct bootstate *boot = (struct bootstate *) boot_raw;
-	PyThreadState *tstate;
+	//PyThreadState *tstate;
+	PyState_EnterTag entertag;
 	PyObject *res;
 
-	tstate = PyThreadState_New(boot->interp);
+	//tstate = PyThreadState_New(boot->interp);
+	entertag = PyState_Enter();
+	if (!entertag)
+		Py_FatalError("PyState_Enter failed");
 
-	PyEval_AcquireThread(tstate);
+	//PyEval_AcquireThread(tstate);
 	res = PyEval_CallObjectWithKeywords(
 		boot->func, boot->args, boot->keyw);
 	if (res == NULL) {
@@ -443,14 +450,19 @@
 	Py_DECREF(boot->args);
 	Py_XDECREF(boot->keyw);
 	PyMem_DEL(boot_raw);
-	PyThreadState_Clear(tstate);
-	PyThreadState_DeleteCurrent();
+	//PyThreadState_Clear(tstate);
+	//PyThreadState_DeleteCurrent();
+	PyState_Exit(entertag);
 	PyThread_exit_thread();
 }
 
 static PyObject *
 thread_PyThread_start_new_thread(PyObject *self, PyObject *fargs)
 {
+#if 1
+	PyErr_SetString(PyExc_TypeError, "thread.start_new_thread is disabled");
+	return NULL;
+#else
 	PyObject *func, *args, *keyw = NULL;
 	struct bootstate *boot;
 	long ident;
@@ -476,7 +488,7 @@
 	boot = PyMem_NEW(struct bootstate, 1);
 	if (boot == NULL)
 		return PyErr_NoMemory();
-	boot->interp = PyThreadState_GET()->interp;
+	boot->interp = PyThreadState_Get()->interp;
 	boot->func = func;
 	boot->args = args;
 	boot->keyw = keyw;
@@ -494,6 +506,7 @@
 		return NULL;
 	}
 	return PyInt_FromLong(ident);
+#endif
 }
 
 PyDoc_STRVAR(start_new_doc,
Index: Modules/_sqlite/connection.c
===================================================================
--- Modules/_sqlite/connection.c	(revision 58355)
+++ Modules/_sqlite/connection.c	(working copy)
@@ -513,9 +513,11 @@
     PyObject* py_func;
     PyObject* py_retval = NULL;
 
-    PyGILState_STATE threadstate;
+    PyState_EnterTag entertag;
 
-    threadstate = PyGILState_Ensure();
+    entertag = PyState_Enter();
+    if (!entertag)
+        Py_FatalError("PyState_Enter failed");
 
     py_func = (PyObject*)sqlite3_user_data(context);
 
@@ -537,7 +539,7 @@
         _sqlite3_result_error(context, "user-defined function raised exception", -1);
     }
 
-    PyGILState_Release(threadstate);
+    PyState_Exit(threadstate);
 }
 
 static void _pysqlite_step_callback(sqlite3_context *context, int argc, sqlite3_value** params)
@@ -548,9 +550,11 @@
     PyObject** aggregate_instance;
     PyObject* stepmethod = NULL;
 
-    PyGILState_STATE threadstate;
+    PyState_EnterTag entertag;
 
-    threadstate = PyGILState_Ensure();
+    entertag = PyState_Enter();
+    if (!entertag)
+        Py_FatalError("PyState_Enter failed");
 
     aggregate_class = (PyObject*)sqlite3_user_data(context);
 
@@ -597,7 +601,7 @@
     Py_XDECREF(stepmethod);
     Py_XDECREF(function_result);
 
-    PyGILState_Release(threadstate);
+    PyState_Exit(entertag);
 }
 
 void _pysqlite_final_callback(sqlite3_context* context)
@@ -606,9 +610,11 @@
     PyObject** aggregate_instance;
     PyObject* aggregate_class;
 
-    PyGILState_STATE threadstate;
+    PyState_EnterTag entertag;
 
-    threadstate = PyGILState_Ensure();
+    entertag = PyState_Enter();
+    if (!entertag)
+        Py_FatalError("PyState_Enter failed");
 
     aggregate_class = (PyObject*)sqlite3_user_data(context);
 
@@ -636,7 +642,7 @@
     Py_XDECREF(*aggregate_instance);
     Py_XDECREF(function_result);
 
-    PyGILState_Release(threadstate);
+    PyState_Exit(entertag);
 }
 
 void _pysqlite_drop_unused_statement_references(pysqlite_Connection* self)
@@ -731,9 +737,12 @@
 {
     PyObject *ret;
     int rc;
-    PyGILState_STATE gilstate;
+    PyState_EnterTag entertag;
 
-    gilstate = PyGILState_Ensure();
+    entertag = PyState_Enter();
+    if (!entertag)
+        Py_FatalError("PyState_Enter failed");
+
     ret = PyObject_CallFunction((PyObject*)user_arg, "issss", action, arg1, arg2, dbname, access_attempt_source);
 
     if (!ret) {
@@ -753,7 +762,7 @@
         Py_DECREF(ret);
     }
 
-    PyGILState_Release(gilstate);
+    PyState_Exit(entertag);
     return rc;
 }
 
@@ -1017,12 +1026,14 @@
     PyObject* callback = (PyObject*)context;
     PyObject* string1 = 0;
     PyObject* string2 = 0;
-    PyGILState_STATE gilstate;
+    PyState_EnterTag entertag;
 
     PyObject* retval = NULL;
     int result = 0;
 
-    gilstate = PyGILState_Ensure();
+    entertag = PyState_Enter();
+    if (!entertag)
+        Py_FatalError("PyState_Enter failed");
 
     if (PyErr_Occurred()) {
         goto finally;
@@ -1052,7 +1063,7 @@
     Py_XDECREF(string2);
     Py_XDECREF(retval);
 
-    PyGILState_Release(gilstate);
+    PyState_Exit(entertag);
 
     return result;
 }
Index: Modules/_sqlite/module.c
===================================================================
--- Modules/_sqlite/module.c	(revision 58355)
+++ Modules/_sqlite/module.c	(working copy)
@@ -392,7 +392,7 @@
      * threads have already been initialized.
      *  (see pybsddb-users mailing list post on 2002-08-07)
      */
-    PyEval_InitThreads();
+    //PyEval_InitThreads();
 
 error:
     if (PyErr_Occurred())
Index: Modules/_struct.c
===================================================================
--- Modules/_struct.c	(revision 58355)
+++ Modules/_struct.c	(working copy)
@@ -1445,9 +1445,9 @@
 {
 	PyObject *self;
 
-	assert(type != NULL && type->tp_alloc != NULL);
+	assert(type != NULL);
 
-	self = type->tp_alloc(type, 0);
+	self = PyObject_New(type);
 	if (self != NULL) {
 		PyStructObject *s = (PyStructObject*)self;
 		Py_INCREF(Py_None);
@@ -1484,13 +1484,11 @@
 static void
 s_dealloc(PyStructObject *s)
 {
-	if (s->weakreflist != NULL)
-		PyObject_ClearWeakRefs((PyObject *)s);
 	if (s->s_codes != NULL) {
 		PyMem_FREE(s->s_codes);
 	}
 	Py_XDECREF(s->s_format);
-	Py_Type(s)->tp_free((PyObject *)s);
+	PyObject_DEL(s);
 }
 
 static PyObject *
@@ -1875,9 +1873,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	s_init,				/* tp_init */
-	PyType_GenericAlloc,/* tp_alloc */
 	s_new,				/* tp_new */
-	PyObject_Del,		/* tp_free */
 };
 
 /* Module initialization */
Index: Modules/_weakref.c
===================================================================
--- Modules/_weakref.c	(revision 58355)
+++ Modules/_weakref.c	(working copy)
@@ -1,89 +1,36 @@
 #include "Python.h"
 
 
-#define GET_WEAKREFS_LISTPTR(o) \
-        ((PyWeakReference **) PyObject_GET_WEAKREFS_LISTPTR(o))
+PyDoc_STRVAR(weakref_ref__doc__,
+"ref(object) -- returns a weakref for 'object'.");
 
-
-PyDoc_STRVAR(weakref_getweakrefcount__doc__,
-"getweakrefcount(object) -- return the number of weak references\n"
-"to 'object'.");
-
 static PyObject *
-weakref_getweakrefcount(PyObject *self, PyObject *object)
+weakref_ref(PyObject *self, PyObject *object)
 {
-    PyObject *result = NULL;
-
-    if (PyType_SUPPORTS_WEAKREFS(Py_Type(object))) {
-        PyWeakReference **list = GET_WEAKREFS_LISTPTR(object);
-
-        result = PyInt_FromSsize_t(_PyWeakref_GetWeakrefCount(*list));
-    }
-    else
-        result = PyInt_FromLong(0);
-
-    return result;
+    return PyWeakref_NewRef(object, NULL);
 }
 
+PyDoc_STRVAR(weakref_bind__doc__,
+"bind(object, value) -- returns a weakbinding for 'object' and 'value'.");
 
-PyDoc_STRVAR(weakref_getweakrefs__doc__,
-"getweakrefs(object) -- return a list of all weak reference objects\n"
-"that point to 'object'.");
-
 static PyObject *
-weakref_getweakrefs(PyObject *self, PyObject *object)
+weakref_bind(PyObject *self, PyObject *args)
 {
-    PyObject *result = NULL;
+    PyObject *object, *value;
 
-    if (PyType_SUPPORTS_WEAKREFS(Py_Type(object))) {
-        PyWeakReference **list = GET_WEAKREFS_LISTPTR(object);
-        Py_ssize_t count = _PyWeakref_GetWeakrefCount(*list);
+    if (!PyArg_ParseTuple(args, "OO:bind", &object, &value))
+        return NULL;
 
-        result = PyList_New(count);
-        if (result != NULL) {
-            PyWeakReference *current = *list;
-            Py_ssize_t i;
-            for (i = 0; i < count; ++i) {
-                PyList_SET_ITEM(result, i, (PyObject *) current);
-                Py_INCREF(current);
-                current = current->wr_next;
-            }
-        }
-    }
-    else {
-        result = PyList_New(0);
-    }
-    return result;
+    return PyWeakref_NewBinding(object, value);
 }
 
 
-PyDoc_STRVAR(weakref_proxy__doc__,
-"proxy(object[, callback]) -- create a proxy object that weakly\n"
-"references 'object'.  'callback', if given, is called with a\n"
-"reference to the proxy when 'object' is about to be finalized.");
-
-static PyObject *
-weakref_proxy(PyObject *self, PyObject *args)
-{
-    PyObject *object;
-    PyObject *callback = NULL;
-    PyObject *result = NULL;
-
-    if (PyArg_UnpackTuple(args, "proxy", 1, 2, &object, &callback)) {
-        result = PyWeakref_NewProxy(object, callback);
-    }
-    return result;
-}
-
-
 static PyMethodDef
 weakref_functions[] =  {
-    {"getweakrefcount", weakref_getweakrefcount,        METH_O,
-     weakref_getweakrefcount__doc__},
-    {"getweakrefs",     weakref_getweakrefs,            METH_O,
-     weakref_getweakrefs__doc__},
-    {"proxy",           weakref_proxy,                  METH_VARARGS,
-     weakref_proxy__doc__},
+    {"ref",            weakref_ref,                    METH_O | METH_SHARED,
+     weakref_ref__doc__},
+    {"bind",           weakref_bind,                   METH_VARARGS | METH_SHARED,
+     weakref_bind__doc__},
     {NULL, NULL, 0, NULL}
 };
 
@@ -93,20 +40,19 @@
 {
     PyObject *m;
 
-    m = Py_InitModule3("_weakref", weakref_functions,
-                       "Weak-reference support module.");
+    m = Py_InitModule5("_weakref", weakref_functions,
+        "Weak-reference support module.", NULL, PYTHON_API_VERSION, 1);
     if (m != NULL) {
-        Py_INCREF(&_PyWeakref_RefType);
-        PyModule_AddObject(m, "ref",
-                           (PyObject *) &_PyWeakref_RefType);
-        Py_INCREF(&_PyWeakref_RefType);
+        Py_INCREF(&_PyWeakref_Type);
         PyModule_AddObject(m, "ReferenceType",
-                           (PyObject *) &_PyWeakref_RefType);
-        Py_INCREF(&_PyWeakref_ProxyType);
-        PyModule_AddObject(m, "ProxyType",
-                           (PyObject *) &_PyWeakref_ProxyType);
-        Py_INCREF(&_PyWeakref_CallableProxyType);
-        PyModule_AddObject(m, "CallableProxyType",
-                           (PyObject *) &_PyWeakref_CallableProxyType);
+            (PyObject *)&_PyWeakref_Type);
+
+        Py_INCREF(&_PyDeathQueue_Type);
+        PyModule_AddObject(m, "DeathQueueType",
+            (PyObject *)&_PyDeathQueue_Type);
+
+        Py_INCREF(&_PyWeakBinding_Type);
+        PyModule_AddObject(m, "WeakBindingType",
+            (PyObject *)&_PyWeakBinding_Type);
     }
 }
Index: Modules/signalmodule.c
===================================================================
--- Modules/signalmodule.c	(revision 58355)
+++ Modules/signalmodule.c	(working copy)
@@ -1,11 +1,10 @@
+/* Signal module -- many thanks to Lance Ellinghaus
+ * Significantly rewritten by Adam Olsen, to use a dedicated signal thread */
 
-/* Signal module -- many thanks to Lance Ellinghaus */
+#include "Python.h"
 
-/* XXX Signals should be recorded per thread, now we have thread state. */
+#include "branchobject.h"
 
-#include "Python.h"
-#include "intrcheck.h"
-
 #ifdef MS_WINDOWS
 #include <process.h>
 #endif
@@ -23,133 +22,244 @@
 
 #ifndef NSIG
 # if defined(_NSIG)
-#  define NSIG _NSIG		/* For BSD/SysV */
+#  define NSIG _NSIG            /* For BSD/SysV */
 # elif defined(_SIGMAX)
-#  define NSIG (_SIGMAX + 1)	/* For QNX */
+#  define NSIG (_SIGMAX + 1)    /* For QNX */
 # elif defined(SIGMAX)
-#  define NSIG (SIGMAX + 1)	/* For djgpp */
+#  define NSIG (SIGMAX + 1)     /* For djgpp */
 # else
-#  define NSIG 64		/* Use a reasonable default value */
+#  define NSIG 64               /* Use a reasonable default value */
 # endif
 #endif
 
+#define _PySIGNAL_WAKEUP SIGUSR2
 
+
 /*
-   NOTES ON THE INTERACTION BETWEEN SIGNALS AND THREADS
+ * NOTES ON THE INTERACTION BETWEEN SIGNALS AND THREADS
+ *
+ * There isn't much, really.  A dedicated thread now asks what signals
+ * are pending, and the real signal handlers are never invoked.  This
+ * means the various syscalls will NOT get interrupted (unless something
+ * else interferes.)
+ *
+ * This is less portable though.  In old LinuxThread (linux kernels 2.0
+ * and 2.1) the SIGUSR1 and SIGUSR2 signals are unavailable, but we need
+ * one to do our own wakeups.  Signal handling with LinuxThreads is
+ * broken anyway though, as most signals will only be pending on the
+ * main thread, not the signal thread (meaning they'll never get
+ * processed.)
+ */
 
-   When threads are supported, we want the following semantics:
-
-   - only the main thread can set a signal handler
-   - any thread can get a signal handler
-   - signals are only delivered to the main thread
-
-   I.e. we don't support "synchronous signals" like SIGFPE (catching
-   this doesn't make much sense in Python anyway) nor do we support
-   signals as a means of inter-thread communication, since not all
-   thread implementations support that (at least our thread library
-   doesn't).
-
-   We still have the problem that in some implementations signals
-   generated by the keyboard (e.g. SIGINT) are delivered to all
-   threads (e.g. SGI), while in others (e.g. Solaris) such signals are
-   delivered to one random thread (an intermediate possibility would
-   be to deliver it to the main thread -- POSIX?).  For now, we have
-   a working implementation that works in all three cases -- the
-   handler ignores signals if getpid() isn't the same as in the main
-   thread.  XXX This is a hack.
-
-   GNU pth is a user-space threading library, and as such, all threads
-   run within the same process. In this case, if the currently running
-   thread is not the main_thread, send the signal to the main_thread.
-*/
-
-#ifdef WITH_THREAD
-#include <sys/types.h> /* For pid_t */
 #include "pythread.h"
-static long main_thread;
-static pid_t main_pid;
-#endif
+static PyObject *signal_branch;
+static PyThread_type_handle signal_branch_handle;
+static int signal_branch_waiting;
+static int signal_branch_wakeup_sent;
+static int signal_branch_reload;
+static int signal_branch_quit;
+static PyCritical *signal_branch_crit;
+static PyObject *sigint_branch;
+static PyObject *old_sigint_handler;
+static PyMethodDef kbdint_raiser_method_def;
 
 static struct {
-        int tripped;
-        PyObject *func;
+    int banned;  /* We won't touch this signal */
+    int old_ignored;  /* When python initialized the signal was SIG_IGN (not SIG_DFL) */
+    int watched;  /* signal_waiter is watching for this signal */
+    PyObject *func;
 } Handlers[NSIG];
 
-static int is_tripped = 0; /* Speed up sigcheck() when none tripped */
-
 static PyObject *DefaultHandler;
 static PyObject *IgnoreHandler;
 static PyObject *IntHandler;
 
-/* On Solaris 8, gcc will produce a warning that the function
-   declaration is not a prototype. This is caused by the definition of
-   SIG_DFL as (void (*)())0; the correct declaration would have been
-   (void (*)(int))0. */
 
-static PyOS_sighandler_t old_siginthandler = SIG_DFL;
-
-
 static PyObject *
 signal_default_int_handler(PyObject *self, PyObject *args)
 {
-	PyErr_SetNone(PyExc_KeyboardInterrupt);
-	return NULL;
+    PyObject *kbdint_raiser_method, *x;
+    PyObject *m = PyImport_ImportModule("signal");
+    if (m == NULL)
+        return NULL;
+
+    kbdint_raiser_method = PyCFunction_NewEx(&kbdint_raiser_method_def, m, m);
+    if (kbdint_raiser_method == NULL)
+        return NULL;
+
+    x = PyObject_CallMethod(sigint_branch, "add", "O", kbdint_raiser_method);
+    Py_DECREF(kbdint_raiser_method);
+    if (x == NULL)
+        return NULL;
+    Py_DECREF(x);
+
+    Py_INCREF(Py_None);
+    return Py_None;
 }
 
 PyDoc_STRVAR(default_int_handler_doc,
 "default_int_handler(...)\n\
 \n\
 The default handler for SIGINT installed by Python.\n\
-It raises KeyboardInterrupt.");
+It causes KeyboardInterrupt to be raised from a hidden branch above\n\
+the __main__ module.");
 
 
-static int
-checksignals_witharg(void * unused)
+static PyObject *
+kbdint_raiser(PyObject *self)
 {
-	return PyErr_CheckSignals();
+    PyErr_SetNone(PyExc_KeyboardInterrupt);
+    return NULL;
 }
 
 static void
-signal_handler(int sig_num)
+dummy(int sig_num)
 {
-#ifdef WITH_THREAD
-#ifdef WITH_PTH
-	if (PyThread_get_thread_ident() != main_thread) {
-		pth_raise(*(pth_t *) main_thread, sig_num);
-		return;
-	}
-#endif
-	/* See NOTES section above */
-	if (getpid() == main_pid) {
-#endif
-		is_tripped++;
-		Handlers[sig_num].tripped = 1;
-		Py_AddPendingCall(checksignals_witharg, NULL);
-#ifdef WITH_THREAD
-	}
-#endif
-#ifdef SIGCHLD
-	if (sig_num == SIGCHLD) {
-		/* To avoid infinite recursion, this signal remains
-		   reset until explicit re-instated.
-		   Don't clear the 'func' field as it is our pointer
-		   to the Python handler... */
-		return;
-	}
-#endif
-	PyOS_setsig(sig_num, signal_handler);
+    Py_FatalError("dummy should never be called");
 }
 
+static PyObject *
+signal_waiter(PyObject *self)
+{
+    sigset_t set, wakeupset;
+    int sig, wakeupsig;
+    int i;
+    PyObject *func, *x;
+    PyObject *retval = NULL;
 
+    sigemptyset(&wakeupset);
+    sigaddset(&wakeupset, _PySIGNAL_WAKEUP);
+
+    PyCritical_Enter(signal_branch_crit);
+    signal_branch_handle = PyThread_get_handle();
+
+    PyOS_setsig(_PySIGNAL_WAKEUP, dummy);
+
+    while (1) {
+        if (signal_branch_reload) {
+            /* Stop watching old signals */
+            sigemptyset(&set);
+            for (i = 1; i < NSIG; i++) {
+                if (Handlers[i].banned)
+                    continue;
+
+                if (Handlers[i].watched &&
+                        (Handlers[i].func == DefaultHandler ||
+                        Handlers[i].func == IgnoreHandler)) {
+                    void (*func)(int);
+                    if (Handlers[i].func == IgnoreHandler)
+                        func = SIG_IGN;
+                    else
+                        func = SIG_DFL;
+
+                    PyOS_setsig(i, func);
+                    sigaddset(&set, i);
+                    pthread_sigmask(SIG_UNBLOCK, &set, NULL);
+                    Handlers[i].watched = 0;
+                }
+            }
+
+            /* Start watching new signals.  Also sets the set for sigwait */
+            sigemptyset(&set);
+            for (i = 1; i < NSIG; i++) {
+                if (Handlers[i].banned)
+                    continue;
+
+                if (!Handlers[i].watched &&
+                        Handlers[i].func != DefaultHandler &&
+                        Handlers[i].func != IgnoreHandler) {
+                    sigaddset(&set, i);
+                    pthread_sigmask(SIG_BLOCK, &set, NULL);
+                    PyOS_setsig(i, dummy);
+                    Handlers[i].watched = 1;
+                } else if (Handlers[i].watched)
+                    sigaddset(&set, i);
+            }
+
+            /* We always watch for _PySIGNAL_WAKEUP, even though we only
+             * block it around sigwait */
+            sigaddset(&set, _PySIGNAL_WAKEUP);
+            signal_branch_reload = 0;
+        }
+
+        if (signal_branch_quit) {
+            Py_INCREF(Py_None);
+            retval = Py_None;
+            break;
+        }
+
+        pthread_sigmask(SIG_BLOCK, &wakeupset, NULL);
+        signal_branch_waiting = 1;
+        PyCritical_Exit(signal_branch_crit);
+        PyState_Suspend();
+
+        errno = 0;
+        if (sigwait(&set, &sig)) {
+            /* XXX I've seen some mention that gdb can cause sigwait to
+             * be interrupted.  If verified, this needs to be modified
+             * to loop on EINTR */
+            dprintf(2, "sigwait failed: %d\n", errno);
+            Py_FatalError("sigwait failed!");
+        }
+
+        PyState_Resume();
+        PyCritical_Enter(signal_branch_crit);
+        signal_branch_waiting = 0;
+        if (sig != _PySIGNAL_WAKEUP && signal_branch_wakeup_sent) {
+            /* Purge any pending wakeups */
+            sigwait(&wakeupset, &wakeupsig);
+            assert(wakeupsig == _PySIGNAL_WAKEUP);
+        }
+        signal_branch_wakeup_sent = 0;
+        pthread_sigmask(SIG_UNBLOCK, &wakeupset, NULL);
+
+        assert(sig >= 1 && sig < NSIG);
+        if (sig != _PySIGNAL_WAKEUP) {
+            func = Handlers[sig].func;
+            Py_INCREF(func);
+            if (func == DefaultHandler || func == IgnoreHandler)
+                /* XXX FIXME the signal handler could be changed at the
+                 * same time we get a signal for it, meaning we
+                 * legitimately have no handler by the time we get here */
+                Py_FatalError("sigwait got signal without handler");
+            PyCritical_Exit(signal_branch_crit);
+            x = PyObject_CallFunction(func, "iO", sig, Py_None);
+            Py_DECREF(func);
+            Py_XDECREF(x);
+            PyCritical_Enter(signal_branch_crit);
+            if (x == NULL)
+                break;
+        }
+    }
+
+    /* Reset all signals to their original handlers */
+    sigemptyset(&set);
+    for (i = 1; i < NSIG; i++) {
+        if (!Handlers[i].banned) {
+            if (!Handlers[i].old_ignored)
+                PyOS_setsig(i, SIG_DFL);
+            else
+                PyOS_setsig(i, SIG_IGN);
+            sigaddset(&set, i);
+            Handlers[i].watched = 0;
+        }
+    }
+    pthread_sigmask(SIG_UNBLOCK, &set, NULL);
+    PyOS_setsig(_PySIGNAL_WAKEUP, SIG_DFL);
+    PyCritical_Exit(signal_branch_crit);
+    return retval;
+}
+
+
 #ifdef HAVE_ALARM
 static PyObject *
 signal_alarm(PyObject *self, PyObject *args)
 {
-	int t;
-	if (!PyArg_ParseTuple(args, "i:alarm", &t))
-		return NULL;
-	/* alarm() returns the number of seconds remaining */
-	return PyInt_FromLong((long)alarm(t));
+    int t;
+    if (!PyArg_ParseTuple(args, "i:alarm", &t))
+        return NULL;
+    /* alarm() returns the number of seconds remaining */
+    return PyInt_FromLong((long)alarm(t));
 }
 
 PyDoc_STRVAR(alarm_doc,
@@ -158,71 +268,41 @@
 Arrange for SIGALRM to arrive after the given number of seconds.");
 #endif
 
-#ifdef HAVE_PAUSE
+
 static PyObject *
-signal_pause(PyObject *self)
+signal_signal(PyObject *self, PyObject *args)
 {
-	Py_BEGIN_ALLOW_THREADS
-	(void)pause();
-	Py_END_ALLOW_THREADS
-	/* make sure that any exceptions that got raised are propagated
-	 * back into Python
-	 */
-	if (PyErr_CheckSignals())
-		return NULL;
+    PyObject *obj;
+    int sig_num;
+    PyObject *old_handler;
+    void (*func)(int);
 
-	Py_INCREF(Py_None);
-	return Py_None;
-}
-PyDoc_STRVAR(pause_doc,
-"pause()\n\
-\n\
-Wait until a signal arrives.");
+    if (!PyArg_ParseTuple(args, "iO:signal", &sig_num, &obj))
+        return NULL;
 
-#endif
+    if (sig_num < 1 || sig_num >= NSIG) {
+        PyErr_SetString(PyExc_ValueError, "signal number out of range");
+        return NULL;
+    }
+    if (obj != IgnoreHandler && obj != DefaultHandler &&
+            !PyCallable_Check(obj)) {
+        PyErr_SetString(PyExc_TypeError, "signal handler must be "
+            "signal.SIG_IGN, signal.SIG_DFL, or a callable object");
+        return NULL;
+    }
 
+    PyCritical_Enter(signal_branch_crit);
+    Py_INCREF(obj);
+    old_handler = Handlers[sig_num].func;
+    Handlers[sig_num].func = obj;
+    signal_branch_reload = 1;
+    if (signal_branch_waiting && !signal_branch_wakeup_sent) {
+        PyThread_send_signal(signal_branch_handle, _PySIGNAL_WAKEUP);
+        signal_branch_wakeup_sent = 1;
+    }
+    PyCritical_Exit(signal_branch_crit);
 
-static PyObject *
-signal_signal(PyObject *self, PyObject *args)
-{
-	PyObject *obj;
-	int sig_num;
-	PyObject *old_handler;
-	void (*func)(int);
-	if (!PyArg_ParseTuple(args, "iO:signal", &sig_num, &obj))
-		return NULL;
-#ifdef WITH_THREAD
-	if (PyThread_get_thread_ident() != main_thread) {
-		PyErr_SetString(PyExc_ValueError,
-				"signal only works in main thread");
-		return NULL;
-	}
-#endif
-	if (sig_num < 1 || sig_num >= NSIG) {
-		PyErr_SetString(PyExc_ValueError,
-				"signal number out of range");
-		return NULL;
-	}
-	if (obj == IgnoreHandler)
-		func = SIG_IGN;
-	else if (obj == DefaultHandler)
-		func = SIG_DFL;
-	else if (!PyCallable_Check(obj)) {
-		PyErr_SetString(PyExc_TypeError,
-"signal handler must be signal.SIG_IGN, signal.SIG_DFL, or a callable object");
-		return NULL;
-	}
-	else
-		func = signal_handler;
-	if (PyOS_setsig(sig_num, func) == SIG_ERR) {
-		PyErr_SetFromErrno(PyExc_RuntimeError);
-		return NULL;
-	}
-	old_handler = Handlers[sig_num].func;
-	Handlers[sig_num].tripped = 0;
-	Py_INCREF(obj);
-	Handlers[sig_num].func = obj;
-	return old_handler;
+    return old_handler;
 }
 
 PyDoc_STRVAR(signal_doc,
@@ -233,25 +313,28 @@
 returned.  See getsignal() for possible return values.\n\
 \n\
 *** IMPORTANT NOTICE ***\n\
-A signal handler function is called with two arguments:\n\
-the first is the signal number, the second is the interrupted stack frame.");
+A signal handler function is called with only *one* argument: the signal number.");
 
 
 static PyObject *
 signal_getsignal(PyObject *self, PyObject *args)
 {
-	int sig_num;
-	PyObject *old_handler;
-	if (!PyArg_ParseTuple(args, "i:getsignal", &sig_num))
-		return NULL;
-	if (sig_num < 1 || sig_num >= NSIG) {
-		PyErr_SetString(PyExc_ValueError,
-				"signal number out of range");
-		return NULL;
-	}
-	old_handler = Handlers[sig_num].func;
-	Py_INCREF(old_handler);
-	return old_handler;
+    int sig_num;
+    PyObject *old_handler;
+
+    if (!PyArg_ParseTuple(args, "i:getsignal", &sig_num))
+        return NULL;
+
+    if (sig_num < 1 || sig_num >= NSIG) {
+        PyErr_SetString(PyExc_ValueError, "signal number out of range");
+        return NULL;
+    }
+
+    PyCritical_Enter(signal_branch_crit);
+    old_handler = Handlers[sig_num].func;
+    Py_INCREF(old_handler);
+    PyCritical_Exit(signal_branch_crit);
+    return old_handler;
 }
 
 PyDoc_STRVAR(getsignal_doc,
@@ -267,20 +350,23 @@
 /* List of functions defined in the module */
 static PyMethodDef signal_methods[] = {
 #ifdef HAVE_ALARM
-	{"alarm",	        signal_alarm, METH_VARARGS, alarm_doc},
+    {"alarm",               signal_alarm, METH_VARARGS, alarm_doc},
 #endif
-	{"signal",	        signal_signal, METH_VARARGS, signal_doc},
-	{"getsignal",	        signal_getsignal, METH_VARARGS, getsignal_doc},
-#ifdef HAVE_PAUSE
-	{"pause",	        (PyCFunction)signal_pause,
-	 METH_NOARGS,pause_doc},
-#endif
-	{"default_int_handler", signal_default_int_handler, 
-	 METH_VARARGS, default_int_handler_doc},
-	{NULL,			NULL}		/* sentinel */
+    {"signal",              signal_signal, METH_VARARGS, signal_doc},
+    {"getsignal",           signal_getsignal, METH_VARARGS, getsignal_doc},
+    {"default_int_handler", signal_default_int_handler, METH_VARARGS,
+        default_int_handler_doc},
+    {NULL,                  NULL}  /* sentinel */
 };
 
+/* This are NOT exported methods.  They are only used internally
+ * by the signal machinery */
+static PyMethodDef signal_waiter_method_def = {"signal_waiter",
+    (PyCFunction)signal_waiter, METH_NOARGS | METH_SHARED, NULL};
+static PyMethodDef kbdint_raiser_method_def = {"kbdint_raiser",
+    (PyCFunction)kbdint_raiser, METH_NOARGS | METH_SHARED, NULL};
 
+
 PyDoc_STRVAR(module_doc,
 "This module provides mechanisms to use signal handlers in Python.\n\
 \n\
@@ -289,7 +375,6 @@
 alarm() -- cause SIGALRM after a specified time [Unix only]\n\
 signal() -- set the action for a given signal\n\
 getsignal() -- get the signal action for a given signal\n\
-pause() -- wait until a signal arrives [Unix only]\n\
 default_int_handler() -- default SIGINT handler\n\
 \n\
 Constants:\n\
@@ -304,373 +389,401 @@
 A signal handler function is called with two arguments:\n\
 the first is the signal number, the second is the interrupted stack frame.");
 
-PyMODINIT_FUNC
-initsignal(void)
+void
+_PySignal_Init(void)
 {
-	PyObject *m, *d, *x;
-	int i;
+    sigset_t set;
+    PyObject *m, *d, *x;
+    PyObject *e_type, *e_val, *e_tb;
+    PyObject *signal_waiter_method;
+    int i;
 
-#ifdef WITH_THREAD
-	main_thread = PyThread_get_thread_ident();
-	main_pid = getpid();
-#endif
+    /* Create the module and add the functions */
+    m = Py_InitModule3("signal", signal_methods, module_doc);
+    if (m == NULL)
+            Py_FatalError("failed to initialize signalmodule");
+    /* XXX FIXME is fixup redundant here? */
+    _PyImport_FixupExtension("signal", "signal");
 
-	/* Create the module and add the functions */
-	m = Py_InitModule3("signal", signal_methods, module_doc);
-	if (m == NULL)
-		return;
+    /* Add some symbolic constants to the module */
+    d = PyModule_GetDict(m);
 
-	/* Add some symbolic constants to the module */
-	d = PyModule_GetDict(m);
+    DefaultHandler = PyLong_FromVoidPtr((void *)SIG_DFL);
+    if (DefaultHandler == NULL ||
+            PyDict_SetItemString(d, "SIG_DFL", DefaultHandler) < 0)
+        Py_FatalError("failed to initialize SIG_DFL");
 
-	x = DefaultHandler = PyLong_FromVoidPtr((void *)SIG_DFL);
-        if (!x || PyDict_SetItemString(d, "SIG_DFL", x) < 0)
-                goto finally;
+    IgnoreHandler = PyLong_FromVoidPtr((void *)SIG_IGN);
+    if (IgnoreHandler == NULL ||
+            PyDict_SetItemString(d, "SIG_IGN", IgnoreHandler) < 0)
+        Py_FatalError("failed to initialize SIG_IGN");
 
-	x = IgnoreHandler = PyLong_FromVoidPtr((void *)SIG_IGN);
-        if (!x || PyDict_SetItemString(d, "SIG_IGN", x) < 0)
-                goto finally;
+    x = PyInt_FromLong((long)NSIG);
+    if (x == NULL || PyDict_SetItemString(d, "NSIG", x) < 0)
+        Py_FatalError("failed to initialize NSIG");
+    Py_DECREF(x);
 
-        x = PyInt_FromLong((long)NSIG);
-        if (!x || PyDict_SetItemString(d, "NSIG", x) < 0)
-                goto finally;
-        Py_DECREF(x);
+    IntHandler = PyDict_GetItemString(d, "default_int_handler");
+    if (IntHandler == NULL)
+        Py_FatalError("failed to initialize default_int_handler");
+    Py_INCREF(IntHandler);
 
-	x = IntHandler = PyDict_GetItemString(d, "default_int_handler");
-        if (!x)
-                goto finally;
-	Py_INCREF(IntHandler);
 
-	Handlers[0].tripped = 0;
-	for (i = 1; i < NSIG; i++) {
-		void (*t)(int);
-		t = PyOS_getsig(i);
-		Handlers[i].tripped = 0;
-		if (t == SIG_DFL)
-			Handlers[i].func = DefaultHandler;
-		else if (t == SIG_IGN)
-			Handlers[i].func = IgnoreHandler;
-		else
-			Handlers[i].func = Py_None; /* None of our business */
-		Py_INCREF(Handlers[i].func);
-	}
-	if (Handlers[SIGINT].func == DefaultHandler) {
-		/* Install default int handler */
-		Py_INCREF(IntHandler);
-		Py_DECREF(Handlers[SIGINT].func);
-		Handlers[SIGINT].func = IntHandler;
-		old_siginthandler = PyOS_setsig(SIGINT, signal_handler);
-	}
+#define add_signal(name) \
+    x = PyInt_FromLong(name); \
+    if (x == NULL) \
+        Py_FatalError("failed to create signal constant " #name); \
+    if (PyDict_SetItemString(d, #name, x) < 0) \
+        Py_FatalError("failed to add signal constant " #name); \
+    Py_DECREF(x);
 
 #ifdef SIGHUP
-	x = PyInt_FromLong(SIGHUP);
-	PyDict_SetItemString(d, "SIGHUP", x);
-        Py_XDECREF(x);
+    add_signal(SIGHUP);
 #endif
 #ifdef SIGINT
-	x = PyInt_FromLong(SIGINT);
-	PyDict_SetItemString(d, "SIGINT", x);
-        Py_XDECREF(x);
+    add_signal(SIGINT);
 #endif
 #ifdef SIGBREAK
-	x = PyInt_FromLong(SIGBREAK);
-	PyDict_SetItemString(d, "SIGBREAK", x);
-        Py_XDECREF(x);
+    add_signal(SIGBREAK);
 #endif
 #ifdef SIGQUIT
-	x = PyInt_FromLong(SIGQUIT);
-	PyDict_SetItemString(d, "SIGQUIT", x);
-        Py_XDECREF(x);
+    add_signal(SIGQUIT);
 #endif
 #ifdef SIGILL
-	x = PyInt_FromLong(SIGILL);
-	PyDict_SetItemString(d, "SIGILL", x);
-        Py_XDECREF(x);
+    add_signal(SIGILL);
 #endif
 #ifdef SIGTRAP
-	x = PyInt_FromLong(SIGTRAP);
-	PyDict_SetItemString(d, "SIGTRAP", x);
-        Py_XDECREF(x);
+    add_signal(SIGTRAP);
 #endif
 #ifdef SIGIOT
-	x = PyInt_FromLong(SIGIOT);
-	PyDict_SetItemString(d, "SIGIOT", x);
-        Py_XDECREF(x);
+    add_signal(SIGIOT);
 #endif
 #ifdef SIGABRT
-	x = PyInt_FromLong(SIGABRT);
-	PyDict_SetItemString(d, "SIGABRT", x);
-        Py_XDECREF(x);
+    add_signal(SIGABRT);
 #endif
 #ifdef SIGEMT
-	x = PyInt_FromLong(SIGEMT);
-	PyDict_SetItemString(d, "SIGEMT", x);
-        Py_XDECREF(x);
+    add_signal(SIGEMT);
 #endif
 #ifdef SIGFPE
-	x = PyInt_FromLong(SIGFPE);
-	PyDict_SetItemString(d, "SIGFPE", x);
-        Py_XDECREF(x);
+    add_signal(SIGFPE);
 #endif
 #ifdef SIGKILL
-	x = PyInt_FromLong(SIGKILL);
-	PyDict_SetItemString(d, "SIGKILL", x);
-        Py_XDECREF(x);
+    add_signal(SIGKILL);
 #endif
 #ifdef SIGBUS
-	x = PyInt_FromLong(SIGBUS);
-	PyDict_SetItemString(d, "SIGBUS", x);
-        Py_XDECREF(x);
+    add_signal(SIGBUS);
 #endif
 #ifdef SIGSEGV
-	x = PyInt_FromLong(SIGSEGV);
-	PyDict_SetItemString(d, "SIGSEGV", x);
-        Py_XDECREF(x);
+    add_signal(SIGSEGV);
 #endif
 #ifdef SIGSYS
-	x = PyInt_FromLong(SIGSYS);
-	PyDict_SetItemString(d, "SIGSYS", x);
-        Py_XDECREF(x);
+    add_signal(SIGSYS);
 #endif
 #ifdef SIGPIPE
-	x = PyInt_FromLong(SIGPIPE);
-	PyDict_SetItemString(d, "SIGPIPE", x);
-        Py_XDECREF(x);
+    add_signal(SIGPIPE);
 #endif
 #ifdef SIGALRM
-	x = PyInt_FromLong(SIGALRM);
-	PyDict_SetItemString(d, "SIGALRM", x);
-        Py_XDECREF(x);
+    add_signal(SIGALRM);
 #endif
 #ifdef SIGTERM
-	x = PyInt_FromLong(SIGTERM);
-	PyDict_SetItemString(d, "SIGTERM", x);
-        Py_XDECREF(x);
+    add_signal(SIGTERM);
 #endif
 #ifdef SIGUSR1
-	x = PyInt_FromLong(SIGUSR1);
-	PyDict_SetItemString(d, "SIGUSR1", x);
-        Py_XDECREF(x);
+    add_signal(SIGUSR1);
 #endif
 #ifdef SIGUSR2
-	x = PyInt_FromLong(SIGUSR2);
-	PyDict_SetItemString(d, "SIGUSR2", x);
-        Py_XDECREF(x);
+    add_signal(SIGUSR2);
 #endif
 #ifdef SIGCLD
-	x = PyInt_FromLong(SIGCLD);
-	PyDict_SetItemString(d, "SIGCLD", x);
-        Py_XDECREF(x);
+    add_signal(SIGCLD);
 #endif
 #ifdef SIGCHLD
-	x = PyInt_FromLong(SIGCHLD);
-	PyDict_SetItemString(d, "SIGCHLD", x);
-        Py_XDECREF(x);
+    add_signal(SIGCHLD);
 #endif
 #ifdef SIGPWR
-	x = PyInt_FromLong(SIGPWR);
-	PyDict_SetItemString(d, "SIGPWR", x);
-        Py_XDECREF(x);
+    add_signal(SIGPWR);
 #endif
 #ifdef SIGIO
-	x = PyInt_FromLong(SIGIO);
-	PyDict_SetItemString(d, "SIGIO", x);
-        Py_XDECREF(x);
+    add_signal(SIGIO);
 #endif
 #ifdef SIGURG
-	x = PyInt_FromLong(SIGURG);
-	PyDict_SetItemString(d, "SIGURG", x);
-        Py_XDECREF(x);
+    add_signal(SIGURG);
 #endif
 #ifdef SIGWINCH
-	x = PyInt_FromLong(SIGWINCH);
-	PyDict_SetItemString(d, "SIGWINCH", x);
-        Py_XDECREF(x);
+    add_signal(SIGWINCH);
 #endif
 #ifdef SIGPOLL
-	x = PyInt_FromLong(SIGPOLL);
-	PyDict_SetItemString(d, "SIGPOLL", x);
-        Py_XDECREF(x);
+    add_signal(SIGPOLL);
 #endif
 #ifdef SIGSTOP
-	x = PyInt_FromLong(SIGSTOP);
-	PyDict_SetItemString(d, "SIGSTOP", x);
-        Py_XDECREF(x);
+    add_signal(SIGSTOP);
 #endif
 #ifdef SIGTSTP
-	x = PyInt_FromLong(SIGTSTP);
-	PyDict_SetItemString(d, "SIGTSTP", x);
-        Py_XDECREF(x);
+    add_signal(SIGTSTP);
 #endif
 #ifdef SIGCONT
-	x = PyInt_FromLong(SIGCONT);
-	PyDict_SetItemString(d, "SIGCONT", x);
-        Py_XDECREF(x);
+    add_signal(SIGCONT);
 #endif
 #ifdef SIGTTIN
-	x = PyInt_FromLong(SIGTTIN);
-	PyDict_SetItemString(d, "SIGTTIN", x);
-        Py_XDECREF(x);
+    add_signal(SIGTTIN);
 #endif
 #ifdef SIGTTOU
-	x = PyInt_FromLong(SIGTTOU);
-	PyDict_SetItemString(d, "SIGTTOU", x);
-        Py_XDECREF(x);
+    add_signal(SIGTTOU);
 #endif
 #ifdef SIGVTALRM
-	x = PyInt_FromLong(SIGVTALRM);
-	PyDict_SetItemString(d, "SIGVTALRM", x);
-        Py_XDECREF(x);
+    add_signal(SIGVTALRM);
 #endif
 #ifdef SIGPROF
-	x = PyInt_FromLong(SIGPROF);
-	PyDict_SetItemString(d, "SIGPROF", x);
-        Py_XDECREF(x);
+    add_signal(SIGPROF);
 #endif
 #ifdef SIGXCPU
-	x = PyInt_FromLong(SIGXCPU);
-	PyDict_SetItemString(d, "SIGXCPU", x);
-        Py_XDECREF(x);
+    add_signal(SIGXCPU);
 #endif
 #ifdef SIGXFSZ
-	x = PyInt_FromLong(SIGXFSZ);
-	PyDict_SetItemString(d, "SIGXFSZ", x);
-        Py_XDECREF(x);
+    add_signal(SIGXFSZ);
 #endif
 #ifdef SIGRTMIN
-        x = PyInt_FromLong(SIGRTMIN);
-        PyDict_SetItemString(d, "SIGRTMIN", x);
-        Py_XDECREF(x);
+    add_signal(SIGRTMIN);
 #endif
 #ifdef SIGRTMAX
-        x = PyInt_FromLong(SIGRTMAX);
-        PyDict_SetItemString(d, "SIGRTMAX", x);
-        Py_XDECREF(x);
+    add_signal(SIGRTMAX);
 #endif
 #ifdef SIGINFO
-	x = PyInt_FromLong(SIGINFO);
-	PyDict_SetItemString(d, "SIGINFO", x);
-        Py_XDECREF(x);
+    add_signal(SIGINFO);
 #endif
-        if (!PyErr_Occurred())
-                return;
 
-	/* Check for errors */
-  finally:
-        return;
-}
 
-static void
-finisignal(void)
-{
-	int i;
-	PyObject *func;
+#ifdef SIGPIPE
+    PyOS_setsig(SIGPIPE, SIG_IGN);
+#endif
+#ifdef SIGXFZ
+    PyOS_setsig(SIGXFZ, SIG_IGN);
+#endif
+#ifdef SIGXFSZ
+    PyOS_setsig(SIGXFSZ, SIG_IGN);
+#endif
 
-	PyOS_setsig(SIGINT, old_siginthandler);
-	old_siginthandler = SIG_DFL;
 
-	for (i = 1; i < NSIG; i++) {
-		func = Handlers[i].func;
-		Handlers[i].tripped = 0;
-		Handlers[i].func = NULL;
-		if (i != SIGINT && func != NULL && func != Py_None &&
-		    func != DefaultHandler && func != IgnoreHandler)
-			PyOS_setsig(i, SIG_DFL);
-		Py_XDECREF(func);
-	}
+    sigemptyset(&set);
+    sigaddset(&set, i);
+    for (i = 1; i < NSIG; i++) {
+        void (*t)(int);
+        t = PyOS_getsig(i);
+        if (t == SIG_DFL) {
+            Handlers[i].watched = 1;
+            Handlers[i].old_ignored = 0;
+            Handlers[i].func = DefaultHandler;
+            sigaddset(&set, i);
+        } else if (t == SIG_IGN) {
+            Handlers[i].watched = 1;
+            Handlers[i].old_ignored = 1;
+            Handlers[i].func = IgnoreHandler;
+            sigaddset(&set, i);
+        } else {
+            Handlers[i].banned = 1; /* None of our business */
+            Handlers[i].func = Py_None;
+        }
+        Py_INCREF(Handlers[i].func);
+    }
+    pthread_sigmask(SIG_BLOCK, &set, NULL);
 
-	Py_XDECREF(IntHandler);
-	IntHandler = NULL;
-	Py_XDECREF(DefaultHandler);
-	DefaultHandler = NULL;
-	Py_XDECREF(IgnoreHandler);
-	IgnoreHandler = NULL;
+    signal_branch_crit = PyCritical_Allocate(PyCRITICAL_NORMAL);
+    if (signal_branch_crit == NULL)
+        Py_FatalError("failed to initialize signal_branch_crit");
+
+    signal_branch = PyObject_CallObject((PyObject *)&PyBranch_Type, NULL);
+    if (signal_branch == NULL)
+        Py_FatalError("failed to initialize signal_branch");
+    x = PyObject_CallMethod(signal_branch, "__enter__", "");
+    if (x == NULL)
+        Py_FatalError("failed to call signal_branch.__enter__()");
+    Py_DECREF(x);
+
+    signal_branch_reload = 1;
+    signal_waiter_method = PyCFunction_NewEx(&signal_waiter_method_def, m, m);
+    if (signal_waiter_method == NULL)
+        Py_FatalError("failed to create signal_waiter_method");
+    x = PyObject_CallMethod(signal_branch, "add", "O", signal_waiter_method);
+    Py_DECREF(signal_waiter_method);
+    if (x == NULL)
+        Py_FatalError("failed to call signal_branch.add()");
+    Py_DECREF(x);
 }
 
-
-/* Declared in pyerrors.h */
-int
-PyErr_CheckSignals(void)
+void
+_PySignal_Fini(void)
 {
-	int i;
-	PyObject *f;
+    int i;
+    PyObject *x, *func;
+    PyObject *e_type, *e_val, *e_tb;
 
-	if (!is_tripped)
-		return 0;
-#ifdef WITH_THREAD
-	if (PyThread_get_thread_ident() != main_thread)
-		return 0;
-#endif
-	if (!(f = (PyObject *)PyEval_GetFrame()))
-		f = Py_None;
-	
-	for (i = 1; i < NSIG; i++) {
-		if (Handlers[i].tripped) {
-			PyObject *result = NULL;
-			PyObject *arglist = Py_BuildValue("(iO)", i, f);
-			Handlers[i].tripped = 0;
+    PyCritical_Enter(signal_branch_crit);
+    signal_branch_quit = 1;
+    if (signal_branch_waiting && !signal_branch_wakeup_sent) {
+        PyThread_send_signal(signal_branch_handle, _PySIGNAL_WAKEUP);
+        signal_branch_wakeup_sent = 1;
+    }
+    PyCritical_Exit(signal_branch_crit);
 
-			if (arglist) {
-				result = PyEval_CallObject(Handlers[i].func,
-							   arglist);
-				Py_DECREF(arglist);
-			}
-			if (!result)
-				return -1;
+    /* XXX This is all a big bodge */
+    PyErr_Fetch(&e_type, &e_val, &e_tb);
+    PyErr_NormalizeException(&e_type, &e_val, &e_tb);
+    if (e_type == NULL) {
+        Py_INCREF(Py_None);
+        e_type = Py_None;
+        Py_INCREF(Py_None);
+        e_val = Py_None;
+    }
+    if (e_tb == NULL) {
+        Py_INCREF(Py_None);
+        e_tb = Py_None;
+    }
+    assert(e_type && e_val && e_tb);
+    x = PyObject_CallMethod(signal_branch, "__exit__", "OOO", e_type, e_val, e_tb);
+    /* XXX any DECREFs needed? */
+    if (x == NULL)
+        Py_FatalError("failed to call signal_branch.__exit__()");
+    Py_DECREF(x);
+    Py_CLEAR(signal_branch);
+    /* XXX reraise or whatever as required by __exit__ specs */
 
-			Py_DECREF(result);
-		}
-	}
-	is_tripped = 0;
-	return 0;
+    PyCritical_Free(signal_branch_crit);
+    signal_branch_crit = NULL;
+
+    for (i = 1; i < NSIG; i++)
+        Py_CLEAR(Handlers[i].func);
+    Py_CLEAR(IntHandler);
+    Py_CLEAR(DefaultHandler);
+    Py_CLEAR(IgnoreHandler);
 }
 
-
-/* Replacements for intrcheck.c functionality
- * Declared in pyerrors.h
- */
 void
-PyErr_SetInterrupt(void)
+_PySignal_InitSigInt(int handle_sigint)
 {
-	is_tripped++;
-	Handlers[SIGINT].tripped = 1;
-	Py_AddPendingCall((int (*)(void *))PyErr_CheckSignals, NULL);
+    PyObject *x;
+
+    sigint_branch = PyObject_CallObject((PyObject *)&PyBranch_Type, NULL);
+    if (sigint_branch == NULL)
+        Py_FatalError("failed to initialize sigint_branch");
+    x = PyObject_CallMethod(sigint_branch, "__enter__", "");
+    if (x == NULL)
+        Py_FatalError("failed to call sigint_branch.__enter__()");
+    Py_DECREF(x);
+
+    if (handle_sigint) {
+        PyObject *m = PyImport_ImportModule("signal");
+        if (!m)
+            Py_FatalError("Can't import signal module");
+
+        old_sigint_handler = PyObject_CallMethod(m, "signal", "iO", SIGINT, IntHandler);
+        if (old_sigint_handler == NULL)
+            Py_FatalError("Failed to install sigint handler");
+    }
 }
 
 void
-PyOS_InitInterrupts(void)
+_PySignal_FiniSigInt(void)
 {
-	initsignal();
-	_PyImport_FixupExtension("signal", "signal");
+    PyObject *x;
+    PyObject *e_type, *e_val, *e_tb;
+
+    if (old_sigint_handler) {
+        PyObject *m = PyImport_ImportModule("signal");
+        if (!m)
+            Py_FatalError("Can't import signal module");
+
+        x = PyObject_CallMethod(m, "signal", "iO", SIGINT, old_sigint_handler);
+        if (x == NULL)
+            Py_FatalError("Failed to uninstall sigint handler");
+        Py_DECREF(x);
+        Py_CLEAR(old_sigint_handler);
+    }
+
+    /* XXX This is all a big bodge */
+    PyErr_Fetch(&e_type, &e_val, &e_tb);
+    PyErr_NormalizeException(&e_type, &e_val, &e_tb);
+    if (e_type == NULL) {
+        Py_INCREF(Py_None);
+        e_type = Py_None;
+        Py_INCREF(Py_None);
+        e_val = Py_None;
+    }
+    if (e_tb == NULL) {
+        Py_INCREF(Py_None);
+        e_tb = Py_None;
+    }
+    assert(e_type && e_val && e_tb);
+    x = PyObject_CallMethod(sigint_branch, "__exit__", "OOO", e_type, e_val, e_tb);
+    /* XXX any DECREFs needed? */
+    if (x == NULL)
+        PyErr_Print();
+        //Py_FatalError("failed to call sigint_branch.__exit__()");
+    Py_XDECREF(x);
+    Py_CLEAR(sigint_branch);
+    /* XXX reraise or whatever as required by __exit__ specs */
 }
 
-void
-PyOS_FiniInterrupts(void)
+
+/* Wrappers around sigaction() or signal(). */
+PyOS_sighandler_t
+PyOS_getsig(int sig)
 {
-	finisignal();
+#ifdef HAVE_SIGACTION
+    struct sigaction context;
+    if (sigaction(sig, NULL, &context) == -1)
+        return SIG_ERR;
+    return context.sa_handler;
+#else
+    PyOS_sighandler_t handler;
+/* Special signal handling for the secure CRT in Visual Studio 2005 */
+#if defined(_MSC_VER) && _MSC_VER >= 1400
+    switch (sig) {
+        /* Only these signals are valid */
+        case SIGINT:
+        case SIGILL:
+        case SIGFPE:
+        case SIGSEGV:
+        case SIGTERM:
+        case SIGBREAK:
+        case SIGABRT:
+            break;
+        /* Don't call signal() with other values or it will assert */
+        default:
+            return SIG_ERR;
+    }
+#endif /* _MSC_VER && _MSC_VER >= 1400 */
+    handler = signal(sig, SIG_IGN);
+    if (handler != SIG_ERR)
+        signal(sig, handler);
+    return handler;
+#endif
 }
 
-int
-PyOS_InterruptOccurred(void)
+PyOS_sighandler_t
+PyOS_setsig(int sig, PyOS_sighandler_t handler)
 {
-	if (Handlers[SIGINT].tripped) {
-#ifdef WITH_THREAD
-		if (PyThread_get_thread_ident() != main_thread)
-			return 0;
+#ifdef HAVE_SIGACTION
+    struct sigaction context, ocontext;
+    context.sa_handler = handler;
+    sigemptyset(&context.sa_mask);
+    context.sa_flags = 0;
+    if (sigaction(sig, &context, &ocontext) == -1)
+            return SIG_ERR;
+    return ocontext.sa_handler;
+#else
+    PyOS_sighandler_t oldhandler;
+    oldhandler = signal(sig, handler);
+#ifdef HAVE_SIGINTERRUPT
+    siginterrupt(sig, 1);
 #endif
-		Handlers[SIGINT].tripped = 0;
-		return 1;
-	}
-	return 0;
+    return oldhandler;
+#endif
 }
 
+
 void
 PyOS_AfterFork(void)
 {
-#ifdef WITH_THREAD
-	PyEval_ReInitThreads();
-	main_thread = PyThread_get_thread_ident();
-	main_pid = getpid();
-	_PyImport_ReInitLock();
-#endif
+    PyState_CleanupForkChild();
+    _PyImport_ReInitLock();
 }
Index: Modules/Setup.config.in
===================================================================
--- Modules/Setup.config.in	(revision 58355)
+++ Modules/Setup.config.in	(working copy)
@@ -4,10 +4,10 @@
 # based on configure-time options.
 
 # Threading
-@USE_THREAD_MODULE@thread threadmodule.c
+#@USE_THREAD_MODULE@thread threadmodule.c
 
 # The signal module
-@USE_SIGNAL_MODULE@signal signalmodule.c
+#@USE_SIGNAL_MODULE@signal signalmodule.c
 
 # The rest of the modules previously listed in this file are built
 # by the setup.py script in Python 2.1 and later.
Index: Modules/_sre.c
===================================================================
--- Modules/_sre.c	(revision 58355)
+++ Modules/_sre.c	(working copy)
@@ -1836,8 +1836,6 @@
 static void
 pattern_dealloc(PatternObject* self)
 {
-    if (self->weakreflist != NULL)
-        PyObject_ClearWeakRefs((PyObject *) self);
     Py_XDECREF(self->pattern);
     Py_XDECREF(self->groupindex);
     Py_XDECREF(self->indexgroup);
@@ -2477,7 +2475,7 @@
     PatternObject* copy;
     int offset;
 
-    copy = PyObject_NEW_VAR(PatternObject, &Pattern_Type, self->codesize);
+    copy = PyObject_NEWVAR(PatternObject, &Pattern_Type, self->codesize);
     if (!copy)
         return NULL;
 
@@ -2661,7 +2659,7 @@
 
     n = PyList_GET_SIZE(code);
 
-    self = PyObject_NEW_VAR(PatternObject, &Pattern_Type, n);
+    self = PyObject_NEWVAR(PatternObject, &Pattern_Type, n);
     if (!self)
         return NULL;
 
@@ -3023,7 +3021,7 @@
 
     slots = 2 * (self->pattern->groups+1);
 
-    copy = PyObject_NEW_VAR(MatchObject, &Match_Type, slots);
+    copy = PyObject_NEWVAR(MatchObject, &Match_Type, slots);
     if (!copy)
         return NULL;
 
@@ -3170,7 +3168,7 @@
     if (status > 0) {
 
         /* create match object (with room for extra group marks) */
-        match = PyObject_NEW_VAR(MatchObject, &Match_Type,
+        match = PyObject_NEWVAR(MatchObject, &Match_Type,
                                  2*(pattern->groups+1));
         if (!match)
             return NULL;
Index: Modules/pyexpat.c
===================================================================
--- Modules/pyexpat.c	(revision 58355)
+++ Modules/pyexpat.c	(working copy)
@@ -340,7 +340,7 @@
 call_with_frame(PyCodeObject *c, PyObject* func, PyObject* args,
                 xmlparseobject *self)
 {
-    PyThreadState *tstate = PyThreadState_GET();
+    PyThreadState *tstate = PyThreadState_Get();
     PyFrameObject *f;
     PyObject *res;
 
@@ -1030,7 +1030,7 @@
     new_parser = PyObject_New(xmlparseobject, &Xmlparsetype);
 #else
     /* Python versions 2.2 and later */
-    new_parser = PyObject_GC_New(xmlparseobject, &Xmlparsetype);
+    new_parser = PyObject_NEW(xmlparseobject, &Xmlparsetype);
 #endif
 
     if (new_parser == NULL)
@@ -1045,7 +1045,7 @@
             PyObject_Del(new_parser);
 #else
             /* Code for versions 2.2 and later. */
-            PyObject_GC_Del(new_parser);
+            PyObject_DEL(new_parser);
 #endif
             return PyErr_NoMemory();
         }
@@ -1062,7 +1062,6 @@
     new_parser->intern = self->intern;
     Py_XINCREF(new_parser->intern);
 #ifdef Py_TPFLAGS_HAVE_GC
-    PyObject_GC_Track(new_parser);
 #else
     PyObject_GC_Init(new_parser);
 #endif
@@ -1229,7 +1228,7 @@
 
 #ifdef Py_TPFLAGS_HAVE_GC
     /* Code for versions 2.2 and later */
-    self = PyObject_GC_New(xmlparseobject, &Xmlparsetype);
+    self = PyObject_NEW(xmlparseobject, &Xmlparsetype);
 #else
     self = PyObject_New(xmlparseobject, &Xmlparsetype);
 #endif
@@ -1253,7 +1252,6 @@
     self->intern = intern;
     Py_XINCREF(self->intern);
 #ifdef Py_TPFLAGS_HAVE_GC
-    PyObject_GC_Track(self);
 #else
     PyObject_GC_Init(self);
 #endif
@@ -1286,7 +1284,6 @@
 {
     int i;
 #ifdef Py_TPFLAGS_HAVE_GC
-    PyObject_GC_UnTrack(self);
 #else
     PyObject_GC_Fini(self);
 #endif
@@ -1314,7 +1311,7 @@
     PyObject_Del(self);
 #else
     /* Code for versions 2.2 and later. */
-    PyObject_GC_Del(self);
+    PyObject_DEL(self);
 #endif
 }
 
Index: Modules/gcmodule.c
===================================================================
--- Modules/gcmodule.c	(revision 58355)
+++ Modules/gcmodule.c	(working copy)
@@ -19,12 +19,20 @@
 */
 
 #include "Python.h"
+#include "pythread.h"
 
+#define GC_MAX_DEALLOC_DEPTH 50
+
+#if 0
 /* Get an object's GC head */
 #define AS_GC(o) ((PyGC_Head *)(o)-1)
 
 /* Get the object given the GC head */
 #define FROM_GC(g) ((PyObject *)(((PyGC_Head *)g)+1))
+#else
+#define AS_GC
+#define FROM_GC
+#endif
 
 /*** Global GC state ***/
 
@@ -38,13 +46,23 @@
 #define NUM_GENERATIONS 3
 #define GEN_HEAD(n) (&generations[n].head)
 
+#if 0
 /* linked lists of container objects */
 static struct gc_generation generations[NUM_GENERATIONS] = {
 	/* PyGC_Head,				threshold,	count */
-	{{{GEN_HEAD(0), GEN_HEAD(0), 0}},	700,		0},
-	{{{GEN_HEAD(1), GEN_HEAD(1), 0}},	10,		0},
-	{{{GEN_HEAD(2), GEN_HEAD(2), 0}},	10,		0},
+	{{{0, GEN_HEAD(0), GEN_HEAD(0), 0}},	700,		0},
+	{{{0, GEN_HEAD(1), GEN_HEAD(1), 0}},	10,		0},
+	{{{0, GEN_HEAD(2), GEN_HEAD(2), 0}},	10,		0},
 };
+#else
+/* linked lists of container objects */
+static struct gc_generation generations[NUM_GENERATIONS] = {
+	/* PyGC_Head,				threshold,	count */
+	{{GEN_HEAD(0), GEN_HEAD(0), 0, 0, 0, 0, NULL},	700,		0},
+	{{GEN_HEAD(1), GEN_HEAD(1), 0, 0, 0, 0, NULL},	10,		0},
+	{{GEN_HEAD(2), GEN_HEAD(2), 0, 0, 0, 0, NULL},	10,		0},
+};
+#endif
 
 PyGC_Head *_PyGC_generation0 = GEN_HEAD(0);
 
@@ -75,6 +93,8 @@
 static int debug;
 static PyObject *tmod = NULL;
 
+static PyThread_type_lock PyGC_lock;
+
 /*--------------------------------------------------------------------------
 gc_refs values.
 
@@ -82,12 +102,12 @@
 
 GC_UNTRACKED
     The initial state; objects returned by PyObject_GC_Malloc are in this
-    state.  The object doesn't live in any generation list, and its
-    tp_traverse slot must not be called.
+    state.  The object doesn't live in any generation list, and
+    gc_traverse must not be called.
 
 GC_REACHABLE
-    The object lives in some generation list, and its tp_traverse is safe to
-    call.  An object transitions to GC_REACHABLE when PyObject_GC_Track
+    The object lives in some generation list, and gc_traverse is safe to
+    call.  An object transitions to GC_REACHABLE when GC_Track
     is called.
 
 During a collection, gc_refs can temporarily take on other states:
@@ -118,46 +138,54 @@
 #define GC_REACHABLE			_PyGC_REFS_REACHABLE
 #define GC_TENTATIVELY_UNREACHABLE	_PyGC_REFS_TENTATIVELY_UNREACHABLE
 
-#define IS_TRACKED(o) ((AS_GC(o))->gc.gc_refs != GC_UNTRACKED)
-#define IS_REACHABLE(o) ((AS_GC(o))->gc.gc_refs == GC_REACHABLE)
+#define IS_TRACKED(o) ((AS_GC(o))->ob_refcnt_trace != GC_UNTRACKED)
+#define IS_REACHABLE(o) (((PyObject *)(o))->ob_refcnt_trace == GC_REACHABLE)
 #define IS_TENTATIVELY_UNREACHABLE(o) ( \
-	(AS_GC(o))->gc.gc_refs == GC_TENTATIVELY_UNREACHABLE)
+	((PyObject *)(o))->ob_refcnt_trace == GC_TENTATIVELY_UNREACHABLE)
 
+#define GC_TRACK(o) do { \
+	if (((PyObject *)(o))->ob_refcnt_trace != _PyGC_REFS_UNTRACKED) \
+		Py_FatalError("GC object already tracked"); \
+	((PyObject *)(o))->ob_refcnt_trace = _PyGC_REFS_REACHABLE; \
+    } while (0);
+
+#define GC_UNTRACK(o) do { \
+	assert(((PyObject *)(o))->ob_refcnt_trace != _PyGC_REFS_UNTRACKED); \
+	((PyObject *)(o))->ob_refcnt_trace = _PyGC_REFS_UNTRACKED; \
+    } while (0);
+
 /*** list functions ***/
 
 static void
 gc_list_init(PyGC_Head *list)
 {
-	list->gc.gc_prev = list;
-	list->gc.gc_next = list;
+	list->ob_prev = list;
+	list->ob_next = list;
 }
 
 static int
 gc_list_is_empty(PyGC_Head *list)
 {
-	return (list->gc.gc_next == list);
+	return (list->ob_next == list);
 }
 
-#if 0
-/* This became unused after gc_list_move() was introduced. */
 /* Append `node` to `list`. */
 static void
 gc_list_append(PyGC_Head *node, PyGC_Head *list)
 {
-	node->gc.gc_next = list;
-	node->gc.gc_prev = list->gc.gc_prev;
-	node->gc.gc_prev->gc.gc_next = node;
-	list->gc.gc_prev = node;
+	node->ob_next = list;
+	node->ob_prev = list->ob_prev;
+	node->ob_prev->ob_next = node;
+	list->ob_prev = node;
 }
-#endif
 
 /* Remove `node` from the gc list it's currently in. */
 static void
 gc_list_remove(PyGC_Head *node)
 {
-	node->gc.gc_prev->gc.gc_next = node->gc.gc_next;
-	node->gc.gc_next->gc.gc_prev = node->gc.gc_prev;
-	node->gc.gc_next = NULL; /* object is not currently tracked */
+	node->ob_prev->ob_next = node->ob_next;
+	node->ob_next->ob_prev = node->ob_prev;
+	node->ob_next = NULL; /* object is not currently tracked */
 }
 
 /* Move `node` from the gc list it's currently in (which is not explicitly
@@ -168,15 +196,15 @@
 gc_list_move(PyGC_Head *node, PyGC_Head *list)
 {
 	PyGC_Head *new_prev;
-	PyGC_Head *current_prev = node->gc.gc_prev;
-	PyGC_Head *current_next = node->gc.gc_next;
+	PyGC_Head *current_prev = node->ob_prev;
+	PyGC_Head *current_next = node->ob_next;
 	/* Unlink from current list. */
-	current_prev->gc.gc_next = current_next;
-	current_next->gc.gc_prev = current_prev;
+	current_prev->ob_next = current_next;
+	current_next->ob_prev = current_prev;
 	/* Relink at end of new list. */
-	new_prev = node->gc.gc_prev = list->gc.gc_prev;
-	new_prev->gc.gc_next = list->gc.gc_prev = node;
-	node->gc.gc_next = list;
+	new_prev = node->ob_prev = list->ob_prev;
+	new_prev->ob_next = list->ob_prev = node;
+	node->ob_next = list;
 }
 
 /* append list `from` onto list `to`; `from` becomes an empty list */
@@ -186,11 +214,11 @@
 	PyGC_Head *tail;
 	assert(from != to);
 	if (!gc_list_is_empty(from)) {
-		tail = to->gc.gc_prev;
-		tail->gc.gc_next = from->gc.gc_next;
-		tail->gc.gc_next->gc.gc_prev = tail;
-		to->gc.gc_prev = from->gc.gc_prev;
-		to->gc.gc_prev->gc.gc_next = to;
+		tail = to->ob_prev;
+		tail->ob_next = from->ob_next;
+		tail->ob_next->ob_prev = tail;
+		to->ob_prev = from->ob_prev;
+		to->ob_prev->ob_next = to;
 	}
 	gc_list_init(from);
 }
@@ -200,7 +228,7 @@
 {
 	PyGC_Head *gc;
 	Py_ssize_t n = 0;
-	for (gc = list->gc.gc_next; gc != list; gc = gc->gc.gc_next) {
+	for (gc = list->ob_next; gc != list; gc = gc->ob_next) {
 		n++;
 	}
 	return n;
@@ -213,7 +241,7 @@
 append_objects(PyObject *py_list, PyGC_Head *gc_list)
 {
 	PyGC_Head *gc;
-	for (gc = gc_list->gc.gc_next; gc != gc_list; gc = gc->gc.gc_next) {
+	for (gc = gc_list->ob_next; gc != gc_list; gc = gc->ob_next) {
 		PyObject *op = FROM_GC(gc);
 		if (op != py_list) {
 			if (PyList_Append(py_list, op)) {
@@ -227,6 +255,71 @@
 /*** end of list stuff ***/
 
 
+static void
+gc_traverse(PyObject *ob, visitproc func, void *arg)
+{
+    traverseproc traverse;
+
+    if (PyType_SUPPORTS_WEAKREFS(Py_Type(ob))) {
+        PyWeakReference **ptr = _PY_GETWEAKREFPTR(ob);
+        PyWeakReference *ref = (PyWeakReference *)AO_load_full((AO_t *)ptr);
+        if (ref != NULL) {
+            PyLinkedList *binding_links = &ref->binding_links;
+
+            /* Traverse the weakref */
+            if (func((PyObject *)ref, arg) != 0)
+                Py_FatalError("non-zero retval in gc_traverse");
+
+            while (PyLinkedList_Next(&ref->binding_links, &binding_links)) {
+                PyWeakBinding *bind = PyLinkedList_Restore(PyWeakBinding,
+                        weakref_links, binding_links);
+                if (bind->value == NULL)
+                    continue;
+
+                /* Traverse a binding's value (which is really owned by ob) */
+                if (func(bind->value, arg) != 0)
+                    Py_FatalError("non-zero retval in gc_traverse");
+            }
+
+        }
+    }
+
+    /* Traverse the rest of ob */
+    traverse = Py_Type(ob)->tp_traverse;
+    if (traverse && traverse(ob, func, arg) != 0)
+        Py_FatalError("non-zero retval in gc_traverse");
+}
+
+static void
+gc_clear(PyObject *ob)
+{
+    inquiry clear = Py_Type(ob)->tp_clear;
+
+    /* clear functions need a borrowed reference to ob.  Since they may
+     * remove the reference that's currently in a cycle, we make sure
+     * to create our own */
+    Py_INCREF(ob);
+
+    if (PyType_SUPPORTS_WEAKREFS(Py_Type(ob))) {
+        PyWeakReference *ref;
+        PyWeakReference **ptr = _PY_GETWEAKREFPTR(ob);
+
+        ref = (PyWeakReference *)AO_load_full((AO_t *)ptr);
+        if (ref != NULL) {
+            /* We create our own reference to ref here too */
+            Py_INCREF(ref);
+            _PyWeakref_ClearBindings(ob, ref);
+            Py_DECREF(ref);
+        }
+    }
+
+    if (clear != NULL)
+        clear(ob);
+
+    Py_DECREF(ob);
+}
+
+
 /* Set all gc_refs = ob_refcnt.  After this, gc_refs is > 0 for all objects
  * in containers, and is GC_REACHABLE for all tracked gc objects not in
  * containers.
@@ -234,10 +327,10 @@
 static void
 update_refs(PyGC_Head *containers)
 {
-	PyGC_Head *gc = containers->gc.gc_next;
-	for (; gc != containers; gc = gc->gc.gc_next) {
-		assert(gc->gc.gc_refs == GC_REACHABLE);
-		gc->gc.gc_refs = Py_Refcnt(FROM_GC(gc));
+	PyGC_Head *gc = containers->ob_next;
+	for (; gc != containers; gc = gc->ob_next) {
+		assert(gc->ob_refcnt_trace == GC_REACHABLE);
+		gc->ob_refcnt_trace = Py_RefcntSnoop(FROM_GC(gc));
 		/* Python's cyclic gc should never see an incoming refcount
 		 * of 0:  if something decref'ed to 0, it should have been
 		 * deallocated immediately at that time.
@@ -256,7 +349,7 @@
 		 * so serious that maybe this should be a release-build
 		 * check instead of an assert?
 		 */
-		assert(gc->gc.gc_refs != 0);
+		assert(gc->ob_refcnt_trace != 0);
 	}
 }
 
@@ -271,9 +364,9 @@
 		 * generation being collected, which can be recognized
 		 * because only they have positive gc_refs.
 		 */
-		assert(gc->gc.gc_refs != 0); /* else refcount was too small */
-		if (gc->gc.gc_refs > 0)
-			gc->gc.gc_refs--;
+		assert(gc->ob_refcnt_trace != 0); /* else refcount was too small */
+		if (gc->ob_refcnt_trace > 0)
+			gc->ob_refcnt_trace--;
 	}
 	return 0;
 }
@@ -287,13 +380,9 @@
 subtract_refs(PyGC_Head *containers)
 {
 	traverseproc traverse;
-	PyGC_Head *gc = containers->gc.gc_next;
-	for (; gc != containers; gc=gc->gc.gc_next) {
-		traverse = Py_Type(FROM_GC(gc))->tp_traverse;
-		(void) traverse(FROM_GC(gc),
-			       (visitproc)visit_decref,
-			       NULL);
-	}
+	PyGC_Head *gc = containers->ob_next;
+	for (; gc != containers; gc=gc->ob_next)
+		gc_traverse(gc, (visitproc)visit_decref, NULL);
 }
 
 /* A traversal callback for move_unreachable. */
@@ -302,7 +391,7 @@
 {
 	if (PyObject_IS_GC(op)) {
 		PyGC_Head *gc = AS_GC(op);
-		const Py_ssize_t gc_refs = gc->gc.gc_refs;
+		const Py_ssize_t gc_refs = gc->ob_refcnt_trace;
 
 		if (gc_refs == 0) {
 			/* This is in move_unreachable's 'young' list, but
@@ -310,7 +399,7 @@
 			 * we need to do is tell move_unreachable that it's
 			 * reachable.
 			 */
-			gc->gc.gc_refs = 1;
+			gc->ob_refcnt_trace = 1;
 		}
 		else if (gc_refs == GC_TENTATIVELY_UNREACHABLE) {
 			/* This had gc_refs = 0 when move_unreachable got
@@ -320,7 +409,7 @@
 			 * again.
 			 */
 			gc_list_move(gc, reachable);
-			gc->gc.gc_refs = 1;
+			gc->ob_refcnt_trace = 1;
 		}
 		/* Else there's nothing to do.
 		 * If gc_refs > 0, it must be in move_unreachable's 'young'
@@ -350,7 +439,7 @@
 static void
 move_unreachable(PyGC_Head *young, PyGC_Head *unreachable)
 {
-	PyGC_Head *gc = young->gc.gc_next;
+	PyGC_Head *gc = young->ob_next;
 
 	/* Invariants:  all objects "to the left" of us in young have gc_refs
 	 * = GC_REACHABLE, and are indeed reachable (directly or indirectly)
@@ -364,23 +453,21 @@
 	while (gc != young) {
 		PyGC_Head *next;
 
-		if (gc->gc.gc_refs) {
+		if (gc->ob_refcnt_trace) {
                         /* gc is definitely reachable from outside the
                          * original 'young'.  Mark it as such, and traverse
                          * its pointers to find any other objects that may
                          * be directly reachable from it.  Note that the
-                         * call to tp_traverse may append objects to young,
+                         * call to gc_traverse may append objects to young,
                          * so we have to wait until it returns to determine
                          * the next object to visit.
                          */
                         PyObject *op = FROM_GC(gc);
-                        traverseproc traverse = Py_Type(op)->tp_traverse;
-                        assert(gc->gc.gc_refs > 0);
-                        gc->gc.gc_refs = GC_REACHABLE;
-                        (void) traverse(op,
-                                        (visitproc)visit_reachable,
-                                        (void *)young);
-                        next = gc->gc.gc_next;
+                        assert(gc->ob_refcnt_trace > 0);
+                        gc->ob_refcnt_trace = GC_REACHABLE;
+                        gc_traverse(op, (visitproc)visit_reachable,
+                                (void *)young);
+                        next = gc->ob_next;
 		}
 		else {
 			/* This *may* be unreachable.  To make progress,
@@ -390,9 +477,9 @@
 			 * visit_reachable will eventually move gc back into
 			 * young if that's so, and we'll see it again.
 			 */
-			next = gc->gc.gc_next;
+			next = gc->ob_next;
 			gc_list_move(gc, unreachable);
-			gc->gc.gc_refs = GC_TENTATIVELY_UNREACHABLE;
+			gc->ob_refcnt_trace = GC_TENTATIVELY_UNREACHABLE;
 		}
 		gc = next;
 	}
@@ -411,7 +498,7 @@
 	if (PyGen_CheckExact(op))
 		return PyGen_NeedsFinalizing((PyGenObject *)op);
 	else
-		return op->ob_type->tp_del != NULL;
+		return 0;
 }
 
 /* Move the objects in unreachable with __del__ methods into `finalizers`.
@@ -427,15 +514,15 @@
 	/* March over unreachable.  Move objects with finalizers into
 	 * `finalizers`.
 	 */
-	for (gc = unreachable->gc.gc_next; gc != unreachable; gc = next) {
+	for (gc = unreachable->ob_next; gc != unreachable; gc = next) {
 		PyObject *op = FROM_GC(gc);
 
 		assert(IS_TENTATIVELY_UNREACHABLE(op));
-		next = gc->gc.gc_next;
+		next = gc->ob_next;
 
 		if (has_finalizer(op)) {
 			gc_list_move(gc, finalizers);
-			gc->gc.gc_refs = GC_REACHABLE;
+			gc->ob_refcnt_trace = GC_REACHABLE;
 		}
 	}
 }
@@ -448,7 +535,7 @@
 		if (IS_TENTATIVELY_UNREACHABLE(op)) {
 			PyGC_Head *gc = AS_GC(op);
 			gc_list_move(gc, tolist);
-			gc->gc.gc_refs = GC_REACHABLE;
+			gc->ob_refcnt_trace = GC_REACHABLE;
 		}
 	}
 	return 0;
@@ -460,14 +547,10 @@
 static void
 move_finalizer_reachable(PyGC_Head *finalizers)
 {
-	traverseproc traverse;
-	PyGC_Head *gc = finalizers->gc.gc_next;
-	for (; gc != finalizers; gc = gc->gc.gc_next) {
+	PyGC_Head *gc = finalizers->ob_next;
+	for (; gc != finalizers; gc = gc->ob_next) {
 		/* Note that the finalizers list may grow during this. */
-		traverse = Py_Type(FROM_GC(gc))->tp_traverse;
-		(void) traverse(FROM_GC(gc),
-				(visitproc)visit_move,
-				(void *)finalizers);
+		gc_traverse(gc, (visitproc)visit_move, (void *)finalizers);
 	}
 }
 
@@ -488,12 +571,14 @@
 	PyGC_Head *gc;
 	PyObject *op;		/* generally FROM_GC(gc) */
 	PyWeakReference *wr;	/* generally a cast of op */
-	PyGC_Head wrcb_to_call;	/* weakrefs with callbacks to call */
 	PyGC_Head *next;
 	int num_freed = 0;
 
-	gc_list_init(&wrcb_to_call);
-
+        /* XXX FIXME clearing cyclic objects should cause them to be
+         * deleted, calling Py_Dealloc, which should clear weakrefs for
+         * us.  A cleared object should never live past the tracing
+         * operation, so this lazy weakref handling should be sufficient. */
+#if 0
 	/* Clear all weakrefs to the objects in unreachable.  If such a weakref
 	 * also has a callback, move it into `wrcb_to_call` if the callback
 	 * needs to be invoked.  Note that we cannot invoke any callbacks until
@@ -502,14 +587,14 @@
 	 * make another pass over wrcb_to_call, invoking callbacks, after this
 	 * pass completes.
 	 */
-	for (gc = unreachable->gc.gc_next; gc != unreachable; gc = next) {
+	for (gc = unreachable->ob_next; gc != unreachable; gc = next) {
 		PyWeakReference **wrlist;
 
 		op = FROM_GC(gc);
 		assert(IS_TENTATIVELY_UNREACHABLE(op));
-		next = gc->gc.gc_next;
+		next = gc->ob_next;
 
-		if (! PyType_SUPPORTS_WEAKREFS(Py_Type(op)))
+		if (!PyType_SUPPORTS_WEAKREFS(Py_Type(op)))
 			continue;
 
 		/* It supports weakrefs.  Does it have any? */
@@ -530,97 +615,10 @@
 			assert(wr->wr_object == op);
 			_PyWeakref_ClearRef(wr);
 			assert(wr->wr_object == Py_None);
-			if (wr->wr_callback == NULL)
-				continue;	/* no callback */
-
-	/* Headache time.  `op` is going away, and is weakly referenced by
-	 * `wr`, which has a callback.  Should the callback be invoked?  If wr
-	 * is also trash, no:
-	 *
-	 * 1. There's no need to call it.  The object and the weakref are
-	 *    both going away, so it's legitimate to pretend the weakref is
-	 *    going away first.  The user has to ensure a weakref outlives its
-	 *    referent if they want a guarantee that the wr callback will get
-	 *    invoked.
-	 *
-	 * 2. It may be catastrophic to call it.  If the callback is also in
-	 *    cyclic trash (CT), then although the CT is unreachable from
-	 *    outside the current generation, CT may be reachable from the
-	 *    callback.  Then the callback could resurrect insane objects.
-	 *
-	 * Since the callback is never needed and may be unsafe in this case,
-	 * wr is simply left in the unreachable set.  Note that because we
-	 * already called _PyWeakref_ClearRef(wr), its callback will never
-	 * trigger.
-	 *
-	 * OTOH, if wr isn't part of CT, we should invoke the callback:  the
-	 * weakref outlived the trash.  Note that since wr isn't CT in this
-	 * case, its callback can't be CT either -- wr acted as an external
-	 * root to this generation, and therefore its callback did too.  So
-	 * nothing in CT is reachable from the callback either, so it's hard
-	 * to imagine how calling it later could create a problem for us.  wr
-	 * is moved to wrcb_to_call in this case.
-	 */
-	 		if (IS_TENTATIVELY_UNREACHABLE(wr))
-	 			continue;
-			assert(IS_REACHABLE(wr));
-
-			/* Create a new reference so that wr can't go away
-			 * before we can process it again.
-			 */
-			Py_INCREF(wr);
-
-			/* Move wr to wrcb_to_call, for the next pass. */
-			wrasgc = AS_GC(wr);
-			assert(wrasgc != next); /* wrasgc is reachable, but
-			                           next isn't, so they can't
-			                           be the same */
-			gc_list_move(wrasgc, &wrcb_to_call);
 		}
 	}
+#endif
 
-	/* Invoke the callbacks we decided to honor.  It's safe to invoke them
-	 * because they can't reference unreachable objects.
-	 */
-	while (! gc_list_is_empty(&wrcb_to_call)) {
-		PyObject *temp;
-		PyObject *callback;
-
-		gc = wrcb_to_call.gc.gc_next;
-		op = FROM_GC(gc);
-		assert(IS_REACHABLE(op));
-		assert(PyWeakref_Check(op));
-		wr = (PyWeakReference *)op;
-		callback = wr->wr_callback;
-		assert(callback != NULL);
-
-		/* copy-paste of weakrefobject.c's handle_callback() */
-		temp = PyObject_CallFunctionObjArgs(callback, wr, NULL);
-		if (temp == NULL)
-			PyErr_WriteUnraisable(callback);
-		else
-			Py_DECREF(temp);
-
-		/* Give up the reference we created in the first pass.  When
-		 * op's refcount hits 0 (which it may or may not do right now),
-		 * op's tp_dealloc will decref op->wr_callback too.  Note
-		 * that the refcount probably will hit 0 now, and because this
-		 * weakref was reachable to begin with, gc didn't already
-		 * add it to its count of freed objects.  Example:  a reachable
-		 * weak value dict maps some key to this reachable weakref.
-		 * The callback removes this key->weakref mapping from the
-		 * dict, leaving no other references to the weakref (excepting
-		 * ours).
-		 */
-		Py_DECREF(op);
-		if (wrcb_to_call.gc.gc_next == gc) {
-			/* object is still alive -- move it */
-			gc_list_move(gc, old);
-		}
-		else
-			++num_freed;
-	}
-
 	return num_freed;
 }
 
@@ -645,14 +643,14 @@
 static int
 handle_finalizers(PyGC_Head *finalizers, PyGC_Head *old)
 {
-	PyGC_Head *gc = finalizers->gc.gc_next;
+	PyGC_Head *gc = finalizers->ob_next;
 
 	if (garbage == NULL) {
 		garbage = PyList_New(0);
 		if (garbage == NULL)
 			Py_FatalError("gc couldn't create gc.garbage list");
 	}
-	for (; gc != finalizers; gc = gc->gc.gc_next) {
+	for (; gc != finalizers; gc = gc->ob_next) {
 		PyObject *op = FROM_GC(gc);
 
 		if ((debug & DEBUG_SAVEALL) || has_finalizer(op)) {
@@ -675,7 +673,7 @@
 	inquiry clear;
 
 	while (!gc_list_is_empty(collectable)) {
-		PyGC_Head *gc = collectable->gc.gc_next;
+		PyGC_Head *gc = collectable->ob_next;
 		PyObject *op = FROM_GC(gc);
 
 		assert(IS_TENTATIVELY_UNREACHABLE(op));
@@ -689,10 +687,10 @@
 				Py_DECREF(op);
 			}
 		}
-		if (collectable->gc.gc_next == gc) {
+		if (collectable->ob_next == gc) {
 			/* object is still alive, move it, it may die later */
 			gc_list_move(gc, old);
-			gc->gc.gc_refs = GC_REACHABLE;
+			gc->ob_refcnt_trace = GC_REACHABLE;
 		}
 	}
 }
@@ -712,6 +710,10 @@
 	PyGC_Head *gc;
 	double t1 = 0.0;
 
+	/* XXX the lists can now include objects that say GC_UNTRACKED.
+	 * This means those objects are deallocated but in the cache.
+	 * We need to start skipping them. */
+	return 0; /* XXX FIXME HACK */
 	if (delstr == NULL) {
 		delstr = PyUnicode_InternFromString("__del__");
 		if (delstr == NULL)
@@ -795,8 +797,8 @@
 	/* Collect statistics on collectable objects found and print
 	 * debugging information.
 	 */
-	for (gc = unreachable.gc.gc_next; gc != &unreachable;
-			gc = gc->gc.gc_next) {
+	for (gc = unreachable.ob_next; gc != &unreachable;
+			gc = gc->ob_next) {
 		m++;
 		if (debug & DEBUG_COLLECTABLE) {
 			debug_cycle("collectable", FROM_GC(gc));
@@ -825,9 +827,9 @@
 
 	/* Collect statistics on uncollectable objects found and print
 	 * debugging information. */
-	for (gc = finalizers.gc.gc_next;
+	for (gc = finalizers.ob_next;
 	     gc != &finalizers;
-	     gc = gc->gc.gc_next) {
+	     gc = gc->ob_next) {
 		n++;
 		if (debug & DEBUG_UNCOLLECTABLE)
 			debug_cycle("uncollectable", FROM_GC(gc));
@@ -1035,13 +1037,26 @@
 			     generations[2].count);
 }
 
+struct referrers_state {
+    PyObject *objs;
+    int match;
+};
+
 static int
-referrersvisit(PyObject* obj, PyObject *objs)
+referrersvisit(PyObject* obj, struct referrers_state *state)
 {
 	Py_ssize_t i;
-	for (i = 0; i < PyTuple_GET_SIZE(objs); i++)
-		if (PyTuple_GET_ITEM(objs, i) == obj)
-			return 1;
+
+	if (state->match)
+		return 0;
+
+	for (i = 0; i < PyTuple_GET_SIZE(state->objs); i++) {
+		if (PyTuple_GET_ITEM(state->objs, i) == obj) {
+			state->match = 1;
+			return 0;
+		}
+	}
+
 	return 0;
 }
 
@@ -1050,13 +1065,17 @@
 {
 	PyGC_Head *gc;
 	PyObject *obj;
+	struct referrers_state state;
 	traverseproc traverse;
-	for (gc = list->gc.gc_next; gc != list; gc = gc->gc.gc_next) {
+
+	state.objs = objs;
+
+	for (gc = list->ob_next; gc != list; gc = gc->ob_next) {
 		obj = FROM_GC(gc);
-		traverse = Py_Type(obj)->tp_traverse;
-		if (obj == objs || obj == resultlist)
-			continue;
-		if (traverse(obj, (visitproc)referrersvisit, objs)) {
+		state.match = 0;
+
+		gc_traverse(obj, (visitproc)referrersvisit, &state);
+		if (state.match) {
 			if (PyList_Append(resultlist, obj) < 0)
 				return 0; /* error */
 		}
@@ -1073,7 +1092,8 @@
 {
 	int i;
 	PyObject *result = PyList_New(0);
-	if (!result) return NULL;
+	if (!result)
+		return NULL;
 
 	for (i = 0; i < NUM_GENERATIONS; i++) {
 		if (!(gc_referrers_for(args, GEN_HEAD(i), result))) {
@@ -1084,11 +1104,23 @@
 	return result;
 }
 
-/* Append obj to list; return true if error (out of memory), false if OK. */
+struct referents_state {
+    PyObject *list;
+    int status;
+};
+
+/* Append obj to state->list; set state->status to 1 if an error (out
+ * of memory) occurs. */
 static int
-referentsvisit(PyObject *obj, PyObject *list)
+referentsvisit(PyObject *obj, struct referents_state *state)
 {
-	return PyList_Append(list, obj) < 0;
+	if (state->status)
+		return 0;
+
+	if (PyList_Append(state->list, obj) < 0)
+		state->status = 1;
+
+	return 0;
 }
 
 PyDoc_STRVAR(gc_get_referents__doc__,
@@ -1098,27 +1130,26 @@
 static PyObject *
 gc_get_referents(PyObject *self, PyObject *args)
 {
+	struct referents_state state;
 	Py_ssize_t i;
-	PyObject *result = PyList_New(0);
 
-	if (result == NULL)
+	state.list = PyList_New(0);
+	if (state.list == NULL)
 		return NULL;
 
 	for (i = 0; i < PyTuple_GET_SIZE(args); i++) {
 		traverseproc traverse;
 		PyObject *obj = PyTuple_GET_ITEM(args, i);
 
-		if (! PyObject_IS_GC(obj))
+		if (!PyObject_IS_GC(obj))
 			continue;
-		traverse = Py_Type(obj)->tp_traverse;
-		if (! traverse)
-			continue;
-		if (traverse(obj, (visitproc)referentsvisit, result)) {
-			Py_DECREF(result);
+		gc_traverse(obj, (visitproc)referentsvisit, &state);
+		if (state.status) {
+			Py_DECREF(state.list);
 			return NULL;
 		}
 	}
-	return result;
+	return state.list;
 }
 
 PyDoc_STRVAR(gc_get_objects__doc__,
@@ -1181,6 +1212,15 @@
 	{NULL,	NULL}		/* Sentinel */
 };
 
+void
+_PyGC_Init(void)
+{
+	/* XXX we leak this */
+	PyGC_lock = PyThread_lock_allocate();
+	if (!PyGC_lock)
+		Py_FatalError("unable to allocate lock");
+}
+
 PyMODINIT_FUNC
 initgc(void)
 {
@@ -1231,6 +1271,8 @@
 {
 	Py_ssize_t n;
 
+	Py_FatalError("Cycle GC Disabled");
+
 	if (collecting)
 		n = 0; /* already collecting, don't do anything */
 	else {
@@ -1252,112 +1294,774 @@
 /* extension modules might be compiled with GC support so these
    functions must always be available */
 
-#undef PyObject_GC_Track
-#undef PyObject_GC_UnTrack
 #undef PyObject_GC_Del
 #undef _PyObject_GC_Malloc
 
 void
-PyObject_GC_Track(void *op)
+_Py_Refchain_Init(void)
 {
-	_PyObject_GC_TRACK(op);
+#ifdef Py_TRACE_REFS
+	refchain_lock = PyThread_lock_allocate();
+	if (!refchain_lock)
+		Py_FatalError("Can't allocate refchain_lock");
+#endif
 }
 
-/* for binary compatibility with 2.2 */
 void
-_PyObject_GC_Track(PyObject *op)
+_Py_Refchain_Fini(void)
 {
-    PyObject_GC_Track(op);
+#ifdef Py_TRACE_REFS
+	PyThread_lock_free(refchain_lock);
+	refchain_lock = 0;
+#endif
 }
 
+static void
+_Py_NewReference(PyObject *op)
+{
+	_Py_INC_REFTOTAL();
+	op->ob_refowner = (AO_t)PyThreadState_Get();
+	op->ob_refcnt = 1;
+#ifdef Py_TRACE_REFS
+	_Py_AddToAllObjects(op, 1);
+#endif
+	_Py_INC_TPALLOCS(op);
+}
+
+static void
+_Py_ForgetReference(PyObject *op)
+{
+#ifdef Py_TRACE_REFS
+#ifdef SLOW_UNREF_CHECK
+        register PyObject *p;
+#endif
+	PyThread_lock_acquire(refchain_lock);
+	if (Py_RefcntSnoop(op) < 0)
+		Py_FatalError("UNREF negative refcnt");
+	if (op == &refchain ||
+	    op->_ob_prev->_ob_next != op || op->_ob_next->_ob_prev != op)
+		Py_FatalError("UNREF invalid object");
+#ifdef SLOW_UNREF_CHECK
+	for (p = refchain._ob_next; p != &refchain; p = p->_ob_next) {
+		if (p == op)
+			break;
+	}
+	if (p == &refchain) /* Not found */
+		Py_FatalError("UNREF unknown object");
+#endif
+	op->_ob_next->_ob_prev = op->_ob_prev;
+	op->_ob_prev->_ob_next = op->_ob_next;
+	op->_ob_next = op->_ob_prev = NULL;
+#endif
+	_Py_INC_TPFREES(op);
+#ifdef Py_TRACE_REFS
+	PyThread_lock_release(refchain_lock);
+#endif
+}
+
+static void
+_Py_Dealloc(register PyThreadState *tstate, PyObject *op)
+{
+    destructor dealloc = Py_Type(op)->tp_dealloc;
+    assert(dealloc != NULL);
+
+    if (tstate->dealloc_depth > GC_MAX_DEALLOC_DEPTH) {
+        Py_DECREF_ASYNC(op);
+        return;
+    }
+
+    if (PyType_IS_GC(Py_Type(op)))
+        GC_UNTRACK(op);
+
+    if (PyType_SUPPORTS_WEAKREFS(Py_Type(op)) &&
+            _PyObject_TryClearWeakref(op)) {
+        /* He's not dead, he's pining for the fjords! */
+        PyObject_Revive(op);
+        Py_DECREF_ASYNC(op);
+    } else {
+        _Py_INC_TPFREES(op) _Py_COUNT_ALLOCS_COMMA	\
+        tstate->dealloc_depth++;
+        (*dealloc)(op);
+        tstate->dealloc_depth--;
+
+        if (tstate->dealloc_depth == 0) {
+            /* XXX do something if we've got some queued deallocs */
+        }
+    }
+}
+#ifdef Py_TRACE_REFS
+/* Print all live objects.  Because PyObject_Print is called, the
+ * interpreter must be in a healthy state.
+ */
 void
-PyObject_GC_UnTrack(void *op)
+_Py_PrintReferences(FILE *fp)
 {
-	/* Obscure:  the Py_TRASHCAN mechanism requires that we be able to
-	 * call PyObject_GC_UnTrack twice on an object.
-	 */
-	if (IS_TRACKED(op))
-		_PyObject_GC_UNTRACK(op);
+	PyObject *op;
+	PyThread_lock_acquire(refchain_lock);
+	fprintf(fp, "Remaining objects:\n");
+	for (op = refchain._ob_next; op != &refchain; op = op->_ob_next) {
+		fprintf(fp, "%p [%" PY_FORMAT_SIZE_T "d] ", op,
+			Py_RefcntSnoop(op));
+		/* XXX FIXME This is *wrong*.  It modifies the refchain
+		   again to do the print. */
+		if (PyObject_Print(op, fp, 0) != 0)
+			PyErr_Clear();
+		putc('\n', fp);
+	}
+	PyThread_lock_release(refchain_lock);
 }
 
-/* for binary compatibility with 2.2 */
+/* Print the addresses of all live objects.  Unlike _Py_PrintReferences, this
+ * doesn't make any calls to the Python C API, so is always safe to call.
+ */
 void
-_PyObject_GC_UnTrack(PyObject *op)
+_Py_PrintReferenceAddresses(FILE *fp)
 {
-    PyObject_GC_UnTrack(op);
+	PyObject *op;
+	PyThread_lock_acquire(refchain_lock);
+	fprintf(fp, "Remaining object addresses:\n");
+	for (op = refchain._ob_next; op != &refchain; op = op->_ob_next)
+		fprintf(fp, "%p [%" PY_FORMAT_SIZE_T "d] %s\n", op,
+			Py_RefcntSnoop(op), Py_Type(op)->tp_name);
+	PyThread_lock_release(refchain_lock);
 }
 
+/* This is dangerous.  It relies on PyList_Append to not create or
+ * delete any objects. */
 PyObject *
-_PyObject_GC_Malloc(size_t basicsize)
+_Py_GetObjects(PyObject *self, PyObject *args)
 {
-	PyObject *op;
-	PyGC_Head *g = (PyGC_Head *)PyObject_MALLOC(
-                sizeof(PyGC_Head) + basicsize);
-	if (g == NULL)
-		return PyErr_NoMemory();
-	g->gc.gc_refs = GC_UNTRACKED;
-	generations[0].count++; /* number of allocated GC objects */
- 	if (generations[0].count > generations[0].threshold &&
- 	    enabled &&
- 	    generations[0].threshold &&
- 	    !collecting &&
- 	    !PyErr_Occurred()) {
-		collecting = 1;
-		collect_generations();
-		collecting = 0;
+	int i, n;
+	PyObject *t = NULL;
+	PyObject *res, *op;
+
+	if (!PyArg_ParseTuple(args, "i|O", &n, &t))
+		return NULL;
+	res = PyList_New(0);
+	if (res == NULL)
+		return NULL;
+	PyThread_lock_acquire(refchain_lock);
+	op = refchain._ob_next;
+	for (i = 0; (n == 0 || i < n) && op != &refchain; i++) {
+		while (op == self || op == args || op == res || op == t ||
+		       (t != NULL && Py_Type(op) != (PyTypeObject *) t)) {
+			op = op->_ob_next;
+			if (op == &refchain) {
+				PyThread_lock_release(refchain_lock);
+				return res;
+			}
+		}
+		if (PyList_Append(res, op) < 0) {
+			PyThread_lock_release(refchain_lock);
+			Py_DECREF(res);
+			return NULL;
+		}
+		op = op->_ob_next;
 	}
-	op = FROM_GC(g);
-	return op;
+	PyThread_lock_release(refchain_lock);
+	return res;
 }
 
-PyObject *
-_PyObject_GC_New(PyTypeObject *tp)
+#endif
+static AO_t hit_count;
+static AO_t adj_count;
+static AO_T col_count;
+
+static void
+add_hit(void)
 {
-	PyObject *op = _PyObject_GC_Malloc(_PyObject_SIZE(tp));
-	if (op != NULL)
-		op = PyObject_INIT(op, tp);
-	return op;
+	AO_t count = AO_fetch_and_add1(&hit_count);
+	if ((count % 1000000) == 0)
+		printf("Hits: %lu\n", count);
 }
 
-PyVarObject *
-_PyObject_GC_NewVar(PyTypeObject *tp, Py_ssize_t nitems)
+static void
+add_adj(void)
 {
-	const size_t size = _PyObject_VAR_SIZE(tp, nitems);
-	PyVarObject *op = (PyVarObject *) _PyObject_GC_Malloc(size);
-	if (op != NULL)
-		op = PyObject_INIT_VAR(op, tp, nitems);
-	return op;
+	AO_t count = AO_fetch_and_add1(&adj_count);
+	if ((count % 1000) == 0)
+		printf("Adjacent: %lu\n", count);
 }
 
-PyVarObject *
+static void
+add_col(void)
+{
+	AO_t count = AO_fetch_and_add1(&col_count);
+	if ((count % 1000000) == 0)
+		printf("Collisions: %lu\n", count);
+}
+
+static AO_T obj_count;
+
+static void
+add_obj(void)
+{
+	AO_t count = AO_fetch_and_add1(&obj_count);
+	if ((count % 1000) == 0)
+		printf("Objects: %lu\n", count);
+}
+
+static void
+del_obj(void)
+{
+	AO_fetch_and_sub1(&obj_count);
+}
+
+
+static inline void
+_PyGC_AsyncRefcount_FlushSingle(PyAsyncRefEntry *entry)
+{
+	assert(entry->obj);
+	AO_fetch_and_add_full(&entry->obj->ob_refcnt, entry->diff);
+	entry->obj = NULL;
+	entry->diff = 0;
+}
+
+void
+_PyGC_AsyncRefcount_Flush(void)
+{
+	PyThreadState *tstate = PyThreadState_Get();
+	int i;
+
+	for (i = 0; i < Py_ASYNCREFCOUNT_TABLE; i++) {
+		PyAsyncRefEntry *entry = &tstate->async_refcounts[i];
+		if (entry->obj != NULL)
+			_PyGC_AsyncRefcount_FlushSingle(entry);
+		assert(entry->obj == NULL);
+		assert(entry->diff == 0);
+	}
+}
+
+/* Attempts to promote the object's refowner one step.  May fail, even
+ * allowing the object's refowner to change to something else entierly. */
+void
+_PyGC_RefMode_Promote(PyObject *op)
+{
+	PyThreadState *tstate = PyThreadState_Get();
+	AO_t oldmode;
+
+	//assert(monitorspace != NULL);
+	//printf("Promoting %p\n", op);
+
+	oldmode = AO_load_acquire(&op->ob_refowner);
+	if (oldmode == Py_REFOWNER_STATICINIT)
+		AO_compare_and_swap_full(&op->ob_refowner,
+			Py_REFOWNER_STATICINIT, (AO_t)tstate);
+	else if (oldmode == Py_REFOWNER_ASYNC) {
+		/* Do nothing */
+	} else {
+		/* XXX FIXME this should only be a partial suspend.  We
+		 * musn't allow the tracing GC to collect the
+		 * PyThreadState we're about to use.  Some sort of usage
+		 * count? */
+		PyThreadState *owner = (PyThreadState *)oldmode;
+
+		AO_fetch_and_add1_full(&owner->inspect_count);
+		PyState_Suspend();
+		PyThread_lock_acquire(owner->inspect_queue_lock);
+		AO_store_full(&owner->inspect_flag, 1);
+		PyThread_lock_acquire(owner->inspect_lock);
+		AO_store_full(&owner->inspect_flag, 0);
+		PyThread_lock_release(owner->inspect_queue_lock);
+
+		/* Another thread may already have altered the object's
+		 * refowner field, so we do another comparison. */
+		AO_compare_and_swap_full(&op->ob_refowner, oldmode,
+			Py_REFOWNER_ASYNC);
+
+		PyThread_lock_release(owner->inspect_lock);
+		PyState_Resume();
+		AO_fetch_and_sub1_full(&owner->inspect_count);
+	}
+}
+
+static PyAsyncRefEntry *
+_Py_GetAsyncRefEntry(PyThreadState *tstate, PyObject *op)
+{
+	/* XXX this probably needs to be heavily optimized */
+	PyAsyncRefEntry *entry;
+	AO_t index = (AO_t)op;
+
+	index ^= (index >> 3) ^ (index >> 7) ^ (index >> 17);
+	index &= Py_ASYNCREFCOUNT_TABLE - 1;
+
+	entry = &tstate->async_refcounts[index];
+
+	if (entry->obj == op || entry->obj == NULL) {
+		//add_hit();
+		return entry;
+	}
+	//add_col();
+	_PyGC_AsyncRefcount_FlushSingle(entry);
+	return entry;
+}
+
+
+void
+Py_IncRef(PyObject *o)
+{
+    Py_XINCREF(o);
+}
+
+void
+Py_DecRef(PyObject *o)
+{
+    Py_XDECREF(o);
+}
+
+/* These seem to help on my box, but on other boxes or different compiler
+ * versions may produce too strong of a preference.  YMMV. */
+#define _Py_EXPECT(expr) __builtin_expect((expr) != 0, 1)
+#define _Py_NOEXPECT(expr) __builtin_expect((expr) != 0, 0)
+
+#ifdef WITH_FREETHREAD
+void
+_Py_INCREF(PyObject *op, register PyThreadState *tstate)
+{
+	assert(tstate != NULL);
+	assert(!tstate->suspended);
+
+//	if (PyType_Check(op) && ((PyTypeObject *)op)->tp_flags & Py_TPFLAGS_HEAPTYPE)
+//		printf("Heap type incref %s %d\n",
+//			((PyTypeObject *)op)->tp_name, Py_RefcntSnoop(op));
+
+	_Py_INC_REFTOTAL();
+
+	/* Blah, this should be done at compile time, or maybe in configure. */
+	assert(sizeof(AO_t) == sizeof(Py_ssize_t));
+
+	while (1) {
+
+		void *owner = (void *)AO_load_acquire(&op->ob_refowner);
+		if (_Py_EXPECT(owner == Py_REFOWNER_ASYNC)) {
+			/* This should use a tstate hash table */
+			PyAsyncRefEntry *entry = _Py_GetAsyncRefEntry(tstate, op);
+			entry->diff++;
+			if (entry->diff == 0)
+				entry->obj = NULL;
+			else
+				entry->obj = op;
+			return;
+		} else if (_Py_EXPECT(owner == tstate)) {
+			op->ob_refcnt++;
+			return;
+		} else {
+			_PyGC_RefMode_Promote(op);
+			continue;
+		}
+	}
+}
+
+void
+_Py_DECREF(PyObject *op, register PyThreadState *tstate)
+{
+	assert(tstate != NULL);
+	assert(!tstate->suspended);
+
+//	if (PyType_Check(op) && ((PyTypeObject *)op)->tp_flags & Py_TPFLAGS_HEAPTYPE)
+//		printf("Heap type decref %s %d\n",
+//			((PyTypeObject *)op)->tp_name, Py_RefcntSnoop(op));
+
+	_Py_DEC_REFTOTAL();
+
+	/* Blah, this should be done at compile time, or maybe in configure. */
+	assert(sizeof(AO_t) == sizeof(Py_ssize_t));
+
+	while (1) {
+		void *owner = (void *)AO_load_acquire(&op->ob_refowner);
+		if (_Py_EXPECT(owner == Py_REFOWNER_ASYNC)) {
+			PyAsyncRefEntry *entry = _Py_GetAsyncRefEntry(tstate, op);
+			entry->diff--;
+			if (entry->diff == 0)
+				entry->obj = NULL;
+			else
+				entry->obj = op;
+			return;
+		} else if (_Py_EXPECT(owner == tstate)) {
+			if (op->ob_refcnt > 1)
+				op->ob_refcnt--;
+			else
+				_Py_Dealloc(tstate, op);
+#ifdef Py_REF_DEBUG
+			if (((Py_ssize_t)op->ob_refcnt) < 0)
+				_Py_NegativeRefcount(__FILE__, __LINE__, op, op->ob_refcnt);
+#endif
+			return;
+		} else {
+			_PyGC_RefMode_Promote(op);
+			continue;
+		}
+	}
+}
+
+/* Ensures the DECREF is always asynchronous, and thus will not
+ * recursively call _Py_Dealloc */
+void
+_Py_DECREF_ASYNC(PyObject *op, register PyThreadState *tstate)
+{
+	assert(tstate != NULL);
+	assert(!tstate->suspended);
+
+//	if (PyType_Check(op) && ((PyTypeObject *)op)->tp_flags & Py_TPFLAGS_HEAPTYPE)
+//		printf("Heap type decref %s %d\n",
+//			((PyTypeObject *)op)->tp_name, Py_RefcntSnoop(op));
+
+	_Py_DEC_REFTOTAL();
+
+	/* Blah, this should be done at compile time, or maybe in configure. */
+	assert(sizeof(AO_t) == sizeof(Py_ssize_t));
+
+	while (1) {
+		void *owner = (void *)AO_load_acquire(&op->ob_refowner);
+		if (_Py_EXPECT(owner == Py_REFOWNER_ASYNC)) {
+			PyAsyncRefEntry *entry = _Py_GetAsyncRefEntry(tstate, op);
+			entry->diff--;
+			if (entry->diff == 0)
+				entry->obj = NULL;
+			else
+				entry->obj = op;
+			return;
+		} else {
+			_PyGC_RefMode_Promote(op);
+			continue;
+		}
+	}
+}
+#endif /* WITH_FREETHREAD */
+
+Py_ssize_t
+_Py_RefcntSnoop(PyObject *op)
+{
+	PyThreadState *tstate = PyThreadState_Get();
+	void *owner = (void *)AO_load_acquire(&op->ob_refowner);
+
+	if (owner == tstate)
+		return op->ob_refcnt;
+	else
+		return 1000000;  /* Arbitrary large value */
+}
+
+
+#define GET_SIZE(size_class) ((size_class) <= 0 ? gc_cache_size_classes[-(size_class)] : (size_class))
+
+/* XXX Must match up with PYGC_CACHE_SIZECLASSES */
+static const Py_ssize_t gc_cache_size_classes[] = {
+	32,
+	48,
+	64,
+	96,
+	128,
+	192,
+	256,
+	384,
+	512,
+	768,
+	1024,
+	1536,
+	2048,
+};
+
+static Py_ssize_t
+find_size_class(size_t size)
+{
+	Py_ssize_t i;
+
+	assert(sizeof(gc_cache_size_classes) / sizeof(*gc_cache_size_classes) ==
+			PYGC_CACHE_SIZECLASSES);
+	if (size > gc_cache_size_classes[PYGC_CACHE_SIZECLASSES - 1])
+		return size; /* Too large to cache */
+
+	for (i = 0; ; i++) {
+		if (size <= gc_cache_size_classes[i])
+			return -i;
+	}
+}
+
+
+static void
+PyGC_lock_count(void)
+{
+#if 0
+	static unsigned long long count;
+	count++;
+	if ((count % 1000) == 0)
+		printf("Lock count: %llu\n", count);
+#endif
+}
+
+static PyObject *
+_PyObject_GC_Malloc(size_t basicsize)
+{
+	PyGC_Head *g = NULL;
+	//Py_ssize_t size_class = find_size_class(sizeof(PyGC_Head) + basicsize);
+	Py_ssize_t size_class = find_size_class(basicsize);
+
+	if (size_class <= 0) {
+		PyThreadState *tstate = PyThreadState_Get();
+		Py_ssize_t i;
+
+		for (i = 0; i < PYGC_CACHE_COUNT; i++) {
+			if (tstate->gc_object_cache[-size_class][i] != NULL) {
+				g = tstate->gc_object_cache[-size_class][i];
+				tstate->gc_object_cache[-size_class][i] = NULL;
+				g->ob_sizeclass = size_class;
+				assert(g->ob_refcnt_trace == GC_UNTRACKED);
+				//printf("Cache hit!\n");
+				break;
+			}
+		}
+	}
+
+	if (g == NULL) {
+		//printf("Cache miss.\n");
+		g = malloc(GET_SIZE(size_class));
+		if (g == NULL)
+			return PyErr_NoMemory();
+		g->ob_sizeclass = size_class;
+		g->ob_refcnt_trace = GC_UNTRACKED;
+
+		PyThread_lock_acquire(PyGC_lock);
+		PyGC_lock_count();
+
+		generations[0].count++; /* number of allocated GC objects */
+		if (generations[0].count > generations[0].threshold &&
+				enabled &&
+				generations[0].threshold &&
+				!collecting &&
+				!PyErr_Occurred()) {
+			collecting = 1;
+			collect_generations();
+			collecting = 0;
+		}
+
+		gc_list_append(g, _PyGC_generation0);
+
+		PyThread_lock_release(PyGC_lock);
+	}
+
+	return FROM_GC(g);
+}
+
+static PyVarObject *
 _PyObject_GC_Resize(PyVarObject *op, Py_ssize_t nitems)
 {
-	const size_t basicsize = _PyObject_VAR_SIZE(Py_Type(op), nitems);
-	PyGC_Head *g = AS_GC(op);
-	g = (PyGC_Head *)PyObject_REALLOC(g,  sizeof(PyGC_Head) + basicsize);
-	if (g == NULL)
-		return (PyVarObject *)PyErr_NoMemory();
+	/* XXX FIXME Some code assumes a sentinal is allocated.  Blah. */
+	const size_t basicsize = _PyObject_VAR_SIZE(Py_Type(op), nitems + 1);
+	PyObject *g = (PyObject *)op;
+	//Py_ssize_t size_class = find_size_class(sizeof(PyGC_Head) + basicsize);
+	Py_ssize_t size_class = find_size_class(basicsize);
+
+	if (IS_TRACKED((PyObject *)op))
+		Py_FatalError("_PyObject_GC_Resize called for tracked object");
+
+	if (size_class == g->ob_sizeclass) {
+		//printf("Resize avoided\n");
+		Py_Size(op) = nitems;
+		return op; /* That was easy */
+	}
+
+	//printf("Resizing\n");
+	PyThread_lock_acquire(PyGC_lock);
+
+	g = realloc(g, GET_SIZE(size_class));
+	if (g == NULL) {
+		PyThread_lock_release(PyGC_lock);
+		return (PyVarObject *) PyErr_NoMemory();
+	}
+
+	g->ob_sizeclass = size_class;
+	gc_list_move(g, _PyGC_generation0);
+
+	PyThread_lock_release(PyGC_lock);
+
 	op = (PyVarObject *) FROM_GC(g);
 	Py_Size(op) = nitems;
 	return op;
 }
 
-void
-PyObject_GC_Del(void *op)
+static void
+_PyObject_GC_Del(void *arg)
 {
-	PyGC_Head *g = AS_GC(op);
-	if (IS_TRACKED(op))
-		gc_list_remove(g);
+	PyGC_Head *g = AS_GC(arg);
+	Py_ssize_t size_class = g->ob_sizeclass;
+
+	assert(g == arg); /* WTF? */
+
+	if (size_class <= 0) {
+		PyThreadState *tstate = PyThreadState_Get();
+		Py_ssize_t i;
+
+		for (i = 0; i < PYGC_CACHE_COUNT; i++) {
+			if (tstate->gc_object_cache[-size_class][i] == NULL) {
+				//printf("Filling cache\n");
+				tstate->gc_object_cache[-size_class][i] = g;
+				return;
+			}
+		}
+	}
+	//printf("Cache full\n");
+
+	PyThread_lock_acquire(PyGC_lock);
+	PyGC_lock_count();
+
+	gc_list_remove(g);
 	if (generations[0].count > 0) {
 		generations[0].count--;
 	}
-	PyObject_FREE(g);
+
+	PyThread_lock_release(PyGC_lock);
+	free(g);
 }
 
-/* for binary compatibility with 2.2 */
-#undef _PyObject_GC_Del
 void
-_PyObject_GC_Del(PyObject *op)
+_PyGC_Object_Cache_Flush(void)
 {
-    PyObject_GC_Del(op);
+	PyThreadState *tstate = PyThreadState_Get();
+	Py_ssize_t i, j;
+
+	PyThread_lock_acquire(PyGC_lock);
+	PyGC_lock_count();
+
+	for (i = 0; i < PYGC_CACHE_SIZECLASSES; i++) {
+		for (j = 0; j < PYGC_CACHE_COUNT; j++) {
+			PyGC_Head *g = tstate->gc_object_cache[i][j];
+			tstate->gc_object_cache[i][j] = NULL;
+
+			if (g != NULL) {
+				gc_list_remove(g);
+				if (generations[0].count > 0) {
+					generations[0].count--;
+				}
+
+				assert(g->ob_refcnt == Py_REFCNT_DELETED);
+
+				free(g);
+			}
+		}
+	}
+
+	PyThread_lock_release(PyGC_lock);
 }
+
+PyObject *
+_PyObject_New(PyTypeObject *tp)
+{
+	const size_t size = _PyObject_SIZE(tp);
+	PyObject *op = _PyObject_GC_Malloc(size);
+	if (op == NULL)
+		return NULL;
+	assert(tp->tp_itemsize == 0);
+//	if (tp->tp_flags & Py_TPFLAGS_HEAPTYPE)
+//		printf("New obj type %s %d\n", tp->tp_name, Py_RefcntSnoop(tp));
+
+	Py_Type(op) = tp;
+	_Py_NewReference(op);
+	Py_INCREF(tp);
+	if (!PyType_HasFeature(tp, Py_TPFLAGS_SKIPWIPE)) {
+		memset(((char *)op) + sizeof(PyObject), '\0',
+			size - sizeof(PyObject));
+		if (PyType_IS_GC(tp))
+			GC_TRACK(op);
+	}
+
+	return op;
+}
+
+PyObject *
+_PyObject_NewVar(PyTypeObject *tp, Py_ssize_t nitems)
+{
+	/* XXX FIXME Some code assumes a sentinal is allocated.  Blah. */
+	const size_t size = _PyObject_VAR_SIZE(tp, nitems + 1);
+	PyObject *op = _PyObject_GC_Malloc(size);
+	if (op == NULL)
+		return NULL;
+	assert(tp->tp_itemsize != 0);
+//	if (tp->tp_flags & Py_TPFLAGS_HEAPTYPE)
+//		printf("Newvar obj type %s %d\n", tp->tp_name, Py_RefcntSnoop(tp));
+
+	Py_Size(op) = nitems;
+	Py_Type(op) = tp;
+	_Py_NewReference(op);
+	Py_INCREF(tp);
+	if (!PyType_HasFeature(tp, Py_TPFLAGS_SKIPWIPE)) {
+		memset(((char *)op) + sizeof(PyVarObject), '\0',
+			size - sizeof(PyVarObject));
+		if (PyType_IS_GC(tp))
+			GC_TRACK(op);
+	}
+
+	return op;
+}
+
+/* Should only be used during tp_dealloc, or in a failed *_New.
+ * Requires object have only one reference, which is consumed. */
+void
+_PyObject_Del(PyObject *op)
+{
+    /* XXX Rename this.  It should call a private _Free function */
+    PyTypeObject *tp = Py_Type(op);
+//    if (tp->tp_flags & Py_TPFLAGS_HEAPTYPE)
+//        printf("Del obj type %s %d\n", tp->tp_name, Py_RefcntSnoop(tp));
+    /* If called during *_New it's probably still tracked (unless
+     * SKIPWIPE is used) */
+    if (IS_TRACKED(op))
+        GC_UNTRACK(op);
+    assert(Py_RefcntSnoop(op) == 1);
+    op->ob_refowner = Py_REFOWNER_DELETED;
+    op->ob_refcnt = Py_REFCNT_DELETED;
+    _PyObject_GC_Del(op);
+    Py_DECREF(tp);
+}
+
+/* Revives an object who's tp_dealloc was called, but wasn't actually
+ * deleted.  Causes the GC to track it again.
+ *
+ * Objects with a weakref field cannot be revived. */
+void
+_PyObject_Revive(PyObject *op)
+{
+    if (PyType_SUPPORTS_WEAKREFS(Py_Type(op)))
+        Py_FatalError("Cannot revive objects that support weakrefs");
+
+    if (PyType_IS_GC(Py_Type(op)))
+        GC_TRACK(op);
+}
+
+/* Tracks op, "completing" the allocation process.  This is only useful
+ * for base classes that would rather wipe themselves lazily.
+ *
+ * _PyObject_Resize cannot be used until the object has been completed. */
+void
+_PyObject_Complete(PyObject *op)
+{
+	if (PyType_HasFeature(Py_Type(op), Py_TPFLAGS_SKIPWIPE) &&
+			PyType_IS_GC(Py_Type(op)))
+		GC_TRACK(op);
+}
+
+PyObject *
+_PyObject_Resize(PyObject *op, Py_ssize_t nitems)
+{
+	size_t oldsize = _PyObject_VAR_SIZE(Py_Type(op), Py_Size(op));
+	/* XXX FIXME Some code assumes a sentinal is allocated.  Blah. */
+	size_t newsize = _PyObject_VAR_SIZE(Py_Type(op), nitems + 1);
+
+	_Py_DEC_REFTOTAL();
+	if (PyType_IS_GC(Py_Type(op)))
+		GC_UNTRACK(op);
+
+	/* XXX FIXME we're leaving op with its reference forgotten and untracked */
+	_Py_ForgetReference(op);
+	/* XXX FIXME _PyObject_GC_Resize should use newsize, not nitems */
+	op = (PyObject *)_PyObject_GC_Resize((PyVarObject *)op, nitems);
+	if (op == NULL)
+		return NULL;
+	_Py_NewReference(op);
+
+	/* Zero out items added by growing */
+	if (newsize > oldsize)
+		memset(((char *)op) + oldsize, 0, newsize - oldsize);
+	if (PyType_IS_GC(Py_Type(op)))
+		GC_TRACK(op);
+	return op;
+}
Index: Modules/parsermodule.c
===================================================================
--- Modules/parsermodule.c	(revision 58355)
+++ Modules/parsermodule.c	(working copy)
@@ -255,7 +255,7 @@
 static PyObject*
 parser_newstobject(node *st, int type)
 {
-    PyST_Object* o = PyObject_New(PyST_Object, &PyST_Type);
+    PyST_Object* o = PyObject_NEW(PyST_Object, &PyST_Type);
 
     if (o != 0) {
         o->st_node = st;
@@ -277,7 +277,7 @@
 parser_free(PyST_Object *st)
 {
     PyNode_Free(st->st_node);
-    PyObject_Del(st);
+    PyObject_DEL(st);
 }
 
 
Index: Modules/_elementtree.c
===================================================================
--- Modules/_elementtree.c	(revision 58355)
+++ Modules/_elementtree.c	(working copy)
@@ -294,7 +294,7 @@
 {
     ElementObject* self;
 
-    self = PyObject_New(ElementObject, &Element_Type);
+    self = PyObject_NEW(ElementObject, &Element_Type);
     if (self == NULL)
         return NULL;
 
@@ -307,7 +307,7 @@
     if (attrib != Py_None) {
 
         if (element_new_extra(self, attrib) < 0) {
-            PyObject_Del(self);
+            PyObject_DEL(self);
             return NULL;
 	}
 
@@ -525,7 +525,7 @@
 
     RELEASE(sizeof(ElementObject), "destroy element");
 
-    PyObject_Del(self);
+    PyObject_DEL(self);
 }
 
 /* -------------------------------------------------------------------- */
@@ -1417,7 +1417,7 @@
 {
     TreeBuilderObject* self;
 
-    self = PyObject_New(TreeBuilderObject, &TreeBuilder_Type);
+    self = PyObject_NEW(TreeBuilderObject, &TreeBuilder_Type);
     if (self == NULL)
         return NULL;
 
@@ -1468,7 +1468,7 @@
 
     RELEASE(sizeof(TreeBuilderObject), "destroy treebuilder");
 
-    PyObject_Del(self);
+    PyObject_DEL(self);
 }
 
 /* -------------------------------------------------------------------- */
@@ -1574,7 +1574,7 @@
         Py_INCREF(data); self->data = data;
     } else {
         /* more than one item; use a list to collect items */
-        if (PyString_CheckExact(self->data) && Py_Refcnt(self->data) == 1 &&
+        if (PyString_CheckExact(self->data) && Py_RefcntMatches(self->data, 1) &&
             PyString_CheckExact(data) && PyString_GET_SIZE(data) == 1) {
             /* expat often generates single character data sections; handle
                the most common case by resizing the existing string... */
@@ -2157,20 +2157,20 @@
     }
 #endif
 
-    self = PyObject_New(XMLParserObject, &XMLParser_Type);
+    self = PyObject_NEW(XMLParserObject, &XMLParser_Type);
     if (self == NULL)
         return NULL;
 
     self->entity = PyDict_New();
     if (!self->entity) {
-        PyObject_Del(self);
+        PyObject_DEL(self);
         return NULL;
     }
      
     self->names = PyDict_New();
     if (!self->names) {
-        PyObject_Del(self->entity);
-        PyObject_Del(self);
+        PyObject_DEL(self->entity);
+        PyObject_DEL(self);
         return NULL;
     }
 
@@ -2180,9 +2180,9 @@
 
     self->parser = EXPAT(ParserCreate_MM)(encoding, &memory_handler, "}");
     if (!self->parser) {
-        PyObject_Del(self->names);
-        PyObject_Del(self->entity);
-        PyObject_Del(self);
+        PyObject_DEL(self->names);
+        PyObject_DEL(self->entity);
+        PyObject_DEL(self);
         PyErr_NoMemory();
         return NULL;
     }
@@ -2192,9 +2192,9 @@
         target = treebuilder_new();
         if (!target) {
             EXPAT(ParserFree)(self->parser);
-            PyObject_Del(self->names);
-            PyObject_Del(self->entity);
-            PyObject_Del(self);
+            PyObject_DEL(self->names);
+            PyObject_DEL(self->entity);
+            PyObject_DEL(self);
             return NULL;
         }
     } else
@@ -2263,7 +2263,7 @@
 
     RELEASE(sizeof(XMLParserObject), "destroy expatparser");
 
-    PyObject_Del(self);
+    PyObject_DEL(self);
 }
 
 /* -------------------------------------------------------------------- */
Index: Modules/posixmodule.c
===================================================================
--- Modules/posixmodule.c	(revision 58355)
+++ Modules/posixmodule.c	(working copy)
@@ -156,6 +156,16 @@
 #endif  /* ! __WATCOMC__ || __QNX__ */
 #endif /* ! __IBMC__ */
 
+#if !defined(HAVE_SPAWNV) && (defined(HAVE_FORK) && defined(HAVE_EXECV))
+#define EMULATE_SPAWNV
+#define HAVE_SPAWNV
+#endif
+
+/* These are broken so we disable them */
+#undef HAVE_FORK
+#undef HAVE_FORK1
+#undef HAVE_FORKPTY
+
 #ifndef _MSC_VER
 
 #if defined(__sgi)&&_COMPILER_VERSION>=700
@@ -3013,6 +3023,64 @@
 #endif /* HAVE_EXECV */
 
 
+#ifdef EMULATE_SPAWNV
+#define _P_WAIT 1
+#define _P_NOWAIT 2
+#define _OLD_P_OVERLAY 42
+#define _P_OVERLAY 43
+/* XXX is this really right?  Am I getting all the spawn semantics right?
+ * Should I even claim I am emulating spawn? */
+static Py_intptr_t
+_py_spawn(int mode, const char *path, char **argvlist, char **envlist)
+{
+	int pid;
+
+	/* We only support _P_WAIT and _P_NOWAIT */
+	assert(mode == _P_WAIT || mode == _P_NOWAIT);
+
+	pid = fork();
+	if (pid == -1)
+		return -1;
+	else if (pid == 0) {
+		/* XXX purge open file descriptors.  Doesn't that mean
+		 * we need an argument telling us which to keep though? */
+		if (envlist == NULL)
+			execv(path, argvlist);
+		else
+			execve(path, argvlist, envlist);
+
+		/* IF we get here then execv{,e} failed */
+		_exit(1);
+	} else {
+		if (mode == _P_WAIT) {
+			int status;
+			/* XXX FIXME loop if the child gets stopped? */
+			if (waitpid(pid, &status, 0) == -1)
+				return -1;
+			return status;
+		}
+		return pid;
+	}
+}
+
+static Py_intptr_t
+_py_spawnv(int mode, const char *path, char **argvlist)
+{
+	return _py_spawn(mode, path, argvlist, NULL);
+}
+
+static Py_intptr_t
+_py_spawnve(int mode, const char *path, char **argvlist, char **envlist)
+{
+	return _py_spawn(mode, path, argvlist, envlist);
+}
+#else
+#define _py_spawnv _spawnv
+#define _py_spawnve _spawnve
+#define _py_spawnvp _spawnvp
+#endif /* EMULATE_SPAWNV */
+
+
 #ifdef HAVE_SPAWNV
 PyDoc_STRVAR(posix_spawnv__doc__,
 "spawnv(mode, path, args)\n\n\
@@ -3083,7 +3151,7 @@
 		mode = _P_OVERLAY;
 
 	Py_BEGIN_ALLOW_THREADS
-	spawnval = _spawnv(mode, path, argvlist);
+	spawnval = _py_spawnv(mode, path, argvlist);
 	Py_END_ALLOW_THREADS
 #endif
 
@@ -3228,7 +3296,7 @@
 		mode = _P_OVERLAY;
 
 	Py_BEGIN_ALLOW_THREADS
-	spawnval = _spawnve(mode, path, argvlist, envlist);
+	spawnval = _py_spawnve(mode, path, argvlist, envlist);
 	Py_END_ALLOW_THREADS
 #endif
 
@@ -3320,7 +3388,7 @@
 #if defined(PYCC_GCC)
 	spawnval = spawnvp(mode, path, argvlist);
 #else
-	spawnval = _spawnvp(mode, path, argvlist);
+	spawnval = _py_spawnvp(mode, path, argvlist);
 #endif
 	Py_END_ALLOW_THREADS
 
@@ -3491,10 +3559,17 @@
 static PyObject *
 posix_fork1(PyObject *self, PyObject *noargs)
 {
-	int pid = fork1();
+	int pid;
+
+	PyState_PrepareFork();
+	pid = fork1();
+	if (pid == 0) {
+		PyOS_AfterFork();
+		return PyInt_FromLong((long)pid);
+	}
+	PyState_CleanupForkParent();
 	if (pid == -1)
 		return posix_error();
-	PyOS_AfterFork();
 	return PyInt_FromLong((long)pid);
 }
 #endif
@@ -3509,11 +3584,17 @@
 static PyObject *
 posix_fork(PyObject *self, PyObject *noargs)
 {
-	int pid = fork();
+	int pid;
+
+	PyState_PrepareFork();
+	pid = fork();
+	if (pid == 0) {
+		PyOS_AfterFork();
+		return PyInt_FromLong((long)pid);
+	}
+	PyState_CleanupForkParent();
 	if (pid == -1)
 		return posix_error();
-	if (pid == 0)
-		PyOS_AfterFork();
 	return PyInt_FromLong((long)pid);
 }
 #endif
@@ -7226,11 +7307,13 @@
 #else
         if (ins(d, "P_WAIT", (long)_P_WAIT)) return -1;
         if (ins(d, "P_NOWAIT", (long)_P_NOWAIT)) return -1;
+#ifndef EMULATE_SPAWNV
         if (ins(d, "P_OVERLAY", (long)_OLD_P_OVERLAY)) return -1;
         if (ins(d, "P_NOWAITO", (long)_P_NOWAITO)) return -1;
         if (ins(d, "P_DETACH", (long)_P_DETACH)) return -1;
 #endif
 #endif
+#endif
 
 #if defined(PYOS_OS2)
         if (insertvalues(d)) return -1;
Index: Modules/xxsubtype.c
===================================================================
--- Modules/xxsubtype.c	(revision 58355)
+++ Modules/xxsubtype.c	(working copy)
@@ -137,7 +137,6 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	(initproc)spamlist_init,		/* tp_init */
-	0,					/* tp_alloc */
 	0,					/* tp_new */
 };
 
@@ -228,7 +227,6 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	(initproc)spamdict_init,		/* tp_init */
-	0,					/* tp_alloc */
 	0,					/* tp_new */
 };
 
Index: Modules/_functoolsmodule.c
===================================================================
--- Modules/_functoolsmodule.c	(revision 58355)
+++ Modules/_functoolsmodule.c	(working copy)
@@ -42,7 +42,7 @@
 	}
 
 	/* create partialobject structure */
-	pto = (partialobject *)type->tp_alloc(type, 0);
+	pto = PyObject_NEW(partialobject, type);
 	if (pto == NULL)
 		return NULL;
 
@@ -74,14 +74,11 @@
 static void
 partial_dealloc(partialobject *pto)
 {
-	PyObject_GC_UnTrack(pto);
-	if (pto->weakreflist != NULL)
-		PyObject_ClearWeakRefs((PyObject *) pto);
 	Py_XDECREF(pto->fn);
 	Py_XDECREF(pto->args);
 	Py_XDECREF(pto->kw);
 	Py_XDECREF(pto->dict);
-	Py_Type(pto)->tp_free(pto);
+	PyObject_DEL(pto);
 }
 
 static PyObject *
@@ -235,9 +232,7 @@
 	0,				/* tp_descr_set */
 	offsetof(partialobject, dict),	/* tp_dictoffset */
 	0,				/* tp_init */
-	0,				/* tp_alloc */
 	partial_new,			/* tp_new */
-	PyObject_GC_Del,		/* tp_free */
 };
 
 
@@ -267,7 +262,7 @@
 	for (;;) {
 		PyObject *op2;
 
-		if (args->ob_refcnt > 1) {
+		if (Py_RefcntSnoop(args) > 1) {
 			Py_DECREF(args);
 			if ((args = PyTuple_New(2)) == NULL)
 				goto Fail;
Index: Modules/_testcapimodule.c
===================================================================
--- Modules/_testcapimodule.c	(revision 58355)
+++ Modules/_testcapimodule.c	(working copy)
@@ -652,7 +652,8 @@
 	return NULL;
 }
 
-#ifdef WITH_THREAD
+//#ifdef WITH_THREAD
+#if 0
 
 /* test_thread_state spawns a thread of its own, and that thread releases
  * `thread_done` when it's finished.  The driver code has to know when the
@@ -661,16 +662,18 @@
  * synchronization caused rare segfaults, so rare that they were seen only
  * on a Mac buildbot (although they were possible on any box).
  */
-static PyThread_type_lock thread_done = NULL;
+static PyThread_type_sem thread_done = NULL;
 
 static void
 _make_call(void *callable)
 {
 	PyObject *rc;
-	PyGILState_STATE s = PyGILState_Ensure();
+	PyState_EnterTag entertag = PyState_Enter();
+	if (!entertag)
+		Py_FatalError("PyState_Enter failed");
 	rc = PyObject_CallFunction((PyObject *)callable, "");
 	Py_XDECREF(rc);
-	PyGILState_Release(s);
+	PyState_Exit(entertag);
 }
 
 /* Same thing, but releases `thread_done` when it returns.  This variant
@@ -680,7 +683,7 @@
 _make_call_from_thread(void *callable)
 {
 	_make_call(callable);
-	PyThread_release_lock(thread_done);
+	PyThread_sem_post(thread_done);
 }
 
 static PyObject *
@@ -688,15 +691,14 @@
 {
 	PyObject *fn;
 
+	if (!PyArg_RequireShareable("test_thread_state", args, NULL))
+		return NULL;
 	if (!PyArg_ParseTuple(args, "O:test_thread_state", &fn))
 		return NULL;
 
-	/* Ensure Python is set up for threading */
-	PyEval_InitThreads();
-	thread_done = PyThread_allocate_lock();
+	thread_done = PyThread_sem_allocate(0);
 	if (thread_done == NULL)
 		return PyErr_NoMemory();
-	PyThread_acquire_lock(thread_done, 1);
 
 	/* Start a new thread with our callback. */
 	PyThread_start_new_thread(_make_call_from_thread, fn);
@@ -705,7 +707,7 @@
 	/* Do it all again, but this time with the thread-lock released */
 	Py_BEGIN_ALLOW_THREADS
 	_make_call(fn);
-	PyThread_acquire_lock(thread_done, 1);  /* wait for thread to finish */
+	PyThread_sem_wait(thread_done);  /* wait for thread to finish */
 	Py_END_ALLOW_THREADS
 
 	/* And once more with and without a thread
@@ -715,13 +717,10 @@
 	Py_BEGIN_ALLOW_THREADS
 	PyThread_start_new_thread(_make_call_from_thread, fn);
 	_make_call(fn);
-	PyThread_acquire_lock(thread_done, 1);  /* wait for thread to finish */
+	PyThread_sem_wait(thread_done);  /* wait for thread to finish */
 	Py_END_ALLOW_THREADS
 
-	/* Release lock we acquired above.  This is required on HP-UX. */
-	PyThread_release_lock(thread_done);
-
-	PyThread_free_lock(thread_done);
+	PyThread_sem_free(thread_done);
 	Py_RETURN_NONE;
 }
 #endif
@@ -916,9 +915,9 @@
 #endif
 	{"test_u_code",		(PyCFunction)test_u_code,	 METH_NOARGS},
 	{"test_Z_code",		(PyCFunction)test_Z_code,	 METH_NOARGS},
-#ifdef WITH_THREAD
-	{"_test_thread_state",  test_thread_state, 		 METH_VARARGS},
-#endif
+//#ifdef WITH_THREAD
+//	{"_test_thread_state",  test_thread_state, 		 METH_VARARGS},
+#//endif
 #ifdef HAVE_GETTIMEOFDAY
 	{"profile_int",		profile_int,			METH_NOARGS},
 #endif
@@ -980,7 +979,7 @@
 		"LK"
 		#endif
 		;
-	test_structmembers *ob=PyObject_New(test_structmembers, type);
+	test_structmembers *ob=PyObject_NEW(test_structmembers, type);
 	if (ob==NULL)
 		return NULL;
 	memset(&ob->structmembers, 0, sizeof(all_structmembers));
@@ -1001,7 +1000,7 @@
 }
 
 static void test_structmembers_free(PyObject *ob){
-	PyObject_FREE(ob);
+	PyObject_Del(ob);
 }
 
 static PyTypeObject test_structmembersType = {
@@ -1041,7 +1040,6 @@
 	0,
 	0,
 	0,
-	0,
 	test_structmembers_new,			/* tp_new */
 };
 
Index: Modules/_collectionsmodule.c
===================================================================
--- Modules/_collectionsmodule.c	(revision 58355)
+++ Modules/_collectionsmodule.c	(working copy)
@@ -99,7 +99,7 @@
 		return NULL;
 
 	/* create dequeobject structure */
-	deque = (dequeobject *)type->tp_alloc(type, 0);
+	deque = PyObject_NEW(dequeobject, type);
 	if (deque == NULL)
 		return NULL;
 
@@ -534,9 +534,6 @@
 static void
 deque_dealloc(dequeobject *deque)
 {
-	PyObject_GC_UnTrack(deque);
-	if (deque->weakreflist != NULL)
-		PyObject_ClearWeakRefs((PyObject *) deque);
 	if (deque->leftblock != NULL) {
 		deque_clear(deque);
 		assert(deque->leftblock != NULL);
@@ -544,7 +541,7 @@
 	}
 	deque->leftblock = NULL;
 	deque->rightblock = NULL;
-	Py_Type(deque)->tp_free(deque);
+	PyObject_DEL(deque);
 }
 
 static int
@@ -816,9 +813,7 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	(initproc)deque_init,		/* tp_init */
-	PyType_GenericAlloc,		/* tp_alloc */
 	deque_new,			/* tp_new */
-	PyObject_GC_Del,		/* tp_free */
 };
 
 /*********************** Deque Iterator **************************/
@@ -839,7 +834,7 @@
 {
 	dequeiterobject *it;
 
-	it = PyObject_New(dequeiterobject, &dequeiter_type);
+	it = PyObject_NEW(dequeiterobject, &dequeiter_type);
 	if (it == NULL)
 		return NULL;
 	it->b = deque->leftblock;
@@ -855,7 +850,7 @@
 dequeiter_dealloc(dequeiterobject *dio)
 {
 	Py_XDECREF(dio->deque);
-	Py_Type(dio)->tp_free(dio);
+	PyObject_DEL(dio);
 }
 
 static PyObject *
@@ -941,7 +936,7 @@
 {
 	dequeiterobject *it;
 
-	it = PyObject_New(dequeiterobject, &dequereviter_type);
+	it = PyObject_NEW(dequeiterobject, &dequereviter_type);
 	if (it == NULL)
 		return NULL;
 	it->b = deque->rightblock;
@@ -1253,9 +1248,7 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	defdict_init,			/* tp_init */
-	PyType_GenericAlloc,		/* tp_alloc */
 	0,				/* tp_new */
-	PyObject_GC_Del,		/* tp_free */
 };
 
 /* module level code ********************************************************/
Index: Modules/main.c
===================================================================
--- Modules/main.c	(revision 58355)
+++ Modules/main.c	(working copy)
@@ -181,7 +181,7 @@
 {
 #ifdef WITH_THREAD
 	PyObject *result;
-	PyThreadState *tstate = PyThreadState_GET();
+	PyThreadState *tstate = PyThreadState_Get();
 	PyObject *threading = PyMapping_GetItemString(tstate->interp->modules,
 						      "threading");
 	if (threading == NULL) {
Index: Modules/ossaudiodev.c
===================================================================
--- Modules/ossaudiodev.c	(revision 58355)
+++ Modules/ossaudiodev.c	(working copy)
@@ -133,7 +133,7 @@
         return NULL;
     }
     /* Create and initialize the object */
-    if ((self = PyObject_New(oss_audio_t, &OSSAudioType)) == NULL) {
+    if ((self = PyObject_NEW(oss_audio_t, &OSSAudioType)) == NULL) {
         close(fd);
         return NULL;
     }
@@ -151,7 +151,7 @@
     /* if already closed, don't reclose it */
     if (self->fd != -1)
         close(self->fd);
-    PyObject_Del(self);
+    PyObject_DEL(self);
 }
 
 
@@ -181,7 +181,7 @@
         return NULL;
     }
 
-    if ((self = PyObject_New(oss_mixer_t, &OSSMixerType)) == NULL) {
+    if ((self = PyObject_NEW(oss_mixer_t, &OSSMixerType)) == NULL) {
         close(fd);
         return NULL;
     }
@@ -197,7 +197,7 @@
     /* if already closed, don't reclose it */
     if (self->fd != -1)
         close(self->fd);
-    PyObject_Del(self);
+    PyObject_DEL(self);
 }
 
 
Index: Modules/_hashopenssl.c
===================================================================
--- Modules/_hashopenssl.c	(revision 58355)
+++ Modules/_hashopenssl.c	(working copy)
@@ -55,7 +55,7 @@
 static EVPobject *
 newEVPobject(PyObject *name)
 {
-    EVPobject *retval = (EVPobject *)PyObject_New(EVPobject, &EVPtype);
+    EVPobject *retval = PyObject_NEW(EVPobject, &EVPtype);
 
     /* save the name for .name to return */
     if (retval != NULL) {
Index: Modules/itertoolsmodule.c
===================================================================
--- Modules/itertoolsmodule.c	(revision 58355)
+++ Modules/itertoolsmodule.c	(working copy)
@@ -34,7 +34,7 @@
 					 &it, &keyfunc))
 		return NULL;
 
-	gbo = (groupbyobject *)type->tp_alloc(type, 0);
+	gbo = PyObject_NEW(groupbyobject, type);
 	if (gbo == NULL)
 		return NULL;
 	gbo->tgtkey = NULL;
@@ -53,13 +53,12 @@
 static void
 groupby_dealloc(groupbyobject *gbo)
 {
-	PyObject_GC_UnTrack(gbo);
 	Py_XDECREF(gbo->it);
 	Py_XDECREF(gbo->keyfunc);
 	Py_XDECREF(gbo->tgtkey);
 	Py_XDECREF(gbo->currkey);
 	Py_XDECREF(gbo->currvalue);
-	Py_Type(gbo)->tp_free(gbo);
+	PyObject_DEL(gbo);
 }
 
 static int
@@ -177,9 +176,7 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	0,				/* tp_init */
-	0,				/* tp_alloc */
 	groupby_new,			/* tp_new */
-	PyObject_GC_Del,		/* tp_free */
 };
 
 
@@ -198,7 +195,7 @@
 {
 	_grouperobject *igo;
 
-	igo = PyObject_New(_grouperobject, &_grouper_type);
+	igo = PyObject_NEW(_grouperobject, &_grouper_type);
 	if (igo == NULL)
 		return NULL;
 	igo->parent = (PyObject *)parent;
@@ -214,7 +211,7 @@
 {
 	Py_DECREF(igo->parent);
 	Py_DECREF(igo->tgtkey);
-	PyObject_Del(igo);
+	PyObject_DEL(igo);
 }
 
 static PyObject *
@@ -297,9 +294,7 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	0,				/* tp_init */
-	0,				/* tp_alloc */
 	0,				/* tp_new */
-	PyObject_Del,			/* tp_free */
 };
 
  
@@ -338,7 +333,7 @@
 {
 	teedataobject *tdo;
 
-	tdo = PyObject_GC_New(teedataobject, &teedataobject_type);
+	tdo = PyObject_NEW(teedataobject, &teedataobject_type);
 	if (tdo == NULL)
 		return NULL;
 
@@ -346,7 +341,6 @@
 	tdo->nextlink = NULL;
 	Py_INCREF(it);
 	tdo->it = it;
-	PyObject_GC_Track(tdo);
 	return (PyObject *)tdo;
 }
 
@@ -405,9 +399,8 @@
 static void
 teedataobject_dealloc(teedataobject *tdo)
 {
-	PyObject_GC_UnTrack(tdo);
 	teedataobject_clear(tdo);
-	PyObject_GC_Del(tdo);
+	PyObject_DEL(tdo);
 }
 
 PyDoc_STRVAR(teedataobject_doc, "Data container common to multiple tee objects.");
@@ -450,9 +443,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	0,					/* tp_new */
-	PyObject_GC_Del,			/* tp_free */
 };
 
 
@@ -488,14 +479,13 @@
 {
 	teeobject *newto;
 
-	newto = PyObject_GC_New(teeobject, &tee_type);
+	newto = PyObject_NEW(teeobject, &tee_type);
 	if (newto == NULL)
 		return NULL;
 	Py_INCREF(to->dataobj);
 	newto->dataobj = to->dataobj;
 	newto->index = to->index;
 	newto->weakreflist = NULL;
-	PyObject_GC_Track(newto);
 	return (PyObject *)newto;
 }
 
@@ -515,19 +505,18 @@
 		goto done;
 	}
 
-	to = PyObject_GC_New(teeobject, &tee_type);
+	to = PyObject_NEW(teeobject, &tee_type);
 	if (to == NULL) 
 		goto done;
 	to->dataobj = (teedataobject *)teedataobject_new(it);
 	if (!to->dataobj) {
-		PyObject_GC_Del(to);
+		PyObject_DEL(to);
 		to = NULL;
 		goto done;
 	}
 
 	to->index = 0;
 	to->weakreflist = NULL;
-	PyObject_GC_Track(to);
 done:
 	Py_XDECREF(it);
 	return (PyObject *)to;
@@ -546,8 +535,6 @@
 static int
 tee_clear(teeobject *to)
 {
-	if (to->weakreflist != NULL)
-		PyObject_ClearWeakRefs((PyObject *) to);
 	Py_CLEAR(to->dataobj);
 	return 0;
 }
@@ -555,9 +542,8 @@
 static void
 tee_dealloc(teeobject *to)
 {
-	PyObject_GC_UnTrack(to);
 	tee_clear(to);
-	PyObject_GC_Del(to);
+	PyObject_DEL(to);
 }
 
 PyDoc_STRVAR(teeobject_doc,
@@ -606,9 +592,7 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	0,				/* tp_init */
-	0,				/* tp_alloc */
 	tee_new,			/* tp_new */
-	PyObject_GC_Del,		/* tp_free */
 };
 
 static PyObject *
@@ -695,7 +679,7 @@
 	}
 
 	/* create cycleobject structure */
-	lz = (cycleobject *)type->tp_alloc(type, 0);
+	lz = PyObject_NEW(cycleobject, type);
 	if (lz == NULL) {
 		Py_DECREF(it);
 		Py_DECREF(saved);
@@ -711,10 +695,9 @@
 static void
 cycle_dealloc(cycleobject *lz)
 {
-	PyObject_GC_UnTrack(lz);
 	Py_XDECREF(lz->saved);
 	Py_XDECREF(lz->it);
-	Py_Type(lz)->tp_free(lz);
+	PyObject_DEL(lz);
 }
 
 static int
@@ -802,9 +785,7 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	0,				/* tp_init */
-	0,				/* tp_alloc */
 	cycle_new,			/* tp_new */
-	PyObject_GC_Del,		/* tp_free */
 };
 
 
@@ -838,7 +819,7 @@
 		return NULL;
 
 	/* create dropwhileobject structure */
-	lz = (dropwhileobject *)type->tp_alloc(type, 0);
+	lz = PyObject_NEW(dropwhileobject, type);
 	if (lz == NULL) {
 		Py_DECREF(it);
 		return NULL;
@@ -854,10 +835,9 @@
 static void
 dropwhile_dealloc(dropwhileobject *lz)
 {
-	PyObject_GC_UnTrack(lz);
 	Py_XDECREF(lz->func);
 	Py_XDECREF(lz->it);
-	Py_Type(lz)->tp_free(lz);
+	PyObject_DEL(lz);
 }
 
 static int
@@ -945,9 +925,7 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	0,				/* tp_init */
-	0,				/* tp_alloc */
 	dropwhile_new,			/* tp_new */
-	PyObject_GC_Del,		/* tp_free */
 };
 
 
@@ -981,7 +959,7 @@
 		return NULL;
 
 	/* create takewhileobject structure */
-	lz = (takewhileobject *)type->tp_alloc(type, 0);
+	lz = PyObject_NEW(takewhileobject, type);
 	if (lz == NULL) {
 		Py_DECREF(it);
 		return NULL;
@@ -997,10 +975,9 @@
 static void
 takewhile_dealloc(takewhileobject *lz)
 {
-	PyObject_GC_UnTrack(lz);
 	Py_XDECREF(lz->func);
 	Py_XDECREF(lz->it);
-	Py_Type(lz)->tp_free(lz);
+	PyObject_DEL(lz);
 }
 
 static int
@@ -1085,9 +1062,7 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	0,				/* tp_init */
-	0,				/* tp_alloc */
 	takewhile_new,			/* tp_new */
-	PyObject_GC_Del,		/* tp_free */
 };
 
 
@@ -1171,7 +1146,7 @@
 		return NULL;
 
 	/* create isliceobject structure */
-	lz = (isliceobject *)type->tp_alloc(type, 0);
+	lz = PyObject_NEW(isliceobject, type);
 	if (lz == NULL) {
 		Py_DECREF(it);
 		return NULL;
@@ -1188,9 +1163,8 @@
 static void
 islice_dealloc(isliceobject *lz)
 {
-	PyObject_GC_UnTrack(lz);
 	Py_XDECREF(lz->it);
-	Py_Type(lz)->tp_free(lz);
+	PyObject_DEL(lz);
 }
 
 static int
@@ -1280,9 +1254,7 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	0,				/* tp_init */
-	0,				/* tp_alloc */
 	islice_new,			/* tp_new */
-	PyObject_GC_Del,		/* tp_free */
 };
 
 
@@ -1315,7 +1287,7 @@
 		return NULL;
 
 	/* create starmapobject structure */
-	lz = (starmapobject *)type->tp_alloc(type, 0);
+	lz = PyObject_NEW(starmapobject, type);
 	if (lz == NULL) {
 		Py_DECREF(it);
 		return NULL;
@@ -1330,10 +1302,9 @@
 static void
 starmap_dealloc(starmapobject *lz)
 {
-	PyObject_GC_UnTrack(lz);
 	Py_XDECREF(lz->func);
 	Py_XDECREF(lz->it);
-	Py_Type(lz)->tp_free(lz);
+	PyObject_DEL(lz);
 }
 
 static int
@@ -1411,9 +1382,7 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	0,				/* tp_init */
-	0,				/* tp_alloc */
 	starmap_new,			/* tp_new */
-	PyObject_GC_Del,		/* tp_free */
 };
 
 
@@ -1459,7 +1428,7 @@
 	}
 
 	/* create imapobject structure */
-	lz = (imapobject *)type->tp_alloc(type, 0);
+	lz = PyObject_NEW(imapobject, type);
 	if (lz == NULL) {
 		Py_DECREF(iters);
 		return NULL;
@@ -1475,10 +1444,9 @@
 static void
 imap_dealloc(imapobject *lz)
 {
-	PyObject_GC_UnTrack(lz);
 	Py_XDECREF(lz->iters);
 	Py_XDECREF(lz->func);
-	Py_Type(lz)->tp_free(lz);
+	PyObject_DEL(lz);
 }
 
 static int
@@ -1590,9 +1558,7 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	0,				/* tp_init */
-	0,				/* tp_alloc */
 	imap_new,			/* tp_new */
-	PyObject_GC_Del,		/* tp_free */
 };
 
 
@@ -1638,7 +1604,7 @@
 	}
 
 	/* create chainobject structure */
-	lz = (chainobject *)type->tp_alloc(type, 0);
+	lz = PyObject_NEW(chainobject, type);
 	if (lz == NULL) {
 		Py_DECREF(ittuple);
 		return NULL;
@@ -1654,9 +1620,8 @@
 static void
 chain_dealloc(chainobject *lz)
 {
-	PyObject_GC_UnTrack(lz);
 	Py_XDECREF(lz->ittuple);
-	Py_Type(lz)->tp_free(lz);
+	PyObject_DEL(lz);
 }
 
 static int
@@ -1734,9 +1699,7 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	0,				/* tp_init */
-	0,				/* tp_alloc */
 	chain_new,			/* tp_new */
-	PyObject_GC_Del,		/* tp_free */
 };
 
 
@@ -1769,7 +1732,7 @@
 		return NULL;
 
 	/* create ifilterobject structure */
-	lz = (ifilterobject *)type->tp_alloc(type, 0);
+	lz = PyObject_NEW(ifilterobject, type);
 	if (lz == NULL) {
 		Py_DECREF(it);
 		return NULL;
@@ -1784,10 +1747,9 @@
 static void
 ifilter_dealloc(ifilterobject *lz)
 {
-	PyObject_GC_UnTrack(lz);
 	Py_XDECREF(lz->func);
 	Py_XDECREF(lz->it);
-	Py_Type(lz)->tp_free(lz);
+	PyObject_DEL(lz);
 }
 
 static int
@@ -1877,9 +1839,7 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	0,				/* tp_init */
-	0,				/* tp_alloc */
 	ifilter_new,			/* tp_new */
-	PyObject_GC_Del,		/* tp_free */
 };
 
 
@@ -1913,7 +1873,7 @@
 		return NULL;
 
 	/* create ifilterfalseobject structure */
-	lz = (ifilterfalseobject *)type->tp_alloc(type, 0);
+	lz = PyObject_NEW(ifilterfalseobject, type);
 	if (lz == NULL) {
 		Py_DECREF(it);
 		return NULL;
@@ -1928,10 +1888,9 @@
 static void
 ifilterfalse_dealloc(ifilterfalseobject *lz)
 {
-	PyObject_GC_UnTrack(lz);
 	Py_XDECREF(lz->func);
 	Py_XDECREF(lz->it);
-	Py_Type(lz)->tp_free(lz);
+	PyObject_DEL(lz);
 }
 
 static int
@@ -2021,9 +1980,7 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	0,				/* tp_init */
-	0,				/* tp_alloc */
 	ifilterfalse_new,		/* tp_new */
-	PyObject_GC_Del,		/* tp_free */
 };
 
 
@@ -2049,7 +2006,7 @@
 		return NULL;
 
 	/* create countobject structure */
-	lz = (countobject *)PyObject_New(countobject, &count_type);
+	lz = PyObject_NEW(countobject, &count_type);
 	if (lz == NULL)
 		return NULL;
 	lz->cnt = cnt;
@@ -2086,7 +2043,7 @@
 	sizeof(countobject),		/* tp_basicsize */
 	0,				/* tp_itemsize */
 	/* methods */
-	(destructor)PyObject_Del,	/* tp_dealloc */
+	0,				/* tp_dealloc */
 	0,				/* tp_print */
 	0,				/* tp_getattr */
 	0,				/* tp_setattr */
@@ -2118,7 +2075,6 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	0,				/* tp_init */
-	0,				/* tp_alloc */
 	count_new,			/* tp_new */
 };
 
@@ -2181,7 +2137,7 @@
 	}
 
 	/* create izipobject structure */
-	lz = (izipobject *)type->tp_alloc(type, 0);
+	lz = PyObject_NEW(izipobject, type);
 	if (lz == NULL) {
 		Py_DECREF(ittuple);
 		Py_DECREF(result);
@@ -2197,10 +2153,9 @@
 static void
 izip_dealloc(izipobject *lz)
 {
-	PyObject_GC_UnTrack(lz);
 	Py_XDECREF(lz->ittuple);
 	Py_XDECREF(lz->result);
-	Py_Type(lz)->tp_free(lz);
+	PyObject_DEL(lz);
 }
 
 static int
@@ -2223,7 +2178,7 @@
 
 	if (tuplesize == 0)
 		return NULL;
-	if (Py_Refcnt(result) == 1) {
+	if (Py_RefcntMatches(result, 1)) {
 		Py_INCREF(result);
 		for (i=0 ; i < tuplesize ; i++) {
 			it = PyTuple_GET_ITEM(lz->ittuple, i);
@@ -2304,9 +2259,7 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	0,				/* tp_init */
-	0,				/* tp_alloc */
 	izip_new,			/* tp_new */
-	PyObject_GC_Del,		/* tp_free */
 };
 
 
@@ -2336,7 +2289,7 @@
 	if (PyTuple_Size(args) == 2 && cnt < 0)
 		cnt = 0;
 
-	ro = (repeatobject *)type->tp_alloc(type, 0);
+	ro = PyObject_NEW(repeatobject, type);
 	if (ro == NULL)
 		return NULL;
 	Py_INCREF(element);
@@ -2348,9 +2301,8 @@
 static void
 repeat_dealloc(repeatobject *ro)
 {
-	PyObject_GC_UnTrack(ro);
 	Py_XDECREF(ro->element);
-	Py_Type(ro)->tp_free(ro);
+	PyObject_DEL(ro);
 }
 
 static int
@@ -2441,9 +2393,7 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	0,				/* tp_init */
-	0,				/* tp_alloc */
 	repeat_new,			/* tp_new */
-	PyObject_GC_Del,		/* tp_free */
 };
 
 /* iziplongest object ************************************************************/
@@ -2513,7 +2463,7 @@
 	}
 
 	/* create iziplongestobject structure */
-	lz = (iziplongestobject *)type->tp_alloc(type, 0);
+	lz = PyObject_NEW(iziplongestobject, type);
 	if (lz == NULL) {
 		Py_DECREF(ittuple);
 		Py_DECREF(result);
@@ -2531,11 +2481,10 @@
 static void
 izip_longest_dealloc(iziplongestobject *lz)
 {
-	PyObject_GC_UnTrack(lz);
 	Py_XDECREF(lz->ittuple);
 	Py_XDECREF(lz->result);
 	Py_XDECREF(lz->fillvalue);
-	Py_Type(lz)->tp_free(lz);
+	PyObject_DEL(lz);
 }
 
 static int
@@ -2561,7 +2510,7 @@
 		return NULL;
         if (lz->numactive == 0)
                 return NULL;
-	if (Py_Refcnt(result) == 1) {
+	if (Py_RefcntMatches(result, 1)) {
 		Py_INCREF(result);
 		for (i=0 ; i < tuplesize ; i++) {
 			it = PyTuple_GET_ITEM(lz->ittuple, i);
@@ -2669,9 +2618,7 @@
 	0,				/* tp_descr_set */
 	0,				/* tp_dictoffset */
 	0,				/* tp_init */
-	0,				/* tp_alloc */
 	izip_longest_new,			/* tp_new */
-	PyObject_GC_Del,		/* tp_free */
 };
 
 /* module level code ********************************************************/
Index: Modules/_csv.c
===================================================================
--- Modules/_csv.c	(revision 58355)
+++ Modules/_csv.c	(working copy)
@@ -317,7 +317,7 @@
 Dialect_dealloc(DialectObj *self)
 {
         Py_XDECREF(self->lineterminator);
-        Py_Type(self)->tp_free((PyObject *)self);
+        PyObject_DEL(self);
 }
 
 static char *dialect_kws[] = {
@@ -382,7 +382,7 @@
 			return dialect;
 	}
 
-	self = (DialectObj *)type->tp_alloc(type, 0);
+	self = PyObject_NEW(DialectObj, type);
 	if (self == NULL) {
 		Py_XDECREF(dialect);
 		return NULL;
@@ -504,9 +504,7 @@
 	0,					/* tp_descr_set */
 	0,					/* tp_dictoffset */
 	0,					/* tp_init */
-	0,					/* tp_alloc */
 	dialect_new,			        /* tp_new */
-	0,                           		/* tp_free */
 };
 
 /*
@@ -827,13 +825,12 @@
 static void
 Reader_dealloc(ReaderObj *self)
 {
-	PyObject_GC_UnTrack(self);
         Py_XDECREF(self->dialect);
         Py_XDECREF(self->input_iter);
         Py_XDECREF(self->fields);
         if (self->field != NULL)
         	PyMem_Free(self->field);
-	PyObject_GC_Del(self);
+	PyObject_DEL(self);
 }
 
 static int
@@ -913,7 +910,7 @@
 csv_reader(PyObject *module, PyObject *args, PyObject *keyword_args)
 {
 	PyObject * iterator, * dialect = NULL;
-        ReaderObj * self = PyObject_GC_New(ReaderObj, &Reader_Type);
+        ReaderObj * self = PyObject_NEW(ReaderObj, &Reader_Type);
 
         if (!self)
                 return NULL;
@@ -947,7 +944,6 @@
                 return NULL;
         }
 
-	PyObject_GC_Track(self);
         return (PyObject *)self;
 }
 
@@ -1258,12 +1254,11 @@
 static void
 Writer_dealloc(WriterObj *self)
 {
-	PyObject_GC_UnTrack(self);
         Py_XDECREF(self->dialect);
         Py_XDECREF(self->writeline);
 	if (self->rec != NULL)
 		PyMem_Free(self->rec);
-	PyObject_GC_Del(self);
+	PyObject_DEL(self);
 }
 
 static int
@@ -1328,7 +1323,7 @@
 csv_writer(PyObject *module, PyObject *args, PyObject *keyword_args)
 {
 	PyObject * output_file, * dialect = NULL;
-        WriterObj * self = PyObject_GC_New(WriterObj, &Writer_Type);
+        WriterObj * self = PyObject_NEW(WriterObj, &Writer_Type);
 
         if (!self)
                 return NULL;
@@ -1357,7 +1352,6 @@
                 Py_DECREF(self);
                 return NULL;
         }
-	PyObject_GC_Track(self);
         return (PyObject *)self;
 }
 
Index: pyconfig.h.in
===================================================================
--- pyconfig.h.in	(revision 58355)
+++ pyconfig.h.in	(working copy)
@@ -891,6 +891,10 @@
    Dyld is necessary to support frameworks. */
 #undef WITH_DYLD
 
+/* Define if you want to build an interpreter with free (scalable) threading.
+   */
+#undef WITH_FREETHREAD
+
 /* Define to 1 if libintl is needed for locale functions. */
 #undef WITH_LIBINTL
 
